<Type Name="Array" FullName="System.Array">
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>配列の作成、操作、検索、および並べ替えを行うメソッドを提供します。これにより、共通言語ランタイムのすべての配列の基本クラスとして機能します。  
  
 この型の .NET Framework ソース コードを参照するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/array.cs#156e066ecc4ccedf)です。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを表示するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/array.cs#156e066ecc4ccedf)です。 ソース コードをオンラインで参照、オフラインで表示、リファレンスをダウンロードおよび; デバッグ中にソース \(パッチや更新を含む\) をステップsee [instructions](http://referencesource.microsoft.com/).  
  
 <xref:System.Array>クラスは、の一部、<xref:System.Collections>名前空間。 ただし、まだと見なされますコレクションに基づいているため、<xref:System.Collections.IList>インターフェイスです。  
  
 <xref:System.Array>クラスは、配列をサポートする言語実装の基本クラスです。 ただし、システムとコンパイラから派生できる明示的に、<xref:System.Array>クラスです。 ユーザーは、言語によって提供される配列構造を使用する必要があります。  
  
 要素の値は、<xref:System.Array>です。 長さ、<xref:System.Array>に格納できる要素の合計数です。 下限の境界、<xref:System.Array>最初の要素のインデックスです。<xref:System.Array>下限を持つことができますが、既定では 0 の下限の境界があります。 インスタンスを作成するときに、別の下限を定義することができます、<xref:System.Array>クラスを使用して<xref:System.Array.CreateInstance%2A>です。多次元<xref:System.Array>各次元の下限を持つことができます。 配列には、最大 32 次元を持つことができます。  
  
 内のクラスとは異なり、<xref:System.Collections>名前空間、<xref:System.Array>固定容量があります。 容量を増やす必要がありますを作成する新しい<xref:System.Array>必要な容量を持つオブジェクトを古い要素のコピー<xref:System.Array>を新しいオブジェクトを古い<xref:System.Array>です。  
  
 既定では、最大サイズ、 <xref:System.Array> 2 ギガバイト \(GB\)。 64 ビット環境では、設定してサイズの制限を回避できます、`enabled`の属性、 [gcAllowVeryLargeObjects](http://msdn.microsoft.com/ja-jp/5c7ea24a-39ac-4e5f-83b7-b9f9a1b556ab)構成要素を`true`実行時環境でします。 ただし、配列が 40億要素の合計と 0X7FEFFFFF の特定のディメンション \(0X7FFFFFC7 バイト配列および 1 バイト構造体の配列の場合\) 内の最大のインデックスに制限できます。  
  
 .NET Framework 2.0 以降で、<xref:System.Array>クラスが実装する、 <xref:System.Collections.Generic.IList%601?displayProperty=fullName>、 <xref:System.Collections.Generic.ICollection%601?displayProperty=fullName>、および<xref:System.Collections.Generic.IEnumerable%601?displayProperty=fullName>ジェネリック インターフェイス。 実装は実行時に、配列に提供され、その結果、ジェネリック インターフェイスに表示されないの宣言の構文、<xref:System.Array>クラスです。 さらに、ジェネリック インターフェイスの種類 \(明示的なインターフェイスの実装\) の配列をキャストによってのみアクセス可能なインターフェイス メンバーの参照トピックではありません。 これらのインターフェイスのいずれかに配列をキャストするときの注意すべき重要な点は、追加するメンバーが挿入、または、要素のスローを削除<xref:System.NotSupportedException>です。  
  
 <xref:System.Type>オブジェクトは、配列型の宣言に関する情報を提供します。<xref:System.Array>同じ配列の型を持つオブジェクトが同じ<xref:System.Type>オブジェクト。  
  
 <xref:System.Type.IsArray%2A?displayProperty=fullName> <xref:System.Type.GetElementType%2A?displayProperty=fullName>で期待どおりの結果を返さない可能性があります<xref:System.Array>ため場合、配列は、型にキャスト<xref:System.Array>結果は配列ではなく、オブジェクト。 つまり、`typeof(System.Array).IsArray`返します`false`、および`typeof(System.Array).GetElementType`返します`null`です。  
  
 <xref:System.Array.Copy%2A?displayProperty=fullName>メソッドだけでなく配列間の同じ型が、さまざまな種類の標準的な配列間の要素のコピーです。 型キャストを自動的に処理します。  
  
 一部のメソッドでなど<xref:System.Array.CreateInstance%2A>、 <xref:System.Array.Copy%2A>、 <xref:System.Array.CopyTo%2A>、 <xref:System.Array.GetValue%2A>、および<xref:System.Array.SetValue%2A>大容量の配列に対応するパラメーターとして 64 ビット整数値を許容するオーバー ロードを提供します。<xref:System.Array.LongLength%2A>および<xref:System.Array.GetLongLength%2A>64 ビット整数の配列の長さを示すを返します。  
  
 <xref:System.Array>並べ替えは保証されません。  並べ替える必要があります、<xref:System.Array>操作を実行する前に \(など<xref:System.Array.BinarySearch%2A>\) を必要とする、<xref:System.Array>並べ替えられます。  
  
 使用して、<xref:System.Array>オブジェクトのネイティブ コード内のポインターではサポートされていませんがスローされます、<xref:System.NotSupportedException>のいくつかの方法です。  
  
   
  
## 例  
 次のコード例に示す方法<xref:System.Array.Copy%2A?displayProperty=fullName>整数型の配列と型の配列の要素をコピー<xref:System.Object>です。  
  
 [!code-cpp[Classic Array Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 次のコード例は、作成し、初期化、<xref:System.Array>し、そのプロパティおよびその要素を表示します。  
  
 [!code-cpp[Classic Array Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 \(<see langword="Shared" /> Visual Basic で\) この型のメンバーは、スレッド セーフであります。 インスタンス メンバーの場合は、スレッド セーフであるとは限りません。  
  
 この実装は同期済みは提供されません \(スレッド セーフな\) ラッパーを<see cref="T:System.Array" />。 ただし、.NET Framework のクラス<see cref="T:System.Array" />を使って、コレクションの同期バージョンを独自に提供、<see cref="P:System.Array.SyncRoot" />プロパティです。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">読み取り専用の <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> ラッパーでラップする、インデックス番号が 0 から始まる 1 次元配列。</param>
        <summary>指定した配列をラップする読み取り専用のラッパーを作成します。</summary>
        <returns>指定した配列をラップする読み取り専用の <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> ラッパー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 配列へのすべての変更を防ぐためには、このラッパーを介してのみ配列を公開します。  
  
 読み取り専用であるコレクションは、コレクションのコレクションの変更を防止するラッパーです。そのため、基になるコレクションの変更が加えられた、読み取り専用コレクションはそれらの変更を反映します。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次の例は、読み取り専用で配列をラップ<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>です。  
  
 [!code-cpp[System.Array.AsReadOnly\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>配列の各要素および指定したオブジェクトによって実装されている <see cref="T:System.IComparable" /> インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から特定の要素を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス \+1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。`array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます \(~、C\# の場合は、 `Not` Visual Basic で\) インデックスを生成するために負の値の結果にします。 このインデックスが 1 つである場合、配列の上限よりも大きい要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 いずれか`value`のすべての要素または`array`実装する必要があります、<xref:System.IComparable>比較に使用されるインターフェイス。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前に。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、出現回数の 1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O \(ログ`n`\) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次のコード例は、使用する方法を示しています。<xref:System.Array.BinarySearch%2A>の特定のオブジェクトを検索する、<xref:System.Array>です。  
  
> [!NOTE]
>  配列には、昇順で並べ替え順序では、要素が作成されます。<xref:System.Array.BinarySearch%2A>メソッドには、昇順で並べ替えられて、配列が必要です。  
  
 [!code-cpp[Classic Array.BinarySearch Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> の型は、<paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 \-または\-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.IComparer" /> インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス \+1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。`array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます \(~、C\# の場合は、 `Not` Visual Basic では\) インデックスを生成するために負の値の結果にします。 このインデックスは 1 つの配列の上限より小さい値がない場合よりも大きい要素`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較<xref:System.Collections.IComparer>実装します。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が実行を使用して、<xref:System.IComparable>または指定した値によって、要素自体によって提供される実装。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前にします。 検索に実装されていない要素が発生すると、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`を適切な渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装に指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O \(ログ`n`\) 操作では、ここで`n`はの<xref:System.Array.Length%2A>の`array`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> の型に <paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>配列の各要素および指定した値によって実装されている <see cref="T:System.IComparable" /> インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス \+1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。`array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます \(~、C\# の場合は、 `Not` Visual Basic では\) インデックスを生成するために負の値の結果にします。 このインデックスが 1 つである場合、配列の上限よりも大きい要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 いずれか`value`のすべての要素または`array`実装する必要があります、<xref:System.IComparable>比較に使用されるインターフェイス。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、<xref:System.IComparable>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前に。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい複数の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される<xref:System.IComparable>場合でも、実装`value`は`null`です。 つまり、<xref:System.IComparable>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O \(ログ`n`\) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 \-または\-  
  
 <paramref name="value" /> の型に <paramref name="array" /> の要素との互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる並べ替え済みの 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 \-または\-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.IComparer" /> インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス \+1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。`array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 <xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます \(~ C\# の場合、 `Not` Visual Basic では\) インデックスを生成するために負の値の結果にします。 このインデックスが 1 つである場合、配列の上限よりも大きい要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、<xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較<xref:System.Collections.IComparer>実装します。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が行われますを使用して、<xref:System.IComparable>または指定した値によって、要素自体によって提供される実装します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要がありますの<xref:System.IComparable>の実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`を実装しません、<xref:System.IComparable>インターフェイスの要素の`array`用にテストされていません<xref:System.IComparable>で検索を開始する前にします。 検索が実装されていない要素が発生した場合、例外がスローされます<xref:System.IComparable>です。  
  
 重複する要素が許可されます。 場合、<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`を使用する場合に例外を生成しない<xref:System.IComparable>です。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`を適切な渡される<xref:System.IComparable>場合でも、実装`value`は`null`します。 つまり、<xref:System.IComparable>実装に指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O \(ログ`n`\) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 \-または\-  
  
 <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> の型に <paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <see cref="T:System.IComparable" /> インターフェイスを実装しておらず、<see cref="T:System.IComparable" /> インターフェイスを実装していない要素が検索により検出されました。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素および指定したオブジェクトによって実装されている <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から特定の要素を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス \+1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。`array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合`array`、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます \(~、C\# の場合は、 `Not` Visual Basic では\) インデックスを生成するために負の値の結果にします。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 `T`実装する必要があります、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>ジェネリック インターフェイスは、比較に使用します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、[BinarySearch\(T\) メソッド \(T\<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>実装に指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O \(ログ`n`\) 操作では、ここで`n`は、[BinarySearch\(T\) メソッド \(T\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次のコード例を示しています、[BinarySearch\(T\) メソッド \(T\<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>ジェネリック メソッドのオーバー ロードと[BinarySearch\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードします。 任意の順序で、文字列の配列が作成されます。  
  
 配列が表示され、並べ替え、もう一度表示されます。 配列を使用するために並べ替える必要があります、[BinarySearch\(T\) メソッド \(T\<xref:System.Array.BinarySearch%2A>メソッドです。  
  
> [!NOTE]
>  呼び出し、[BinarySearch\(T\) メソッド \(T\<xref:System.Array.Sort%2A>および[BinarySearch\(T\) メソッド \(T\<xref:System.Array.BinarySearch%2A>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c\#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、[Ildasm.exe \(IL Disassembler\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b)を Microsoft intermediate language \(MSIL\) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [BinarySearch\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、[BinarySearch\(T\) メソッド \(T\<xref:System.Array.BinarySearch%2A>メソッドに渡される、`ShowWhere`それ以外の場合、要素検索文字列は間に配列を使用した場合、文字列が見つかった場合は、インデックス値を表示するジェネリック メソッドです。 インデックスが負の値の文字列が配列でない場合ため、`ShowWhere`メソッドにはビットごとの補数 \(の ~ c\# および Visual C で演算子`Xor`Visual Basic では\-1\) が検索文字列より大きい一覧の最初の要素のインデックスを取得します。  
  
 [!code-cpp[Array\_SortSearch\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array\_SortSearch\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array\_SortSearch\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> は、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  
  
 \-または\-  
  
 各要素の <see cref="T:System.IComparable`1" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列全体の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス \+1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。`array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 場合、 [BinarySearch\(T\) メソッド \(T\<xref:System.Array> 、指定した値を含まない、メソッドは、負の整数を返します。 ビットごとの補数演算子を適用することができます \(~、C\# の場合は、 `Not` Visual Basic では\) インデックスを生成するために負の値の結果。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、[BinarySearch\(T\) メソッド \(T\<xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較[BinarySearch\(T\) メソッド \(T\<xref:System.Collections.Generic.IComparer%601>ジェネリック インターフェイスの実装です。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が行われますを使用して、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>で提供されるジェネリック インターフェイス実装`T`です。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
> [!NOTE]
>  場合`comparer`は`null`と`value`を実装しません、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>ジェネリック インターフェイスでの要素`array`用にテストされていません[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>で検索を開始する前に。 検索に実装されていない要素が発生すると、例外がスローされます[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>です。  
  
 重複する要素が許可されます。 場合、[BinarySearch\(T\) メソッド \(T\<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O \(ログ`n`\)、操作、`n`は、[BinarySearch\(T\) メソッド \(T\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次の例で、[BinarySearch\(T\) メソッド \(T\<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードおよび[BinarySearch\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードします。  
  
 名前付き文字列の代替の比較子を定義するコード例`ReverseCompare`を実装します`IComparer<string>`\(`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で\) ジェネリック インターフェイス。 比較演算子の呼び出し、[BinarySearch\(T\) メソッド \(T\<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低\-高にではなく低\-高を並べ替えられるように、比較対照値の順序を反転します。  
  
 配列が表示され、並べ替え、もう一度表示されます。 配列を使用するために並べ替える必要があります、[BinarySearch\(T\) メソッド \(T\<xref:System.Array.BinarySearch%2A>メソッドです。  
  
> [!NOTE]
>  呼び出し、[BinarySearch\(T\) メソッド \(T\<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と[BinarySearch\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c\#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe \(IL Disassembler\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b) Microsoft intermediate language \(MSIL\) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [BinarySearch\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、[BinarySearch\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>メソッドに渡される、`ShowWhere`それ以外の場合、要素検索文字列は間に配列を使用した場合、文字列が見つかった場合は、インデックス値を表示するジェネリック メソッドです。 インデックスが負の値の文字列は、n がない場合配列、ため、`ShowWhere`メソッドにはビットごとの補数 \(の ~ c\# および Visual C で演算子`Xor`Visual Basic では\-1\) が検索文字列より大きい一覧の最初の要素のインデックスを取得します。  
  
 [!code-cpp[Array\_SortSearchComparer\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array\_SortSearchComparer\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array\_SortSearchComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> は <paramref name="array" /> の要素と互換性がない型です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> は <see langword="null" /> であり、<paramref name="T" /> は <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素および指定した値によって実装されている <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス \+1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。`array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 配列に指定された値が含まれていない場合、このメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます \(~、C\# の場合は、 `Not` Visual Basic では\) インデックスを生成するために負の値の結果にします。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 `T`実装する必要があります、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>ジェネリック インターフェイスは、比較に使用します。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、[BinarySearch\(T\) メソッド \(T\<xref:System.Array>に等しい複数の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`例外を生成しません。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>場合でも、実装`value`は`null`です。 つまり、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>実装を指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O \(ログ`n`\) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 \-または\-  
  
 <paramref name="value" /> の型は、<paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> は、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する並べ替え済みの 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">検索範囲の開始位置を示すインデックス。</param>
        <param name="length">検索する範囲の長さ。</param>
        <param name="value">検索するオブジェクト。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  
  
 \-または\-  
  
 各要素の <see cref="T:System.IComparable`1" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して、1 次元の並べ替え済み配列の要素範囲の中から値を検索します。</summary>
        <returns>
          <paramref name="value" /> が存在する場合は、指定した <paramref name="array" /> における指定した <paramref name="value" /> のインデックス。それ以外の場合は負の数値。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内の 1 つ以上の要素よりも小さい場合、返される負の数値は <paramref name="value" /> より大きい最初の要素のインデックスのビットごとの補数となります。<paramref name="value" /> が見つからず、<paramref name="value" /> が <paramref name="array" /> 内のどの要素よりも大きい場合は、返される負の数値は最後の要素のインデックス \+1 のビットごとの補数となります。 並べ替えられていない <paramref name="array" /> に対してこのメソッドを呼び出すと、<paramref name="value" /> が <paramref name="array" /> に存在していても、戻り値が間違っている場合や、負の数値が返される場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、負のインデックスを含む配列の検索をサポートしていません。`array`このメソッドを呼び出す前に並べ替える必要があります。  
  
 配列に指定された値が含まれていない場合、このメソッドは負の整数を返します。 ビットごとの補数演算子を適用することができます \(~、C\# の場合は、 `Not` Visual Basic では\) インデックスを生成するために負の値の結果にします。 このインデックスが配列のサイズに等しい場合は、要素が存在しないよりも大きい`value`配列にします。 それ以外の場合より大きい最初の要素のインデックス`value`です。  
  
 比較演算子は、要素を比較する方法をカスタマイズします。 たとえば、使用することができます、[BinarySearch\(T\) メソッド \(T\<xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName>として大文字と小文字の文字列検索を実行する比較子。  
  
 場合`comparer`は`null`の要素`array`指定して、指定した値と比較[BinarySearch\(T\) メソッド \(T\<xref:System.Collections.Generic.IComparer%601>ジェネリック インターフェイスの実装です。 要素`array`既にによって定義されている並べ替え順序に従って値を昇順に並べ替える必要があります`comparer`以外の場合、結果が正しくない可能性があります。  
  
 場合`comparer`は`null`、比較が行われますを使用して、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>ジェネリック インターフェイスの実装の種類指定した`T`です。 要素`array`既にによって定義されている並べ替え順序に従って値を増やすことで並べ替える必要があります、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>実装です。 それ以外の場合、結果正しく可能性がありますされません。  
  
 重複する要素が許可されます。 場合、[BinarySearch\(T\) メソッド \(T\<xref:System.Array>に等しい 2 つ以上の要素が含まれる`value`メソッドは、発生した回数、1 つだけとは限りません最初の 1 つのインデックスを返します。  
  
 `null`常に参照型; と比較できます。そのため、比較で`null`を使用する場合に例外を生成しない[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>です。  
  
> [!NOTE]
>  テストするには、すべての要素に対して`value`、適切なに渡される[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>場合でも、実装`value`は`null`します。 つまり、[BinarySearch\(T\) メソッド \(T\<xref:System.IComparable%601>実装に指定された要素を比較する方法を決定`null`です。  
  
 このメソッドは、O \(ログ`n`\) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 \-または\-  
  
 <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="value" /> の型に <paramref name="array" /> の要素と互換性がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> は <see langword="null" /> であり、<paramref name="T" /> は <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要素を削除する必要がある配列。</param>
        <param name="index">削除する要素の範囲の開始インデックス。</param>
        <param name="length">削除する要素の数。</param>
        <summary>配列内にある要素の範囲を、各要素の型の既定値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、配列内の各要素を要素の型の既定値にリセットします。 参照型の要素を設定 \(など<xref:System.String>要素\) を`null`、し、値型の要素を次の表に示すように既定値に設定します。  
  
|型|値|  
|-------|-------|  
|<xref:System.Boolean>|`false`|  
|すべての整数と浮動小数点数値型|0 \(ゼロ\)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=fullName>|  
|他の値型|型のフィールドの既定値|  
  
 範囲は、要素のラップが行ごとに多次元配列内にクリアされます。  
  
 このメソッドは、要素の値のみをクリアします。要素自体は削除されません。 配列が固定サイズです。そのため、要素を追加または削除することはできません。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次の例では、<xref:System.Array.Clear%2A>メソッドを 1 次元、2 次元、および 3 次元配列で整数値をリセットします。  
  
 [!code-csharp[System.Array.Clear\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 次の例では定義、`TimeZoneTime`を含む構造体、<xref:System.TimeZoneInfo>フィールドおよび<xref:System.DateTimeOffset>フィールドです。 呼び出して、<xref:System.Array.Clear%2A>の 2 つの要素の配列内の 1 つの要素を消去するメソッドを`TimeZoneTime`値。 メソッドの既定値に消去された要素の値を設定する、<xref:System.TimeZoneInfo>オブジェクトは`null`、および既定値の<xref:System.DateTimeOffset>オブジェクトは<xref:System.DateTimeOffset.MinValue?displayProperty=fullName>です。  
  
 [!code-csharp[System.Array.Clear\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> と <paramref name="length" /> の合計が <paramref name="array" /> のサイズを超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Array" /> の簡易コピーを作成します。</summary>
        <returns>
          <see cref="T:System.Array" /> の簡易コピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 簡易コピーを<xref:System.Array>の要素のみをコピー、<xref:System.Array>は参照型または値の型が、参照先のオブジェクトはコピーされませんがあるかどうか、します。 新しい参照<xref:System.Array>オブジェクトを指す同じ、参照元を<xref:System.Array> をポイントします。  
  
 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 クローンは、同じ<xref:System.Type>元<xref:System.Array>です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。  
  
   
  
## 例  
 次のコード例のクローン、<xref:System.Globalization.CultureInfo?displayProperty=fullName>配列し、シャロー コピーの動作を示します。  
  
 [!code-cpp[System.Array.Clone\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">コピー操作の開始位置となる <c>sourceArray</c> 内のインデックスを表す 32 ビット整数。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">格納を開始する <c>destinationArray</c> のインデックスを表す 32 ビット整数。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。  コピーが完全に成功しない限り、変更は一切適用されません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `sourceArray`および`destinationArray`のパラメーターが同じ次元数をいる必要があります。`sourceArray`型と同じである必要がありますかから派生した、`destinationArray`入力です。 それ以外の場合、<xref:System.ArrayTypeMismatchException>がスローされます。  異なり<xref:System.Array.Copy%2A>、<xref:System.Array.ConstrainedCopy%2A>任意の操作を実行する前に、配列型の互換性を確認します。  
  
 多次元配列間でコピーする場合、配列のように動作長い 1 次元配列では、場所行 \(または列\) は、概念的に配置されるエンド ツー エンドです。 たとえば、配列要素がある 3 つの行 \(列\) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 \(または列\) の 4 つすべての要素と、2 番目の行 \(または列\) の最初の 2 つの要素コピーします。 3 番目の行 \(または列の\)、2 番目の要素からコピーを開始する`sourceIndex`さらに 2 番目の行 \(または列\) の長さ \+ 2 の最初の行 \(または列\) の上限をする必要があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 \[C\+\+\]  
  
 このメソッドは、標準の C\/C\+\+ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。  場合`sourceArray`および`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピーを<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素であり、要素によって直接的または間接的に参照するすべてのコピーします。  
  
 このメソッドは、コピー中に例外をスローした場合、`destinationArray`は変更されていません。 したがって、<xref:System.Array.ConstrainedCopy%2A>制約された実行領域内で使用できます \(<xref:System.Runtime.ConstrainedExecution.Cer>\)。  
  
 このメソッドは、O \(`n`\)、操作を`n`は`length`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="destinationArray" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> はどちらも同じでもなく、<paramref name="destinationArray" /> 型から派生したものでもありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> は <paramref name="sourceArray" /> の最初の次元の下限を下回っています。  
  
 または  
  
 <paramref name="destinationIndex" /> は <paramref name="destinationArray" /> の最初の次元の下限を下回っています。  
  
 または  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  
  
 \-または\-  
  
 <paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">元の配列要素の型。</typeparam>
        <typeparam name="TOutput">変換後の配列要素の型。</typeparam>
        <param name="array">変換元となる、インデックス番号が 0 から始まる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="converter">各要素の型を変換するための <see cref="T:System.Converter`2" />。</param>
        <summary>ある型の配列を別の型の配列に変換します。</summary>
        <returns>要素の型を変換した後の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [ConvertAll\(TInput, TOutput\) メソッド \(TInput\<xref:System.Converter%602>オブジェクトを対象の型に変換するメソッドにデリゲートします。  要素`array`に個別に渡される、 [ConvertAll\(TInput, TOutput\) メソッド \(TInput\<xref:System.Converter%602>、し、新しい配列に変換された要素が保存されます。  
  
 ソース`array`は変更されません。  
  
 このメソッドは、O \(`n`\) 操作、場所`n`は、[ConvertAll\(TInput, TOutput\) メソッド \(TInput\<xref:System.Array.Length%2A>の`array`です。  
  
   
  
## 例  
 次のコード例は、という名前のメソッドを定義`PointFToPoint`変換する、[ConvertAll\(TInput, TOutput\) メソッド \(TInput\<xref:System.Drawing.PointF>に構造体、[ConvertAll\(TInput, TOutput\) メソッド \(TInput\<xref:System.Drawing.Point>構造体。 配列を作成し[ConvertAll\(TInput, TOutput\) メソッド \(TInput\<xref:System.Drawing.PointF>構造と、作成、`Converter<PointF, Point>`委任 \(`Converter(Of PointF, Point)` Visual Basic で\) を表す、`PointFToPoint`メソッドにデリゲートを渡します、[ConvertAll\(TInput, TOutput\) メソッド \(TInput\<xref:System.Array.ConvertAll%2A>メソッドです。[ConvertAll\(TInput, TOutput\) メソッド \(TInput\<xref:System.Array.ConvertAll%2A>メソッドは成功する入力の一覧の各要素、`PointFToPoint`メソッドの新しいリストに変換された要素を格納および[ConvertAll\(TInput, TOutput\) メソッド \(TInput\<xref:System.Drawing.Point>構造体。 両方の一覧が表示されます。  
  
 [!code-cpp[Array\_ConvertAll\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array\_ConvertAll\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array\_ConvertAll\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="converter" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>最初の要素を開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、最初の要素を開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素にコピーしたデータを対応する必要があります。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 \(または列\) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 \(列\) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 \(または列\) の 4 つすべての要素と、2 番目の行 \(または列\) の最初の 2 つの要素コピーします。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 \[C\+\+\]  
  
 このメソッドは、標準の C\/C\+\+ 関数`memmove`ではなく、`memcpy`です。  
  
 配列には、参照型の配列または値型の配列を指定できます。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化が解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするとき、 <xref:System.Object> 、参照型または値型の配列と割り当て先の配列が可能であれば、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピーを<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの \(定義済み\) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの \(ユーザー定義\) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト \(たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから\) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="destinationArray" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceArray" /> にある要素の数を超えています。  
  
 または  
  
 <paramref name="length" /> は <paramref name="destinationArray" /> にある要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="length">コピーする要素の数を表す 64 ビット整数。 この整数は 0 から <see cref="F:System.Int32.MaxValue" /> \(この値を含む\) の間である必要があります。</param>
        <summary>最初の要素を開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、最初の要素を開始位置として他の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さは 64 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `sourceArray`と`destinationArray`のパラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素にコピーしたデータを対応する必要があります。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 \(または列\) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 \(列\) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 \(または列\) の 4 つすべての要素と、2 番目の行 \(または列\) の最初の 2 つの要素コピーします。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 \[C\+\+\]  
  
 このメソッドは、標準の C\/C\+\+ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするとき、 <xref:System.Object> 、参照型または値型の配列と割り当て先の配列が可能であれば、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピー、<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの \(定義済み\) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの \(ユーザー定義\) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト \(たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから\) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`length`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="destinationArray" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> が 0 未満であるか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceArray" /> にある要素の数を超えています。  
  
 または  
  
 <paramref name="length" /> は <paramref name="destinationArray" /> にある要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">コピー操作の開始位置となる <c>sourceArray</c> 内のインデックスを表す 32 ビット整数。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">格納を開始する <c>destinationArray</c> のインデックスを表す 32 ビット整数。</param>
        <param name="length">コピーする要素の数を表す 32 ビット整数。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として別の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さとインデックスは、32 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素から始まる必要があります、`destinationIndex`にコピーしたデータを対応する位置。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 \(または列\) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 \(列\) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 \(列\) の 4 つすべての要素と、2 番目の行 \(または列\) の最初の 2 つの要素にコピーはします。 3 番目の行 \(または列の\)、2 番目の要素からコピーを開始する`sourceIndex`さらに、2 番目の行 \(または列\) の長さ \+ 2、最初の行 \(または列\) の上限をする必要があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`する前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 \[C\+\+\]  
  
 このメソッドは、標準の C\/C\+\+ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化が解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするとき、<xref:System.Object>可能であれば、参照型または値型の配列と割り当て先の配列は、<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、 <xref:System.Object>、シャロー コピーを実行します。 簡易コピーを<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの \(定義済み\) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの \(ユーザー定義\) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト \(たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから\) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次のコード例は、1 つをコピーする方法を示しています。<xref:System.Array>型の<xref:System.Object>別<xref:System.Array>整数型。  
  
 [!code-cpp[Classic Array.Copy1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="destinationArray" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> は <paramref name="sourceArray" /> の最初の次元の下限を下回っています。  
  
 または  
  
 <paramref name="destinationIndex" /> は <paramref name="destinationArray" /> の最初の次元の下限を下回っています。  
  
 または  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  
  
 \-または\-  
  
 <paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">コピーするデータを格納している <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">コピー操作の開始位置となる <c>sourceArray</c> 内のインデックスを表す 64 ビット整数。</param>
        <param name="destinationArray">データを受け取る <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">格納を開始する <c>destinationArray</c> のインデックスを表す 64 ビット整数。</param>
        <param name="length">コピーする要素の数を表す 64 ビット整数。 この整数は 0 から <see cref="F:System.Int32.MaxValue" /> \(この値を含む\) の間である必要があります。</param>
        <summary>指定したコピー元インデックスを開始位置として <see cref="T:System.Array" /> から要素の範囲をコピーし、指定したコピー先インデックスを開始位置として別の <see cref="T:System.Array" /> にそれらの要素を貼り付けます。 長さとインデックスは、64 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `sourceArray`と`destinationArray`パラメーターが同じ次元数を持つ必要があります。 さらに、`destinationArray`次元されて既に必要があり、十分な数の要素から始まる必要があります、`destinationIndex`にコピーしたデータを対応する位置。  
  
 多次元配列間でコピーする場合、配列動作長い 1 次元配列のように、行 \(または列\) が概念的にレイアウトされるエンド ツー エンドします。 たとえば、配列要素がある 3 つの行 \(列\) 4 つの要素で、各コピー 6 つの配列の先頭から場合は、最初の行 \(または列\) の 4 つすべての要素と、2 番目の行 \(または列\) の最初の 2 つの要素コピーします。 3 番目の行 \(または列の\)、2 番目の要素からコピーを開始する`sourceIndex`さらに、2 番目の行 \(または列\) の長さ \+ 2、最初の行 \(または列\) の上限をする必要があります。  
  
 場合`sourceArray`と`destinationArray`重なっているため、のこのメソッドの動作としての元の値`sourceArray`前に一時的な場所に保存された`destinationArray`は上書きされます。  
  
 \[C\+\+\]  
  
 このメソッドは、標準の C\/C\+\+ 関数`memmove`ではなく、`memcpy`です。  
  
 配列は、参照型の配列または値型の配列になります。 型のダウン キャストを実行すると、必要に応じて。  
  
-   参照型の配列から値型の配列にコピーするとき、各要素はボックス化解除され、コピーします。 参照型の配列に値型の配列からコピーする場合は、各要素がボックス化され、コピーされます。  
  
-   参照型または値型の配列からコピーするとき、 <xref:System.Object> 、配列、<xref:System.Object>がそれぞれの値または参照を保持するために作成され、その後、コピーします。 コピーするときに<xref:System.Object>配列、参照型または値型の配列および割り当て処理は不可能な<xref:System.InvalidCastException>がスローされます。  
  
-   場合`sourceArray`と`destinationArray`両方の参照型の配列または型の両方の配列は、<xref:System.Object>を簡易コピーを実行できます。 簡易コピーを<xref:System.Array>は、新しい<xref:System.Array>元と同じ要素への参照を含む<xref:System.Array>です。 要素自体または要素が参照はコピーされません。 詳細がこれに対し、コピー、<xref:System.Array>要素と要素が直接または間接的に参照するすべてコピーします。  
  
 <xref:System.ArrayTypeMismatchException>の配列が互換性のない型である場合にスローされます。 型の互換性の定義は次のとおりです。  
  
-   型と互換性のあります。  
  
-   値型と互換性が<xref:System.Object>とその値の型によって実装されたインターフェイス型を使用します。 値型では、直接そのインターフェイスを実装する場合にのみ、インターフェイスに接続されていると見なされます。 切断されている型に互換性がありません。  
  
-   2 つの組み込みの \(定義済み\) の値型に拡大変換元の型から変換先の型へのコピーがある場合に互換性がします。 拡大変換では縮小変換には、情報が失われる可能性が一方については、失われます。 たとえば、拡大変換は、32 ビット符号付き整数に変換する 64 ビット符号付き整数にし、縮小変換は、64 ビット符号付き整数に変換する 32 ビット符号付き整数。 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
-   非組み込みの \(ユーザー定義\) の値の型とのみ互換性が自体です。  
  
-   列挙型に暗黙的な変換がある<xref:System.Enum>とその基になる型。  
  
 場合のすべての要素`sourceArray`キャスト \(たとえば、派生クラスを基底クラスまたはオブジェクトへのインターフェイスから\) が必要ですし、1 つまたは複数の要素に対応する型にキャストできません`destinationArray`、<xref:System.InvalidCastException>がスローされます。  
  
 このメソッドの状態のコピー中に例外をスローした場合`destinationArray`が定義されていません。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次のコード例は、1 つをコピーする方法を示しています。<xref:System.Array>型の<xref:System.Object>別<xref:System.Array>整数型。  
  
 [!code-cpp[Classic Array.Copy1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="destinationArray" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> のランクが異なります。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> と <paramref name="destinationArray" /> の型は互換性がありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="sourceArray" /> の少なくとも 1 つの要素が <paramref name="destinationArray" /> の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> は <paramref name="sourceArray" /> の有効なインデックスの範囲外です。  
  
 \-または\-  
  
 <paramref name="destinationIndex" /> は <paramref name="destinationArray" /> の有効なインデックスの範囲外です。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満であるか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> は <paramref name="sourceIndex" /> から最後の <paramref name="sourceArray" /> までの要素の数を超えています。  
  
 \-または\-  
  
 <paramref name="length" /> は <paramref name="destinationIndex" /> から最後の <paramref name="destinationArray" /> までの要素の数を超えています。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">現在の配列からコピーされる要素のコピー先である 1 次元配列。</param>
        <param name="index">コピーを開始する <c>array</c> のインデックスを表す 32 ビット整数。</param>
        <summary>現在の 1 次元配列のすべての要素を、指定したコピー先配列インデックスで開始する指定の 1 次元配列にコピーします。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、現在の配列インスタンスのすべての要素をコピー、`array`コピー先の配列、インデックスから始まります`index`です。`array`コピー先の配列次元されて既に必要があり、十分な数の要素をコピーした要素に対応する必要があります。 そうしないと、例外がスローされます。  
  
 このメソッドは、サポート、<xref:System.Collections.ICollection?displayProperty=fullName>インターフェイスです。 実装する場合<xref:System.Collections.ICollection?displayProperty=fullName>が使用して明示的に必要な<xref:System.Array.Copy%2A>余分な間接参照を回避します。  
  
 このメソッドは、状態のコピー中に例外をスローした場合`array`が定義されていません。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。のみの簡易コピーを実行します。  
  
   
  
## 例  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>下限が 0 にします。 なおソース全体<xref:System.Array>はコピーすると、ターゲット内の既存の要素を上書きする空の要素を含む<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  
  
 または  
  
 コピー元配列の要素数が、コピー先 <paramref name="array" /> の <paramref name="index" /> から末尾までの使用可能な要素数を超えています。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">コピー元の <see cref="T:System.Array" /> の型をコピー先の <paramref name="array" /> の型に自動的にキャストすることはできません。</exception>
        <exception cref="T:System.RankException">ソース配列が多次元配列です。</exception>
        <exception cref="T:System.InvalidCastException">コピー元 <see cref="T:System.Array" /> の中の少なくとも 1 つの要素を、コピー先 <paramref name="array" /> の型にキャストすることができません。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">現在の配列からコピーされる要素のコピー先である 1 次元配列。</param>
        <param name="index">コピーを開始する <c>array</c> のインデックスを表す 64 ビット整数。</param>
        <summary>現在の 1 次元配列のすべての要素を、指定したコピー先配列インデックスで開始する指定の 1 次元配列にコピーします。 このインデックスは 64 ビット整数値として指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、現在の配列インスタンスのすべての要素をコピー、`array`コピー先の配列、インデックスから始まります`index`です。`array`コピー先の配列次元されて既に必要があり、十分な数の要素をコピーした要素に対応する必要があります。 そうしないと、例外がスローされます。  
  
 このメソッドは、サポート、<xref:System.Collections.ICollection?displayProperty=fullName>インターフェイスです。 実装する場合<xref:System.Collections.ICollection?displayProperty=fullName>が使用して明示的に必要な<xref:System.Array.Copy%2A>余分な間接参照を回避します。  
  
 このメソッドの状態のコピー中に例外をスローした場合`array`が定義されていません。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。のみの簡易コピーを実行します。  
  
   
  
## 例  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 次のコード例をコピーする方法を示しています、<xref:System.Array>別<xref:System.Array>下限が 0 にします。 なおソース全体<xref:System.Array>をコピーすると、ターゲット内の既存の要素を上書きする空の要素を含む<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CopyTo Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は <paramref name="array" /> の正しいインデックスの範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  
  
 または  
  
 コピー元配列の要素数が、コピー先 <paramref name="array" /> の <paramref name="index" /> から末尾までの使用可能な要素数を超えています。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">コピー元の <see cref="T:System.Array" /> の型をコピー先の <paramref name="array" /> の型に自動的にキャストすることはできません。</exception>
        <exception cref="T:System.RankException">コピー元の <see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.InvalidCastException">コピー元 <see cref="T:System.Array" /> の中の少なくとも 1 つの要素を、コピー先 <paramref name="array" /> の型にキャストすることができません。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="length">作成する <see cref="T:System.Array" /> のサイズ。</param>
        <summary>
          <see cref="T:System.Type" /> と長さを指定して、0 から始まるインデックス番号を持つ 1 次元の <see cref="T:System.Array" /> を作成します。</summary>
        <returns>長さを指定した、0 から始まるインデックス番号を使用する指定した <see cref="T:System.Type" /> の新しい 1 次元の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次のコード例は、作成し、1 次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="lengths">作成する <see cref="T:System.Array" /> の各次元のサイズを表す 32 ビット整数の配列。</param>
        <summary>
          <see cref="T:System.Type" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ多次元の <see cref="T:System.Array" /> を作成します。 次元の長さは、32 ビット整数の配列で指定します。</summary>
        <returns>各次元が指定した長さで、インデックス番号が 0 から始まる、指定した <see cref="T:System.Type" /> の新しい多次元 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 内の要素の数、`lengths`配列で、新しいディメンションの数でなければなりません。<xref:System.Array>です。 各要素、`lengths`配列は新たに対応する次元の長さを指定する必要があります<xref:System.Array>です。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O \(`n`\)、操作を`n`は、製品のすべての値の`lengths`します。  
  
   
  
## 例  
 次のコード例は、作成して、多次元の初期化方法を示します<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="lengths" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  
  
 または  
  
 <paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> 内の値が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="lengths">作成する <see cref="T:System.Array" /> の各次元のサイズを表す 64 ビット整数の配列。 配列内の各整数はゼロから <see cref="F:System.Int32.MaxValue" /> までの値であることが必要です。</param>
        <summary>
          <see cref="T:System.Type" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ多次元の <see cref="T:System.Array" /> を作成します。 次元の長さは、64 ビット整数の配列で指定します。</summary>
        <returns>各次元が指定した長さで、インデックス番号が 0 から始まる、指定した <see cref="T:System.Type" /> の新しい多次元 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 内の要素の数、`lengths`配列で、新しいディメンションの数でなければなりません。<xref:System.Array>です。 各要素、`lengths`配列が新たに対応する次元の長さを指定する必要があります<xref:System.Array>です。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`のすべての値の積は、`lengths`です。  
  
   
  
## 例  
 次のコード例は、作成して、多次元の初期化方法を示します<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="lengths" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  
  
 または  
  
 <paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> のすべての値が 0 未満であるか、<see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="length1">作成する <see cref="T:System.Array" /> の最初の次元のサイズ。</param>
        <param name="length2">作成する <see cref="T:System.Array" /> の 2 番目の次元のサイズ。</param>
        <summary>
          <see cref="T:System.Type" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ 2 次元の <see cref="T:System.Array" /> を作成します。</summary>
        <returns>指定した <see cref="T:System.Type" /> の、次元ごとに指定した長さの、0 から始まるインデックス番号を持つ新しい 2 次元の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`の製品は、`length1`と`length2`です。  
  
   
  
## 例  
 次のコード例は、作成し、2 次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> が 0 未満です。  
  
 \-または\-  
  
 <paramref name="length2" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="lengths">作成する <see cref="T:System.Array" /> の各次元のサイズを格納する 1 次元配列。</param>
        <param name="lowerBounds">作成する <see cref="T:System.Array" /> の各次元の下限 \(開始インデックス\) を格納する 1 次元配列。</param>
        <summary>指定した <see cref="T:System.Type" /> と次元の長さの、指定した下限を持つ多次元の <see cref="T:System.Array" /> を作成します。</summary>
        <returns>次元ごとに指定した長さと下限を持つ、指定した <see cref="T:System.Type" /> の新しい多次元の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどのクラスとは異なり[CreateInstance メソッド \(Type, Int32\<xref:System.Array>提供、[CreateInstance メソッド \(Type, Int32\<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 `lengths`と`lowerBounds`配列は同じ数の要素を持つ必要があります。 内の要素の数、`lengths`配列で、新しいディメンションの数でなければなりません。[CreateInstance メソッド \(Type, Int32\<xref:System.Array>です。  
  
 各要素、`lengths`配列は新たに対応する次元の長さを指定する必要があります[CreateInstance メソッド \(Type, Int32\<xref:System.Array>です。  
  
 各要素、`lowerBounds`配列は新たに対応する次元の下限を指定する必要があります[CreateInstance メソッド \(Type, Int32\<xref:System.Array>です。 一般に、.NET Framework クラス ライブラリと多くのプログラミング言語は、0 以外の下限を処理しません。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O \(`n`\)、操作を`n`は、製品のすべての値の`lengths`します。  
  
   
  
## 例  
 次のコード例は、作成し、多次元を初期化する方法を示しています。[CreateInstance メソッド \(Type, Int32\<xref:System.Array>下限を指定します。  
  
 [!code-cpp[Classic Array.CreateInstance4 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="lengths" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="lowerBounds" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。  
  
 または  
  
 <paramref name="lengths" /> 配列に含まれる要素が 1 つ未満です。  
  
 または  
  
 <paramref name="lengths" /> と <paramref name="lowerBounds" /> の配列に含まれている要素の数が異なります。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lengths" /> 内の値が 0 未満です。  
  
 または  
  
 <paramref name="lowerBounds" /> 内に非常に大きな値があり、ディメンションの下限の境界と長さの合計が <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">作成する <see cref="T:System.Array" /> の <see cref="T:System.Type" />。</param>
        <param name="length1">作成する <see cref="T:System.Array" /> の最初の次元のサイズ。</param>
        <param name="length2">作成する <see cref="T:System.Array" /> の 2 番目の次元のサイズ。</param>
        <param name="length3">作成する <see cref="T:System.Array" /> の 3 番目の次元のサイズ。</param>
        <summary>
          <see cref="T:System.Type" /> と次元の長さを指定して、0 から始まるインデックス番号を持つ 3 次元の <see cref="T:System.Array" /> を作成します。</summary>
        <returns>指定した <see cref="T:System.Type" /> の、次元ごとに指定した長さの、0 から始まるインデックス番号を持つ新しい 3 次元の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどのクラスとは異なり<xref:System.Array>提供、<xref:System.Array.CreateInstance%2A>メソッド、遅延バインディング アクセスを許可する、パブリック コンス トラクターの代わりにします。  
  
 参照型の要素に初期化されます`null`です。 値型の要素は、ゼロに初期化されます。  
  
 このメソッドは、O \(`n`\) 操作、場所`n`の製品は、 `length1`、 `length2`、および`length3`です。  
  
   
  
## 例  
 次のコード例は、作成し、3 次元を初期化する方法を示しています。<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.CreateInstance2 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> は有効な <see cref="T:System.Type" /> ではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> がサポートされていません。 たとえば、<see cref="T:System.Void" /> はサポートされていません。  
  
 または  
  
 <paramref name="elementType" /> はオープン ジェネリック型です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> が 0 未満です。  
  
 \-または\-  
  
 <paramref name="length2" /> が 0 未満です。  
  
 \-または\-  
  
 <paramref name="length3" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <summary>空の配列を返します。</summary>
        <returns>空の <see cref="T:System.Array" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>指定された配列に、指定された述語によって定義された条件と一致する要素が含まれているかどうかを判断します。</summary>
        <returns>指定された述語によって定義された条件と一致する 1 つ以上の要素が <paramref name="array" /> に存在する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [Exists\(T\) メソッド \(T\<xref:System.Predicate%601> を返すメソッドにデリゲート `true` デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素 `array` に個別に渡される、 [Exists\(T\) メソッド \(T\<xref:System.Predicate%601>, 、一致が見つかったときに処理が停止しているとします。  
  
> [!NOTE]
>  C\# と Visual Basic での必要はありませんを作成する、 [Exists\(T\) メソッド \(T\<xref:System.Predicate%601> 明示的に委任します。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は、 [Exists\(T\) メソッド \(T\<xref:System.Array.Length%2A> の `array`です。  
  
   
  
## 例  
 次の例についての一致条件を指定する、 [Exists\(T\) メソッド \(T\<xref:System.Array.Exists%2A>メソッド usinglambda 式惑星が特定の文字で始まるかどうか、または指定した配列に地球を検出するかどうかを確認します。  
  
 [!code-csharp[System.Array.Exists\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 次の例では、 [Exists\(T\) メソッド \(T\<xref:System.Array.Exists%2A> を文字列配列の任意の名前が指定した文字で始まるかどうかを示す方法。 インスタンス化、 `StringSearcher` クラス コンス トラクターを検索する文字列を渡すことによってオブジェクトです。`StringSearcher.StartsWith` メソッドと同じシグネチャを持つ、 [Exists\(T\) メソッド \(T\<xref:System.Predicate%601> を委任します。 ときに、[Exists\(T\) メソッド \(T\<xref:System.Array.Exists%2A> メソッドが呼び出されると、返されるまでに、配列の各メンバーが、デリゲートに渡された `true` または配列内のすべての要素を反復処理します。  
  
 [!code-csharp[System.Array.Exists\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 ラムダ式を使用しても代わりできます、デリゲートのシグネチャを持つ対応するメソッドを明示的に定義します。 次の例が置き換えられます、 `StringSearcher`クラスとその `StartsWith` ラムダ式を持つメソッドです。  
  
 [!code-csharp[System.Array.Exists\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="match">検索する要素の条件を定義する述語。</param>
        <summary>指定された述語によって定義された条件と一致する要素を検索し、<see cref="T:System.Array" /> 全体の中で最もインデックス番号の小さい要素を返します。</summary>
        <returns>見つかった場合は、指定された述語によって定義された条件と一致する最初の要素。それ以外の場合は、型 <paramref name="T" /> の既定値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [Find\(T\) メソッド \(T\<xref:System.Predicate%601>メソッドまたはラムダ式を返すデリゲート`true`デリゲートまたはラムダ式で定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、 [Find\(T\) メソッド \(T\<xref:System.Predicate%601>、最初の要素で開始および終了の最後の要素。  一致が見つかった場合は、処理が停止しました。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は、[Find\(T\) メソッド \(T\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次の例では、[Find\(T\) メソッド \(T\<xref:System.Predicate%601>を持つデリゲート、[Find\(T\) メソッド \(T\<xref:System.Array.Find%2A>ジェネリック メソッドの配列を検索する[Find\(T\) メソッド \(T\<xref:System.Drawing.Point>構造体。 デリゲートが表すメソッド`ProductGT10`、返します`true`X と Y のフィールドの製品が 100,000 より大きい場合。[Find\(T\) メソッド \(T\<xref:System.Array.Find%2A>メソッドがテスト条件を満たす最初のポイントを返す、配列の各要素に対してデリゲートを呼び出します。  
  
> [!NOTE]
>  Visual Basic および C\# では、デリゲートを明示的に作成またはジェネリック メソッドの型引数を指定する必要はありません。 コンパイラでは、指定したメソッドの引数から必要な型を決定します。  
  
 [!code-csharp[System.Array.Find\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 必要なシグネチャを持つメソッドを明示的に定義するのではなくインスタンス化する、[Find\(T\) メソッド \(T\<xref:System.Predicate%601>を委任して、デリゲートに渡すこと、[Find\(T\) メソッド \(T\<xref:System.Array.Find%2A>メソッド、ラムダ式を使用する一般的なは。 ラムダ式として使用する点を除いては、次の例は、1 つ前と同じ、`match`引数。  
  
 [!code-csharp[System.Array.Find\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> が <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>指定された述語によって定義された条件と一致するすべての要素を取得します。</summary>
        <returns>指定した述語によって定義される条件に一致する要素が見つかった場合は、そのすべての要素を格納する <see cref="T:System.Array" />。それ以外の場合は、空の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [FindAll\(T\) メソッド \(T\<xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、[FindAll\(T\) メソッド \(T\<xref:System.Predicate%601>条件に一致する要素が返される配列に保存されます。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は、[FindAll\(T\) メソッド \(T\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次の例では、範囲は 0 ~ 1,000 値を持つ 50 個のランダムな数値の配列を作成します。 呼び出して、 [FindAll\(T\) メソッド \(T\<xref:System.Array.FindAll%2A> 600 に 300 の値の範囲を返すラムダ式を持つメソッドです。 ラムダ式のという名前のパラメーターが渡されることに注意してください`x`です。 渡される個々 の配列のメンバーを表すこの、[FindAll\(T\) メソッド \(T\<xref:System.Predicate%601>です。 またを注意してください。 ローカル`lBound`と`uBound`変数は、ラムダ式内でアクセス可能です。  
  
 [!code-csharp[System.Array.FindAll\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 次のコード例を示しています、 [FindAll\(T\) メソッド \(T\<xref:System.Array.Find%2A>、 [FindAll\(T\) メソッド \(T\<xref:System.Array.FindLast%2A>、および[FindAll\(T\) メソッド \(T\<xref:System.Array.FindAll%2A>ジェネリック メソッドです。 "Saurus"で終わる \(位置 1 から 5 など\) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 [FindAll\(T\) メソッド \(T\<xref:System.Array.Find%2A>ジェネリック メソッドは、各要素を順番に渡して、先頭から、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`要素"Amargasaurus"です。  
  
> [!NOTE]
>  C\# および Visual Basic の場合では作成に必要な`Predicate<string>`委任 \(`Predicate(Of String)` Visual Basic の\) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 [FindAll\(T\) メソッド \(T\<xref:System.Array.FindLast%2A>ジェネリック メソッドは、配列の末尾から旧バージョンとの検索に使用します。 "Dilophosaurus"5 番目の位置にある要素を検索します。[FindAll\(T\) メソッド \(T\<xref:System.Array.FindAll%2A>で"終了するすべての要素を含む配列を返すジェネリック メソッドを使用します。 要素が表示されます。  
  
 このコード例も示します、[FindAll\(T\) メソッド \(T\<xref:System.Array.Exists%2A>と[FindAll\(T\) メソッド \(T\<xref:System.Array.TrueForAll%2A>ジェネリック メソッドです。  
  
 [!code-cpp[Array\_FindEtAl\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array\_FindEtAl\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array\_FindEtAl\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> 全体から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [FindIndex\(T\) メソッド \(T\<xref:System.Array>前方最初の要素を起点と最後の要素で終了が検索されます。  
  
 [FindIndex\(T\) メソッド \(T\<xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、[FindIndex\(T\) メソッド \(T\<xref:System.Predicate%601>です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は、[FindIndex\(T\) メソッド \(T\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次のコード例に示しますの 3 つすべてのオーバー ロード、[FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる \(位置 1 から 5 など\) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返すことを示す、入力文字列では"かどうかの値します。  
  
 [FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡して、先頭から配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C\# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 \(`Predicate(Of String)` Visual Basic の\) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 [FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾を続行する配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、[FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、\-1 を返します。  
  
 [!code-cpp[Array\_FindIndex\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array\_FindIndex\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array\_FindIndex\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> の指定したインデックスから最後の要素までの範囲内で、指定した述語にで定義される条件に一致する要素を検索し、最初に見つかった 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [FindIndex\(T\) メソッド \(T\<xref:System.Array>転送を開始位置として検索`startIndex`と最後の要素で終了します。  
  
 [FindIndex\(T\) メソッド \(T\<xref:System.Predicate%601>はデリゲートを返すメソッドを`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、[FindIndex\(T\) メソッド \(T\<xref:System.Predicate%601>です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`要素の数は、`startIndex`の末尾に`array`です。  
  
   
  
## 例  
 次のコード例は、の 3 つすべてのオーバー ロードを示します、[FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる \(位置 1 から 5 など\) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`文字列パラメーターを受け入れる、およびブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 [FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡して、先頭から、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C\# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 \(`Predicate(Of String)` Visual Basic の\) 明示的にします。 これらの言語は、コンテキストから適切なデリゲートを推論し、自動的に作成されます。  
  
 [FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾を続行する配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、[FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、\-1 を返します。  
  
 [!code-cpp[Array\_FindIndex\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array\_FindIndex\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array\_FindIndex\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> のうち、指定したインデックスから始まり、指定した要素数が含まれる範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在した場合、最もインデックス番号の小さい要素の 0 から始まるインデックス。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [FindIndex\(T\) メソッド \(T\<xref:System.Array>転送を開始位置として検索が`startIndex`で終わる`startIndex`plus`count`から 1 を引いた場合`count`は 0 より大きい。  
  
 [FindIndex\(T\) メソッド \(T\<xref:System.Predicate%601>はデリゲートを返すメソッドを`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、[FindIndex\(T\) メソッド \(T\<xref:System.Predicate%601>です。  
  
 このメソッドは、O \(`n`\)、操作を`n`は`count`です。  
  
   
  
## 例  
 次のコード例は、の 3 つすべてのオーバー ロードを示します、[FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる \(位置 1 から 5 など\) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`文字列パラメーターを受け入れる、およびブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 [FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、各要素を順番に渡して、先頭から、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の位置 1 にある要素。  
  
> [!NOTE]
>  C\# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 \(`Predicate(Of String)` Visual Basic の\) 明示的にします。 これらの言語は、コンテキストから適切なデリゲートを推論し、自動的に作成されます。  
  
 [FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から開始し、配列の末尾を続行する配列を検索するメソッド オーバー ロードを使用します。 5 番目の位置にある要素を検索します。 最後に、[FindIndex\(T\) メソッド \(T\<xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 2 から 3 つの要素の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、\-1 を返します。  
  
 [!code-cpp[Array\_FindIndex\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array\_FindIndex\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array\_FindIndex\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>指定された述語によって定義された条件と一致する要素を、<see cref="T:System.Array" /> 全体を対象に検索し、最もインデックス番号の大きい要素を返します。</summary>
        <returns>見つかった場合は、指定された述語によって定義された条件と一致する最後の要素。それ以外の場合は、型 <paramref name="T" /> の既定値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [FindLast\(T\) メソッド \(T\<xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、[FindLast\(T\) メソッド \(T\<xref:System.Predicate%601>への移行の旧バージョンと、 [FindLast\(T\) メソッド \(T\<xref:System.Array>、最後の要素で開始および終了の最初の要素。  一致が見つかった場合は、処理が停止しました。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は、[FindLast\(T\) メソッド \(T\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次のコード例を示しています、 [FindLast\(T\) メソッド \(T\<xref:System.Array.Find%2A>、 [FindLast\(T\) メソッド \(T\<xref:System.Array.FindLast%2A>、および[FindLast\(T\) メソッド \(T\<xref:System.Array.FindAll%2A>ジェネリック メソッドです。 "Saurus"で終わる \(位置 1 から 5 など\) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 [FindLast\(T\) メソッド \(T\<xref:System.Array.Find%2A>ジェネリック メソッドは、各要素を順番に渡して、先頭から、配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`要素"Amargasaurus"です。  
  
> [!NOTE]
>  C\# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 \(`Predicate(Of String)` Visual Basic の\) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 [FindLast\(T\) メソッド \(T\<xref:System.Array.FindLast%2A>ジェネリック メソッドは、配列の末尾から旧バージョンとの検索に使用します。 "Dilophosaurus"5 番目の位置にある要素を検索します。[FindLast\(T\) メソッド \(T\<xref:System.Array.FindAll%2A>で"終了するすべての要素を含む配列を返すジェネリック メソッドを使用します。 要素が表示されます。  
  
 このコード例も示します、[FindLast\(T\) メソッド \(T\<xref:System.Array.Exists%2A>と[FindLast\(T\) メソッド \(T\<xref:System.Array.TrueForAll%2A>ジェネリック メソッドです。  
  
 [!code-cpp[Array\_FindEtAl\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array\_FindEtAl\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array\_FindEtAl\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> 全体から、指定した述語によって定義される条件に一致する要素を検索し、最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array> は、最後の要素を起点と最初の要素の終了を逆方向検索します。  
  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Predicate%601> を返すメソッドにデリゲート `true` デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素 `array` に個別に渡される、 [FindLastIndex\(T\) メソッド \(T\<xref:System.Predicate%601>です。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は、 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array.Length%2A> の `array`です。  
  
   
  
## 例  
 次のコード例を次の 3 つのオーバー ロードがすべてを示しています、 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%2A> ジェネリック メソッドです。 "Saurus"で終わる \(位置 1 と 5 など\) のうちの 2 つの 8 恐竜名前を含む文字列の配列を作成します。 このコード例はという名前の検索述語メソッドも定義 `EndsWithSaurus`, 文字列パラメーターを受け入れる、およびブール値を返しますが、入力文字列が"saurus"で終わるかどうかを示すを値します。  
  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバー ロードは、終了すると、各要素を順番に渡すから旧バージョンとの配列を通過する時間、 `EndsWithSaurus` メソッドです。 検索を停止するときに、 `EndsWithSaurus` メソッドが返す `true` 5 番目の位置にある要素のです。  
  
> [!NOTE]
>  C\# と Visual Basic での必要はありませんを作成する、 `Predicate<string>` 委任 \(`Predicate(Of String)` Visual Basic で\) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 位置 4 から開始し、配列の先頭に逆方向に進むの配列を検索するメソッドのオーバー ロードを使用します。 位置 1 の要素を検索します。 最後に、 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> メソッドのオーバー ロードは次の 3 つの要素位置 4 から開始し、逆方向 \(つまり、4、3、および 2\) の範囲を検索するために使用します。 "Saurus"で終わる範囲に恐竜の名前がないために、\-1 を返します。  
  
 [!code-cpp[Array\_FindLastIndex\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array\_FindLastIndex\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array\_FindLastIndex\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> のうち、先頭の要素から指定したインデックスまでの範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`その最初の要素で終了します。  
  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、[FindLastIndex\(T\) メソッド \(T\<xref:System.Predicate%601>です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`の先頭から要素の数は、`array`に`startIndex`です。  
  
   
  
## 例  
 次のコード例に示しますの 3 つすべてのオーバー ロード、[FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる \(位置 1 から 5 など\) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返すことを示す、入力文字列では"かどうかの値します。  
  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、最後に、各要素を順番に渡してから旧バージョンとの配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の 5 番目の位置にある要素。  
  
> [!NOTE]
>  C\# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 \(`Predicate(Of String)` Visual Basic の\) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 4 から開始し、配列の先頭に後方に進むの配列を検索するメソッド オーバー ロードを使用します。 位置 1 である要素を検索します。 最後に、 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 3 つの要素位置 4 から開始し、逆方向 \(つまり、4、3、および 2\) の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、\-1 を返します。  
  
 [!code-cpp[Array\_FindLastIndex\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array\_FindLastIndex\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array\_FindLastIndex\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <param name="match">検索する要素の条件を定義する <see cref="T:System.Predicate`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> のうち、指定したインデックスで終わり、指定した要素数が含まれる範囲の中で、指定した述語によって定義される条件に一致する要素を検索し、そのうち最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="match" /> で定義された条件と一致する要素が存在する場合、最もインデックス番号の大きい要素の 0 から始まるインデックス。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`で終わる`startIndex`マイナス`count`1、さらに場合`count`が 0 より大きい。  
  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、[FindLastIndex\(T\) メソッド \(T\<xref:System.Predicate%601>です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`count`します。  
  
   
  
## 例  
 次のコード例に示しますの 3 つすべてのオーバー ロード、[FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%2A>ジェネリック メソッドです。 "Saurus"で終わる \(位置 1 から 5 など\) のうちの 2 台の 8 恐竜の名前を含む文字列の配列が作成されます。 コード例でも定義という名前の検索述語メソッド`EndsWithSaurus`、文字列パラメーターを受け入れるし、ブール値を返しますが、入力文字列では"かどうかを示すを値です。  
  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>メソッドのオーバー ロードは、最後に、各要素を順番に渡してから旧バージョンとの配列を通過する時間、`EndsWithSaurus`メソッドです。 検索を停止するときに、`EndsWithSaurus`メソッドを返します。`true`の 5 番目の位置にある要素。  
  
> [!NOTE]
>  C\# および Visual Basic の場合は、その必要はありませんを作成する、`Predicate<string>`委任 \(`Predicate(Of String)` Visual Basic の\) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>位置 4 から開始し、配列の先頭を続行する前に、配列を検索するメソッド オーバー ロードを使用します。 位置 1 である要素を検索します。 最後に、 [FindLastIndex\(T\) メソッド \(T\<xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> 3 つの要素位置 4 から開始し、逆方向 \(つまり、4、3、および 2\) の範囲を検索するメソッド オーバー ロードを使用します。 "Saurus"で終わる範囲に恐竜の名前が存在しないために、\-1 を返します。  
  
 [!code-cpp[Array\_FindLastIndex\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array\_FindLastIndex\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array\_FindLastIndex\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">要素に処理を実行する、インデックス番号が 0 から始まる 1 次元の <see cref="T:System.Array" />。</param>
        <param name="action">
          <c>array</c> の各要素に対して実行する <see cref="T:System.Action`1" />。</param>
        <summary>指定された配列内の各要素に対して、指定された処理を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [ForEach\(T\) メソッド \(T\<xref:System.Action%601>はオブジェクトが操作を実行するメソッドにデリゲートが渡されます。  要素`array`に個別に渡される、[ForEach\(T\) メソッド \(T\<xref:System.Action%601>です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は、[ForEach\(T\) メソッド \(T\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次の例は、使用する方法を示しています。[ForEach\(T\) メソッド \(T\<xref:System.Array.ForEach%2A>整数配列の各要素の四角形を表示します。  
  
 [!code-cpp[System.Array.ForEach\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="action" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IEnumerator" /> の <see cref="T:System.Array" /> を返します。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> の <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 \[Visual Basic、C\# の場合\]  
  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual Basic で\)、列挙子の複雑さが隠されています。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。<xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、<xref:System.Collections.IEnumerator.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合<xref:System.Collections.IEnumerator.MoveNext%2A>列挙子をコレクションの末尾が、コレクション内の最後の要素の後に配置されているパスと<xref:System.Collections.IEnumerator.MoveNext%2A>返します`false`です。 列挙子がこの位置では、後続の呼び出しの場合<xref:System.Collections.IEnumerator.MoveNext%2A>を返すことも`false`します。 最後の呼び出し場合<xref:System.Collections.IEnumerator.MoveNext%2A>返される`false`、<xref:System.Collections.IEnumerator.Current%2A>が定義されていません。<xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子には、コレクションへの排他アクセスがありません。したがって、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例は、使用する方法を示しています。 <xref:System.Array.GetEnumerator%2A> 、配列の要素の一覧を表示します。  
  
 [!code-cpp[System.Array\_GetEnumerator\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array\_GetEnumerator\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array\_GetEnumerator\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">長さを指定する必要がある <see cref="T:System.Array" /> の 0 から始まる次元。</param>
        <summary>
          <see cref="T:System.Array" /> の指定した次元にある要素の数を表す 32 ビット整数を取得します。</summary>
        <returns>指定した次元にある要素の数を表す 32 ビット整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 例を<xref:System.Array.GetLength%2A>は`GetLength(0)`の最初の次元で要素の数が返されます、<xref:System.Array>です。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次の例は、使用する方法を示しています。<xref:System.Array.GetLength%2A>ランクが異なる 2 つの配列のサイズを表示します。  
  
 [!code-cpp[System.Array.GetLength\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  
  
 または  
  
 <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">長さを指定する必要がある <see cref="T:System.Array" /> の 0 から始まる次元。</param>
        <summary>
          <see cref="T:System.Array" /> の指定した次元にある要素の数を表す 64 ビット整数を取得します。</summary>
        <returns>指定した次元にある要素の数を表す 64 ビット整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 例を<xref:System.Array.GetLongLength%2A>は`GetLongLength(0)`の最初の次元で要素の数が返されます、<xref:System.Array>です。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  
  
 または  
  
 <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">開始インデックスを指定する配列の 0 から始まる次元。</param>
        <summary>配列内で指定した次元の、最初の要素のインデックスを取得します。</summary>
        <returns>配列内で指定した次元の、最初の要素のインデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `GetLowerBound(0)`配列の最初の次元の開始インデックスを返しますと`GetLowerBound(Rank - 1)`配列の最後の次元の開始インデックスを返します。  
  
 <xref:System.Array.GetLowerBound%2A>メソッドは、配列が空の場合でも常に、配列の下限のインデックスを示す値を返します。  
  
 なお、.NET Framework でのほとんどの配列は 0 から始まる \(は、<xref:System.Array.GetLowerBound%2A>配列の各次元のゼロが返される\)、.NET Framework は 0 から始まる配列をサポートします。 そのような配列を作成できます、<xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29>メソッド、およびアンマネージ コードから返すこともできます。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次の例では、<xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドを 1 次元、2 次元配列の境界を表示して、配列要素の値を表示します。  
  
 [!code-cpp[System.Array.GetUpperBound\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  
  
 または  
  
 <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">上限を指定する配列の 0 から始まる次元。</param>
        <summary>配列内で指定した次元の、最後の要素のインデックスを取得します。</summary>
        <returns>配列内で指定した次元の最後の要素のインデックス、または指定した次元が空の場合は \-1 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `GetUpperBound(0)`配列の最初の次元の最後のインデックスを返しますと`GetUpperBound(Rank - 1)`配列の最後の次元の最後のインデックスを返します。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次の例で、<xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>1 次元、2 次元配列の境界を表示して、配列要素の値を表示する方法です。  
  
 [!code-cpp[System.Array.GetUpperBound\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> が 0 未満です。  
  
 または  
  
 <paramref name="dimension" /> が <see cref="P:System.Array.Rank" /> 以上になっています。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得する <see cref="T:System.Array" /> 要素の位置を表す 32 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>方法を決定できるかどうかの値`index`が範囲外です。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 1 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> は 現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">取得する <see cref="T:System.Array" /> 要素の位置を指定するインデックスを表す 32 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値の配列として指定します。</summary>
        <returns>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内の要素の数`indices`内のディメンションの数と同じにする必要があります、<xref:System.Array>です。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>です。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が <paramref name="indices" /> 内の要素の数と等しくありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="indices" /> 内の要素が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">取得する <see cref="T:System.Array" /> 要素の位置を表す 64 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 64 ビット整数値として指定します。</summary>
        <returns>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>方法を決定できるかどうかの値`index`が範囲外です。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 1 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は 現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">取得する <see cref="T:System.Array" /> 要素の位置を指定するインデックスを表す 32 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 64 ビット整数値の配列として指定します。</summary>
        <returns>多次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素数 `indices` 内のディメンションの数と同じにする必要があります、 <xref:System.Array>です。 すべての要素、 `indices` 配列が多次元で目的の要素の位置をまとめて指定する必要があります <xref:System.Array>します。  
  
 <xref:System.Array.GetLowerBound%2A> と <xref:System.Array.GetUpperBound%2A> メソッドが範囲外のインデックスのいずれかであるかどうかを判断できます。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が <paramref name="indices" /> 内の要素の数と等しくありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indices" /> 内の要素が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>2 次元の <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>2 次元の <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 2 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> または <paramref name="index2" /> は、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>2 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 64 ビット整数値として指定します。</summary>
        <returns>2 次元の <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A> と <xref:System.Array.GetUpperBound%2A> メソッドが範囲外のインデックスのいずれかであるかどうかを判断できます。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 2 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> または <paramref name="index2" /> は、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index3">取得する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 32 ビット整数値として指定します。</summary>
        <returns>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドが範囲外のインデックスのいずれかであるかどうかを判断できます。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 3 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />、<paramref name="index2" />、または <paramref name="index3" /> は、現在の <see cref="T:System.Array" /> の対応する次元に有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">取得する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">取得する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index3">取得する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値を取得します。 インデックスは 64 ビット整数値として指定します。</summary>
        <returns>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A> と <xref:System.Array.GetUpperBound%2A> メソッドが範囲外のインデックスのいずれかであるかどうかを判断できます。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 3 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />、<paramref name="index2" />、または <paramref name="index3" /> は、現在の <see cref="T:System.Array" /> の対応する次元に有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる 1 次元配列。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを検索し、1 次元配列でそのオブジェクトが最初に見つかった位置のインデックス番号を返します。</summary>
        <returns>
          <paramref name="array" /> で <paramref name="value" /> が見つかった場合は、最初に見つかった位置のインデックス。それ以外の場合は、配列の下限 \- 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、1 次元 arrayfor のすべての要素を検索`value`です。 決定するかどうか`value`内に存在する`array`、メソッドを呼び出して各要素の等値比較を実行する`Equals`メソッドの一致が見つかるまでです。 つまり、この要素をオーバーライドする場合、<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>メソッド、その上書きが呼び出されます。  
  
 ほとんどの配列の下限を 0 ため、このメソッドは、– 1 返します通常を行う場合`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=fullName>\(0x80000000\) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=fullName>\(0x7FFFFFFF\) です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 例がの次の 3 つオーバー ロードを呼び出して、<xref:System.Array.IndexOf%2A>文字列配列の文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、文字列の最初に見つかった位置を決定する、文字列配列の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する文字列配列の最後の要素の 4 番目の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する、文字列"the"の配列を配列の末尾に最後の一致を後ろにある要素。  
  
 [!code-cpp[Classic Array.IndexOf Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる 1 次元配列。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始インデックス。 空の配列では 0 \(ゼロ\) は正しい値です。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 要素範囲は、指定されたインデックスから、配列の最後までの範囲です。</summary>
        <returns>
          <paramref name="startIndex" /> から最後の要素までを範囲として <paramref name="array" /> の要素範囲内で <paramref name="value" /> を検索し、見つかった場合は、インデックス番号の最も小さい要素のインデックス番号。それ以外の場合は、配列の下限 \- 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、1 次元配列のインデックス位置にある要素から、検索`startIndex`最後の要素。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`Equals`一致が見つかるまでのすべての要素のメソッドです。 つまり、この要素をオーバーライドする場合、<xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>メソッド、その上書きが呼び出されます。  
  
 ほとんどの配列の下限を 0 ため、このメソッドは、– 1 返します通常を行う場合`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=fullName>\(0x80000000\) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=fullName>\(0x7FFFFFFF\) です。  
  
 場合`startIndex`equals <xref:System.Array.Length%2A?displayProperty=fullName>\-1 を返します。 場合`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=fullName>がスローされます、<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`から要素の数は、`startIndex`の末尾に`array`です。  
  
   
  
## 例  
 例がの次の 3 つオーバー ロードを呼び出して、<xref:System.Array.IndexOf%2A>文字列配列の文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、文字列の最初に見つかった位置を決定する、文字列配列の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する文字列配列の最後の要素の 4 番目の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する、文字列"the"の配列を配列の末尾に最後の一致を後ろにある要素。  
  
 [!code-cpp[Classic Array.IndexOf Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が <paramref name="array" /> の正しいインデックスの範囲外です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索する 1 次元配列。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始インデックス。 空の配列の場合 0 \(ゼロ\) は有効です。</param>
        <param name="count">検索する要素数。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 範囲は、指定されたインデックスから始まり、指定された数の要素を含む範囲です。</summary>
        <returns>インデックス <paramref name="startIndex" /> から <paramref name="startIndex" /> \+ <paramref name="count" /> \- 1 までの <paramref name="array" /> 内で見つかった場合は、<paramref name="value" /> の最初の出現箇所のインデックス。見つからない場合は、配列の下限 \- 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、1 次元 arrayfrom の要素を検索`startIndex`に`startIndex`plus`count`から 1 を引いた場合`count`が 0 より大きい。 確認するかどうか`value`内に存在する`array`、メソッドの呼び出しで等値比較を実行する、`Equals`一致が見つかるまでのすべての要素のメソッドです。 つまり、この要素をオーバーライドする場合、<xref:System.Object.Equals%2A?displayProperty=fullName>メソッド、その上書きが呼び出されます。  
  
 Becausemost 配列の下限を 0 である一般的に、このメソッドは – 1 時を返します`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=fullName>\(0x80000000\) と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=fullName>\(0x7FFFFFFF\) です。  
  
 場合`startindex`equals <xref:System.Array.Length%2A?displayProperty=fullName>\-1 を返します。 場合`startIndex`がより大きい<xref:System.Array.Length%2A?displayProperty=fullName>がスローされます、<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`count`します。  
  
   
  
## 例  
 例がの次の 3 つオーバー ロードを呼び出して、<xref:System.Array.IndexOf%2A>文字列配列の文字列のインデックスを検索するメソッド。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>、文字列の最初に見つかった位置を決定する、文字列配列の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する文字列配列の最後の要素の 4 番目の"the"です。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>、文字列の最初に見つかった位置を決定する、文字列"the"の配列を配列の末尾に最後の一致を後ろにある要素。 値を決定する、`count`引数を配列の開始インデックスからの上限値を減算し、1 を追加します。  
  
 [!code-cpp[Classic Array.IndexOf Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを検索し、1 次元配列でそのオブジェクトが最初に見つかった位置のインデックス番号を返します。</summary>
        <returns>
          <paramref name="array" /> 全体を対象とする <paramref name="value" /> の検索で最初に見つかった位置のインデックス \(0 から始まる\)。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの 1 次元配列のすべての要素を検索する`value`です。 決定するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`T.Equals`のすべての要素のメソッドです。 つまり、`T`よりも優先、[IndexOf\(T\) メソッド \(T\<xref:System.Object.Equals%2A>メソッド、その上書きが呼び出されます。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は、[IndexOf\(T\) メソッド \(T\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次の例では、すべて次の 3 つジェネリック オーバー ロードの[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードが 3 のインデックスの場所を開始位置として、配列と、配列の末尾まで続行を検索するために使用し、文字列の 2 番目の出現箇所を検索します。 最後に、[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>その範囲内で検索文字列のインスタンスが存在しないため – 1 を返しますではメソッドのオーバー ロードを使用して、インデックス位置 2 から 2 つのエントリの範囲を検索します。  
  
 [!code-cpp[Array\_IndexOf\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array\_IndexOf\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array\_IndexOf\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。 空の配列では 0 \(ゼロ\) は有効です。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 要素範囲は、指定されたインデックスから、配列の最後までの範囲です。</summary>
        <returns>
          <paramref name="startIndex" /> から最後の要素までの <paramref name="array" /> 内の要素の範囲内で <paramref name="value" /> が見つかった場合は、最初に見つかった位置の 0 から始まるインデックス番号。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを 1 次元配列にある要素からは検索`startIndex`配列の末尾にします。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して、等値比較を実行し、`T.Equals`メソッドのすべての要素をします。 つまり、`T`よりも優先、[IndexOf\(T\) メソッド \(T\<xref:System.Object.Equals%2A>メソッド、その上書きが呼び出されます。  
  
 場合`startIndex`equals [IndexOf\(T\) メソッド \(T\<xref:System.Array.Length%2A>、メソッドを返します \- 1.If`startIndex`がより大きい[IndexOf\(T\) メソッド \(T\<xref:System.Array.Length%2A?displayProperty=fullName>がスローされます、[IndexOf\(T\) メソッド \(T\<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`から要素の数は、`startIndex`の末尾に`array`です。  
  
   
  
## 例  
 次の例では、すべて次の 3 つジェネリック オーバー ロードの[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードが 3 のインデックスの場所を開始位置として、配列と、配列の末尾まで続行を検索するために使用し、文字列の 2 番目の出現箇所を検索します。 最後に、[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>その範囲内で検索文字列のインスタンスが存在しないため – 1 を返しますではメソッドのオーバー ロードを使用して、インデックス位置 2 から 2 つのエントリの範囲を検索します。  
  
 [!code-cpp[Array\_IndexOf\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array\_IndexOf\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array\_IndexOf\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の配列。インデックス番号が 0 から始まる必要があります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">検索の開始位置を示す 0 から始まるインデックス。 空の配列では 0 \(ゼロ\) は正しい値です。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定されたオブジェクトを 1 次元配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。 要素範囲は、指定されたインデックスから始まり、指定された数の要素を含む範囲です。</summary>
        <returns>
          <paramref name="startIndex" /> から始まり <paramref name="count" /> で指定された数の要素を含む範囲内で <paramref name="array" /> の要素を検索して、最初に見つかった <paramref name="value" /> の位置を示す 0 から始まるインデックス番号。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッド searchesthe、1 次元の配列の要素から`startIndex`に`startIndex`plus`count`から 1 を引いた場合`count`が 0 より大きい。 確認するかどうか`value`内に存在する`array`、メソッドを呼び出して等値比較を実行する、`T.Equals`メソッドのすべての要素をします。 つまり、`T`よりも優先、[IndexOf\(T\) メソッド \(T\<xref:System.Object.Equals%2A>メソッド、その上書きが呼び出されます。  
  
 場合`startIndex`equals [IndexOf\(T\) メソッド \(T\<xref:System.Array.Length%2A?displayProperty=fullName>\-1 を返します。  場合`startIndex`がより大きい[IndexOf\(T\) メソッド \(T\<xref:System.Array.Length%2A?displayProperty=fullName>がスローされます、[IndexOf\(T\) メソッド \(T\<xref:System.ArgumentOutOfRangeException>です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`count`します。  
  
   
  
## 例  
 次の例では、すべて次の 3 つジェネリック オーバー ロードの[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%2A>メソッドです。 インデックス位置 0 と 5 のインデックス位置に 2 回、表示される 1 つのエントリで、文字列の配列が作成されます。[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>メソッドのオーバー ロードは、最初から配列を検索し、文字列の最初の出現箇所を検索します。[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>メソッドのオーバー ロードが 3 のインデックスの場所を開始位置として、配列と、配列の末尾まで続行を検索するために使用し、文字列の 2 番目の出現箇所を検索します。 最後に、[IndexOf\(T\) メソッド \(T\<xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>その範囲内で検索文字列のインスタンスが存在しないため – 1 を返しますではメソッドのオーバー ロードを使用して、インデックス位置 2 から 2 つのエントリの範囲を検索します。  
  
 [!code-cpp[Array\_IndexOf\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array\_IndexOf\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array\_IndexOf\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>値型の既定のコンストラクターを呼び出して、この値型 <see cref="T:System.Array" /> の各要素を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドがコンパイラが値型の配列をサポートするように設計されていますほとんどのユーザーには、このメソッドは必要ありません。 これは参照型の配列で使用しないでください。  
  
 場合、<xref:System.Array>値型ではない<xref:System.Array>または値の型に既定のコンス トラクターがあるない場合、<xref:System.Array>は変更されません。  
  
 値型<xref:System.Array>の下限およびディメンションの任意の数を持つことができます。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は<xref:System.Array.Length%2A>します。  
  
> [!CAUTION]
>  このメソッドはコンス トラクター; を持つ値型でのみ使用できます。ただし、ネイティブに C\# の場合は、値型には、コンス トラクターはありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> が固定サイズかどうかを示す値を取得します。</summary>
        <value>このプロパティは、すべての配列に対して常に <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array>実装する、<xref:System.Array.IsFixedSize%2A>プロパティが必要としているため、<xref:System.Collections.IList?displayProperty=fullName>インターフェイスです。  
  
 固定サイズの配列は、追加または削除できません要素の配列が作成された後で既存の要素は変更できます。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> が読み取り専用かどうかを示す値を取得します。</summary>
        <value>このプロパティは、すべての配列に対して常に <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array>実装する、<xref:System.Array.IsReadOnly%2A>プロパティが必要としているため、<xref:System.Collections.IList?displayProperty=fullName>インターフェイスです。 読み取り専用配列を追加、削除、または要素の変更後にできません、配列を作成します。  
  
 読み取り専用コレクションを必要とする場合を使用して、<xref:System.Collections>を実装するクラス、<xref:System.Collections.IList?displayProperty=fullName>インターフェイスです。  
  
 キャストの配列に変換するか、<xref:System.Collections.IList>インターフェイス オブジェクト、<xref:System.Collections.IList.IsReadOnly%2A?displayProperty=fullName>プロパティから返される`false`です。 ただし、キャストの配列に変換するか、 <xref:System.Collections.Generic.IList%601> 、インターフェイス、`IsReadOnly`プロパティから返される`true`です。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> へのアクセスが同期されている \(スレッド セーフである\) かどうかを示す値を取得します。</summary>
        <value>このプロパティは、すべての配列に対して常に <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array>実装する、<xref:System.Array.IsSynchronized%2A>プロパティが必要としているため、<xref:System.Collections.ICollection?displayProperty=fullName>インターフェイスです。  
  
 .NET framework のクラスがに基づいて<xref:System.Array>独自の同期されたバージョンを使用して、コレクションの提供、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 配列を使用するクラスに、独自の同期を使用することができますも実装、<xref:System.Array.SyncRoot%2A>プロパティです。 同期されたコードで操作を実行する必要があります、`SyncRoot`コレクションの操作は、コレクションのです。 これにより、他のオブジェクトから派生したコレクションを適切に操作できるようになります。 具体的には、コレクションを同時に変更する可能性がある別スレッドとの適切な同期を維持します。 なおの実装によって<xref:System.Array.SyncRoot%2A>返す可能性があります、<xref:System.Array>自体です。  
  
 コレクションの列挙は本質的にスレッド セーフな方法です。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
   
  
## 例  
 次のコード例を使用して配列を列挙中にロックする方法を示しています、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 [!code-cpp[System.Array.SyncRoot\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを検索し、1 次元の <see cref="T:System.Array" /> 全体でそのオブジェクトが最後に見つかった位置のインデックス番号を返します。</summary>
        <returns>
          <paramref name="array" /> 全体を対象に <paramref name="value" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素のインデックス番号。それ以外の場合は、配列の下限 \- 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 1 次元<xref:System.Array>後方の最後の要素の最初と最後の最初の要素が検索されます。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=fullName>メソッドです。 要素の型が非組み込みの \(ユーザー定義\) 型の場合、`Equals`その型の実装を使用します。  
  
 ほとんどの配列が下限を 0 であるためこのメソッドは、通常 – 1 の場合に`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=fullName>と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=fullName>、これは`System.Int32.MinValue - 1`します。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 .NET framework version 2.0 では、このメソッドを使用して、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、<xref:System.Array>を決定するかどうか、<xref:System.Object>によって指定された、`value`パラメーターが存在します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、 `value`<xref:System.Object>自体です。  
  
 <xref:System.IComparable.CompareTo%2A>メソッド、`item`パラメーター コレクション内のオブジェクトにします。  
  
   
  
## 例  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを確認する方法を示します。  
  
 [!code-cpp[Classic Array.LastIndexOf Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">逆方向検索の開始インデックス。</param>
        <summary>指定したオブジェクトを、1 次元 <see cref="T:System.Array" /> の先頭の要素から、指定されたインデックス位置までを範囲として検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns>
          <paramref name="array" /> の先頭の要素から <paramref name="startIndex" /> までを範囲として <paramref name="value" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素のインデックス番号。それ以外の場合は、配列の下限 \- 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 1 次元 <xref:System.Array> 検索旧バージョンとを開始位置として、 `startIndex` 、その最初の要素で終了します。  
  
 要素は、指定した値を使用して、 <xref:System.Object.Equals%2A?displayProperty=fullName> メソッドです。 要素の型が非組み込み \(ユーザー定義の\) 型の場合、 `Equals` その型の実装を使用します。  
  
 ほとんどの配列は、下限を 0 であるがので、このメソッドは、通常 – 1 と `value` が見つかりません。 配列の下限値と等しいはまれなケース <xref:System.Int32.MinValue?displayProperty=fullName> と `value` が検出されなければ、このメソッドが戻る <xref:System.Int32.MaxValue?displayProperty=fullName>, 、これは `System.Int32.MinValue - 1`です。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` の先頭から要素の数は、 `array` に `startIndex`します。  
  
 .NET framework version 2.0 では、このメソッドを使用して、 <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> のメソッド、 <xref:System.Array> を判断するかどうか、 <xref:System.Object> によって指定された、 `value` パラメーターが存在します。 .NET Framework の以前のバージョンでは、この判断を下しますを使用して行われた、 <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> のメソッド、 `value`<xref:System.Object> 自体です。  
  
   
  
## 例  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを特定する方法を示します。  
  
 [!code-cpp[Classic Array.LastIndexOf Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の正しいインデックスの範囲外です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">検索対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">逆方向検索の開始インデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定したオブジェクトを、1 次元 <see cref="T:System.Array" /> の指定したインデックス位置から、指定した要素数を範囲として検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns>
          <paramref name="count" /> の <paramref name="startIndex" /> から、<paramref name="array" /> で指定された要素数を範囲として <paramref name="value" /> を検索し、見つかった場合は、インデックス番号の最も大きい要素のインデックス番号。それ以外の場合は、配列の下限 \- 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 1 次元<xref:System.Array>検索旧バージョンとを開始位置として、`startIndex`で終わる`startIndex`マイナス`count`1、さらに場合`count`が 0 より大きい。  
  
 要素は、指定した値を使用して、<xref:System.Object.Equals%2A?displayProperty=fullName>メソッドです。 要素の型が非組み込みの \(ユーザー定義\) 型の場合、`Equals`その型の実装を使用します。  
  
 ほとんどの配列が下限を 0 であるためこのメソッドは、通常 – 1 の場合に`value`が見つかりません。 配列の下限の境界と等しいというまれなケース<xref:System.Int32.MinValue?displayProperty=fullName>と`value`が見つからない、このメソッドが戻る<xref:System.Int32.MaxValue?displayProperty=fullName>、これは`System.Int32.MinValue - 1`します。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`count`します。  
  
 .NET framework version 2.0 では、このメソッドを使用して、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、<xref:System.Array>を決定するかどうか、<xref:System.Object>によって指定された、`value`パラメーターが存在します。 .NET Framework の以前のバージョンでは、この決定を使用して行われた、<xref:System.Object.Equals%2A>と<xref:System.IComparable.CompareTo%2A>のメソッド、 `value`<xref:System.Object>自体です。  
  
   
  
## 例  
 次のコード例では、配列内の指定した要素の最後に見つかった位置のインデックスを確認する方法を示します。 注意してください、<xref:System.Array.LastIndexOf%2A>メソッドは逆方向検索です。 したがって、`count`以下にする必要があります \(`startIndex`マイナス 1 を足した数、配列の下限値\)。  
  
 [!code-cpp[Classic Array.LastIndexOf Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> および <paramref name="count" /> は <paramref name="array" /> 内の有効なセクションを指定していません。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <summary>指定したオブジェクトを <see cref="T:System.Array" /> 全体を対象に検索し、インデックス番号の最も大きい要素のインデックスを返します。</summary>
        <returns>
          <paramref name="value" /> が見つかった場合は、<paramref name="array" /> 全体で最後に見つかった位置のインデックス番号 \(0 から始まる\)。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [LastIndexOf\(T\) メソッド \(T\<xref:System.Array> は、最後の要素を起点と最初の要素の終了を逆方向検索します。  
  
 要素は、指定した値を使用して、 [LastIndexOf\(T\) メソッド \(T\<xref:System.Object.Equals%2A?displayProperty=fullName> メソッドです。 要素の型が非組み込み \(ユーザー定義の\) 型の場合、 `Equals` その型の実装を使用します。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は、 [LastIndexOf\(T\) メソッド \(T\<xref:System.Array.Length%2A> の `array`です。  
  
   
  
## 例  
 次のコード例をすべて次の 3 つ汎用のオーバー ロードを示しています、 [LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%2A> メソッドです。 インデックス位置 0 とインデックスの場所、5 に、2 回表示される 1 つのエントリで、文字列の配列が作成されます。[LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> メソッドのオーバー ロードから最後に、配列全体を検索し、文字列の 2 番目の出現箇所を検索します。[LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> メソッドのオーバー ロードが 3 のインデックスの場所で旧バージョンと配列と、配列の先頭に進むの検索に使用され、文字列の最初の出現箇所を検索します。 最後に、 [LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバー ロードが 4 のインデックス位置にある開始し、逆方向に拡張する 4 つのエントリの範囲を検索に使用される \(つまり、検索 4、3、2、および 1 の場所にある項目\)。 その範囲で検索文字列のインスタンスが存在しないため、この検索は – 1 を返します。  
  
 [!code-cpp[Array\_LastIndexOf\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array\_LastIndexOf\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array\_LastIndexOf\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">後方検索の開始位置を示す 0 から始まるインデックス。</param>
        <summary>指定したオブジェクトを、<see cref="T:System.Array" /> の先頭の要素から、指定されたインデックス位置までを範囲として検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns>最初の要素から <paramref name="startIndex" /> までの <paramref name="array" /> 内の要素の範囲内で <paramref name="value" /> が見つかった場合は、最後に見つかった位置の 0 から始まるインデックス番号。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [LastIndexOf\(T\) メソッド \(T\<xref:System.Array> 検索旧バージョンとを開始位置として、 `startIndex` 、その最初の要素で終了します。  
  
 要素は、指定した値を使用して、 [LastIndexOf\(T\) メソッド \(T\<xref:System.Object.Equals%2A?displayProperty=fullName> メソッドです。 要素の型が非組み込み \(ユーザー定義の\) 型の場合、 `Equals` その型の実装を使用します。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` の先頭から要素の数は、 `array` に `startIndex`します。  
  
   
  
## 例  
 次のコード例をすべて次の 3 つ汎用のオーバー ロードを示しています、 [LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%2A> メソッドです。 インデックス位置 0 とインデックスの場所、5 に、2 回表示される 1 つのエントリで、文字列の配列が作成されます。[LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> メソッドのオーバー ロードから最後に、配列全体を検索し、文字列の 2 番目の出現箇所を検索します。[LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> メソッドのオーバー ロードが 3 のインデックスの場所で旧バージョンと配列と、配列の先頭に進むの検索に使用され、文字列の最初の出現箇所を検索します。 最後に、 [LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバー ロードが 4 のインデックス位置にある開始し、逆方向に拡張する 4 つのエントリの範囲を検索に使用される \(つまり、検索 4、3、2、および 1 の場所にある項目\)。 その範囲で検索文字列のインスタンスが存在しないため、この検索は – 1 を返します。  
  
 [!code-cpp[Array\_LastIndexOf\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array\_LastIndexOf\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array\_LastIndexOf\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> は <paramref name="array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">検索する 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="value">
          <c>array</c> 内で検索するオブジェクト。</param>
        <param name="startIndex">逆方向検索の開始位置を示す 0 から始まるインデックス。</param>
        <param name="count">検索対象の範囲内にある要素の数。</param>
        <summary>指定したオブジェクトを、指定した数の要素を含み、かつ指定したインデックスで終了する <see cref="T:System.Array" /> の要素の範囲内で検索し、インデックス番号の最も大きい要素のインデックス番号を返します。</summary>
        <returns>
          <paramref name="count" /> で指定した数の要素を含み、<paramref name="startIndex" /> で終了する <paramref name="array" /> の要素の範囲内にある、インデックス番号の最も大きい <paramref name="value" /> の 0 から始まるインデックス番号。見つからない場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [LastIndexOf\(T\) メソッド \(T\<xref:System.Array> 検索旧バージョンとを開始位置として、 `startIndex` で終わる `startIndex` マイナス `count` 1 を加えた場合 `count` が 0 より大きい。  
  
 要素は、指定した値を使用して、 [LastIndexOf\(T\) メソッド \(T\<xref:System.Object.Equals%2A?displayProperty=fullName> メソッドです。 要素の型が非組み込み \(ユーザー定義の\) 型の場合、 `Equals` その型の実装を使用します。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は `count`です。  
  
   
  
## 例  
 次のコード例をすべて次の 3 つ汎用のオーバー ロードを示しています、 [LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%2A> メソッドです。 インデックス位置 0 とインデックスの場所、5 に、2 回表示される 1 つのエントリで、文字列の配列が作成されます。[LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> メソッドのオーバー ロードから最後に、配列全体を検索し、文字列の 2 番目の出現箇所を検索します。[LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> メソッドのオーバー ロードが 3 のインデックスの場所で旧バージョンと配列と、配列の先頭に進むの検索に使用され、文字列の最初の出現箇所を検索します。 最後に、 [LastIndexOf\(T\) メソッド \(T\<xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> メソッドのオーバー ロードが 4 のインデックス位置にある開始し、逆方向に拡張する 4 つのエントリの範囲を検索に使用される \(つまり、検索 4、3、2、および 1 の場所にある項目\)。 その範囲で検索文字列のインスタンスが存在しないため、この検索は – 1 を返します。  
  
 [!code-cpp[Array\_LastIndexOf\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array\_LastIndexOf\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array\_LastIndexOf\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> が <paramref name="array" /> の有効なインデックスの範囲外です。  
  
 または  
  
 <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="startIndex" /> <paramref name="count" /> で有効なセクションを指定しない <paramref name="array" />します。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> のすべての次元内の要素の総数を取得します。</summary>
        <value>
          <see cref="T:System.Array" /> のすべての次元内の要素の総数。配列内に要素がない場合はゼロ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
   
  
## 例  
 次の例では、<xref:System.Array.Length%2A>配列内の要素の合計数を取得するプロパティです。 また、使用、<xref:System.Array.GetUpperBound%2A>多次元配列の各次元内の要素の数を決定するメソッド。  
  
 [!code-csharp[System.Array.Length\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">配列は多次元で、<see cref="F:System.Int32.MaxValue" /> を超える要素が含まれます。</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> のすべての次元内の要素の総数を表す 64 ビット整数を取得します。</summary>
        <value>
          <see cref="T:System.Array" /> のすべての次元内の要素の総数を表す 64 ビット整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> のランク \(次元数\) を取得します。 たとえば、1 次元配列は 1 を返し、2 次元配列は 2 を返すなどです。</summary>
        <value>
          <see cref="T:System.Array" /> のランク \(次元数\)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 たとえば、Visual Basic コード  
  
```  
Dim TDArray(0,0,0) As Integer  
```  
  
 および c\# コード  
  
```  
int[,,] TDArray = new int[1,1,1];  
```  
  
 次の 3 つの次元の配列を作成、<xref:System.Array.Rank%2A>プロパティの値は 3 です。  
  
 ジャグ配列 \(配列の配列\) が 1 次元配列です。値、<xref:System.Array.Rank%2A>プロパティは 1 です。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
   
  
## 例  
 次の例は、1 次元の配列、2 次元の配列およびジャグ配列を初期化し、取得、<xref:System.Array.Rank%2A>それぞれのプロパティです。  
  
 [!code-csharp[System.Array.Rank\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[] array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">サイズ変更の対象となる、インデックス番号が 0 から始まる 1 次元配列。指定したサイズの新しい配列を作成する場合は <see langword="null" />。</param>
        <param name="newSize">新しい配列のサイズ。</param>
        <summary>1 次元配列の要素数を、指定した新しいサイズに変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、指定したサイズで新しい配列を割り当てます、要素を元の配列から新しい 1 つにコピーされ、新しい元の配列に置き換えます。`array` 1 次元配列でなければなりません。  
  
 場合`array`は`null`、このメソッドは、指定したサイズで新しい配列を作成します。  
  
 場合`newSize`がより大きい、[Resize\(T\) メソッド \(T\<xref:System.Array.Length%2A>元の配列の新しい配列が割り当てられ、新しいに元の配列からすべての要素がコピーされます。  場合`newSize`はより小さい[Resize\(T\) メソッド \(T\<xref:System.Array.Length%2A>元の配列の新しい配列が割り当てられている、要素がコピーされた元の配列から新しいゲートウェイに新しいが塗りつぶされるまで以外の場合は元の配列内の要素の残りの部分は無視されます。  場合`newSize`と等しい、[Resize\(T\) メソッド \(T\<xref:System.Array.Length%2A>の元の配列では、このメソッドでは何も行われません。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`newSize`します。  
  
 [Resize\(T\) メソッド \(T\<xref:System.Array.Resize%2A>メソッド サイズを 1 次元配列のみを変更します。[Resize\(T\) メソッド \(T\<xref:System.Array>多次元配列のサイズを変更するためのメソッドがクラスに含まれません。 これを行うには、独自のコードを指定するか、サード パーティ ライブラリで特殊なメソッドを呼び出す必要があります。 次のコードの配列のサイズを変更するメソッドの 1 つの可能な実装を示しています。 *n*ディメンションです。  
  
 [!code-csharp[System.Array.Resize\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## 例  
 次の例では、配列のサイズを変更するしくみを示します。  
  
 [!code-cpp[System.Array.Resize\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">反転させる 1 次元の <see cref="T:System.Array" />。</param>
        <summary>1 次元の <see cref="T:System.Array" /> 内全体の要素のシーケンスを反転させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドでは、位置にある要素への呼び出し後`myArray[i]`ここで、`i`配列内のすべてのインデックスに移動`myArray[j]`ここで、`j`と等しい`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`です。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 次の例に示すように、<xref:System.Array.Reverse%2A>ジャグ配列を反転させるメソッドを使用できます。 現在のカルチャのカレンダーの現在の年の各月の 1 つの要素を持つジャグ配列を初期化します。 各要素には、その月の日と同じ数の要素を配列が含まれています。 例では、呼び出し、配列の内容を表示する、<xref:System.Array.Reverse%2A>メソッド、および、逆順の配列の内容を表示します。  
  
 [!code-csharp[System.Array.Reverse\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## 例  
 次のコード例の値の並べ替えを取り消す方法を示しています、<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.Reverse Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">反転させる 1 次元の <see cref="T:System.Array" />。</param>
        <param name="index">反転させる範囲の先頭位置を示すインデックス。</param>
        <param name="length">反転対象の範囲内にある要素の数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> における要素範囲内の要素の並び順を反転させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドでは、位置にある要素への呼び出し後`myArray[i]`ここで、`i`配列のインデックスに移動`myArray[j]`ここで、`j`と等しい`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`です。  
  
 <xref:System.Array.Reverse%2A>ジャグ配列を反転させるメソッドを使用できます。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次のコード例は、内の要素の範囲内の値の並べ替えを取り消す方法を示しています、<xref:System.Array>です。  
  
 [!code-cpp[Classic Array.Reverse1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="index">設定する <see cref="T:System.Array" /> 要素の位置を表す 32 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>方法を決定できるかどうかの値`index`が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o \(1\) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 1 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> は現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> は 現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="indices">設定する要素の位置を指定するインデックスを表す 32 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 32 ビット整数値の配列として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内の要素の数`indices`内のディメンションの数と同じにする必要があります、<xref:System.Array>です。 すべての要素、`indices`配列が多次元で、目的の要素の位置をまとめて指定する必要があります<xref:System.Array>です。  
  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドは、かどうかの値のいずれかを判断できます、`indices`配列が範囲外です。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o \(1\) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>を割り当てるため`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が <paramref name="indices" /> 内の要素の数と等しくありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> は現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="indices" /> 内の要素が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="index">設定する <see cref="T:System.Array" /> 要素の位置を表す 64 ビット整数。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 64 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A> と <xref:System.Array.GetUpperBound%2A> メソッドを決定できるかどうかの値 `index` が範囲外です。  
  
 変換の詳細については、次を参照してください。 <xref:System.Convert>します。  
  
 このメソッドは、o \(1\) 操作です。  
  
> [!NOTE]
>  場合 <xref:System.Array.SetValue%2A> を割り当てるため `null` 値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は null 参照ではありませんし、null 参照の検索で見つけられない。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 1 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> は現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は 現在の <see cref="T:System.Array" /> の有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="indices">設定する要素の位置を指定するインデックスを表す 64 ビット整数の 1 次元配列。</param>
        <summary>多次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 64 ビット整数値の配列として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素数 `indices` 内のディメンションの数と同じにする必要があります、 <xref:System.Array>です。 すべての要素、 `indices` 配列が多次元で目的の要素の位置をまとめて指定する必要があります <xref:System.Array>します。  
  
 <xref:System.Array.GetLowerBound%2A> と <xref:System.Array.GetUpperBound%2A> かどうかの値のいずれかの方法を決定できます、 `indices` 配列が範囲外です。  
  
 変換の詳細については、次を参照してください。 <xref:System.Convert>します。  
  
 このメソッドは、o \(1\) 操作です。  
  
> [!NOTE]
>  場合 <xref:System.Array.SetValue%2A> を割り当てるため `null` 値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は null 参照ではありませんし、null 参照の検索で見つけられない。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> の次元数が <paramref name="indices" /> 内の要素の数と等しくありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> は現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indices" /> 内の要素が、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>2 次元 <see cref="T:System.Array" /> の指定された位置にある要素に値を設定します。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A>と<xref:System.Array.GetUpperBound%2A>メソッドでは、範囲外のインデックスのいずれかがいるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。<xref:System.Convert>です。  
  
 このメソッドは、o \(1\) 操作です。  
  
> [!NOTE]
>  場合<xref:System.Array.SetValue%2A>割り当てるために使用`null`値の型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は、null 参照ではありません、null 参照を検索して見つかりません。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> が 2 次元ではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> は現在の <see cref="T:System.Array" /> の要素型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> または <paramref name="index2" /> は、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>2 次元 <see cref="T:System.Array" /> の指定された位置にある要素に値を設定します。 インデックスは 64 ビット整数として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A> と <xref:System.Array.GetUpperBound%2A> メソッドが範囲外のインデックスのいずれかであるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。 <xref:System.Convert>します。  
  
 このメソッドは、o \(1\) 操作です。  
  
> [!NOTE]
>  場合 <xref:System.Array.SetValue%2A> を割り当てるため `null` 値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は null 参照ではありませんし、null 参照の検索で見つけられない。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 2 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> は現在の <see cref="T:System.Array" /> の要素型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> または <paramref name="index2" /> は、現在の <see cref="T:System.Array" /> の対応する次元の有効なインデックスの範囲に含まれていません。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">指定した要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 32 ビット整数。</param>
        <param name="index3">設定する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 32 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 32 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A> と <xref:System.Array.GetUpperBound%2A> メソッドが範囲外のインデックスのいずれかであるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。 <xref:System.Convert>します。  
  
 このメソッドは、o \(1\) 操作です。  
  
> [!NOTE]
>  場合 <xref:System.Array.SetValue%2A> を割り当てるため `null` 値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は null 参照ではありませんし、null 参照の検索で見つけられない。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> に設定されている次元が 3 つではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> は現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />、<paramref name="index2" />、または <paramref name="index3" /> は、現在の <see cref="T:System.Array" /> の対応する次元に有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">指定された要素の新しい値。</param>
        <param name="index1">設定する <see cref="T:System.Array" /> 要素の最初の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index2">設定する <see cref="T:System.Array" /> 要素の 2 番目の次元のインデックスを表す 64 ビット整数。</param>
        <param name="index3">設定する <see cref="T:System.Array" /> 要素の 3 番目の次元のインデックスを表す 64 ビット整数。</param>
        <summary>3 次元 <see cref="T:System.Array" /> 内の指定した位置にある要素に値を設定します。 インデックスは 64 ビット整数値として指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Array.GetLowerBound%2A> と <xref:System.Array.GetUpperBound%2A> メソッドが範囲外のインデックスのいずれかであるかどうかを判断できます。  
  
 変換の詳細については、次を参照してください。 <xref:System.Convert>します。  
  
 このメソッドは、o \(1\) 操作です。  
  
> [!NOTE]
>  場合 <xref:System.Array.SetValue%2A> を割り当てるため `null` 値型の配列の要素に、要素のすべてのフィールドが 0 に初期化されます。 要素の値は null 参照ではありませんし、null 参照の検索で見つけられない。  
  
   
  
## 例  
 次のコード例では、設定および 1 次元または多次元配列内の特定の値を取得する方法を示します。  
  
 [!code-cpp[System.Array\_GetSetValue\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array\_GetSetValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array\_GetSetValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 3 つの次元を持つわけではありません。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> は現在の <see cref="T:System.Array" /> の要素の型にキャストできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />、<paramref name="index2" />、または <paramref name="index3" /> は、現在の <see cref="T:System.Array" /> の対応する次元に有効なインデックスの範囲外です。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素の <see cref="T:System.IComparable" /> 実装を使用して、1 次元 <see cref="T:System.Array" /> 全体の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、[insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は; 不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次のコード例の値を並べ替える方法を示しています、<xref:System.Array>既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象となるキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items">
          <c>keys</c> <see cref="T:System.Array" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  
  
 \-または\-  
  
 <c>keys</c> <see cref="T:System.Array" /> のみを並べ替える場合は <see langword="null" />。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト \(一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する\) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各キーに、 `keys`<xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items`<xref:System.Array>同様の位置を変更します。 したがって、 `items`<xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 各キーに、 `keys`<xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`keys`します。  
  
   
  
## 例  
 次の例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" /> <see cref="T:System.Array" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="items" /> <see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" /> <see cref="T:System.Array" /> 内の 1 つ以上の要素が <see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元配列。</param>
        <param name="comparer">要素を比較する場合に使用する実装。  
  
 \-または\-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>1 次元 <see cref="T:System.Array" /> 内の要素を、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合`comparer`は`null`の各要素`array`実装する必要があります、<xref:System.IComparable>の他のすべての要素との比較ができるようにするインターフェイス`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
 .NET Framework は定義済み<xref:System.Collections.IComparer>実装は、次の表に示されています。  
  
|実装|説明|  
|--------|--------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName>|任意の 2 つのオブジェクトを比較しますが、文字列の大文字と小文字の比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=fullName>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=fullName>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することによって、カスタム比較をサポートすることも<xref:System.Collections.IComparer>実装を`comparer`パラメーター。 この例ではこれを定義して、`ReverseComparer`クラスの既定の並べ替え順序を反転する型のインスタンス大文字と小文字の文字列比較を実行します。  
  
   
  
## 例  
 次の例では、既定の比較子を使用して文字列 arrayby で値が並べ替えられます。 カスタムも定義<xref:System.Collections.IComparer>という名前の実装`ReverseComparer`を反転し、結果オブジェクトの既定の並べ替え順序、大文字と小文字の文字列の比較を実行します。 出力は、現在のカルチャによって異なる場合がありますに注意してください。  
  
 [!code-cpp[System.Array.Sort\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> であり、かつ <paramref name="array" /> 内の 1 つ以上の要素で、<see cref="T:System.IComparable" /> インターフェイスが実装されていません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage">
          <para>The .NET Framework 4 and earlier versions used only the Quicksort algorithm. Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer. For the most part, this applies to arrays with fewer than 16 elements.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象となるキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items">
          <c>keys</c> <see cref="T:System.Array" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  
  
 \-または\-  
  
 <c>keys</c> <see cref="T:System.Array" /> のみを並べ替える場合は <see langword="null" />。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 \-または\-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト \(一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する\) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各キーに、 `keys`<xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items`<xref:System.Array>同様の位置を変更します。 したがって、 `items`<xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 場合`comparer`は`null`、それぞれのキー、 `keys`<xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework は定義済み<xref:System.Collections.IComparer>実装は、次の表に示されています。  
  
|実装|説明|  
|--------|--------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName>|任意の 2 つのオブジェクトを比較しますが、文字列の大文字と小文字の比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=fullName>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=fullName>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することによって、カスタム比較をサポートすることも<xref:System.Collections.IComparer>実装を`comparer`パラメーター。 この例ではこれを定義して、<xref:System.Collections.IComparer>既定の並べ替え順序を反転し、大文字と小文字の文字列比較を実行する実装。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`keys`します。  
  
   
  
## 例  
 次の例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" /> <see cref="T:System.Array" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="items" /> <see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> が <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。  
  
 または  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較する場合、0 を返さない可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が <see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <block subset="none" type="usage">
          <para>The .NET Framework 4 and earlier versions used only the Quicksort algorithm. Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previouslythrew <see cref="T:System.ArgumentException" /> will not throw an exception, becausethe insertion sort and heapsort algorithms do not detect an invalid comparer. For the most part, this applies to arrays with fewer than 16 elements.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素によって実装された <see cref="T:System.IComparable" /> を使用して、1 次元 <see cref="T:System.Array" /> のうちある要素範囲の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内の要素の指定した範囲内の各要素`array`実装する必要があります、<xref:System.IComparable>で他のすべての要素との比較ができるようにするインターフェイス`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次のコード例は、内の値を並べ替える方法を示しています、<xref:System.Array>既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象のキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items">
          <c>keys</c> <see cref="T:System.Array" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  
  
 \-または\-  
  
 <c>keys</c> <see cref="T:System.Array" /> のみを並べ替える場合は <see langword="null" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト \(一方がキーを格納し、他方が対応する項目を格納する\) の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各キーに、 `keys`<xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items`<xref:System.Array>同様の位置を変更します。 したがって、 `items`<xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 内の要素の指定された範囲内の各キー、 `keys`<xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次のコード例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" /> <see cref="T:System.Array" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="items" /> <see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さよりも大きいです。  
  
 \-または\-  
  
 <paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> の有効な範囲を指定していません。  
  
 \-または\-  
  
 <paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> の有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" /> <see cref="T:System.Array" /> 内の 1 つ以上の要素が <see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">並べ替え対象となる 1 次元 <see cref="T:System.Array" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 \-または\-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>1 次元 <see cref="T:System.Array" /> の要素の範囲内の要素を、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `comparer` は `null`, 、内の要素の指定した範囲内の各要素 `array` を実装する必要があります、 <xref:System.IComparable> の他のすべての要素との比較ができるようにするインターフェイス `array`します。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework は定義済み <xref:System.Collections.IComparer> の実装は、次の表に示されています。  
  
|実装|説明|  
|--------|--------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName>|任意の 2 つのオブジェクトを比較しますが、文字列の小文字を区別しない比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=fullName>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=fullName>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName>|型の 2 つのオブジェクトを比較して `T` 型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することにより、カスタム比較をサポートすることも <xref:System.Collections.IComparer> 実装を `comparer` パラメーター。 この例ではこれを定義して、 `ReverseComparer` クラスの既定の並べ替え順序を反転する型のインスタンスが小文字を区別しない文字列比較を実行します。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) アルゴリズムです。  
  
-   パーティションの数が 2 を上回る場合 \* ログ<sup>N</sup>, ここで、  *N* 範囲を使用して、入力配列の [Heapsort](http://en.wikipedia.org/wiki/Heapsort) アルゴリズムです。  
  
-   それ以外の場合、それを使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort) アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行します。つまり、2 つの要素が等しい場合は、その順序が維持されない可能性があります。 これに対し、安定した並べ替えが等しい要素の順序を保持します。  
  
 最悪の場合、Heapsort およびクイック ソート アルゴリズムを使用して並べ替えた配列の場合は、このメソッドは、O \(`n` ログ `n`\) 操作の場合、 `n` は `length`です。  
  
   
  
## 例  
 次のコード例の値を並べ替える方法を示しています、 <xref:System.Array> 既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合があります注 <xref:System.Globalization.CultureInfo>します。  
  
 [!code-cpp[System.Array.Sort\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 \-または\-  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、項目をそれ自体と比較する場合、<paramref name="comparer" /> は 0 を返さない可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> であり、かつ <paramref name="array" /> 内の 1 つ以上の要素で、<see cref="T:System.IComparable" /> インターフェイスが実装されていません。</exception>
        <block subset="none" type="usage">
          <para>The .NET Framework 4 and earlier versions used only the Quicksort algorithm. Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer. For the most part, this applies to arrays with fewer than 16 elements.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">並べ替え対象となるキーを格納する 1 次元 <see cref="T:System.Array" />。</param>
        <param name="items">
          <c>keys</c> <see cref="T:System.Array" /> 内の各キーに対応する項目を格納する 1 次元 <see cref="T:System.Array" />。  
  
 \-または\-  
  
 <c>keys</c> <see cref="T:System.Array" /> のみを並べ替える場合は <see langword="null" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する場合に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 \-または\-  
  
 各要素の <see cref="T:System.IComparable" /> 実装を使用する場合は <see langword="null" />。</param>
        <summary>2 つの 1 次元 <see cref="T:System.Array" /> オブジェクト \(一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する\) 内の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.IComparer" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各キーに、 `keys`<xref:System.Array>に対応するアイテムがある、 `items`<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items`<xref:System.Array>同様の位置を変更します。 したがって、 `items`<xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`<xref:System.Array>です。  
  
 場合`comparer`は`null`、内の要素の指定された範囲内の各キー、 `keys`<xref:System.Array>実装する必要があります、<xref:System.IComparable>他のすべてのキーの比較ができるようにするインターフェイスです。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 .NET Framework は定義済み<xref:System.Collections.IComparer>実装は、次の表に示されています。  
  
|実装|説明|  
|--------|--------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=fullName>|任意の 2 つのオブジェクトを比較しますが、文字列の大文字と小文字の比較を実行します。|  
|<xref:System.Collections.Comparer.Default?displayProperty=fullName>|現在のカルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=fullName>|インバリアント カルチャの並べ替え規則を使用して、2 つのオブジェクトを比較します。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName>|型の 2 つのオブジェクトを比較`T`型の既定の並べ替え順序を使用しています。|  
  
 独自のインスタンスを提供することによって、カスタム比較をサポートすることも<xref:System.Collections.IComparer>実装を`comparer`パラメーター。 この例ではこのカスタムを定義することで<xref:System.Collections.IComparer>既定の並べ替え順序を反転し、大文字と小文字の文字列比較を実行する実装。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次のコード例では、キーと値を格納する 2 番目の配列の 2 つの関連付けられている配列を並べ替える方法を示します。 並べ替えを行います既定の比較子と並べ替え順序を反転するカスタムの比較演算子を使用します。 現在に応じて結果が異なる場合がありますを<xref:System.Globalization.CultureInfo>です。  
  
 [!code-cpp[System.Array.Sort2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" /> <see cref="T:System.Array" /> が多次元です。  
  
 \-または\-  
  
 <paramref name="items" /> <see cref="T:System.Array" /> が多次元です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  
  
 \-または\-  
  
 <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。  
  
 \-または\-  
  
 <paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> の有効な範囲を指定していません。  
  
 \-または\-  
  
 <paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  
  
 または  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較する場合、0 を返さない可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が <see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <block subset="none" type="usage">
          <para>The .NET Framework 4 and earlier versions used only the Quicksort algorithm. Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer. For the most part, this applies to arrays with fewer than 16 elements.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素によって実装された <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して、<see cref="T:System.Array" /> 全体の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各要素`array`実装する必要があります、<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は、<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次のコード例を示しています、<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>ジェネリック メソッドのオーバー ロードおよび<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードします。 任意の順序で、文字列の配列が作成されます。  
  
 配列が表示され、並べ替え、もう一度表示されます。  
  
> [!NOTE]
>  呼び出し、<xref:System.Array.Sort%2A>と<xref:System.Array.BinarySearch%2A>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c\#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、 [Ildasm.exe \(IL Disassembler\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b) Microsoft intermediate language \(MSIL\) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、<xref:System.Array.BinarySearch%2A>メソッドに渡される、`ShowWhere`場合は、文字列が検出され、それ以外の場合、要素検索文字列が間に配列を使用した場合は、インデックス値を表示するジェネリック メソッドです。 インデックスが負の値、文字列は、n がない場合、配列のため、`ShowWhere`メソッドにはビットごとの補数 \(、~ c\# および Visual C で演算子`Xor`Visual Basic では\-1\) が検索文字列より大きい一覧の最初の要素のインデックスを取得します。  
  
 [!code-cpp[Array\_SortSearch\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array\_SortSearch\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array\_SortSearch\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号が 0 から始まる必要があります。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素が実装する <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用する場合は <see langword="null" />。</param>
        <summary>
          <see cref="T:System.Array" /> 内の要素を、指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合`comparer`は`null`の各要素`array`実装する必要があります、[Sort\(T\) メソッド \(T\<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は、[Sort\(T\) メソッド \(T\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次のコード例を示しています、[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードおよび[Sort\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` \(`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で\) ジェネリック インターフェイス。 比較演算子の呼び出し、[Sort\(T\) メソッド \(T\<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低\-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 配列が表示され、並べ替え、もう一度表示されます。 配列を使用するために並べ替える必要があります、[Sort\(T\) メソッド \(T\<xref:System.Array.BinarySearch%2A>メソッドです。  
  
> [!NOTE]
>  呼び出し、[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と[Sort\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドの表示が、対応する非への呼び出しから、他と同じため、Visual Basic、c\#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、[Ildasm.exe \(IL Disassembler\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b)を Microsoft intermediate language \(MSIL\) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [Sort\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッドのオーバー ロードが 2 つの文字列の検索に使用しに含まれていない、配列と 1 つを 1 つです。 配列との戻り値、[Sort\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>メソッドに渡される、`ShowWhere`場合は、文字列が検出され、それ以外の場合、要素検索文字列が間に配列を使用した場合は、インデックス値を表示するジェネリック メソッドです。 インデックスが負の値、文字列は、n がない場合、配列のため、`ShowWhere`メソッドにはビットごとの補数 \(、~ c\# および Visual C で演算子`Xor`Visual Basic では\-1\) が検索文字列より大きい一覧の最初の要素のインデックスを取得します。  
  
 [!code-cpp[Array\_SortSearchComparer\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array\_SortSearchComparer\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array\_SortSearchComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage">
          <para>The .NET Framework 4 and earlier versions used only the Quicksort algorithm. Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer. For the most part, this applies to arrays with fewer than 16 elements.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="comparison">要素を比較する場合に使用する <see cref="T:System.Comparison`1" />。</param>
        <summary>
          <see cref="T:System.Array" /> 内の要素を、指定した <see cref="T:System.Comparison`1" /> を使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は、[Sort\(T\) メソッド \(T\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次のコード例を示しています、[Sort\(T\) メソッド \(T\<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列に対して代替の比較のメソッドを定義`CompareDinosByLength`です。 このメソッドは次のように機能します。 最初に、テスト、comparandsare`null`、null 参照が null でない未満として扱われます。 次に、文字列の長さが比較され、長い文字列は、大きい値を指定するものと見なされます。 3 番目に、長さが等しい場合は、通常の文字列比較は使用されます。  
  
 文字列の配列が作成され、任意の順序で、4 つの文字列に設定されます。 一覧は、空の文字列と null 参照にも含まれます。 使用して並べ替えられて、一覧が表示されます、[Sort\(T\) メソッド \(T\<xref:System.Comparison%601>を表すジェネリック デリゲート、`CompareDinosByLength`メソッドを再び表示されます。  
  
 [!code-cpp[Array\_SortComparison\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array\_SortComparison\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array\_SortComparison\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="comparison" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparison" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparison" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <block subset="none" type="usage">
          <para>The .NET Framework 4 and earlier versions used only the Quicksort algorithm. Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer. For the most part, this applies to arrays with fewer than 16 elements.</para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>
          <see cref="T:System.Array" /> の各要素の <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスの実装を使用して、<see cref="T:System.Array" /> の中のある要素範囲の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内の要素の指定した範囲内の各要素`array`実装する必要があります、[Sort\(T\) メソッド \(T\<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次のコード例を示しています、[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードおよび[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>配列内の範囲を並べ替えるためのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` \(`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で\) ジェネリック インターフェイス。 比較演算子の呼び出し、[Sort\(T\) メソッド \(T\<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低\-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前では、正確に言うと\) 後に次の 3 つの恐竜から成る配列を表示します。[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>が表示され、配列の最後の 3 つの要素を並べ替えるジェネリック メソッドのオーバー ロードを使用します。[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>とジェネリック メソッドのオーバー ロードを使用`ReverseCompare`最後の 3 つの要素を逆の順序で並べ替える。 徹底的に混乱を防ぐ恐竜が再度表示されます。  
  
> [!NOTE]
>  呼び出し、[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と[Sort\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッド表示が、対応する非への呼び出しと異なるため、Visual Basic、c\#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、[Ildasm.exe \(IL Disassembler\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b)を Microsoft intermediate language \(MSIL\) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array\_SortIntIntIComparer\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array\_SortIntIntIComparer\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array\_SortIntIntIComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">並べ替える 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素の <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスの実装を使用する場合は <see langword="null" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して、<see cref="T:System.Array" /> 内の要素の範囲内の要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合`comparer`は`null`、内の要素の指定した範囲内の各要素`array`実装する必要があります、[Sort\(T\) メソッド \(T\<xref:System.IComparable%601>ジェネリック インターフェイスの他のすべての要素との比較ができるようにする`array`です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次のコード例を示しています、[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>ジェネリック メソッドのオーバー ロードおよび[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>配列内の範囲を並べ替えるためのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` \(`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で\) ジェネリック インターフェイス。 比較演算子の呼び出し、[Sort\(T\) メソッド \(T\<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低\-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前では、正確に言うと\) 後に次の 3 つの恐竜から成る配列を表示します。[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>が表示され、配列の最後の 3 つの要素を並べ替えるジェネリック メソッドのオーバー ロードを使用します。[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>とジェネリック メソッドのオーバー ロードを使用`ReverseCompare`最後の 3 つの要素を逆の順序で並べ替える。 徹底的に混乱を防ぐ恐竜が再度表示されます。  
  
> [!NOTE]
>  呼び出し、[Sort\(T\) メソッド \(T\<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>と[Sort\(T\) メソッド \(T\<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>ジェネリック メソッド表示が、対応する非への呼び出しと異なるため、Visual Basic、c\#、および C は、最初の引数の型から、ジェネリック型パラメーターの型を推論します。 使用する場合、[Ildasm.exe \(IL Disassembler\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b)を Microsoft intermediate language \(MSIL\) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array\_SortIntIntIComparer\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array\_SortIntIntIComparer\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array\_SortIntIntIComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="array" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> および <paramref name="length" /> は <paramref name="array" /> の有効な範囲を指定していません。  
  
 \-または\-  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、項目をそれ自体と比較する場合、<paramref name="comparer" /> は 0 を返さない可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> が <see langword="null" /> で、<paramref name="array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <block subset="none" type="usage">
          <para>The .NET Framework 4 and earlier versions used only the Quicksort algorithm. Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer. For the most part, this applies to arrays with fewer than 16 elements.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーが格納されている 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="items">
          <c>keys</c> 内のキーに対応する項目が格納されている 1 次元の <see cref="T:System.Array" /> \(インデックス番号は 0 から始まります\)。<c>keys</c> だけを並べ替える場合は <see langword="null" />。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト \(一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する\) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各キーに、 `keys`[Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array>に対応するアイテムがある、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array>同様の位置を変更します。 したがって、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`[Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array>です。  
  
 各キーに、 `keys`[Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array>実装する必要があります、[Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、[Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は、[Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次のコード例を示しています、 [Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 [Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、 [Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および[Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` \(`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で\) ジェネリック インターフェイス。 比較演算子の呼び出し、[Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低\-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 このコード例では、作成し、恐竜の名前 \(キー\) の配列と各恐竜メートル \(値\) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列内の恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロード クラスのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が、対応する非への呼び出しの間に違い Visual Basic、c\#、および C\+\+ の最初の 2 つの引数の型からジェネリック型パラメーターの型を推論するため。 使用する場合、 [Ildasm.exe \(IL Disassembler\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b) Microsoft intermediate language \(MSIL\) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  
  
 \-または\-  
  
 <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" /> <see cref="T:System.Array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーが格納されている 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="items">
          <c>keys</c> 内のキーに対応する項目が格納されている 1 次元の <see cref="T:System.Array" /> \(インデックス番号は 0 から始まります\)。<c>keys</c> だけを並べ替える場合は <see langword="null" />。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素の <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスの実装を使用する場合は <see langword="null" />。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト \(一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する\) を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各キーに、 `keys`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>に対応するアイテムがある、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>同様の位置を変更します。 したがって、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>です。  
  
 場合`comparer`は`null`、それぞれのキー、 `keys`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>実装する必要があります、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.IComparable%601>他のすべてのキーの比較ができるようにするジェネリック インターフェイス。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次のコード例を示しています、 [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` \(`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で\) ジェネリック インターフェイス。 比較演算子の呼び出し、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低\-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 このコード例では、作成し、恐竜の名前 \(キー\) の配列と各恐竜メートル \(値\) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列内の恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは、インスタンスの`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が、対応する非への呼び出しの間に違い Visual Basic、c\#、および C\+\+ の最初の 2 つの引数の型からジェネリック型パラメーターの型を推論するため。 使用する場合、 [Ildasm.exe \(IL Disassembler\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b) Microsoft intermediate language \(MSIL\) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  
  
 \-または\-  
  
 <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。  
  
 または  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> は <see langword="null" />であり、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <block subset="none" type="usage">
          <para>The .NET Framework 4 and earlier versions used only the Quicksort algorithm. Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer. For the most part, this applies to arrays with fewer than 16 elements.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーが格納されている 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="items">
          <c>keys</c> 内のキーに対応する項目が格納されている 1 次元の <see cref="T:System.Array" /> \(インデックス番号は 0 から始まります\)。<c>keys</c> だけを並べ替える場合は <see langword="null" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト \(一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する\) の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、各キーによって実装された <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各キーに、 `keys`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>に対応するアイテムがある、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>同様の位置を変更します。 したがって、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>です。  
  
 内の要素の指定された範囲内の各キーの`keys`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>実装する必要があります、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次のコード例を示しています、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、 [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>` \(`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で\) ジェネリック インターフェイス。 比較演算子の呼び出し、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低\-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 \(キー\) の配列と各恐竜メートル \(値\) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列で恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロード クラスのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が非ジェネリックの対応する呼び出しの間に違い Visual Basic、c\#、および C\+\+ の最初の 2 つの引数の型のジェネリック型パラメーターの型を推論するため。 使用する場合、[Ildasm.exe \(IL Disassembler\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b)を Microsoft intermediate language \(MSIL\) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  
  
 \-または\-  
  
 <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。  
  
 \-または\-  
  
 <paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> の有効な範囲を指定していません。  
  
 \-または\-  
  
 <paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> において有効な範囲を指定していません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="keys" /> <see cref="T:System.Array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">キー用の配列要素の型。</typeparam>
        <typeparam name="TValue">項目用の配列要素の型。</typeparam>
        <param name="keys">並べ替えるキーが格納されている 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="items">
          <c>keys</c> 内のキーに対応する項目が格納されている 1 次元の <see cref="T:System.Array" /> \(インデックス番号は 0 から始まります\)。<c>keys</c> だけを並べ替える場合は <see langword="null" />。</param>
        <param name="index">並べ替え対象の範囲の開始位置を示すインデックス。</param>
        <param name="length">並べ替え対象の範囲内にある要素の数。</param>
        <param name="comparer">要素を比較する際に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスの実装。各要素の <see cref="T:System.IComparable`1" /> ジェネリック インターフェイスの実装を使用する場合は <see langword="null" />。</param>
        <summary>2 つの <see cref="T:System.Array" /> オブジェクト \(一方のオブジェクトがキーを格納し、他方のオブジェクトがそれらに対応する項目を格納する\) 内の要素範囲を、最初の <see cref="T:System.Array" /> 内のキーに基づき、指定した <see cref="T:System.Collections.Generic.IComparer`1" /> ジェネリック インターフェイスを使用して並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各キーに、 `keys`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>に対応するアイテムがある、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>です。 キーが、並べ替え、対応する項目の中に再配置される、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>同様の位置を変更します。 したがって、 `items`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>内の対応するキーの並べ替え方法に従って並べ替えられて、 `keys`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>です。  
  
 場合`comparer`は`null`、内の要素の指定された範囲内の各キー、 `keys`[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array>実装する必要があります、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.IComparable%601>ジェネリック インターフェイスとその他のすべてのキーの比較ができるようにします。  
  
 キーよりも項目がありますが、対応するキーのない項目が並べ替えられていない場合を並べ替えることができます。 項目はより多くのキーがある場合に並べ替えることはできません。スローされること、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.ArgumentException>です。  
  
 並べ替えが正常に完了していない場合、結果は未定義です。  
  
 このメソッドは、次のような内省的で並べ替え \(introsort\) アルゴリズムを使用します。  
  
-   パーティションのサイズが 16 個未満の要素の場合は、これを使用して、 [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort)アルゴリズムです。  
  
-   パーティションの数が 2 を超える場合 \* ログ<sup>N</sup>ここで、 *N*範囲を使用して、入力配列の[Heapsort](http://en.wikipedia.org/wiki/Heapsort)アルゴリズムです。  
  
-   それ以外の場合、使用して、 [Quicksort](http://en.wikipedia.org/wiki/Quicksort)アルゴリズムです。  
  
 この実装は、不安定な並べ替えを実行しますつまり、2 つの要素が等しい場合、順序が維持されない可能性があります。 これに対し、安定した並べ替えには、同じである要素の順序が保持されます。  
  
 最悪の場合、Heapsort とクイック ソート アルゴリズムの使用により並べ替えられた配列の場合は、このメソッドは、O \(`n`ログ`n`\) 操作では、ここで`n`は`length`します。  
  
   
  
## 例  
 次のコード例を示しています、 [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、 [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>、および[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>の並べ替えキーと値を表す配列のペアのジェネリック メソッドのオーバー ロードします。  
  
 このコード例は、名前付き文字列の代替の比較子を定義`ReverseCompare`を実装する、 `IComparer<string>`\(`IComparer(Of String)` Visual basic で`IComparer<String^>`Visual C で\) ジェネリック インターフェイス。 比較演算子の呼び出し、[Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.String.CompareTo%28System.String%29>メソッド、文字列は、低\-高にではなく高から低を並べ替えられるように、比較対照値の順序を反転します。  
  
 コード例では、作成し、恐竜の名前 \(キー\) の配列と各恐竜メートル \(値\) の最大長を表す整数の配列が表示されます。 配列の並べ替え、および複数回表示されます。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>オーバー ロードは最初の配列で恐竜名の順序で両方の配列の並べ替えに使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロード クラスのインスタンスおよび`ReverseCompare`ペアの配列の並べ替え順序を反転させるために使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>オーバー ロードは両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
-   [Sort\(TKey, TValue\) メソッド \(TKey\[\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>オーバー ロードは逆の順序で両方の配列の最後の 3 つの要素の並べ替えに使用します。  
  
> [!NOTE]
>  ジェネリック メソッドの呼び出しの表示が、対応する非への呼び出しの間に違い Visual Basic、c\#、および C\+\+ の最初の 2 つの引数の型からジェネリック型パラメーターの型を推論するため。 使用する場合、[Ildasm.exe \(IL Disassembler\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b)を Microsoft intermediate language \(MSIL\) を確認するには、ジェネリック メソッドが呼び出されることを確認できます。  
  
 [!code-cpp[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array\_Sort2IntIntIComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> は、<paramref name="keys" /> の下限を下回っています。  
  
 \-または\-  
  
 <paramref name="length" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の下限が <paramref name="items" /> の下限と一致していません。  
  
 \-または\-  
  
 <paramref name="items" /> は <see langword="null" /> ではなく、<paramref name="keys" /> の長さが <paramref name="items" /> の長さを超えています。  
  
 \-または\-  
  
 <paramref name="index" /> および <paramref name="length" /> は <paramref name="keys" /><see cref="T:System.Array" /> の有効な範囲を指定していません。  
  
 \-または\-  
  
 <paramref name="items" /> は <see langword="null" /> でなく、<paramref name="index" /> と <paramref name="length" /> は <paramref name="items" /><see cref="T:System.Array" /> において有効な範囲を指定していません。  
  
 または  
  
 <paramref name="comparer" /> の実装により、並べ替え中にエラーが発生しました。 たとえば、<paramref name="comparer" /> は、項目をそれ自体と比較したときに 0 を返さなかった可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> は <see langword="null" />であり、<paramref name="keys" /><see cref="T:System.Array" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable`1" /> ジェネリック インターフェイスを実装していません。</exception>
        <block subset="none" type="usage">
          <para>The .NET Framework 4 and earlier versions used only the Quicksort algorithm. Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer. For the most part, this applies to arrays with fewer than 16 elements.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> へのアクセスを同期するために使用できるオブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Array" /> へのアクセスを同期するために使用できるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを実装して、<xref:System.Collections.ICollection?displayProperty=fullName>インターフェイスです。  
  
 .NET framework のクラスがに基づいて<xref:System.Array>独自の同期されたバージョンを使用して、コレクションの提供、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 配列を使用するクラスに、独自の同期を使用することができますも実装、<xref:System.Array.SyncRoot%2A>プロパティです。 同期されたコードで操作を実行する必要があります、`SyncRoot`コレクションの操作は、コレクションのです。 これにより、他のオブジェクトから派生したコレクションを適切に操作できるようになります。 具体的には、コレクションを同時に変更する可能性がある別スレッドとの適切な同期を維持します。 なおの実装によって<xref:System.Array.SyncRoot%2A>返す可能性があります、<xref:System.Array>自体です。  
  
 コレクションの列挙は本質的にスレッド セーフな方法です。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
   
  
## 例  
 次のコード例を使用して配列を列挙中にロックする方法を示しています、<xref:System.Array.SyncRoot%2A>プロパティです。  
  
 [!code-cpp[System.Array.SyncRoot\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> に格納されている要素の数を取得します。</summary>
        <value>コレクションに格納されている要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.ICollection> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Collections.IList" /> に追加するオブジェクト。</param>
        <summary>このメソッドを呼び出すと、必ず <see cref="T:System.NotSupportedException" /> 例外がスローされます。</summary>
        <returns>配列への値の追加はサポートされていません。 値は返されません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 通常、<xref:System.Collections.IList.Add%2A?displayProperty=fullName>実装では、コレクションにメンバーを追加します。 ただし、配列がある固定サイズのため \(、<xref:System.Array.IsFixedSize%2A>プロパティは常に返します`true`\)、このメソッドは常にスロー、<xref:System.NotSupportedException>例外。  
  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IList" /> からすべての項目を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> は読み取り専用です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のリスト内で検索するオブジェクト。 参照型の場合は、検索する要素として <see langword="null" /> を指定できます。</param>
        <summary>ある要素が <see cref="T:System.Collections.IList" /> 内に存在するかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="value" /> に存在する場合は <see cref="T:System.Collections.IList" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のリスト内で検索するオブジェクト。</param>
        <summary>
          <see cref="T:System.Collections.IList" /> 内の特定の項目のインデックスを確認します。</summary>
        <returns>値がリストに存在する場合はそのインデックス。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">
          <c>value</c> を挿入する位置のインデックス番号。</param>
        <param name="value">挿入するオブジェクト。</param>
        <summary>指定したインデックスの <see cref="T:System.Collections.IList" /> に項目を挿入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が <see cref="T:System.Collections.IList" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> は読み取り専用です。  
  
 \-または\-  
  
 <see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> は <see cref="T:System.Collections.IList" /> の null 参照です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得または設定する要素のインデックス。</param>
        <summary>指定したインデックスにある要素を取得または設定します。</summary>
        <value>指定したインデックス位置にある要素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 使用する場合にのみ、<xref:System.Array>にインスタンスをキャスト、<xref:System.Collections.IList>インターフェイスです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> が <see cref="P:System.Collections.ICollection.Count" /> 以上になっています。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Array" /> は正確に 1 つの次元を持つわけではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Collections.IList" /> から削除するオブジェクト。</param>
        <summary>特定のオブジェクトが <see cref="T:System.Collections.IList" /> 内にあるときに、最初に出現したものを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> は読み取り専用です。  
  
 \-または\-  
  
 <see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">削除する要素のインデックス。</param>
        <summary>指定したインデックスにある <see cref="T:System.Collections.IList" /> 項目を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IList> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">インデックスが <see cref="T:System.Collections.IList" /> の正しいインデックスではありません。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> は読み取り専用です。  
  
 \-または\-  
  
 <see cref="T:System.Collections.IList" /> は固定サイズです。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較するオブジェクト。</param>
        <param name="comparer">現在のオブジェクトと <c>other</c> とを比較するオブジェクト。</param>
        <summary>現在のコレクション オブジェクトの並べ替え順序での位置が、別のオブジェクトと比べて前か、後か、または同じかを判断します。</summary>
        <returns>現在のコレクション オブジェクトと他のオブジェクトとの関係を示す整数。次の表を参照してください。  
  
 <list type="table">  
<listheader>  
<term> 戻り値  
  
 </term>  
<description> 説明  
  
 </description>  
</listheader>  
<item>  
<term> \-1  
  
 </term>  
<description> 現在のインスタンスの前に<paramref name="other" />です。  
  
 </description>  
</item>  
<item>  
<term> 0  
  
 </term>  
<description> 現在のインスタンスと<paramref name="other" />が等しい。  
  
 </description>  
</item>  
<item>  
<term> 1  
  
 </term>  
<description> 現在のインスタンスに依存して<paramref name="other" />です。  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Array> のインスタンスが <xref:System.Collections.IStructuralComparable> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">現在のインスタンスと比較するオブジェクト。</param>
        <param name="comparer">現在のインスタンスと <c>other</c> が等しいかどうかを判断するオブジェクト。</param>
        <summary>オブジェクトが現在のインスタンスと等しいかどうかを判断します。</summary>
        <returns>2 つのオブジェクトが等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 使用する場合にのみ、<xref:System.Array>にインスタンスをキャスト、<xref:System.Collections.IStructuralEquatable>インターフェイスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">現在のオブジェクトのハッシュ コードを計算するオブジェクト。</param>
        <summary>現在のインスタンスのハッシュ コードを返します。</summary>
        <returns>現在のインスタンスのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 使用する場合にのみ、<xref:System.Array>にインスタンスをキャスト、<xref:System.Collections.IStructuralEquatable>インターフェイスです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">配列要素の型。</typeparam>
        <param name="array">条件が一致するかどうかをチェックする 1 次元の <see cref="T:System.Array" />。インデックス番号は 0 から始まります。</param>
        <param name="match">要素についてチェックする条件を定義する述語。</param>
        <summary>配列内のすべての要素が、指定された述語によって定義された条件と一致するかどうかを調べます。</summary>
        <returns>
          <paramref name="array" /> 内のすべての要素が、指定された述語によって定義された条件と一致する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 配列内に要素がない場合、戻り値は <see langword="true" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [TrueForAll\(T\) メソッド \(T\<xref:System.Predicate%601>を返すメソッドをデリゲート`true`デリゲートで定義された条件と一致する場合は、オブジェクトに渡されます。  要素`array`に個別に渡される、 [TrueForAll\(T\) メソッド \(T\<xref:System.Predicate%601>、デリゲートが返されるときの処理が停止および`false`任意の要素。  
  
 このメソッドは、O \(`n`\) 操作では、ここで`n`は、[TrueForAll\(T\) メソッド \(T\<xref:System.Array.Length%2A>の`array`します。  
  
   
  
## 例  
 次の例は、文字列の配列内の各要素の最後の文字が数字かどうかを判断します。 2 つの文字列配列を作成します。 両方の文字列のアルファベット文字と数字で終わる文字列で終わる最初 arrayincludes です。2 番目の配列は、数字で終わる文字列ののみで構成されます。 また、`EndWithANumber`メソッド シグネチャが一致する、[TrueForAll\(T\) メソッド \(T\<xref:System.Predicate%601>委任です。 各配列を渡します、[TrueForAll\(T\) メソッド \(T\<xref:System.Array.TrueForAll%2A>メソッドを表すデリゲートと、`EndsWithANumber`メソッドです。  
  
 [!code-csharp[System.Array.TrueForAll\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 文字列配列を通過する点を除いて、次の例は、最初に似ています、[TrueForAll\(T\) メソッド \(T\<xref:System.Array.TrueForAll%2A>メソッドと、特定の配列要素は、数値の文字列形式で終わるかどうかを決定するラムダ式。  
  
 [!code-csharp[System.Array.TrueForAll\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 どちらの場合、[TrueForAll\(T\) メソッド \(T\<xref:System.Array.TrueForAll%2A>メソッドを返します。`false`数値の中で終わっていない最初の配列要素に到達したとすぐにします。 返しますそれ以外の場合、`true`後、配列内のすべての要素を反復処理します。  
  
> [!NOTE]
>  どちらの例から分かるように、c\# および Visual Basic では、作成する必要はありません、`Predicate<string>`委任 \(`Predicate(Of String)` Visual Basic の\) 明示的にします。 これらの言語では、コンテキストから適切なデリゲートを推論し、自動的に作成します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="match" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 次元 <see cref="T:System.Array" /> 内または <see cref="T:System.Array" /> の一部内の要素の順序を反転させます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>一方の <see cref="T:System.Array" /> の要素範囲を他方の <see cref="T:System.Array" /> にコピーし、必要に応じて型キャストとボックス化を実行します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 次元 <see cref="T:System.Array" /> 内または <see cref="T:System.Array" /> の範囲内で値が最後に見つかった位置のインデックス番号を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の 1 次元配列のすべての要素を、指定した 1 次元配列にコピーします。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された述語によって定義された条件と一致する要素を、<see cref="T:System.Array" /> またはその一部分を対象に検索し、最もインデックス番号の小さい要素の 0 から始まるインデックスを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Array" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Array" /> 内の指定した要素の値を取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイナリ サーチ アルゴリズムを使用して、並べ替え済みの 1 次元の <see cref="T:System.Array" /> 内で値を検索します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Array" /> 内の指定した要素を指定した値に設定します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 次元配列の要素を並べ替えます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたオブジェクトを 1 次元の配列または配列の要素範囲内で検索し、最初に見つかったオブジェクトのインデックスを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された述語によって定義された条件と一致する要素を、<see cref="T:System.Array" /> またはその一部分を対象に検索し、最もインデックス番号の大きい要素の 0 から始まるインデックスを返します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>