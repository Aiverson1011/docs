<Type Name="Double" FullName="System.Double">
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>倍精度浮動小数点数を表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Double> value type represents a double\-precision 64\-bit number with values ranging from negative 1.79769313486232e308 to positive 1.79769313486232e308, as well as positive or negative zero, <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>, and not a number \(<xref:System.Double.NaN>\). It is intended to represent values that are extremely large \(such as distances between planets or galaxies\) or extremely small \(the molecular mass of a substance in kilograms\) and that often are imprecise \(such as the distance from earth to another solar system\), The <xref:System.Double> type complies with the IEC 60559:1989 \(IEEE 754\) standard for binary floating\-point arithmetic.  
  
 This topic consists of the following sections:  
  
-   [Floating\-point representation and precision](#Precision)  
  
-   [Testing for equality](#Equality)  
  
-   [Floating\-point values and exceptions](#Exceptions)  
  
-   [Type conversions and the Double structure](#Conversions)  
  
-   [Floating\-point functionality](#Functionality)  
  
<a name="Precision"></a>   
## Floating\-Point Representation and Precision  
 The <xref:System.Double> data type stores double\-precision floating\-point values in a 64\-bit binary format, as shown in the following table:  
  
|Part|Bits|  
|----------|----------|  
|Significand or mantissa|0\-51|  
|Exponent|52\-62|  
|Sign \(0 \= Positive, 1 \= Negative\)|63|  
  
 Just as decimal fractions are unable to precisely represent some fractional values \(such as 1\/3 or <xref:System.Math.PI?displayProperty=fullName>\), binary fractions are unable to represent some fractional values. For example, 1\/10, which is represented precisely by .1 as a decimal fraction, is represented by .001100110011 as a binary fraction, with the pattern "0011" repeating to infinity. In this case, the floating\-point value provides an imprecise representation of the number that it represents. Performing additional mathematical operations on the original floating\-point value often tends to increase its lack of precision. For example, if we compare the result of multiplying .1 by 10 and adding .1 to .1 nine times, we see that addition, because it has involved eight more operations, has produced the less precise result. Note that this disparity is apparent only if we display the two <xref:System.Double> values by using the "R" [standard numeric format string](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467), which if necessary displays all 17 digits of precision supported by the <xref:System.Double> type.  
  
 [!code-csharp[System.Double.Structure\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Because some numbers cannot be represented exactly as fractional binary values, floating\-point numbers can only approximate real numbers.  
  
 All floating\-point numbers also have a limited number of significant digits, which also determines how accurately a floating\-point value approximates a real number.   A <xref:System.Double> value has up to 15 decimal digits of precision, although a maximum of 17 digits is maintained internally. This means that some floating\-point operations may lack the precision to change a floating point value. The following example provides an illustration. It defines a very large floating\-point value, and then adds the product of <xref:System.Double.Epsilon?displayProperty=fullName> and one quadrillion to it. The product, however, is too small to modify the original floating\-point value. Its least significant digit is thousandths, whereas the most significant digit in the product is 1<sup>-312</sup>.  
  
 [!code-csharp[System.Double.Structure\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 The limited precision of a floating\-point number has several consequences:  
  
-   Two floating\-point numbers that appear equal for a particular precision might not compare equal because their least significant digits are different. In the following example, a series of numbers are added together, and their total is compared with their expected total. Although the two values appear to be the same, a call to the **languageKeyword tag is not supported!!!!**  
     method indicates that they are not.  
  
     [!code-csharp[System.Double.Structure\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     If you change the format items in the <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=fullName> statement from `{0}` and `{1}` to `{0:R}` and `{1:R}` to display all significant digits of the two <xref:System.Double> values, it is clear that the two values are unequal because of a loss of precision during the addition operations. In this case, the issue can be resolved by calling the <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=fullName> method to round the <xref:System.Double> values to the desired precision before performing the comparison.  
  
-   A mathematical or comparison operation that uses a floating\-point number might not yield the same result if a decimal number is used, because the binary floating\-point number might not equal the decimal number. A previous example illustrated this by displaying the result of multiplying .1 by 10 and adding .1 times.  
  
     When accuracy in numeric operations with fractional values is important, you can use the <xref:System.Decimal> rather than the <xref:System.Double> type. When accuracy in numeric operations with integral values beyond the range of the <xref:System.Int64> or <xref:System.UInt64> types is important, use the <xref:System.Numerics.BigInteger> type.  
  
-   A value might not round\-trip if a floating\-point number is involved. A value is said to round\-trip if an operation converts an original floating\-point number to another form, an inverse operation transforms the converted form back to a floating\-point number, and the final floating\-point number is not equal to the original floating\-point number. The roundtrip might fail because one or more least significant digits are lost or changed in a conversion. In the following example, three <xref:System.Double> values are converted to strings and saved in a file. As the output shows, however, even though the values appear to be identical, the restored values are not equal to the original values.  
  
     [!code-csharp[System.Double.Structure\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     In this case, the values can be successfully round\-tripped by using the "R" [standard numeric format string](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) to preserve the full precision of <xref:System.Double> values, as the following example shows.  
  
     [!code-csharp[System.Double.Structure\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  
  
-   <xref:System.Single> values have less precision than <xref:System.Double> values. A <xref:System.Single> value that is converted to a seemingly equivalent <xref:System.Double> often does not equal the <xref:System.Double> value because of differences in precision. In the following example, the result of identical division operations is assigned to a <xref:System.Double> and a <xref:System.Single> value. After the <xref:System.Single> value is cast to a <xref:System.Double>, a comparison of the two values shows that they are unequal.  
  
     [!code-csharp[System.Double.Structure\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     To avoid this problem, use either the <xref:System.Double> in place of the <xref:System.Single> data type, or use the <xref:System.Math.Round%2A> method so that both values have the same precision.  
  
 In addition, the result of arithmetic and assignment operations with <xref:System.Double> values may differ slightly by platform because of the loss of precision of the <xref:System.Double> type. For example, the result of assigning a literal <xref:System.Double> value may differ in the 32\-bit and 64\-bit versions of the .NET Framework. The following example illustrates this difference when the literal value \-4.42330604244772E\-305 and a variable whose value is \-4.42330604244772E\-305 are assigned to a <xref:System.Double> variable. Note that the result of the <xref:System.Double.Parse%28System.String%29> method in this case does not suffer from a loss of precision.  
  
 [!code-csharp[System.Double.Class.Precision\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## Testing for Equality  
 To be considered equal, two <xref:System.Double> values must represent identical values. However, because of differences in precision between values, or because of a loss of precision by one or both values, floating\-point values that are expected to be identical often turn out to be unequal because of differences in their least significant digits. As a result, calls to the <xref:System.Double.Equals%2A> method to determine whether two values are equal, or calls to the <xref:System.Double.CompareTo%2A> method to determine the relationship between two <xref:System.Double> values, often yield unexpected results. This is evident in the following example, where two apparently equal <xref:System.Double> values turn out to be unequal because the first has 15 digits of precision, while the second has 17.  
  
 [!code-csharp[System.Double.Structure\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 Calculated values that follow different code paths and that are manipulated in different ways often prove to be unequal. In the following example, one <xref:System.Double> value is squared, and then the square root is calculated to restore the original value. A second <xref:System.Double> is multiplied by 3.51 and squared before the square root of the result is divided by 3.51 to restore the original value. Although the two values appear to be identical, a call to the <xref:System.Double.Equals%28System.Double%29> method indicates that they are not equal. Using the "R" standard format string to return a result string that displays all the significant digits of each Double value shows that the second value is .0000000000001 less than the first.  
  
 [!code-csharp[System.Double.Structure\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 In cases where a loss of precision is likely to affect the result of a comparison, you can adopt any of the following alternatives to calling the <xref:System.Double.Equals%2A> or <xref:System.Double.CompareTo%2A> method:  
  
-   Call the <xref:System.Math.Round%2A?displayProperty=fullName> method to ensure that both values have the same precision. The following example modifies a previous example to use this approach so that two fractional values are equivalent.  
  
     [!code-csharp[System.Double.Structure\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Note, though, that the problem of precision still applies to rounding of midpoint values. For more information, see the <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=fullName> method.  
  
-   Test for approximate equality rather than equality. This requires that you define either an absolute amount by which the two values can differ but still be equal, or that you define a relative amount by which the smaller value can diverge from the larger value.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=fullName> is sometimes used as an absolute measure of the distance between two <xref:System.Double> values when testing for equality.  However, <xref:System.Double.Epsilon?displayProperty=fullName> measures the smallest possible value that can be added to, or subtracted from, a <xref:System.Double> whose value is zero. For most positive and negative <xref:System.Double> values, the value of <xref:System.Double.Epsilon?displayProperty=fullName> is too small to be detected. Therefore, except for values that are zero, we do not recommend its use in tests for equality.  
  
     The following example uses the latter approach to define an `IsApproximatelyEqual` method that tests the relative difference between two values. It also contrasts the result of calls to the `IsApproximatelyEqual` method and the <xref:System.Double.Equals%28System.Double%29> method.  
  
     [!code-csharp[System.Double.Structure\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## Floating\-Point Values and Exceptions  
 Unlike operations with integral types, which throw exceptions in cases of overflow or illegal operations such as division by zero, operations with floating\-point values do not throw exceptions. Instead, in exceptional situations, the result of a floating\-point operation is zero, positive infinity, negative infinity, or not a number \(NaN\):  
  
-   If the result of a floating\-point operation is too small for the destination format, the result is zero. This can occur when two very small numbers are multiplied, as the following example shows.  
  
     [!code-csharp[System.Double.Structure\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   If the magnitude of the result of a floating\-point operation exceeds the range of the destination format, the result of the operation is <xref:System.Double.PositiveInfinity> or <xref:System.Double.NegativeInfinity>, as appropriate for the sign of the result. The result of an operation that overflows <xref:System.Double.MaxValue?displayProperty=fullName> is <xref:System.Double.PositiveInfinity>, and the result of an operation that overflows <xref:System.Double.MinValue?displayProperty=fullName> is <xref:System.Double.NegativeInfinity>, as the following example shows.  
  
     [!code-csharp[System.Double.Structure\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> also results from a division by zero with a positive dividend, and <xref:System.Double.NegativeInfinity> results from a division by zero with a negative dividend.  
  
-   If a floating\-point operation is invalid, the result of the operation is <xref:System.Double.NaN>. For example, <xref:System.Double.NaN> results from the following operations:  
  
    -   Division by zero with a dividend of zero. Note that other cases of division by zero result in either <xref:System.Double.PositiveInfinity> or <xref:System.Double.NegativeInfinity>.  
  
-   Any floating\-point operation with an invalid input. For example, calling the <xref:System.Math.Sqrt%2A?displayProperty=fullName> method with a negative value returns <xref:System.Double.NaN>, as does calling the <xref:System.Math.Acos%2A?displayProperty=fullName> method with a value that is greater than one or less than negative one.  
  
-   Any operation with an argument whose value is <xref:System.Double.NaN?displayProperty=fullName>.  
  
<a name="Conversions"></a>   
## Type conversions and the Double structure  
 The <xref:System.Double> structure does not define any explicit or implicit conversion operators; instead, conversions are implemented by the compiler.  
  
 The conversion of the value of any primitive numeric type to a <xref:System.Double> is a widening conversion and therefore does not require an explicit cast operator or call to a conversion method unless a compiler explicitly requires it. For example, the C\# compiler requires a casting operator for conversions from <xref:System.Decimal> to <xref:System.Double>, while the Visual Basic compiler does not. The following example converts the minimum or maximum value of other primitive numeric types to a <xref:System.Double>.  
  
 [!code-csharp[System.Double.Structure\#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure\#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 In addition, the <xref:System.Single> values <xref:System.Single.NaN?displayProperty=fullName>, <xref:System.Single.PositiveInfinity?displayProperty=fullName>, and <xref:System.Single.NegativeInfinity?displayProperty=fullName> covert to <xref:System.Double.NaN?displayProperty=fullName>, <xref:System.Double.PositiveInfinity?displayProperty=fullName>, and <xref:System.Double.NegativeInfinity?displayProperty=fullName>, respectively.  
  
 Note that the conversion of the value of some numeric types to a <xref:System.Double> value can involve a loss of precision. As the example illustrates, a loss of precision is possible when converting <xref:System.Decimal>, <xref:System.Int64>, <xref:System.Single>, and <xref:System.UInt64> values to <xref:System.Double> values.  
  
 The conversion of a <xref:System.Double> value to a value of any other primitive numeric data type is a narrowing conversion and requires a cast operator \(in C\#\), a conversion method \(in Visual Basic\), or a call to a <xref:System.Convert> method. Values that are outside the range of the target data type, which are defined by the target type's **languageKeyword tag is not supported!!!!**  
 and **languageKeyword tag is not supported!!!!**  
 properties, behave as shown in the following table.  
  
|Target type|Result|  
|-----------------|------------|  
|Any integral type|An <xref:System.OverflowException> exception if the conversion occurs in a checked context.<br /><br /> If the conversion occurs in an unchecked context \(the default in C\#\), the conversion operation succeeds but the value overflows.|  
|<xref:System.Decimal>|An <xref:System.OverflowException> exception.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=fullName> for negative values.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=fullName> for positive values.|  
  
 In addition, <xref:System.Double.NaN?displayProperty=fullName>, <xref:System.Double.PositiveInfinity?displayProperty=fullName>, and <xref:System.Double.NegativeInfinity?displayProperty=fullName> throw an <xref:System.OverflowException> for conversions to integers in a checked context, but these values overflow when converted to integers in an unchecked context. For conversions to <xref:System.Decimal>, they always throw an <xref:System.OverflowException>. For conversions to <xref:System.Single>, they convert to <xref:System.Single.NaN?displayProperty=fullName>, <xref:System.Single.PositiveInfinity?displayProperty=fullName>, and <xref:System.Single.NegativeInfinity?displayProperty=fullName>, respectively.  
  
 Note that a loss of precision may result from converting a <xref:System.Double> value to another numeric type. In the case of converting non\-integral <xref:System.Double> values, as the output from the example shows, the fractional component is lost when the <xref:System.Double> value is either rounded \(as in Visual Basic\) or truncated \(as in C\#\). For conversions to <xref:System.Decimal> and <xref:System.Single> values, the <xref:System.Double> value may not have a precise representation in the target data type.  
  
 The following example converts a number of <xref:System.Double> values to several other numeric types. The conversions occur in a checked context in Visual Basic \(the default\) and in C\# \(because of the [checked](http://msdn.microsoft.com/ja-jp/718a1194-988d-48a3-b089-d6ee8bd1608d) keyword\). The output from the example shows the result for conversions in both a checked an unchecked context. You can perform conversions in an unchecked context in Visual Basic by compiling with the **languageKeyword tag is not supported!!!!**  
 compiler switch and in C\# by commenting out the **languageKeyword tag is not supported!!!!**  
 statement.  
  
 [!code-csharp[System.Double.Structure\#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure\#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 For more information on the conversion of numeric types, see [Type Conversion in the .NET Framework](http://msdn.microsoft.com/ja-jp/ba36154f-064c-47d3-9f05-72f93a7ca96d) and [Type Conversion Tables in the .NET Framework](http://msdn.microsoft.com/ja-jp/0ea65c59-85eb-4a52-94ca-c36d3bd13058).  
  
<a name="Functionality"></a>   
## Floating\-Point Functionality  
 The <xref:System.Double> structure and related types provide methods to perform operations in the following areas:  
  
-   **Comparison of values**. You can call the <xref:System.Double.Equals%2A> method to determine whether two <xref:System.Double> values are equal, or the <xref:System.Double.CompareTo%2A> method to determine the relationship between two values.  
  
     The <xref:System.Double> structure also supports a complete set of comparison operators. For example, you can test for equality or inequality, or determine whether one value is greater than or equal to another. If one of the operands is a numeric type other than a <xref:System.Double>, it is converted to a <xref:System.Double> before performing the comparison.  
  
    > [!WARNING]
    >  Because of differences in precision, two <xref:System.Double> values that you expect to be equal may turn out to be unequal, which affects the result of the comparison. See the [Testing for Equality](#Equality) section for more information about comparing two <xref:System.Double> values.  
  
     You can also call the <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, and <xref:System.Double.IsNegativeInfinity%2A> methods to test for these special values.  
  
-   **Mathematical operations**. Common arithmetic operations, such as addition, subtraction, multiplication, and division, are implemented by language compilers and Common Intermediate Language \(CIL\) instructions, rather than by <xref:System.Double> methods. If one of the operands in a mathematical operation is a numeric type other than a <xref:System.Double>, it is converted to a <xref:System.Double> before performing the operation. The result of the operation is also a <xref:System.Double> value.  
  
     Other mathematical operations can be performed by calling **languageKeyword tag is not supported!!!!**  
     \(**languageKeyword tag is not supported!!!!**  
     in Visual Basic\) methods in the <xref:System.Math?displayProperty=fullName> class. It includes additional methods commonly used for arithmetic \(such as <xref:System.Math.Abs%2A?displayProperty=fullName>, <xref:System.Math.Sign%2A?displayProperty=fullName>, and <xref:System.Math.Sqrt%2A?displayProperty=fullName>\), geometry \(such as <xref:System.Math.Cos%2A?displayProperty=fullName> and <xref:System.Math.Sin%2A?displayProperty=fullName>\), and calculus \(such as <xref:System.Math.Log%2A?displayProperty=fullName>\).  
  
     You can also manipulate the individual bits in a <xref:System.Double> value. The <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=fullName> method preserves a <xref:System.Double> value's bit pattern in a 64\-bit integer. The <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=fullName> method returns its bit pattern in a byte array.  
  
-   **Rounding**. Rounding is often used as a technique for reducing the impact of differences between values caused by problems of floating\-point representation and precision. You can round a <xref:System.Double> value by calling the <xref:System.Math.Round%2A?displayProperty=fullName> method.  
  
-   **Formatting**. You can convert a <xref:System.Double> value to its string representation by calling the <xref:System.Double.ToString%2A> method or by using the composite formatting feature. For information about how format strings control the string representation of floating\-point values, see the [Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467) and [Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4) topics.  
  
-   **Parsing strings**. You can convert the string representation of a floating\-point value to a <xref:System.Double> value by calling either the <xref:System.Double.Parse%2A> or <xref:System.Double.TryParse%2A> method. If the parse operation fails, the <xref:System.Double.Parse%2A> method throws an exception, whereas the <xref:System.Double.TryParse%2A> method returns `false`.  
  
-   **Type conversion**. The <xref:System.Double> structure provides an explicit interface implementation for the <xref:System.IConvertible> interface, which supports conversion between any two standard .NET Framework data types. Language compilers also support the implicit conversion of values of all other standard numeric types to <xref:System.Double> values. Conversion of a value of any standard numeric type to a <xref:System.Double> is a widening conversion and does not require the user of a casting operator or conversion method,  
  
     However, conversion of <xref:System.Int64> and <xref:System.Single> values can involve a loss of precision. The following table lists the differences in precision for each of these types:  
  
    |Type|Maximum precision|Internal precision|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 decimal digits|19 decimal digits|  
    |<xref:System.Single>|7 decimal digits|9 decimal digits|  
  
     The problem of precision most frequently affects <xref:System.Single> values that are converted to <xref:System.Double> values. In the following example, two values produced by identical division operations are unequal because one of the values is a a single\-precision floating point value converted to a <xref:System.Double>.  
  
     [!code-csharp[System.Double.Structure\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## 例  
 The following code example illustrates the use of <xref:System.Double>:  
  
 [!code-cpp[Double Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>All members of this type are thread safe. Members that appear to modify instance state actually return a new instance initialized with the new value. As with any other type, reading and writing to a shared variable that contains an instance of this type must be protected by a lock to guarantee thread safety.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">比較対象の倍精度浮動小数点数。</param>
        <summary>このインスタンスと指定した倍精度浮動小数点数を比較し、このインスタンスの値が指定した倍精度浮動小数点数の値よりも小さいか、同じか、または大きいかを示す整数を返します。</summary>
        <returns>このインスタンスと <paramref name="value" /> の相対値を示す符号付き数値。  
  
 <list type="table">  
<listheader>  
<term> 戻り値  
  
 </term>  
<description> 説明  
  
 </description>  
</listheader>  
<item>  
<term> 0 より小さい値  
  
 </term>  
<description> このインスタンスは、<paramref name="value" /> よりも小さくなっています。  
  
 または  
  
 このインスタンスが数値ではありません \(<see cref="F:System.Double.NaN" />\) および<paramref name="value" />番号です。  
  
 </description>  
</item>  
<item>  
<term> 0  
  
 </term>  
<description> このインスタンスは <paramref name="value" /> と等価です。  
  
 または  
  
 この両方のインスタンスと<paramref name="value" />数値ではありません \(<see cref="F:System.Double.NaN" />\)、 <see cref="F:System.Double.PositiveInfinity" />、または<see cref="F:System.Double.NegativeInfinity" />です。  
  
 </description>  
</item>  
<item>  
<term> 0 より大きい値  
  
 </term>  
<description> このインスタンスは <paramref name="value" /> よりも大きくなっています。  
  
 または  
  
 このインスタンスは数値と<paramref name="value" />数値ではありません \(<see cref="F:System.Double.NaN" />\)。  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値を等価と見なされると同じにする必要があります。 浮動小数点値は、複数の数値演算に依存しているときに特にの有効桁数が失われると、それらの値、最小有効数字を除くとほぼ同じにするには共通です。 このため、戻り値の<xref:System.Double.CompareTo%2A>もメソッドがこのことにより意外見える可能性があります。 たとえば、同じ値で除算の後に特定の値で乗算では、元の値を生成する必要があります。 次の例では、ただし、計算値がわかりました元の値より大きくなければなりません。 "R"を使用して、2 つの値のすべての有効桁数を示す[標準数値書式指定文字列](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467)計算値が、その有効桁数の元の値と異なることを示します。 このような比較を処理する方法については、「解説」セクションを参照してください、<xref:System.Double.Equals%28System.Double%29>メソッドです。  
  
 [!code-csharp[System.Double.CompareTo\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 このメソッドを実装する、<xref:System.IComparable%601?displayProperty=fullName>インターフェイスし、実行よりもわずかに向上、<xref:System.Double.CompareTo%2A?displayProperty=fullName>メソッドに変換があるないため、`value`オブジェクトへのパラメーターです。  
  
 なお、値があるオブジェクトが<xref:System.Double.NaN>値がある別のオブジェクトと等しくないと見なされます<xref:System.Double.NaN>\(場合によってはそれ自体\)、<xref:System.IComparable%601>インターフェイスでは、する必要があります`A.CompareTo(A)`は 0 を返します。  
  
## 拡大変換  
 プログラミング言語に応じてコードに考えられる場合があります、<xref:System.Double.CompareTo%2A>メソッドのパラメーターの型のビット数が少ないがここではインスタンスの型よりもします。 これには一部のプログラミング言語は、ビット数のインスタンスと型としてパラメーターを表す暗黙の拡大変換を実行するため。  
  
 たとえば、インスタンスの型が<xref:System.Double>パラメーターの型と<xref:System.Int32>です。 Microsoft c\# コンパイラはパラメーターとしての値を表す命令を生成、<xref:System.Double>オブジェクトを生成、<xref:System.Double.CompareTo%28System.Double%29?displayProperty=fullName>インスタンスの値とパラメーターの形式を拡張を比較するメソッド。  
  
 コンパイラが数値型の暗黙の拡大変換を実行するプログラミング言語のドキュメントを参照してください。 詳細については、「[Type Conversion Tables in the .NET Framework](http://msdn.microsoft.com/ja-jp/0ea65c59-85eb-4a52-94ca-c36d3bd13058)」を参照してください。  
  
## 比較では有効桁数  
 文書化されている有効桁数を超える浮動小数点数の有効桁数は、実装と .NET Framework のバージョンに固有です。 その結果、数値の内部表現の有効桁数が変わる可能性があるため、.NET Framework のバージョン間で 2 つの数値の比較が変化します。  
  
   
  
## 例  
 次のコード例に示しますジェネリックと非ジェネリック バージョンの<xref:System.Double.CompareTo%2A>いくつかの値と参照型のメソッドです。  
  
 [!code-cpp[T.CompareTo\#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo\#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">比較対象のオブジェクト、または <see langword="null" />。</param>
        <summary>このインスタンスと指定したオブジェクトを比較し、このインスタンスの値が指定したオブジェクトの値よりも小さいか、同じか、または大きいかを示す整数を返します。</summary>
        <returns>このインスタンスと <paramref name="value" /> の相対値を示す符号付き数値。  
  
 <list type="table">  
<listheader>  
<term> 値  
  
 </term>  
<description> 説明  
  
 </description>  
</listheader>  
<item>  
<term> 負の整数  
  
 </term>  
<description> このインスタンスは、<paramref name="value" /> よりも小さくなっています。  
  
 または  
  
 このインスタンスが数値ではありません \(<see cref="F:System.Double.NaN" />\) および<paramref name="value" />番号です。  
  
 </description>  
</item>  
<item>  
<term> 0  
  
 </term>  
<description> このインスタンスは <paramref name="value" /> と等価です。  
  
 または  
  
 このインスタンスと<paramref name="value" />が両方とも<see langword="Double.NaN" />、 <see cref="F:System.Double.PositiveInfinity" />、または<see cref="F:System.Double.NegativeInfinity" />  
  
 </description>  
</item>  
<item>  
<term> 正の整数  
  
 </term>  
<description> このインスタンスは <paramref name="value" /> よりも大きくなっています。  
  
 または  
  
 このインスタンスは数値と<paramref name="value" />数値ではありません \(<see cref="F:System.Double.NaN" />\)。  
  
 または  
  
 <paramref name="value" /> は <see langword="null" /> です。  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `value`パラメーターでなければなりません`null`またはのインスタンス`Double`です。 それ以外の場合、例外がスローされます。 任意のインスタンスの<xref:System.Double>、その値に関係なくが大きいと見なされますより`null`です。  
  
 値を等価と見なされるのと同じにする必要があります。 浮動小数点値は、複数の数値演算に依存しているときに特にの有効桁数が失われると、それらの値、最小有効数字を除くとほぼ同じにするには共通です。 このため、戻り値の<xref:System.Double.CompareTo%2A>もメソッドがこのことにより意外見える可能性があります。 たとえば、同じ値で除算の後に特定の値で乗算では、元の値を生成する必要があります。 次の例では、ただし、計算値がわかりました元の値より大きくなければなりません。 "R"を使用して、2 つの値のすべての有効桁数を示す[標準数値書式指定文字列](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467)計算値が、その有効桁数の元の値と異なることを示します。 このような比較を処理する方法については、「解説」セクションを参照してください、<xref:System.Double.Equals%28System.Double%29>メソッドです。  
  
 [!code-csharp[System.Double.CompareTo\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 このメソッドがサポートするために実装されている、<xref:System.IComparable>インターフェイスです。 なおが、<xref:System.Double.NaN>別に等しいと見なされない<xref:System.Double.NaN>\(場合によってはそれ自体\)、<xref:System.IComparable>インターフェイスでは、する必要があります`A.CompareTo(A)`は 0 を返します。  
  
## 比較では有効桁数  
 文書化されている有効桁数を超える浮動小数点数の有効桁数は、実装と .NET Framework のバージョンに固有です。 その結果、数値の内部表現の有効桁数が変わる可能性があるため、.NET Framework のバージョン間で 2 つの数値の比較が変化します。  
  
   
  
## 例  
 次のコード例は、の使用を示しています。`CompareTo`のコンテキストで`Double`です。  
  
 [!code-cpp[System.Double\#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> が <see cref="T:System.Double" /> ではありません。</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>ゼロより大きい最小の <see cref="T:System.Double" /> 値を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値、 <xref:System.Double.Epsilon> プロパティには、正の最小値が反映されます。 <xref:System.Double> 数値演算や比較の重要では値との値、 <xref:System.Double> インスタンスは 0 です。 たとえば、次のコードに示す 0 を <xref:System.Double.Epsilon> が等しくない値であると見なされますの値のゼロおよび半分 <xref:System.Double.Epsilon> 等しいと見なされます。  
  
 [!code-csharp[System.Double.Epsilon\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 浮動正確には、ポイントを記号、52 ビット仮数部または、有効桁と 11 ビット指数部の形式を構成します。 次の例に示す、0 は、\-1022 の指数部を持ち、0 の仮数を示します。<xref:System.Double.Epsilon> \-1022 の指数部と 1 の仮数部があります。 つまり、この <xref:System.Double.Epsilon> は正の最小 <xref:System.Double> 0 より大きい値し、最小有効値との最小可能なインクリメントを表す、 <xref:System.Double> が指数部が\-1022 します。  
  
 [!code-csharp[System.Double.Epsilon\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 ただし、 <xref:System.Double.Epsilon> プロパティは、有効桁数の全般的なメジャーでは、 <xref:System.Double> 型のみに適用される <xref:System.Double> を\-1022 の指数部またはゼロの値を持つインスタンス。  
  
> [!NOTE]
>  値、 <xref:System.Double.Epsilon> プロパティが浮動小数点演算で丸め処理を行うための相対的なエラーの上限を表すマシン epsilon に相当します。  
  
 この定数の値は 4.94065645841247e\-324。  
  
 2 つの等しい浮動小数点数が、有効桁数が異なるのため、比較するもと等しいされません可能性があります。 たとえば、c\# の式 `(double)1/3 == (double)0.33333`, に等しくない右側にある定数は指定した数字だけに正確では、左側にある除算演算が最大有効桁数を持つためです。 2 つの浮動小数点数値を等しいと見なすかどうかを決定するカスタム アルゴリズムを作成する場合はお勧めしません、アルゴリズムの値を基準とすること、 <xref:System.Double.Epsilon> 等価と見なされる 2 つの値の差の絶対値の許容を確立するために定数です。  \(通常は、差分の余白が何回を超える <xref:System.Double.Epsilon>.\) 2 つの倍精度浮動小数点値の比較については、次を参照してください。 <xref:System.Double> と <xref:System.Double.Equals%28System.Double%29>です。  
  
## プラットフォームに関する注意事項  
 ARM システムでは、値、 <xref:System.Double.Epsilon> 定数小さすぎると、検出されたため、これはゼロに相当します。 2.2250738585072014E に相当する代替 epsilon 値を定義することができます\-308 代わりにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="obj">このインスタンスと比較する <see cref="T:System.Double" /> オブジェクト。</param>
        <summary>このインスタンスと指定した <see cref="T:System.Double" /> オブジェクトが同じ値を表しているかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="obj" /> がこのインスタンスと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method implements the <xref:System.IEquatable%601?displayProperty=fullName> interface, and performs slightly better than <xref:System.Double.Equals%2A> because it does not have to convert the **parameterReference tag is not supported!!!!**  
 parameter to an object.  
  
## Widening Conversions  
 Depending on your programming language, it might be possible to code a <xref:System.Double.Equals%2A> method where the parameter type has fewer bits \(is narrower\) than the instance type. This is possible because some programming languages perform an implicit widening conversion that represents the parameter as a type with as many bits as the instance.  
  
 For example, suppose the instance type is <xref:System.Double> and the parameter type is <xref:System.Int32>. The Microsoft C\# compiler generates instructions to represent the value of the parameter as a <xref:System.Double> object, then generates a <xref:System.Double.Equals%28System.Double%29?displayProperty=fullName> method that compares the values of the instance and the widened representation of the parameter.  
  
 Consult your programming language's documentation to determine if its compiler performs implicit widening conversions of numeric types. For more information, see the [Type Conversion Tables in the .NET Framework](http://msdn.microsoft.com/ja-jp/0ea65c59-85eb-4a52-94ca-c36d3bd13058) topic.  
  
## Precision in Comparisons  
 The<xref:System.Double.Equals%2A> method should be used with caution, because two apparently equivalent values can be unequal due to the differing precision of the two values. The following example reports that the <xref:System.Double> value .333333 and the <xref:System.Double> value returned by dividing 1 by 3 are unequal.  
  
 [!code-csharp[System.Double.Epsilon\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 Rather than comparing for equality, one technique involves defining an acceptable relative margin of difference between two values \(such as .001% of one of the values\). If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to differences in precision and, therefore, the values are likely to be equal. The following example uses this technique to compare .33333 and 1\/3, the two <xref:System.Double> values that the previous code example found to be unequal. In this case, the values are equal.  
  
 [!code-csharp[System.Double.Epsilon\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  Because <xref:System.Double.Epsilon> defines the minimum expression of a positive value whose range is near zero, the margin of difference between two similar values must be greater than <xref:System.Double.Epsilon>. Typically, it is many times greater than <xref:System.Double.Epsilon>. Because of this, we recommend that you do not use <xref:System.Double.Epsilon> when comparing <xref:System.Double> values for equality.  
  
 A second technique involves comparing the difference between two floating\-point numbers with some absolute value. If the difference is less than or equal to that absolute value, the numbers are equal. If it is greater, the numbers are not equal. One alternative is to arbitrarily select an absolute value. This is problematic, however, because an acceptable margin of difference depends on the magnitude of the <xref:System.Double> values. A second alternative takes advantage of a design feature of the floating\-point format: The difference between the integer representation of two floating\-point values indicates the number of possible floating\-point values that separates them. For example, the difference between 0.0 and <xref:System.Double.Epsilon> is 1, because <xref:System.Double.Epsilon> is the smallest representable value when working with a <xref:System.Double> whose value is zero. The following example uses this technique to compare .33333 and 1\/3, which are the two <xref:System.Double> values that the previous code example with the <xref:System.Double.Equals%28System.Double%29> method found to be unequal. Note that the example uses the <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=fullName> method to convert a double\-precision floating\-point value to its integer representation.  
  
 [!code-csharp[System.Double.Equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 The precision of floating\-point numbers beyond the documented precision is specific to the implementation and version of the .NET Framework. Consequently, a comparison of two particular numbers might change between versions of the .NET Framework because the precision of the numbers' internal representation might change.  
  
 If two <xref:System.Double.NaN?displayProperty=fullName> values are tested for equality by calling the <xref:System.Double.Equals%2A> method, the method returns **languageKeyword tag is not supported!!!!**  
. However, if two <xref:System.Double.NaN> values are tested for equality by using the equality operator, the operator returns **languageKeyword tag is not supported!!!!**  
. When you want to determine whether the value of a <xref:System.Double> is not a number \(NaN\), an alternative is to call the <xref:System.Double.IsNaN%2A> method.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Compiler overload resolution may account for an apparent difference in the behavior of the two <see cref="M:System.Double.Equals(System.Object)" /> method overloads. If an implicit conversion between the <paramref name="obj" /> argument and a <see cref="T:System.Double" /> is defined and the argument is not typed as an <see cref="T:System.Object" />, compilers may perform an implicit conversion and call the <see cref="M:System.Double.Equals(System.Double)" /> method. Otherwise, they call the <see cref="M:System.Double.Equals(System.Object)" /> method, which always returns <see langword="false" /> if its <paramref name="obj" /> argument is not a <see cref="T:System.Double" /> value. The following example illustrates the difference in behavior between the two method overloads. In the case of all primitive numeric types except for <see cref="T:System.Decimal" /> and in C#, the first comparison returns <see langword="true" /> because the compiler automatically performs a widening conversion and calls the <see cref="M:System.Double.Equals(System.Double)" /> method, whereas the second comparison returns <see langword="false" /> because the compiler calls the <see cref="M:System.Double.Equals(System.Object)" /> method.  
  
 [!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">このインスタンスと比較するオブジェクト。</param>
        <summary>対象のインスタンスが、指定したオブジェクトに等しいかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="obj" /> が <see cref="T:System.Double" /> のインスタンスで、このインスタンスの値に等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The<xref:System.Double.Equals%2A> method should be used with caution, because two apparently equivalent values can be unequal due to the differing precision of the two values. The following example reports that the <xref:System.Double> value .3333 and the <xref:System.Double> returned by dividing 1 by 3 are unequal.  
  
 [!code-csharp[System.Double.Epsilon\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 For alternatives to calling the <xref:System.Double.Equals%2A> method, see the documentation for the <xref:System.Double.Equals%28System.Double%29> overload.  
  
> [!NOTE]
>  Because <xref:System.Double.Epsilon> defines the minimum expression of a positive value whose range is near zero, the margin of difference between two similar values must be greater than <xref:System.Double.Epsilon>. Typically, it is many times greater than <xref:System.Double.Epsilon>.  
  
 The precision of floating\-point numbers beyond the documented precision is specific to the implementation and version of the .NET Framework. Consequently, a comparison of two particular numbers might change between versions of the .NET Framework because the precision of the numbers' internal representation might change.  
  
 If two <xref:System.Double.NaN?displayProperty=fullName> values are tested for equality by calling the <xref:System.Double.Equals%2A> method, the method returns **languageKeyword tag is not supported!!!!**  
. However, if two <xref:System.Double.NaN> values are tested for equality by using the equality operator, the operator returns **languageKeyword tag is not supported!!!!**  
. When you want to determine whether the value of a <xref:System.Double> is not a number \(NaN\), an alternative is to call the <xref:System.Double.IsNaN%2A> method.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Compiler overload resolution may account for an apparent difference in the behavior of the two <see cref="M:System.Double.Equals(System.Object)" /> method overloads. If an implicit conversion between the <paramref name="obj" /> argument and a <see cref="T:System.Double" /> is defined and the argument is not typed as an <see cref="T:System.Object" />, compilers may perform an implicit conversion and call the <see cref="M:System.Double.Equals(System.Double)" /> method. Otherwise, they call the <see cref="M:System.Double.Equals(System.Object)" /> method, which always returns <see langword="false" /> if its <paramref name="obj" /> argument is not a <see cref="T:System.Double" /> value. The following example illustrates the difference in behavior between the two method overloads. In the case of all primitive numeric types except for <see cref="T:System.Decimal" /> and in C#, the first comparison returns <see langword="true" /> because the compiler automatically performs a widening conversion and calls the <see cref="M:System.Double.Equals(System.Double)" /> method, whereas the second comparison returns <see langword="false" /> because the compiler calls the <see cref="M:System.Double.Equals(System.Object)" /> method.  
  
 [!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.TypeCode" /> 値型の <see cref="T:System.Double" /> を返します。</summary>
        <returns>列挙型定数 <see cref="F:System.TypeCode.Double" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定した数値が負または正の無限大と評価されるかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="d" /> が <see cref="F:System.Double.PositiveInfinity" /> または <see cref="F:System.Double.NegativeInfinity" /> と評価される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 浮動小数点演算<xref:System.Double.PositiveInfinity>または<xref:System.Double.NegativeInfinity>オーバーフロー状態を通知します。  
  
   
  
## 例  
 次のコード例は、の使用を示しています<xref:System.Double.IsInfinity%2A>:。  
  
 [!code-cpp[System.Double\#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定した値が非数値 \(<see cref="F:System.Double.NaN" />\) かどうかを示す値を返します。</summary>
        <returns>
          <paramref name="d" /> が <see cref="F:System.Double.NaN" /> と評価される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 浮動小数点演算<xref:System.Double.NaN>をその操作の結果が定義されていないことを通知します。 たとえば、0.0、0.0 を除算した結果、<xref:System.Double.NaN>です。  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A>返します`false`場合、<xref:System.Double>いずれかの値は<xref:System.Double.PositiveInfinity>または<xref:System.Double.NegativeInfinity>です。 これらの値をテストするには、使用、 <xref:System.Double.IsInfinity%2A>、 <xref:System.Double.IsPositiveInfinity%2A>、および<xref:System.Double.IsNegativeInfinity%2A>メソッドです。  
  
   
  
## 例  
 次のコード例の使用を示しています<xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double\#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定した数値が負の無限大と評価されるかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="d" /> が <see cref="F:System.Double.NegativeInfinity" /> と評価される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 浮動小数点演算<xref:System.Double.NegativeInfinity>オーバーフロー状態を通知します。  
  
   
  
## 例  
 次のコード例の使用を示しています<xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">倍精度浮動小数点数。</param>
        <summary>指定した数値が正の無限大と評価されるかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="d" /> が <see cref="F:System.Double.PositiveInfinity" /> と評価される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 浮動小数点演算<xref:System.Double.PositiveInfinity>オーバーフロー状態を通知します。  
  
   
  
## 例  
 次のコード例は、の使用を示しています<xref:System.Double.IsPositiveInfinity%2A>:。  
  
 [!code-cpp[System.Double\#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>
          <see cref="T:System.Double" /> の最大有効値を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この定数の値は、正 1.7976931348623157 e \+ 308 です。  
  
 超える演算の結果<xref:System.Double.MaxValue?displayProperty=fullName>は<xref:System.Double.PositiveInfinity?displayProperty=fullName>します。 次の例では、<xref:System.Double.PositiveInfinity?displayProperty=fullName>結果を超えたときに結果を加算、乗算、および指数演算操作<xref:System.Double.MaxValue?displayProperty=fullName>です。  
  
 [!code-csharp[System.Double.MaxValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## 例  
 次のコード例は、の使用を示しています<xref:System.Double.MaxValue>:。  
  
 [!code-cpp[Double Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>
          <see cref="T:System.Double" /> の最小有効値を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この定数の値は、負の値の 1.7976931348623157 e \+ 308 です。  
  
 ある操作の結果より小さい<xref:System.Double.MinValue?displayProperty=fullName>は<xref:System.Double.NegativeInfinity?displayProperty=fullName>します。 次の例では、<xref:System.Double.NegativeInfinity?displayProperty=fullName>結果が、減算、乗算の結果より小さい<xref:System.Double.MinValue?displayProperty=fullName>です。  
  
 [!code-csharp[System.Double.MinValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## 例  
 次のコード例は、の使用を示しています<xref:System.Double.MinValue>:。  
  
 [!code-cpp[Double Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>非数 \(<see langword="NaN" />\) の値を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッドまたは演算子を返します<xref:System.Double.NaN>操作の結果が定義されている場合。 たとえば、0 を 0 で除算した結果は<xref:System.Double.NaN>次の例を示します。 \(0 0 以外の数値で除算を返すこと、ただし、<xref:System.Double.PositiveInfinity>または<xref:System.Double.NegativeInfinity>除数の符号に応じて、します\)。  
  
 [!code-csharp[System.Double.NaN\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 さらに、メソッドを呼び出すと、<xref:System.Double.NaN>値またはでの操作、<xref:System.Double.NaN>値を返します<xref:System.Double.NaN>次の例を示します。  
  
 [!code-csharp[System.Double.NaN\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 使用して、<xref:System.Double.IsNaN%2A>値が数値ではないかどうかを調べます。<xref:System.Double.op_Equality%2A>演算子は 2 つが考慮<xref:System.Double.NaN>互いに等しくない場合の値。 一般に、<xref:System.Double>演算子は、比較に使用することはできません<xref:System.Double.NaN?displayProperty=fullName>他<xref:System.Double>ですが、値比較メソッド \(など<xref:System.Double.Equals%2A>と<xref:System.Double.CompareTo%2A>\) ことができます。 次の例との間の動作の違いを示しています。<xref:System.Double>比較演算子とメソッド。  
  
 [!code-csharp[System.Double.NaN\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## 例  
 <xref:System.Double.NaN> の使用例を次に示します。  
  
 [!code-cpp[System.Double\#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>負の無限大を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この定数の値は、負の数を 0 で除算した結果です。  
  
 この定数は、返される操作の結果はより小さい<xref:System.Double.MinValue>です。  
  
 使用して<xref:System.Double.IsNegativeInfinity%2A>値が負の無限大と評価されるかどうかを決定します。  
  
   
  
## 例  
 次のコード例の使用を示しています<xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double\#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値です。</param>
        <param name="right">比較する 2 番目の値です。</param>
        <summary>指定した 2 つの <see cref="T:System.Double" /> 値が等しいかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> と <paramref name="left" /> が等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Double.op_Equality%2A> method defines the equality operator for <xref:System.Double> values.  
  
 If two <xref:System.Double.NaN?displayProperty=fullName> values are tested for equality by using the equality operator, the result is **languageKeyword tag is not supported!!!!**  
; two <xref:System.Double.NaN?displayProperty=fullName> values are not considered equal. If they are tested for equality by calling the <xref:System.Double.Equals%2A> method, the result is **languageKeyword tag is not supported!!!!**  
.  When you want to determine whether the value of a <xref:System.Double> is not a number \(NaN\), an alternative is to call the <xref:System.Double.IsNaN%2A> method.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool op_GreaterThan (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値です。</param>
        <param name="right">比較する 2 番目の値です。</param>
        <summary>指定した <see cref="T:System.Double" /> 値が、指定したもう 1 つの <see cref="T:System.Double" /> 値より大きいかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> より大きい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Double.op_GreaterThan%2A>メソッドは、大きい方の操作を定義\-演算子よりも<xref:System.Double>値。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool op_GreaterThanOrEqual (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値。</param>
        <param name="right">比較する 2 番目の値。</param>
        <summary>指定した <see cref="T:System.Double" /> 値が、指定したもう 1 つの <see cref="T:System.Double" /> 値以上かどうかを示す値を返します。</summary>
        <returns>
          <paramref name="left" /> が <paramref name="right" /> 以上の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Double.op_GreaterThanOrEqual%2A> メソッドの大きいよりも、または等号演算子の動作を定義する <xref:System.Double> 値。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値。</param>
        <param name="right">比較する 2 番目の値。</param>
        <summary>指定した 2 つの <see cref="T:System.Double" /> 値が等しくないかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="left" /> と <paramref name="right" /> が等しくない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Double.op_Inequality%2A> メソッド定義の非等値演算子 <xref:System.Double> 値。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool op_LessThan (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値です。</param>
        <param name="right">比較する 2 番目の値です。</param>
        <summary>指定した <see cref="T:System.Double" /> 値が、指定したもう 1 つの <see cref="T:System.Double" /> 値より小さいかどうかを示す値を返します。</summary>
        <returns>
          <paramref name="left" /> が <paramref name="right" /> より小さい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Double.op_LessThan%2A>メソッドは、以下の操作を定義\-の演算子よりも<xref:System.Double>値。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool op_LessThanOrEqual (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初の値。</param>
        <param name="right">比較する 2 番目の値です。</param>
        <summary>指定した <see cref="T:System.Double" /> 値が、指定したもう 1 つの <see cref="T:System.Double" /> 値以下かどうかを示す値を返します。</summary>
        <returns>
          <paramref name="left" /> が <paramref name="right" /> 以下の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Double.op_LessThanOrEqual%2A> メソッドの低いよりも、または等号演算子の動作を定義する <xref:System.Double> 値。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含んだ文字列。</param>
        <summary>数値の文字列形式を、等価の倍精度浮動小数点数に変換します。</summary>
        <returns>
          <paramref name="s" /> で指定した数値または記号と等価の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `s`パラメーターは、現在のカルチャを含めることができます<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName>、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName>、 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName>、または形式の文字列。  
  
 \[*ws*\]\[*sign*\]\[*integral\-digits*\[*,*\]\]*integral\-digits*\[*.*\[*小数部の桁*\] \[E \[*記号*\]*桁の指数*\] \[*ws*\]  
  
 角かっこ \(\[ および \]\) 内の要素は省略可能です。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*ws*|一連の空白文字。|  
|*sign*|マイナス記号 \(\-\) または、プラス記号 \(\+\) です。 先頭の記号のみを使用できます。|  
|*整数の桁*|一連の数字の 0 から 9 の数の整数部を指定するまでです。 実行*整数の桁*グループの区切り記号でパーティション分割することができます。 たとえば、コンマ \(,\) は、一部のカルチャで、何千ものグループを区切ります。*整数の桁*要素を指定できる場合、文字列が含まれています、*小数部の桁*要素。|  
|,|カルチャ固有の桁区切り記号。|  
|」を参照してください。|カルチャに固有の小数点記号です。|  
|*小数の桁*|一連の数字の 0 から 9 数の小数部を指定するまでです。|  
|E|"E"または"E"文字は、値を指数表記で表されていることを示します。|  
|*指数桁の数字*|一連の数字の 0 から 9 指数部を指定するまでです。|  
  
 `s`パラメーターの組み合わせを使用して解釈されます、<xref:System.Globalization.NumberStyles.Float?displayProperty=fullName>と<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=fullName>フラグ。 つまり、空白文字と桁区切り記号は許可されて、たとえば、通貨記号がないときにします。 きめ細かい制御でどのスタイルより要素が許可されている`s`、解析操作が成功するには、呼び出し、<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=fullName>または<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=fullName>メソッドです。  
  
 `s`パラメーターで書式設定情報を使用して解釈されますが、<xref:System.Globalization.NumberFormatInfo>は現在のスレッド カルチャの初期化されているオブジェクト。 詳細については、「<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>」を参照してください。 その他のいくつかのカルチャの書式情報を使用して文字列を解析するには、呼び出し、<xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>または<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=fullName>メソッドです。  
  
 通常、渡した場合、<xref:System.Double.Parse%2A?displayProperty=fullName>メソッドを呼び出すことによって作成される文字列を<xref:System.Double.ToString%2A?displayProperty=fullName>、元のメソッド<xref:System.Double>値が返されます。 ただし、精度の損失、ため値可能性がありますいないなります。 さらに、いずれかの文字列形式を解析しよう<xref:System.Double.MinValue>または<xref:System.Double.MaxValue>スロー、 <xref:System.OverflowException>、次の例に示すようにします。  
  
 [!code-csharp[System.Double.Parse\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 区切り記号が発生した場合、`s`解析操作では、および適用可能な通貨または 10 進数の間にパラメーターと桁区切り記号が同じには、解析操作では、区切り文字が桁区切り記号ではなく、小数点区切り文字である前提としています。 区切り記号の詳細については、次を参照してください。 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>です。  
  
   
  
## 例  
 <xref:System.Double.Parse%28System.String%29> メソッドの使用例を次に示します。  
  
 [!code-cpp[Double Example\#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example\#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> は有効な形式で数値を表していません。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> は <see cref="F:System.Double.MinValue" /> 未満の数値か、<see cref="F:System.Double.MaxValue" /> より大きい数値を表します。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含んだ文字列。</param>
        <param name="style">
          <c>s</c> で使用可能なスタイル要素を示す、列挙値のビットごとの組み合わせ。 通常指定する値は、<see cref="F:System.Globalization.NumberStyles.Float" /> と <see cref="F:System.Globalization.NumberStyles.AllowThousands" /> の組み合わせです。</param>
        <summary>数値の指定したスタイルでの文字列形式を、それと等価な倍精度浮動小数点数に変換します。</summary>
        <returns>
          <paramref name="s" /> で指定した数値または記号と等価の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `style`パラメーター スタイル要素定義 \(空白文字、数千などの区切り記号および通貨記号\) で許容される、`s`解析操作が成功するためのパラメーターです。 ビット フラグの組み合わせをする必要があります、<xref:System.Globalization.NumberStyles>列挙します。 次<xref:System.Globalization.NumberStyles>メンバーがサポートされていません。  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s`パラメーターは、現在のカルチャを含めることができます<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName>、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName>、または<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName>です。 値に応じて`style`フォームをかかることができます。  
  
 \[*ws*\]\[*$*\]\[*sign*\]\[*integral\-digits*\[*,*\]\]*integral\-digits*\[*.*\[*小数部の桁*\] \[E \[*記号*\]*桁の指数*\] \[*ws*\]  
  
 角かっこ \(\[ および \]\) 内の要素は省略可能です。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*ws*|一連の空白文字。 先頭に空白文字は使用できません`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=fullName>末に表示されることができますフラグ、およびその`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=fullName>フラグ。|  
|$|カルチャ固有の通貨記号。 文字列内での位置がによって定義された、<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=fullName>と<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=fullName>現在のカルチャのプロパティです。 現在のカルチャの通貨記号に表示される`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=fullName>フラグ。|  
|*sign*|マイナス記号 \(\-\) または、プラス記号 \(\+\) です。 先頭に表示できる符号`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=fullName>フラグ、およびそのがの末尾に置くことができます`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=fullName>フラグ。 かっこを使用できる`s`負の値を指定する`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=fullName>フラグ。|  
|*整数の桁*|一連の数字の 0 から 9 の数の整数部を指定するまでです。*整数の桁*要素を指定できる場合、文字列が含まれています、*小数部の桁*要素。|  
|,|カルチャ固有のグループの区切り記号。 現在のカルチャの桁区切り記号に表示される`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=fullName>フラグ|  
|」を参照してください。|カルチャに固有の小数点記号です。 現在のカルチャの小数点記号に表示される`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=fullName>フラグ。|  
|*小数の桁*|一連の数字の 0 から 9 数の小数部を指定するまでです。 小数部の桁が表示できる`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=fullName>フラグ。|  
|E|"E"または"E"文字は、値を指数表記で表されていることを示します。`s`場合、パラメーターは指数表記の数値を表すことができる`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=fullName>フラグ。|  
|*指数桁の数字*|一連の数字の 0 から 9 指数部を指定するまでです。|  
  
 数字のみを含む文字列 \(に対応する、<xref:System.Globalization.NumberStyles.None?displayProperty=fullName>スタイル\) が正常に解析します。 残りの<xref:System.Globalization.NumberStyles?displayProperty=fullName>メンバーが存在する可能性がありますが、入力文字列内に存在する必要がない要素を制御します。 次の表に示す個別<xref:System.Globalization.NumberStyles>フラグに存在可能な要素に影響を与える`s`です。  
  
|NumberStyles 値|使用できる要素`s`数字だけでなく|  
|--------------------|-----------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整数の桁*要素のみです。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点 \(*.*\) および*小数部の桁*要素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"または"E"文字は、指数表記法を示します。 それ自体では、このフラグ形式で値をサポートする*桁の数字*E*桁*以外の場合は追加のフラグが正常に正または負の符号および小数点記号としては、このような要素を含む文字列を解析する必要です。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*の先頭にある要素`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*要素の最後に`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*記号*の先頭にある要素`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*記号*の末尾に要素`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*記号*数値の値を囲むかっこの形式での要素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|桁区切り記号 \(,\) 要素です。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|通貨 \($\) の要素。|  
|<xref:System.Globalization.NumberStyles.Currency>|すべての要素。 ただし、 `s` 16 進数または指数表記の数値を表すことはできません。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*先頭または末尾の位置にある要素`s`、*記号*の先頭に`s`、および小数点 \(.\) 記号です。`s`パラメーターは、指数表記も使用できます。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`、 `sign`、桁区切り記号 \(,\)、小数点 \(.\) 要素です。|  
|<xref:System.Globalization.NumberStyles.Any>|すべての要素。 ただし、 `s` 16 進数を表すことはできません。|  
  
 `s`で書式設定情報を使用してパラメーターを解析する<xref:System.Globalization.NumberFormatInfo>現在のシステムのカルチャに初期化されるオブジェクト。 詳細については、「<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>」を参照してください。  
  
 通常、渡した場合、<xref:System.Double.Parse%2A?displayProperty=fullName>メソッドを呼び出すことによって作成される文字列を<xref:System.Double.ToString%2A?displayProperty=fullName>、元のメソッド<xref:System.Double>値が返されます。 ただし、精度の損失、ため値可能性がありますいないなります。 さらに、いずれかの文字列形式を解析しよう<xref:System.Double.MinValue>または<xref:System.Double.MaxValue>スロー、 <xref:System.OverflowException>、次の例に示すようにします。  
  
 [!code-csharp[System.Double.Parse\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 区切り記号が発生した場合、`s`解析操作では、適用可能な通貨や数値の桁の時にパラメーターと桁区切り記号が同じには、解析操作では、区切り文字が桁区切り記号ではなく、小数点区切り文字である前提としています。 区切り記号の詳細については、次を参照してください。 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>です。  
  
   
  
## 例  
 次の例では、<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>の文字列形式を解析します<xref:System.Double>EN\-US カルチャを使用して値をします。  
  
 [!code-csharp[System.Double.Parse\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> は有効な形式で数値を表していません。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> は <see cref="F:System.Double.MinValue" /> 未満の数値か、<see cref="F:System.Double.MaxValue" /> より大きい数値を表します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> は <see cref="T:System.Globalization.NumberStyles" /> 値ではありません。  
  
 \-または\-  
  
 <paramref name="style" /> には <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 値が含まれています。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含んだ文字列。</param>
        <param name="provider">
          <c>s</c> に関するカルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>指定したカルチャに固有の書式による数値の文字列形式を、それと等価な倍精度浮動小数点数に変換します。</summary>
        <returns>
          <paramref name="s" /> で指定した数値または記号と等価の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロード、<xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29>メソッドでは、さまざまな方法でフォーマットできるテキストに変換するために使用は、通常、<xref:System.Double>値。 たとえば、数値を指定する HTML テキスト ボックスに、ユーザーによって入力されるテキストに変換する、使用できます。  
  
 `s`パラメーターの組み合わせを使用して解釈されます、<xref:System.Globalization.NumberStyles.Float?displayProperty=fullName>と<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=fullName>フラグ。`s`パラメーターを含めることができます<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName>、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName>、または<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName>で指定されたカルチャの`provider`、または形式の文字列を含めることができます。  
  
 \[*ws*\]\[*sign*\]*integral\-digits*\[*.*\[*小数部の桁*\] \[E \[*記号*\]*桁の指数*\] \[*ws*\]  
  
 省略可能な要素は角かっこで囲まれています \(\[および\]\)。 数字の 0 から 9 までの一連の"digits"という語を含む要素で構成されます。  
  
|要素|説明|  
|--------|--------|  
|*ws*|一連の空白文字。|  
|*sign*|マイナス記号 \(\-\) または、プラス記号 \(\+\) です。|  
|*整数の桁*|一連の数字の 0 から 9 の数の整数部を指定するまでです。 実行*整数の桁*グループの区切り記号でパーティション分割することができます。 たとえば、コンマ \(,\) は、一部のカルチャで、何千ものグループを区切ります。*整数の桁*要素を指定できる場合、文字列が含まれています、*小数部の桁*要素。|  
|」を参照してください。|カルチャに固有の小数点記号です。|  
|*小数の桁*|一連の数字の 0 から 9 数の小数部を指定するまでです。|  
|E|"E"または"E"文字は、値を指数表記で表されていることを示します。|  
|*指数桁の数字*|一連の数字の 0 から 9 指数部を指定するまでです。|  
  
 数値形式の詳細については、次を参照してください。、[Formatting Types in the .NET Framework](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)トピックです。  
  
 `provider`パラメーターは、<xref:System.IFormatProvider>実装が<xref:System.IFormatProvider.GetFormat%2A>メソッドを返します、<xref:System.Globalization.NumberFormatInfo>の形式を解釈するときに使用されるカルチャに固有の情報を提供するオブジェクト`s`です。 通常は、<xref:System.Globalization.NumberFormatInfo>または<xref:System.Globalization.CultureInfo>オブジェクト。 場合`provider`は`null`または<xref:System.Globalization.NumberFormatInfo>を取得できません、書式設定については、現在のシステム カルチャが使用されます。  
  
 通常、渡した場合、<xref:System.Double.Parse%2A?displayProperty=fullName>メソッドを呼び出すことによって作成される文字列を<xref:System.Double.ToString%2A?displayProperty=fullName>、元のメソッド<xref:System.Double>値が返されます。 ただし、精度の損失、ため値可能性がありますいないなります。 さらに、いずれかの文字列形式を解析しよう<xref:System.Double.MinValue>または<xref:System.Double.MaxValue>スロー、 <xref:System.OverflowException>、次の例に示すようにします。  
  
 [!code-csharp[System.Double.Parse\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 区切り記号が発生した場合、`s`解析操作では、適用可能な通貨や数値の桁の時にパラメーターと桁区切り記号が同じには、解析操作では、区切り文字が桁区切り記号ではなく、小数点区切り文字である前提としています。 区切り記号の詳細については、次を参照してください。 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>です。  
  
   
  
## 例  
 次の例は、ボタンは、Web フォームのイベント ハンドラーをクリックします。 によって返される配列を使用して、<xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=fullName>プロパティをユーザーのロケールを決定します。 インスタンス化し、<xref:System.Globalization.CultureInfo>そのロケールに対応するオブジェクト。<xref:System.Globalization.NumberFormatInfo>に属しているオブジェクト<xref:System.Globalization.CultureInfo>にオブジェクトが渡され、<xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29>をユーザーに変換するメソッドの入力、<xref:System.Double>値。  
  
 [!code-csharp[ParseMethod\#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> は有効な形式で数値を表していません。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> は <see cref="F:System.Double.MinValue" /> 未満の数値か、<see cref="F:System.Double.MaxValue" /> より大きい数値を表します。</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を含んだ文字列。</param>
        <param name="style">
          <c>s</c> で使用可能なスタイル要素を示す、列挙値のビットごとの組み合わせ。 通常指定する値は、<see cref="F:System.Globalization.NumberStyles.AllowThousands" /> と組み合わせた <see cref="F:System.Globalization.NumberStyles.Float" /> です。</param>
        <param name="provider">
          <c>s</c> に関するカルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>指定したスタイルおよびカルチャ固有の書式での数値の文字列形式を、等価の倍精度浮動小数点数に変換します。</summary>
        <returns>
          <paramref name="s" /> で指定した数値または記号と等価の倍精度浮動小数点数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `style`パラメーター スタイル要素定義 \(空白文字、数千などの区切り記号および通貨記号\) で許容される、`s`解析操作が成功するためのパラメーターです。 ビット フラグの組み合わせを可能にする必要があります、<xref:System.Globalization.NumberStyles>列挙します。 次<xref:System.Globalization.NumberStyles>メンバーがサポートされていません。  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s`パラメーターを含めることができます<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName>、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName>、または<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName>で指定されたカルチャの`provider`します。 値に応じて`style`フォームをかかることができます。  
  
 \[*ws*\] \[*$*\] \[*sign*\]\[*integral\-digits*,\]*integral\-digits*\[.\[*小数部の桁*\]\[E\[*sign*\]*exponential\-digits*\]\[*ws*\]  
  
 要素は角かっこ \(\[および\]\) は省略可能で囲まれています。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*ws*|一連の空白文字。 先頭に空白文字は使用できません`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=fullName>末に表示されることができますフラグ、およびその`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=fullName>フラグ。|  
|$|カルチャ固有の通貨記号。 文字列内での位置がによって定義された、<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=fullName>と<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=fullName>現在のカルチャのプロパティです。 現在のカルチャの通貨記号に表示される`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=fullName>フラグ。|  
|*sign*|マイナス記号 \(\-\) または、プラス記号 \(\+\) です。 先頭に表示できる符号`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=fullName>フラグ、およびそのがの末尾に置くことができます`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=fullName>フラグ。 かっこを使用できる`s`負の値を指定する`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=fullName>フラグ。|  
|*整数の桁*|一連の数字の 0 から 9 の数の整数部を指定するまでです。*整数の桁*要素を指定できる場合、文字列が含まれています、*小数部の桁*要素。|  
|,|カルチャ固有のグループの区切り記号。 現在のカルチャの桁区切り記号に表示される`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=fullName>フラグ|  
|」を参照してください。|カルチャに固有の小数点記号です。 現在のカルチャの小数点記号に表示される`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=fullName>フラグ。|  
|*小数の桁*|一連の数字の 0 から 9 数の小数部を指定するまでです。 小数部の桁が表示できる`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=fullName>フラグ。|  
|E|"E"または"E"文字は、値を指数表記で表されていることを示します。`s`場合、パラメーターは指数表記の数値を表すことができる`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=fullName>フラグ。|  
|*指数桁の数字*|一連の数字の 0 から 9 指数部を指定するまでです。|  
  
 数字のみを含む文字列 \(に対応する、<xref:System.Globalization.NumberStyles.None?displayProperty=fullName>スタイル\) が正常に解析します。 残りの<xref:System.Globalization.NumberStyles?displayProperty=fullName>メンバーが存在する可能性がありますが、入力文字列内に存在する必要がない要素を制御します。 次の表に示す個別<xref:System.Globalization.NumberStyles>フラグに存在可能な要素に影響を与える`s`です。  
  
|NumberStyles 値|使用できる要素`s`数字だけでなく|  
|--------------------|-----------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整数の桁*要素のみです。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|小数点 \(*.*\) および*小数部の桁*要素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|"E"または"E"文字は、指数表記法を示します。 それ自体では、このフラグ形式で値をサポートする*桁の数字*E*桁*以外の場合は追加のフラグが正常に正または負の符号および小数点記号としては、このような要素を含む文字列を解析する必要です。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*の先頭にある要素`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*の末尾に要素`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*記号*の先頭にある要素`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*記号*の末尾に要素`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*記号*数値の値を囲むかっこの形式での要素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|桁区切り記号 \(,\) 要素です。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|通貨 \($\) の要素。|  
|<xref:System.Globalization.NumberStyles.Currency>|すべての要素。 ただし、 `s` 16 進数または指数表記の数値を表すことはできません。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*先頭または末尾の位置にある要素`s`、*記号*の先頭に`s`、および小数点 \(.\) 記号です。`s`パラメーターは、指数表記も使用できます。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`、 `sign`、桁区切り記号 \(,\)、小数点 \(.\) 要素です。|  
|<xref:System.Globalization.NumberStyles.Any>|すべての要素。 ただし、 `s` 16 進数を表すことはできません。|  
  
 `provider`パラメーターは、<xref:System.IFormatProvider>実装が<xref:System.IFormatProvider.GetFormat%2A>メソッドを返します、<xref:System.Globalization.NumberFormatInfo>の形式を解釈するときに使用されるカルチャに固有の情報を提供するオブジェクト`s`です。 通常は、<xref:System.Globalization.NumberFormatInfo>または<xref:System.Globalization.CultureInfo>オブジェクト。 場合`provider`は`null`または<xref:System.Globalization.NumberFormatInfo>を取得できません、書式設定については、現在のシステム カルチャが使用されます。  
  
 通常、渡した場合、<xref:System.Double.Parse%2A?displayProperty=fullName>メソッドを呼び出すことによって作成される文字列を<xref:System.Double.ToString%2A?displayProperty=fullName>メソッドは、元の<xref:System.Double>値が返されます。 ただし、精度の損失、ため値可能性がありますいないなります。 さらに、いずれかの文字列形式を解析しよう<xref:System.Double.MinValue>または<xref:System.Double.MaxValue>スロー、 <xref:System.OverflowException>、次の例に示すようにします。  
  
 [!code-csharp[System.Double.Parse\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 区切り記号が発生した場合、`s`解析操作では、適用可能な通貨や数値の桁の時にパラメーターと桁区切り記号が同じには、解析操作では、区切り文字が桁区切り記号ではなく、小数点区切り文字である前提としています。 区切り記号の詳細については、次を参照してください。 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>です。  
  
   
  
## 例  
 次の例では、使用、<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>温度値のいくつかの文字列形式を割り当てる方法、`Temperature`オブジェクト。  
  
 [!code-csharp[System.Double.Parse\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> が数値を表していません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> は <see cref="T:System.Globalization.NumberStyles" /> 値ではありません。  
  
 \-または\-  
  
 <paramref name="style" /> は <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> 値です。</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> は <see cref="F:System.Double.MinValue" /> 未満の数値か、<see cref="F:System.Double.MaxValue" /> より大きい数値を表します。</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>正の無限大を表します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この定数の値は、0 では正の数値を除算した結果です。  
  
 この定数は操作の結果がよりも大きい場合に返される<xref:System.Double.MaxValue>です。  
  
 使用して<xref:System.Double.IsPositiveInfinity%2A>値が正の無限大と評価されるかどうかを決定します。  
  
   
  
## 例  
 次のコード例は、の使用を示しています<xref:System.Double.PositiveInfinity>:。  
  
 [!code-cpp[System.Double\#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>現在のインスタンスの値が 0 でない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>
          <see cref="T:System.Byte" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToByte%28System.Double%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>この変換はサポートされていません。 このメソッドを使用しようとすると、<see cref="T:System.InvalidCastException" /> がスローされます。</summary>
        <returns>この変換はサポートされていません。 値は返されません。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>この変換はサポートされていません。 このメソッドを使用しようとすると、<see cref="T:System.InvalidCastException" /> がスローされます。</summary>
        <returns>この変換はサポートされていません。 値は返されません。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>
          <see cref="T:System.Decimal" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>変更されていない、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>
          <see cref="T:System.Int16" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>
          <see cref="T:System.Int32" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>
          <see cref="T:System.Int64" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>
          <see cref="T:System.SByte" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>
          <see cref="T:System.Single" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">この <see cref="T:System.Double" /> 値の変換後の型。</param>
        <param name="provider">戻り値の書式に関するカルチャ固有の情報を提供する <see cref="T:System.IFormatProvider" /> の実装。</param>
        <summary>このメンバーの説明については、「<see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />」を参照してください。</summary>
        <returns>
          <paramref name="type" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 `static` \(`Shared` Visual Basic で\) <xref:System.Convert.ChangeType%2A?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>
          <see cref="T:System.UInt16" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />」をご覧ください。</summary>
        <returns>
          <see cref="T:System.UInt32" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">このパラメーターは無視されます。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />」を参照してください。</summary>
        <returns>
          <see cref="T:System.UInt64" /> に変換後の、現在のインスタンスの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Double> のインスタンスが <xref:System.IConvertible> インターフェイスにキャストされる場合にのみ、使用できます。 呼び出す、推奨される代替ことです、 <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの数値を、それと等価な文字列形式に変換します。</summary>
        <returns>このインスタンスの値の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Double.ToString>メソッドの形式、<xref:System.Double>現在のカルチャの形式 \("G"、または \[全般\]\) の既定の値します。 別の形式、有効桁数、またはカルチャを指定する場合は、他のオーバー ロードを使用して、<xref:System.Double.ToString%2A>メソッドは、次のようにします。  
  
|形式を使用するには|カルチャの|オーバー ロードを使用します。|  
|---------------|-----------|---------------------|  
|既定値 \("G"\) 書式|特定のカルチャ|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定の形式または有効桁数|\(現在\) の既定のカルチャ|<xref:System.Double.ToString%28System.String%29>|  
|特定の形式または有効桁数|特定のカルチャ|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 戻り値は、 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>、 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>、または形式の文字列。  
  
 \[サインイン\] 整数の桁 \[です \[。小数部の桁\] \[e \[サインイン\] 指数の桁\]  
  
 省略可能な要素は角かっこで囲まれています \(\[および\]\)。 数字の 0 から 9 までの一連の"digits"という語を含む要素で構成されます。 次の表に示す要素がサポートされています。  
  
|要素|説明|  
|--------|--------|  
|*sign*|負の記号または正の記号。|  
|*整数の桁*|一連の数字の数の整数部分を指定します。 整数の桁がなくてもかまいません桁の小数部がある場合。|  
|'*.*'|カルチャに固有の小数点記号です。|  
|*小数の桁*|一連の数字の数の小数部を指定します。|  
|'*e*'|小文字"e"を示す文字指数表記。|  
|*指数桁の数字*|一連の数字の指数部を指定します。|  
  
 戻り値の例をいくつかは、「100」、「\-123,456,789」、"123.45 e \+ 6"、「500」、「3.1416」、「600」、「\-0.123」と"\-Infinity"です。  
  
 .NET Framework では、次の書式設定のトピックで詳しく説明されている、広範な書式設定サポートを提供します。  
  
-   数値書式指定子の詳細については、次を参照してください。[Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467)と[Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。  
  
-   書式設定に関する詳細については、次を参照してください。[Formatting Types in the .NET Framework](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)です。  
  
   
  
## 例  
 次の例では、既定値<xref:System.Double.ToString?displayProperty=fullName>の数の文字列形式を表示するメソッドを<xref:System.Double>値。  
  
 [!code-csharp[System.Double.ToString\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 次の例は、の使用を示しています。<xref:System.Double.ToString%2A>です。  
  
 [!code-cpp[System.Double\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このインスタンスの数値を、指定したカルチャ固有の書式情報を使用して、それと等価な文字列形式に変換します。</summary>
        <returns>
          <paramref name="provider" /> で指定された、このインスタンスの値の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Double.ToString%28System.IFormatProvider%29>メソッドの形式、<xref:System.Double>値の既定値 \("G"、または \[全般\]\) で指定されたカルチャの形式です。 別の形式またはカルチャを指定する場合の他のオーバー ロードを使用して、<xref:System.Double.ToString%2A>メソッドは、次のようにします。  
  
|形式を使用するには|カルチャの|オーバー ロードを使用します。|  
|---------------|-----------|---------------------|  
|既定値 \("G"\) 書式|既定の \(現在の\)|<xref:System.Double.ToString>|  
|特定の形式または有効桁数|\(現在\) の既定のカルチャ|<xref:System.Double.ToString%28System.String%29>|  
|特定の形式または有効桁数|特定のカルチャ|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 戻り値は、 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>、 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>、または形式の文字列。  
  
 \[サインイン\] 整数の桁 \[です \[。小数部の桁\] \[e \[サインイン\] 指数の桁\]  
  
 省略可能な要素は角かっこで囲まれています \(\[および\]\)。 数字の 0 から 9 までの一連の"digits"という語を含む要素で構成されます。 次の表に示す要素がサポートされています。  
  
|要素|説明|  
|--------|--------|  
|*sign*|負の記号または正の記号。|  
|*整数の桁*|一連の数字の数の整数部分を指定します。 整数の桁がなくてもかまいません桁の小数部がある場合。|  
|'*.*'|カルチャに固有の小数点記号です。|  
|*小数の桁*|一連の数字の数の小数部を指定します。|  
|'*e*'|小文字"e"を示す文字指数表記。|  
|*指数桁の数字*|一連の数字の指数部を指定します。|  
  
 戻り値の例をいくつかは、「100」、「\-123,456,789」、"123.45 e \+ 6"、「500」、「3.1416」、「600」、「\-0.123」と"\-Infinity"です。  
  
 このインスタンスには、\[全般\] の数値書式指定子 \("G"\) が表示されます。  
  
 .NET フレームワークでは、広範な書式設定の次のトピックで詳しく説明されている書式設定サポートを提供します。  
  
-   数値書式指定子の詳細については、次を参照してください。[Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467)と[Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。  
  
-   書式設定に関する詳細については、次を参照してください。[Formatting Types in the .NET Framework](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)です。  
  
 `provider`パラメーターは、<xref:System.IFormatProvider>実装が<xref:System.IFormatProvider.GetFormat%2A>メソッドを返します、<xref:System.Globalization.NumberFormatInfo>オブジェクト。 通常、`provider`は、<xref:System.Globalization.CultureInfo>オブジェクトまたは<xref:System.Globalization.NumberFormatInfo>オブジェクト。`provider`パラメーターの書式設定に使用されるカルチャに固有の情報を提供します。 場合`provider`は`null`を使用して、戻り値が書式設定、<xref:System.Globalization.NumberFormatInfo>現在のカルチャ オブジェクト。  
  
   
  
## 例  
 次の例では、2 つの文字列形式を<xref:System.Double>を使用して値<xref:System.Globalization.CultureInfo>を複数の異なるカルチャを表すオブジェクト。  
  
 [!code-csharp[System.Double.ToString\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 次の例では、使用する<xref:System.Double.ToString%2A>、実行、<xref:System.String>と<xref:System.IFormatProvider>パラメーターとして。  
  
 [!code-cpp[Double Example\#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example\#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">数値書式指定文字列。</param>
        <summary>指定した書式を使用して、このインスタンスの数値を、それと等価な文字列形式に変換します。</summary>
        <returns>
          <paramref name="format" /> で指定された、このインスタンスの値の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Double.ToString%28System.String%29>メソッドの形式、<xref:System.Double>現在のカルチャの規則を使用して、指定した書式の値。 別の形式またはカルチャを指定する場合は、他のオーバー ロードを使用して、<xref:System.Double.ToString%2A>メソッドは、次のようにします。  
  
|形式を使用するには|カルチャの|オーバー ロードを使用します。|  
|---------------|-----------|---------------------|  
|既定値 \("G"\) 書式|\(現在\) の既定のカルチャ|<xref:System.Double.ToString>|  
|既定値 \("G"\) 書式|特定のカルチャ|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定の形式または有効桁数|特定のカルチャ|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 戻り値は、 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>、 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>、またはで指定したとおり、数値の文字列形式を`format`です。  
  
 `format` D と、X を除く任意の有効な標準の数値書式指定子およびカスタム数値書式指定子の任意の組み合わせのパラメーターを指定できます。 場合`format`は`null`または戻り値、空の文字列は、\[全般\] の数値書式指定子 \("G"\) でフォーマットされています。  
  
 .NET Framework では、次の書式設定のトピックで詳しく説明されている、広範な書式設定サポートを提供します。  
  
-   数値書式指定子の詳細については、次を参照してください。[Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467)と[Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。  
  
-   書式設定に関する詳細については、次を参照してください。[Formatting Types](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)です。  
  
 既定では、戻り値にはのみが含まれています 15 桁精度には最大 17 桁が内部的に保持されています。 このインスタンスの値は 15 桁を超える場合<xref:System.Double.ToString%2A>返します<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>または<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>予想された数の代わりにします。 高い精度を必要とする場合は、指定`format`が常に有効桁数、または"R"17 桁を返します、"G17"書式指定する場合を返します 15 桁数を表現できる場合は最大有効桁数を持つ場合は、その有効桁数または桁数が 17 数を表すことができます。  
  
   
  
## 例  
 次の例では、数値の値を定義し、書式を通貨値として"C"標準の数値書式指定文字列を使用して、小数点以下 3 桁の数値として"N"の標準数値書式指定文字列を使用しています。 結果文字列は EN\-US カルチャの規則を使用して書式設定されます。 数値書式指定文字列の詳細については、次を参照してください。[Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467)と[Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。  
  
 [!code-csharp[System.Double.ToString\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 次の例では、いくつかが表示されます<xref:System.Double>値は、サポートされている標準数値書式指定子と共に次の 3 つのカスタム数値書式指定文字列を使用します。 余白を埋めるための方法を示しています、カスタム書式指定文字列の 1 つ、<xref:System.Single>先行ゼロを持つ値です。 さらに、"R"を除く各標準書式指定子と精度指定子を使用します。 0 から 3 の精度指定子の範囲の値。 数値の値を文字列に変換するには、EN\-US カルチャの書式指定規則を使用します。  
  
 [!code-cpp[System.Double.ToString\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> が正しくありません。</exception>
        <block subset="none" type="usage">
          <para>In some cases, <see cref="T:System.Double" /> values formatted with the "R" standard numeric format string do not successfully round-trip if compiled using the <see langword="/platform:x64" /> or <see langword="/platform:anycpu" /> switches and run on 64-bit systems. To work around this problem, you can format <see cref="T:System.Double" /> values by using the "G17" standard numeric format string. The following example uses the "R" format string with a <see cref="T:System.Double" /> value that does not round-trip successfully, and also uses the "G17" format string to successfully round-trip the original value.  
  
 [!code-csharp[System.Double.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex2.cs#6)]
 [!code-vb[System.Double.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex2.vb#6)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">数値書式指定文字列。</param>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <summary>このインスタンスの数値を、指定した書式およびカルチャ固有の書式情報を使用して、それと等価な文字列形式に変換します。</summary>
        <returns>
          <paramref name="format" /> と <paramref name="provider" /> で指定された、このインスタンスの値の文字列形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>メソッドの形式、<xref:System.Double>特定のカルチャの指定した形式の値。 別の形式またはカルチャを指定する場合の他のオーバー ロードを使用して、<xref:System.Double.ToString%2A>メソッドは、次のようにします。  
  
|形式を使用するには|カルチャの|オーバー ロードを使用します。|  
|---------------|-----------|---------------------|  
|既定値 \("G"\) 書式|\(現在\) の既定のカルチャ|<xref:System.Double.ToString>|  
|既定値 \("G"\) 書式|特定のカルチャ|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|特定の形式または有効桁数|\(現在\) の既定のカルチャ|<xref:System.Double.ToString%28System.String%29>|  
  
 戻り値は、 <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>、 <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>、またはで指定したとおり、数値の文字列形式を`format`です。  
  
 `format`パラメーターには、D および X を除く任意の有効な標準の数値書式指定子およびカスタム数値書式指定子の任意の組み合わせを指定できます。 場合`format`は`null`またはこのインスタンスの戻り値、空の文字列が、一般的な数値書式指定子 \("G"\) でフォーマットされています。  
  
 .NET Framework では、次の書式設定のトピックで詳しく説明されている、広範な書式設定サポートを提供します。  
  
-   数値書式指定子の詳細については、次を参照してください。[Standard Numeric Format Strings](http://msdn.microsoft.com/ja-jp/580e57eb-ac47-4ffd-bccd-3a1637c2f467)と[Custom Numeric Format Strings](http://msdn.microsoft.com/ja-jp/6f74fd32-6c6b-48ed-8241-3c2b86dea5f4)です。  
  
-   書式設定に関する詳細については、次を参照してください。[Formatting Types in the .NET Framework](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)です。  
  
 `provider`パラメーターに<xref:System.IFormatProvider>実装が<xref:System.IFormatProvider.GetFormat%2A>メソッドを返します。 を<xref:System.Globalization.NumberFormatInfo>オブジェクト。 通常、`provider`は、<xref:System.Globalization.CultureInfo>オブジェクトまたは<xref:System.Globalization.NumberFormatInfo>オブジェクト。`provider`パラメーターの書式設定に使用されるカルチャに固有の情報を提供します。 場合`provider`は`null`を戻り値を使用して書式設定の<xref:System.Globalization.NumberFormatInfo>の現在のカルチャ オブジェクト。  
  
 既定では、戻り値にはのみが含まれています 15 桁精度には最大 17 桁が内部的に保持されています。 このインスタンスの値は 15 桁を超える場合<xref:System.Double.ToString%2A>返します<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>または<xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>予想された数の代わりにします。 高い精度を必要とする場合は、指定`format`が常に有効桁数、または"R"17 桁を返します、"G17"書式指定する場合を返します 15 桁数を表現できる場合は最大有効桁数を持つ場合は、その有効桁数または桁数が 17 数を表すことができます。  
  
   
  
## 例  
 次の例を表示、<xref:System.Double>値のサポートされている標準数値書式指定子のいくつかの異なるカルチャを使用します。  
  
 [!code-cpp[System.Double.ToString\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 次の例は、の使用を示しています。<xref:System.Double.ToString%2A>かかる時間は、、<xref:System.String>と<xref:System.IFormatProvider>パラメーターとして。  
  
 [!code-cpp[Double Example\#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example\#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>In some cases, <see cref="T:System.Double" /> values formatted with the "R" standard numeric format string do not successfully round-trip if compiled using the <see langword="/platform:x64" /> or <see langword="/platform:anycpu" /> switches and run on 64-bit systems. To work around this problem, you can format <see cref="T:System.Double" /> values by using the "G17" standard numeric format string. The following example uses the "R" format string with a <see cref="T:System.Double" /> value that does not round-trip successfully, and also uses the "G17" format string to successfully round-trip the original value.  
  
 [!code-csharp[System.Double.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex1.cs#5)]
 [!code-vb[System.Double.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex1.vb#5)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, float64 result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を格納する文字列。</param>
        <param name="result">変換が成功した場合、このメソッドから戻るときに、<c>s</c> パラメーターの値と等価の倍精度浮動小数点数を格納します。変換に失敗した場合は 0 を格納します。<c>s</c> パラメーターが <see langword="null" /> または <see cref="F:System.String.Empty" /> であるか、有効な書式の数値ではない、または <see cref="F:System.Double.MinValue" /> より小さいか <see cref="F:System.Double.MaxValue" /> より大きい数値を表している場合、変換は失敗します。 このパラメーターは初期化されていない状態で渡されています。<c>result</c> で最初に指定された任意の値が上書きされます。</param>
        <summary>数値の文字列形式を、等価の倍精度浮動小数点数に変換します。 戻り値は、変換が成功したか失敗したかを示します。</summary>
        <returns>
          <see langword="true" /> が正常に変換された場合は <paramref name="s" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードとは異なります、<xref:System.Double.Parse%28System.String%29?displayProperty=fullName>解析の数値の値を返す代わりに、解析操作が成功したかどうかを示すブール値を返すメソッド。 例外処理をテストするために使用する必要がある、<xref:System.FormatException>イベントで`s`無効なため、正常に解析することはできません。  
  
 `s`パラメーターは、現在のカルチャを含めることができます<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName>、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName>、<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName>文字列比較では、大文字小文字を区別\)、または形式の文字列。  
  
 \[ws\]\[記号\]\[整数の桁\]、整数の桁 \[です \[。小数部の桁\] \[e \[サインイン\] 指数の桁\] \[ws\]  
  
 角かっこ内の要素は省略できます。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*ws*|一連の空白文字。|  
|*sign*|負の記号または正の記号。|  
|*整数の桁*|一連の数字の 0 から 9 の数の整数部を指定するまでです。 整数の桁がなくてもかまいません桁の小数部がある場合。|  
|*,*|カルチャ固有のグループの区切り記号です。|  
|*」を参照してください。*|カルチャに固有の小数点記号です。|  
|*小数の桁*|一連の数字の 0 から 9 数の小数部を指定するまでです。|  
|*E*|大文字または小文字 'e' を示す文字指数表記。|  
|*指数桁の数字*|一連の数字の 0 から 9 指数部を指定するまでです。|  
  
 数値形式の詳細については、次を参照してください。[Formatting Types in the .NET Framework](http://msdn.microsoft.com/ja-jp/0d1364da-5b30-4d42-8e6b-03378343343f)です。  
  
 `s`パラメーターがの組み合わせを使用して解釈されます、<xref:System.Globalization.NumberStyles.Float?displayProperty=fullName>と<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=fullName>フラグ。 つまり、空白文字と桁区切り記号が許可されているが、通貨記号は表示されません。 要素を明示的に定義 \(などの通貨記号、桁区切り記号、および空白\) 内に存在することができます`s`、使用、<xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=fullName>メソッドのオーバー ロードします。  
  
 `s`で書式設定情報を使用してパラメーターを解析、<xref:System.Globalization.NumberFormatInfo>現在のシステムのカルチャに初期化されるオブジェクト。 詳細については、「<xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=fullName>」を参照してください。 文字列を解析するその他の書式情報を使用して指定されたカルチャを使用して、<xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=fullName>メソッドのオーバー ロードします。  
  
 通常、渡した場合、<xref:System.Double.TryParse%2A?displayProperty=fullName>メソッドを呼び出すことによって作成される文字列を<xref:System.Double.ToString%2A?displayProperty=fullName>、元のメソッド<xref:System.Double>値が返されます。 ただし、精度の損失、ため値可能性がありますいないなります。 さらに、いずれかの文字列形式を解析しよう<xref:System.Double.MinValue>または<xref:System.Double.MaxValue>スロー、 <xref:System.OverflowException>、次の例に示すようにします。  
  
 [!code-csharp[System.Double.TryParse\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 区切り記号が発生した場合、`s`解析操作中、および 10 進数とグループの区切り記号のパラメーターは同じ、解析操作では、区切り文字が桁区切り記号ではなく、小数点区切り文字である前提としています。 区切り記号の詳細については、次を参照してください。 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>です。  
  
   
  
## 例  
 次の例では、<xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29>数値の文字列形式を変換する方法の<xref:System.Double>値。 その EN\-US では、現在のカルチャと見なします。  
  
 [!code-csharp[System.Double.TryParse\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, float64 result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">変換する数値を格納する文字列。</param>
        <param name="style">
          <see cref="T:System.Globalization.NumberStyles" /> で使用可能な書式を示す、<c>s</c> 値のビットごとの組み合わせ。 通常指定する値は、<see cref="F:System.Globalization.NumberStyles.AllowThousands" /> と組み合わせた <see cref="F:System.Globalization.NumberStyles.Float" /> です。</param>
        <param name="provider">
          <c>s</c> に関するカルチャに固有の書式設定情報を提供する <see cref="T:System.IFormatProvider" />。</param>
        <param name="result">変換が成功した場合、このメソッドから戻るときに、<c>s</c> に格納された数値または記号と等価の倍精度浮動小数点数を格納します。変換に失敗した場合は 0 を格納します。<c>s</c> パラメーターが <see langword="null" /> または <see cref="F:System.String.Empty" /> である、<c>style</c> に準拠した形式ではない、<see cref="F:System.SByte.MinValue" /> より小さいか <see cref="F:System.SByte.MaxValue" /> より大きい数値を表す、または <c>style</c> が <see cref="T:System.Globalization.NumberStyles" /> 列挙定数の有効な組み合わせではない場合、変換は失敗します。 このパラメーターは初期化されていない状態で渡されています。<c>result</c> で最初に指定された任意の値が上書きされます。</param>
        <summary>指定したスタイルおよびカルチャ固有の書式での数値の文字列形式を、等価の倍精度浮動小数点数に変換します。 戻り値は、変換が成功したか失敗したかを示します。</summary>
        <returns>
          <see langword="true" /> が正常に変換された場合は <paramref name="s" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Double.TryParse%2A>などのメソッドは、<xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>メソッドを除いて、このメソッドは、変換が失敗した場合に例外をスローしません。 戻り値は、変換が成功すると、`true`と`result`パラメーターは、変換の結果に設定します。 変換に失敗した場合、戻り値は`false`と`result`パラメーターが 0 に設定します。 これをテストする例外処理を使用する必要がある、<xref:System.FormatException>イベントで`s`無効なため、正常に解析することはできません。  
  
 `style`パラメーターの使用可能な形式を定義する、`s`解析操作が成功するためのパラメーターです。 ビット フラグの組み合わせを可能にする必要があります、<xref:System.Globalization.NumberStyles>列挙します。 次<xref:System.Globalization.NumberStyles>メンバーがサポートされていません。  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=fullName>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=fullName>  
  
 `s`パラメーターを含めることができます<xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=fullName>、 <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=fullName>、または<xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=fullName>によって示されるカルチャ`provider`です。 値に応じてさらに、 `style`、`s`パラメーターは、次の要素を含めることがあります。  
  
 \[ws\]\[$\]\[記号\]\[整数の桁\]、整数の桁 \[.fractional 桁\] \[e \[サインイン\] 指数の桁\] \[ws\]  
  
 角かっこ \(\[ および \]\) 内の要素は省略可能です。 次の表では、各要素について説明します。  
  
|要素|説明|  
|--------|--------|  
|*ws*|省略可能なホワイト スペースです。 先頭に空白文字は使用できません`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=fullName>フラグ。 末尾に表示できる`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=fullName>フラグ。|  
|*$*|カルチャ固有の通貨記号。 文字列内での位置がによって定義された、<xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=fullName>または<xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=fullName>のプロパティ、<xref:System.Globalization.NumberFormatInfo>によって返されるオブジェクト、<xref:System.IFormatProvider.GetFormat%2A?displayProperty=fullName>のメソッド、`provider`パラメーター。 通貨記号に表示される`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=fullName>フラグ。|  
|*sign*|省略可能な符号の場合。 先頭に表示できる符号`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=fullName>フラグ、およびそのがの末尾に置くことができます`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=fullName>フラグ。 かっこを使用できる`s`負の値を指定する場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=fullName>フラグ。|  
|*整数の桁*|一連の数字の 0 から 9 の数の整数部を指定するまでです。 整数の桁がなくてもかまいません桁の小数部がある場合。|  
|*,*|カルチャ固有の桁区切り記号。 現在のカルチャの数千に区切り記号が表示できる`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=fullName>フラグ。|  
|*」を参照してください。*|カルチャに固有の小数点記号です。 現在のカルチャの小数点記号に表示される`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=fullName>フラグ。|  
|*小数の桁*|一連の数字の 0 から 9 数の小数部を指定するまでです。 小数部の桁が表示できる`s`場合`style`が含まれています、<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=fullName>フラグ。|  
|*e*|E または E の文字は、ことを示します`s`指数表記を使用して数値を表すことができます。`s`スタイルが含まれている場合、パラメーターは指数表記の数値を表すことができます、<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=fullName>フラグ。|  
|*指数桁の数字*|一連の数字の 0 から 9 指数部を指定するまでです。|  
  
 数字のみを含む文字列 \(に対応する、<xref:System.Globalization.NumberStyles.None?displayProperty=fullName>スタイル\) が正常に解析します。 残りの<xref:System.Globalization.NumberStyles?displayProperty=fullName>メンバーを制御する可能性がありますが、入力文字列内に存在する必要はありません要素。 次の表に示す個別<xref:System.Globalization.NumberStyles>フラグに存在可能な要素に影響を与える`s`です。  
  
|NumberStyles 値|数字だけでなく s で許可されている要素|  
|--------------------|--------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*整数の桁*要素のみです。|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|*.*と*小数部の桁*要素。|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s`パラメーターは、指数表記も使用できます。 それ自体では、このフラグは、形式で値をサポートしている*整数の桁*E*桁の指数*以外の追加フラグは、正または負の符号および小数点記号などの要素を含む指数表記で文字列を正しく解析に必要なです。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws*の先頭にある要素`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws*の末尾に要素`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*記号*の先頭にある要素`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*記号*の末尾に要素`s`です。|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*記号*数値の値を囲むかっこの形式での要素。|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|*、*要素。|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|*$*要素。|  
|<xref:System.Globalization.NumberStyles.Currency>|すべて。`s`パラメーターには、16 進数または指数表記の数値を表すことはできません。|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws*先頭または末尾の位置にある要素`s`、*記号*の先頭に`s`、および*.*シンボル。`s`パラメーターは、指数表記も使用できます。|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`、 `sign`、何千もの区切り記号 \(*、\)、*と小数点 \(*.*\) 要素です。|  
|<xref:System.Globalization.NumberStyles.Any>|すべてのスタイルを除く`s`16 進数を表すことはできません。|  
  
 `provider`パラメーターは、<xref:System.IFormatProvider>実装など、<xref:System.Globalization.NumberFormatInfo>または<xref:System.Globalization.CultureInfo>オブジェクト。`provider`パラメーターの解析中に使用されるカルチャに固有の情報を提供します。 場合`provider`は`null`または<xref:System.Globalization.NumberFormatInfo>オブジェクトを取得することはできません、現在のカルチャの書式情報を使用します。  
  
 場合、変換は失敗、`s`パラメーターは`null`または数値値ではなく、`provider`パラメーターを生成しません、<xref:System.Globalization.NumberFormatInfo>オブジェクト、または`style`パラメーターがのビット フラグの組み合わせではありません、<xref:System.Globalization.NumberStyles>列挙します。  
  
 通常、渡した場合、<xref:System.Double.TryParse%2A?displayProperty=fullName>メソッドを呼び出すことによって作成される文字列を<xref:System.Double.ToString%2A?displayProperty=fullName>メソッドは、元の<xref:System.Double>値が返されます。 ただし、精度の損失、ため値可能性がありますいないなります。 さらに、いずれかの文字列形式を解析しよう<xref:System.Double.MinValue>または<xref:System.Double.MaxValue>スロー、 <xref:System.OverflowException>、次の例に示すようにします。  
  
 [!code-csharp[System.Double.TryParse\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 区切り記号が発生した場合、`s`解析操作では、および適用可能な通貨または 10 進数の間にパラメーターと桁区切り記号が同じには、解析操作では、区切り文字が桁区切り記号ではなく、小数点区切り文字である前提としています。 区切り記号の詳細については、次を参照してください。 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>、 <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>、および<xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>です。  
  
   
  
## 例  
 次の例での使用、<xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=fullName>を特定のスタイルがあり、特定のカルチャの規則を使用してフォーマットされている数値の文字列表現を解析します。  
  
 [!code-csharp[System.Double.TryParse\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> が <see cref="T:System.Globalization.NumberStyles" /> 値ではありません。  
  
 \-または\-  
  
 <paramref name="style" /> には値 <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> が含まれています。</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスと指定したオブジェクトまたは <see cref="T:System.Double" /> オブジェクトを比較し、このインスタンスの値が指定したオブジェクトまたは <see cref="T:System.Double" /> オブジェクトの値よりも小さいか、同じか、または大きいかを示す整数を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Double" /> の 2 つのインスタンスが同じ値を表しているかどうかを示す値を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスの数値を、それと等価な文字列形式に変換します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>数値の文字列形式を、等価の倍精度浮動小数点数に変換します。</summary>
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>数値の文字列形式を、等価の倍精度浮動小数点数に変換します。 戻り値は、変換が成功したか失敗したかを示します。</summary>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
  </Members>
</Type>