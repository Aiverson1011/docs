<Type Name="SemanticValue" FullName="System.Speech.Recognition.SemanticValue">
  <TypeSignature Language="C#" Value="public sealed class SemanticValue : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;string,System.Speech.Recognition.SemanticValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit SemanticValue extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.SemanticValue" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("'{_keyName}'= {Value}  -  Children = {_dictionary.Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Speech.Recognition.SemanticValue/SemanticValueDebugDisplay))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>認識された語句のセマンティックの組織を表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Speech.Recognition.SemanticValue> system.speech の違いに意味的なテクノロジを実装する主要なオブジェクトです。 セマンティックの解釈は、文法オーディオ入力を正しく解釈する認識エンジンで使用するための規則を定義できます。 セマンティックの解釈では、認識エンジンのみを返す単語や単語のシーケンスを認識するのではなくより簡単に処理できるように、結果を整理することもできます。  
  
 たとえば、認識エンジンは解析されに使用することが、前に、アプリケーションで解釈する必要があります「赤の背景を変更する」を出力します。 A <xref:System.Speech.Recognition.Grammar> オブジェクトは、セマンティックの解釈というフレーズが 2 つセマンティック サブ構造体を選択するためのバック グラウンドまたはフォア グラウンド \(テキスト"background"によって表される\) \(文字列"red"によって表される\) の色を選択するため、その他のいずれかを指定して明確に処理することを指定できます。  
  
 System.Speech のツリーで認識操作のセマンティクスを表す <xref:System.Speech.Recognition.SemanticValue> オブジェクトです。  
  
 各 <xref:System.Speech.Recognition.SemanticValue> インスタンスには、次が含まれています。  
  
-   <xref:System.Object>, によってアクセスされる、 <xref:System.Speech.Recognition.SemanticValue.Value%2A> のインスタンスのキーに使用する、プロパティ、 <xref:System.Speech.Recognition.SemanticValue>です。  
  
-   によって返されるセマンティック解析の精度のメジャー、 <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> プロパティです。  
  
-   名前\/値ペアのコレクション \(<xref:System.Collections.Generic.KeyValuePair%602>\) も子オブジェクトの <xref:System.Speech.Recognition.SemanticValue> インスタンス。 子ノードはを通してアクセス、 <xref:System.Speech.Recognition.SemanticValue> の実装 <xref:System.Collections.Generic.IDictionary%602> 文字列検索キーを使用して、 <xref:System.Speech.Recognition.SemanticValue> インスタンスは、次の例のようにです。  
  
    ```csharp  
    foreach (KeyValuePair<String, SemanticValue> child in semantics)   
    {  
      Utils.CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
    }  
    ```  
  
 System.Speech に基づいて認識エンジンの有効なインスタンスを提供する <xref:System.Speech.Recognition.SemanticValue> 認識からすべての出力を使用した場合でも語句のない明示的なセマンティック構造体。  
  
 <xref:System.Speech.Recognition.SemanticValue> インスタンス化を使用して、そのフレーズを取得するため、 <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> プロパティを <xref:System.Speech.Recognition.RecognizedPhrase> オブジェクト \(またはから継承されるオブジェクト <xref:System.Speech.Recognition.RecognitionResult>\)。  
  
 <xref:System.Speech.Recognition.SemanticValue> 非セマンティック構造の認識された語句に取得されたオブジェクトが実装されています。  
  
-   子の欠如 \(<xref:System.Speech.Recognition.SemanticValue.Count%2A> は 0\)。  
  
-   <xref:System.Speech.Recognition.SemanticValue.Value%2A> プロパティが `null` です。  
  
-   1.0 の場合は、人為的な意味論的な信頼レベル \(によって返される <xref:System.Speech.Recognition.SemanticValue.Confidence%2A>\)。  
  
 通常、アプリケーションを作成 <xref:System.Speech.Recognition.SemanticValue> に追加することを直接ないインスタンス <xref:System.Speech.Recognition.Grammar> を使用してオブジェクト <xref:System.Speech.Recognition.SemanticResultValue> と <xref:System.Speech.Recognition.SemanticResultKey> と共に内で、インスタンス  <xref:System.Speech.Recognition.Choices> と <xref:System.Speech.Recognition.GrammarBuilder> オブジェクトです。  
  
 構築を直接、 <xref:System.Speech.Recognition.SemanticValue> インスタンスは、厳密に型指定された文法の作成時に便利です。  
  
 <xref:System.Speech.Recognition.SemanticValue> 実装して、 <xref:System.Collections.Generic.IDictionary%602>, 、<xref:System.Collections.Generic.ICollection%601>, 、および <xref:System.Collections.Generic.IEnumerable%601> インターフェイスです。  
  
   
  
## 例  
 次の例では、ハンドラーを <xref:System.Speech.Recognition.Grammar.SpeechRecognized> イベントの前景色と背景色を変更するコマンドを処理するように設計します。  
  
 ハンドラーを検出することによって基になるセマンティック構造を持たない認識された語句を識別する、 <xref:System.Speech.Recognition.SemanticValue.Count%2A> 0 と <xref:System.Speech.Recognition.SemanticValue.Value%2A> の `null`です。 この認識出力は、未加工のテキストを解析して直接が処理されます。  
  
 それ以外の場合に、ハンドラーは、色の名前、または有効なキーが見つからなかったことを示すために、コマンドでは、フォア グラウンドまたはバック グラウンドで変更するかどうかを判断するのにの RGB コンポーネントを入手するのにキーを使用します。  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        // and search for “background” or “foreground” in the input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
  
      // Make sure that text is readable regardless of the background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Speech.Recognition.SemanticValue" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 通常、しては作成されません <xref:System.Speech.Recognition.SemanticValue> オブジェクトを明示的に以外に、厳密に型指定された文法の構築をサポートします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemanticValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.#ctor(System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">格納される情報、 <see cref="T:System.Speech.Recognition.SemanticValue" /> オブジェクトです。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Speech.Recognition.SemanticValue" /> クラスし、意味的な値を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型に制限はありません `value` を格納します。  
  
 アプリケーションで取得できます `value` を使用して、 <xref:System.Speech.Recognition.SemanticValue.Value%2A> プロパティを <xref:System.Speech.Recognition.SemanticValue> インスタンス。  
  
 値、 <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> プロパティを <xref:System.Speech.Recognition.SemanticValue> インスタンスは、\-1 に設定されます。  
  
 A <xref:System.Speech.Recognition.SemanticValue> これを使用して構築メソッドは、キーの名前で参照することはできません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemanticValue (string keyName, object value, float confidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string keyName, object value, float32 confidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.#ctor(System.String,System.Object,System.Single)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="confidence" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="keyName">この接続文字列を使用できるキー <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンス。</param>
        <param name="value">格納される情報を含むオブジェクト、 <see cref="T:System.Speech.Recognition.SemanticValue" /> オブジェクトです。</param>
        <param name="confidence">A <see langword="float" /> セマンティクス分析の確実性の推定値を格納しています。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Speech.Recognition.SemanticValue" /> クラスし、セマンティック値、キー名、および信頼レベルを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型に制限はありません `value` を格納します。  
  
 アプリケーションで取得できます `value` を使用して、 <xref:System.Speech.Recognition.SemanticValue.Value%2A> プロパティを <xref:System.Speech.Recognition.SemanticValue> インスタンス。  
  
 `confidence` パラメーター \(によって返される、 <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> プロパティを <xref:System.Speech.Recognition.SemanticValue> インスタンス\)、0.0 ~ 1.0 でなければなりません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Confidence">
      <MemberSignature Language="C#" Value="public float Confidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 Confidence" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Confidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のインスタンスを返す意味論的な解析の正確性に関して確実性の相対測定値を返す <see cref="T:System.Speech.Recognition.SemanticValue" />します。</summary>
        <value>返します。、 <see langword="float" /> の現在のインスタンスを返す意味論的な解析の確実性の相対測定値は <see cref="T:System.Speech.Recognition.SemanticValue" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Speech.Recognition.SemanticValue.Confidence%2A?displayProperty=fullName> プロパティで、意味的な解析の正確性の測定値が返される必要がありますと混同しないで、 <xref:System.Speech.Recognition.RecognizedPhrase.Confidence%2A?displayProperty=fullName> プロパティで、音声認識の精度のメジャーを返します。  
  
   
  
## 例  
 次の例は、再帰的にスキャンするために使用し、として情報 \(信頼度を含む\) を表示、 <xref:System.Windows.Forms.TreeNodeCollection>, 、またはノードと、そのフレーズを認識する使用のセマンティクスのツリー構造を構成します。  
  
```csharp  
internal static void CreateSemanticsTreeNodes(  
        TreeNodeCollection nodes,  
        SemanticValue semantics,  
        String name)   
{  
  string semanticsText =   
      String.Format("  {0}  (Confidence {1})", name,semantics.Confidence);  
  
  // Format integers as hexadecimal.  
  if (semantics.Value == null )  
  {  
    semanticsText = semanticsText + " = null";  
  }  
  else if (semantics.Value.GetType() == typeof(int))   
  {  
    semanticsText = String.Format("{0} = {1:X} ", semanticsText, semantics.Value);  
  }   
  else   
  {  
    semanticsText = semanticsText + " = " + semantics.Value.ToString();  
  }  
  
  TreeNode semanticsNode = new TreeNode(semanticsText);  
  foreach (KeyValuePair<String, SemanticValue> child in semantics)   
  {  
    CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
  }  
  nodes.Add(semanticsNode);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="item">インスタンス <see cref="T:System.Collections.Generic.KeyValuePair`2" /> キー文字列の指定された値をインスタンス化し、 <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンス。</param>
        <summary>示すかどうか現在 <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンスのコレクションには、特定のキーとの特定のインスタンスが含まれています。 <see cref="T:System.Speech.Recognition.SemanticValue" /> キー\/値ペアとして表されます。</summary>
        <returns>返します。、 <see langword="bool" /> は <see langword="true" /> 場合、現在 <see cref="T:System.Speech.Recognition.SemanticValue" /> のインスタンスが含まれています <c>KeyValuePair&lt;String, SemanticValue&gt;</c> 指定されたキーの文字列の値の、 <see cref="T:System.Speech.Recognition.SemanticValue" />です。 それ以外の場合、 <see langword="false" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.ContainsKey(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.String" /> 子インスタンスを識別するために使用されるキーの文字列を含む <see cref="T:System.Speech.Recognition.SemanticValue" /> 内で、現在 <see cref="T:System.Speech.Recognition.SemanticValue" />します。</param>
        <summary>示すかどうか、現在 <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンスのコレクションには、子が含まれています。 <see cref="T:System.Speech.Recognition.SemanticValue" /> 指定したキーの文字列でのインスタンス。</summary>
        <returns>返します。、 <see langword="bool" />, 、<see langword="true" /> 場合、子インスタンス <see cref="T:System.Speech.Recognition.SemanticValue" /> 文字列でタグ付け <paramref name="key" /> が見つかると、 <see langword="false" /> かどうか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 たとえばを確認するために、実行時にキーの値によってアクセスできるのデータのみ *セマンティック \["myKey"\] です。値*, 、し、例外が生成されます。 オブジェクトをクエリすることをお勧め <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> 使用する前に <xref:System.Speech.Recognition.SemanticValue.Item%2A> の特定のインスタンスで <xref:System.Speech.Recognition.SemanticValue>します。  
  
   
  
## 例  
 次の例では、ハンドラーを <xref:System.Speech.Recognition.Grammar.SpeechRecognized> イベントの前景色と背景色を変更するコマンドを処理するように設計します。  
  
 認識されますが、意味構造を持つ語句を処理が完了したらを使用して適切なキーが存在するかどうかを確認ハンドラー <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> \(`applyChgToBackground`, 、`colorRGBValueList`, 、または `colorStringList)`,  、意味的に編成されたデータを処理します。  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        // searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>子の数を返します <see cref="T:System.Speech.Recognition.SemanticValue" /> 内で、現在のオブジェクト <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンス。</summary>
        <value>子の数 <see cref="T:System.Speech.Recognition.SemanticValue" /> 内で、現在のオブジェクト <see cref="T:System.Speech.Recognition.SemanticValue" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 セマンティックの解析を行わない認識結果を使用して常にある、 <xref:System.Speech.Recognition.SemanticValue.Count%2A> 値の 0 と同様に、 <xref:System.Speech.Recognition.SemanticValue.Value%2A> の `null`です。  
  
   
  
## 例  
 次の例では、ハンドラーを <xref:System.Speech.Recognition.Grammar.SpeechRecognized> イベントの前景色と背景色を変更するコマンドを処理するように設計します。  
  
 ハンドラーを検出することによって基になるセマンティック構造を持たない認識された語句を識別する、 <xref:System.Speech.Recognition.SemanticValue.Count%2A> 0 と <xref:System.Speech.Recognition.SemanticValue.Value%2A> の `null`です。 この認識出力は、未加工のテキストを解析して直接が処理されます。  
  
 それ以外の場合に、ハンドラーは、色の名前、または有効なキーが見つからなかったことを示すために、コマンドでは、フォア グラウンドまたはバック グラウンドで変更するかどうかを判断するのにの RGB コンポーネントを入手するのにキーを使用します。  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        //  searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">評価するオブジェクト。</param>
        <summary>指定したオブジェクトのインスタンスかどうかを判断 <c>SemanticValue</c> し、値の現在のインスタンスに <c>SemanticValue</c>します。</summary>
        <returns>
          <see langword="true" /> 指定したオブジェクトが現在のオブジェクトに等しい場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ハッシュ コードを提供する <c>SemanticValue</c> オブジェクトです。</summary>
        <returns>現在の <see cref="T:System.Speech.Recognition.SemanticValue" /> オブジェクトのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Speech.Recognition.SemanticValue this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Speech.Recognition.SemanticValue Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Item(System.String)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.SemanticValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">キー、 <see langword="KeyValuePair&lt;String, SemanticValue&gt;" /> の現在のインスタンスに含まれている <see cref="T:System.Speech.Recognition.SemanticValue" />します。</param>
        <summary>返します。 子 <see cref="T:System.Speech.Recognition.SemanticValue" /> 現在属しているインスタンス <see cref="T:System.Speech.Recognition.SemanticValue" />します。</summary>
        <value>現在の子を返します <see cref="T:System.Speech.Recognition.SemanticValue" /> キー値のペアの一部としてインデックス処理が可能: <c>KeyValuePair&lt;String,</c><c>SemanticValue&gt;</c>します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Speech.Recognition.SemanticValue.Item%2A> は読み取り専用とメンバーが変更された場合に例外を生成します。  
  
 キーの値を確認する例については、コンパイル時ではなく、実行時にアクセスできるのデータのみ `semantic["myKey"].Value`します。 存在しないキーを指定するには、例外が生成されます。  
  
 指定したキーの存在を検出するために使用して、 <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> プロパティを <xref:System.Speech.Recognition.SemanticValue> インスタンス。  
  
   
  
## 例  
 次の例では、ハンドラーを <xref:System.Speech.Recognition.Grammar.SpeechRecognized> イベントの前景色と背景色を変更するコマンドを処理するように設計します。  
  
 意味構造がない、認識された語句を処理が完了したら、ハンドラーを使用して適切なキーが存在するかどうかを確認 <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> \(`applyChgToBackground`, 、`colorRGBValueList`, 、または `colorStringList)`, 、し、使用して、 <xref:System.Speech.Recognition.SemanticValue.Item%2A> を持つノードを取得するプロパティに他の情報が必要です。  
  
 使用 <xref:System.Speech.Recognition.SemanticValue.Item%2A> 下が強調表示されます。  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        //  searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor =Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor =System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantic keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of the foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">現在のインスタンスの子メンバーを持たない場合にスローされます <see cref="T:System.Speech.Recognition.SemanticValue" /> キーの一致、 <paramref name="key" /> パラメーター。</exception>
        <exception cref="T:System.InvalidOperationException">コードを変更しようとするとスロー、 <see cref="T:System.Speech.Recognition.SemanticValue" /> 指定されたインデックス位置。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue}[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add">
      <MemberSignature Language="C#" Value="void IDictionary&lt;string,SemanticValue&gt;.Add (string key, System.Speech.Recognition.SemanticValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add(string key, class System.Speech.Recognition.SemanticValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Add(System.String,System.Speech.Recognition.SemanticValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;string&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;string,SemanticValue&gt;.Remove (string key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Remove(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;string,SemanticValue&gt;.TryGetValue (string key, out System.Speech.Recognition.SemanticValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue(string key, class System.Speech.Recognition.SemanticValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#TryGetValue(System.String,System.Speech.Recognition.SemanticValue@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;System.Speech.Recognition.SemanticValue&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.Speech.Recognition.SemanticValue&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Speech.Recognition.SemanticValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションを反復処理する列挙子を返します。</summary>
        <returns>コレクションを反復処理する列挙子を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み取り専用プロパティを現在含まれている情報を返す <see cref="T:System.Speech.Recognition.SemanticValue" />します。</summary>
        <value>返します。、 <see cref="T:System.Object" /> に現在格納されている情報を含むインスタンス <see cref="T:System.Speech.Recognition.SemanticValue" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 意味的な解析を行わない認識の結果を使用して常にある、 <xref:System.Speech.Recognition.SemanticValue.Value%2A> の `null` と <xref:System.Speech.Recognition.SemanticValue.Count%2A> 0 のプロパティです。  
  
   
  
## 例  
 次の例は、再帰的にスキャンするために使用し、として情報 \(信頼度を含む\) を表示、 <xref:System.Windows.Forms.TreeNodeCollection>, 、またはノードと、そのフレーズを認識する使用のセマンティクスのツリー構造を構成します。  
  
```csharp  
internal static void CreateSemanticsTreeNodes(  
          TreeNodeCollection nodes,  
          SemanticValue semantics,  
          String name)   
{  
  string semanticsText =   
      String.Format("  {0} ( Confidence {1})", name,semantics.Confidence);  
  
  // Format integers as hexadecimal.  
  if (semantics.Value == null )  
  {  
    semanticsText = semanticsText + " = null";  
  }  
  else if (semantics.Value.GetType() == typeof(int))   
  {  
    semanticsText = String.Format("{0} = {1:X} ", semanticsText, semantics.Value);  
  }  
  else   
  {  
    semanticsText = semanticsText + " = " + semantics.Value.ToString();  
  }  
  
  TreeNode semanticsNode = new TreeNode(semanticsText);  
  foreach (KeyValuePair<String, SemanticValue> child in semantics)   
  {  
    CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
  }  
  nodes.Add(semanticsNode);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>