<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>実行時の動的な動作を指定する基底クラスを提供します。 このクラスは継承される必要があります。直接インスタンス化することはできません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 The **languageKeyword tag is not supported!!!!**  
 class enables you to define which operations can be performed on dynamic objects and how to perform those operations. For example, you can define what happens when you try to get or set an object property, call a method, or perform standard mathematical operations such as addition and multiplication.  
  
 This class can be useful if you want to create a more convenient protocol for a library. For example, if users of your library have to use syntax like `Scriptobj.SetProperty("Count", 1)`, you can provide the ability to use much simpler syntax, like `scriptobj.Count = 1`.  
  
 You cannot directly create an instance of the **languageKeyword tag is not supported!!!!**  
 class. To implement the dynamic behavior, you may want to inherit from the **languageKeyword tag is not supported!!!!**  
 class and override necessary methods. For example, if you need only operations for setting and getting properties, you can override just the <xref:System.Dynamic.DynamicObject.TrySetMember%2A> and <xref:System.Dynamic.DynamicObject.TryGetMember%2A> methods.  
  
 In C\#, to enable dynamic behavior for instances of classes derived from the **languageKeyword tag is not supported!!!!**  
 class, you must use the **languageKeyword tag is not supported!!!!**  
 keyword. For more information, see [Using Type Dynamic \(C\# Programming Guide\)](http://msdn.microsoft.com/ja-jp/3828989d-c967-4a51-b948-857ebc8fdf26).  
  
 In Visual Basic, dynamic operations are supported by late binding. For more information, see [Early and Late Binding](http://msdn.microsoft.com/ja-jp/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
 The following code example demonstrates how to create an instance of a class that is derived from the **languageKeyword tag is not supported!!!!**  
 class.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 You can also add your own members to classes derived from the **languageKeyword tag is not supported!!!!**  
 class. If your class defines properties and also overrides the <xref:System.Dynamic.DynamicObject.TrySetMember%2A> method, the dynamic language runtime \(DLR\) first uses the language binder to look for a static definition of a property in the class. If there is no such property, the DLR calls the <xref:System.Dynamic.DynamicObject.TrySetMember%2A> method.  
  
 The **languageKeyword tag is not supported!!!!**  
 class implements the DLR interface <xref:System.Dynamic.IDynamicMetaObjectProvider>, which enables you to share instances of the **languageKeyword tag is not supported!!!!**  
 class between languages that support the DLR interoperability model. For example, you can create an instance of the **languageKeyword tag is not supported!!!!**  
 class in C\# and then pass it to an IronPython function. For more information, see [Dynamic Language Runtime Overview](http://msdn.microsoft.com/ja-jp/f769a271-8aff-4bea-bfab-6160217ce23d) and documentation on the [CodePlex](http://go.microsoft.com/fwlink/?LinkId=141028) Web site.  
  
> [!NOTE]
>  If you have a simple scenario in which you need an object that can only add and remove members at run time but that does not need to define specific operations and does not have static members, use the <xref:System.Dynamic.ExpandoObject> class.  
>   
>  If you have a more advanced scenario in which you need to define how dynamic objects participate in the interoperability protocol, or you need to manage DLR fast dynamic dispatch caching, create your own implementation of the <xref:System.Dynamic.IDynamicMetaObjectProvider> interface.  
  
   
  
## 例  
 Assume that you want to provide alternative syntax for accessing values in a dictionary, so that instead of writing `sampleDictionary["Text"] = "Sample text"` \(`sampleDictionary("Text") = "Sample text"` in Visual Basic\), you can write `sampleDictionary.Text = "Sample text"`. Also, you want this syntax to be case\-insensitive, so that `sampleDictionary.Text` is equivalent to `sampleDictionary.text`.  
  
 The following code example demonstrates the `DynamicDictionary` class, which is derived from the **languageKeyword tag is not supported!!!!**  
 class. The `DynamicDictionary` class contains an object of the `Dictionary<string, object>` type \(`Dictionary(Of String, Object)` in Visual Basic\) to store the key\-value pairs, and overrides the <xref:System.Dynamic.DynamicObject.TrySetMember%2A> and <xref:System.Dynamic.DynamicObject.TryGetMember%2A> methods to support the new syntax. It also provides a `Count` property, which shows how many dynamic properties the dictionary contains.  
  
 [!code-csharp[System.Dynamic.DynamicObject\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 For more examples, see [Creating Wrappers with DynamicObject](http://go.microsoft.com/fwlink/?LinkId=169008) on the C\# Frequently Asked Questions blog.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>有効に派生した型の新しいインスタンスを初期化するために、 <see cref="T:System.Dynamic.DynamicObject" /> 型です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスを直接作成することはできません、 <xref:System.Dynamic.DynamicObject> クラスです。 動的な動作を実装するのから継承する必要がある、 <xref:System.Dynamic.DynamicObject> クラスし、必要なメソッドをオーバーライドします。  
  
 C\# の場合から派生したクラスのインスタンスの動的な動作を有効にする、 <xref:System.Dynamic.DynamicObject> クラスが使用する必要があります、 `dynamic` キーワードです。 詳細については、「[Using Type Dynamic \(C\# Programming Guide\)](http://msdn.microsoft.com/ja-jp/3828989d-c967-4a51-b948-857ebc8fdf26)」を参照してください。  
  
 Visual Basic の場合は、遅延バインディングによって動的な操作がサポートされます。 詳細については、「[Early and Late Binding](http://msdn.microsoft.com/ja-jp/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)」を参照してください。  
  
   
  
## 例  
 次のコード例から派生したクラスのインスタンスを作成、 <xref:System.Dynamic.DynamicObject> クラスです。  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべての動的メンバー名の列挙を返します。</summary>
        <returns>動的メンバー名を格納しているシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、デバッグにのみ存在します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">表す式 <see cref="T:System.Dynamic.DynamicMetaObject" /> 動的な仮想メソッドにディスパッチします。</param>
        <summary>提供、 <see cref="T:System.Dynamic.DynamicMetaObject" /> 動的な仮想メソッドにディスパッチしています。 中に別のオブジェクトをカプセル化できる <see cref="T:System.Dynamic.DynamicMetaObject" /> を個別のアクションのカスタム動作を提供します。 このメソッドは、言語実装者にとって、動的言語ランタイム インフラストラクチャをサポートし、コードから直接使用するものではありません。</summary>
        <returns>オブジェクト、 <see cref="T:System.Dynamic.DynamicMetaObject" /> 型です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, object result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">二項演算についてを説明します。<c>binder.Operation</c> プロパティを返します。、 <see cref="T:System.Linq.Expressions.ExpressionType" /> オブジェクトです。 たとえば、 <c>sum = first + second</c> ステートメント、 <c>first</c> と <c>second</c> から派生した、 <see langword="DynamicObject" /> クラス、 <c>binder.Operation</c> を返します <c>ExpressionType.Add</c>します。</param>
        <param name="arg">二項演算の右オペランド。 たとえば、 <c>sum = first + second</c> ステートメント、 <c>first</c> と <c>second</c> から派生した、 <see langword="DynamicObject" /> クラス、 <c>arg</c> に等しい <c>second</c>します。</param>
        <param name="result">二項演算の結果です。</param>
        <summary>二項演算の実装を提供します。 派生したクラス、 <see cref="T:System.Dynamic.DynamicObject" /> クラスは、加算や乗算などの操作の動的な動作を指定するには、このメソッドをオーバーライドできます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスは、動的オブジェクトの二項演算を実行する方法を指定するには、このメソッドをオーバーライドできます。 メソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。  
  
 加算や乗算などの二項演算がある場合は、このメソッドが呼び出されます。 たとえば場合、 <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> メソッドがオーバーライドされた場合などのステートメントに対して自動的に呼び出されます `sum = first + second` または `multiply = first*second`, ここで、 `first` から派生した、 `DynamicObject` クラスです。  
  
 二項演算の種類に関する情報を取得するにを使用して、 `Operation` のプロパティ、 `binder` パラメーター。  
  
 C\# および Visual Basic の場合にのみ、動的オブジェクトを使用する場合、 `binder.Operation` から次の値のいずれかのプロパティには、 <xref:System.Linq.Expressions.ExpressionType> 列挙します。 ただし、IronPython や IronRuby などの他の言語では、その他の値を設定できます。 詳細については <xref:System.Linq.Expressions.ExpressionType>, 、ドキュメントを参照して、 [CodePlex](http://go.microsoft.com/fwlink/?LinkId=141028) Web サイトです。  
  
|値|説明|C\#|Visual Basic|  
|-------|--------|---------|------------------|  
|`Add`|数値オペランドに対するオーバーフロー チェックを行わない加算演算します。|`a + b`|`a + b`|  
|`AddAssign`|数値オペランドに対するオーバーフロー チェックを行わない加算複合代入演算します。|`a += b`|サポートされていません。|  
|`And`|ビットごと `AND` 操作します。|`a & b`|`a And b`|  
|`AndAssign`|ビットごと `AND` 複合代入演算します。|`a &= b`|サポートされていません。|  
|`Divide`|算術除算演算します。|`a / b`|`a / b`|  
|`DivideAssign`|算術除算複合代入演算します。|`a /= b`|サポートされていません。|  
|`ExclusiveOr`|ビットごと `XOR` 操作します。|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|ビットごと `XOR` 複合代入演算します。|`a ^= b`|サポートされていません。|  
|`GreaterThan`|「大なり」を比較します。|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|「以上の値を」比較します。|`a >= b`|サポートされていません。|  
|`LeftShift`|ビットごとの左シフト演算します。|`a << b`|`a << b`|  
|`LeftShiftAssign`|ビットごとの左シフト複合代入操作です。|`a <<= b`|サポートされていません。|  
|`LessThan`|「小なり」比較します。|`a < b`|`a < b`|  
|`LessThanOrEqual`|「以下に」を比較します。|`a <= b`|サポートされていません。|  
|`Modulo`|算術剰余演算します。|`a % b`|`a Mod b`|  
|`ModuloAssign`|算術剰余複合代入演算します。|`a %= b`|サポートされていません。|  
|`Multiply`|数値オペランドに対するオーバーフロー チェックを行わない乗算します。|`a * b`|`a * b`|  
|`MultiplyAssign`|数値オペランドに対するオーバーフロー チェックを行わない乗算複合代入演算します。|`a *= b`|サポートされていません。|  
|`NotEqual`|非等価比較します。|`a != b`|`a <> b`|  
|`Or`|論理 or a `OR` 操作します。|`a &#124; b`|`a Or b`|  
|`OrAssign`|論理 or a `OR` 複合代入します。|`a &#124;= b`|サポートされていません。|  
|`Power`|数値の累乗の数学的な操作です。|サポートされていません。|`a ^ b`|  
|`RightShift`|ビットごとの右シフト演算します。|`a >> b`|`a >> b`|  
|`RightShiftAssign`|ビットごとの右シフト複合代入操作です。|`a >>= b`|サポートされていません。|  
|`Subtract`|数値オペランドに対するオーバーフロー チェックを行わない減算します。|`a - b`|`a - b`|  
|`SubtractAssign`|数値オペランドに対するオーバーフロー チェックを行わない減算複合代入演算します。|`a -= b`|サポートされていません。|  
  
> [!NOTE]
>  実装する `OrElse` \(`a || b`\) と `AndAlso` \(`a && b`\) を両方実装することがあります c\# で動的オブジェクトの操作で、 <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> メソッドおよび <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> メソッドです。  
>   
>  `OrElse` 操作では、単項 `IsTrue` 操作と、バイナリ `Or` 操作します。`Or` 場合にのみ操作が実行の結果、 `IsTrue` 操作が `false`です。  
>   
>  `AndAlso` 操作では、単項 `IsFalse` 操作と、バイナリ `And` 操作します。`And` 場合にのみ操作が実行の結果、 `IsFalse` 操作が `false`です。  
  
   
  
## 例  
 数値、テキストと数値表現を格納するデータ構造を作成する必要があり、そのようなデータの加算や減算などの基本的な算術演算を定義することを想定しています。  
  
 次のコード例を示しています、 `DynamicNumber` から派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスです。`DynamicNumber` 上書き、 <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> 数学的な操作を有効にします。 これも上書き、 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> と <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 要素へのアクセスを有効にするメソッドです。  
  
 この例では、唯一の加算と減算操作がサポートされます。 次のステートメントを記述しようとする場合 `resultNumber = firstNumber*secondNumber`, 、実行時例外がスローされます。  
  
 [!code-csharp[System.Dynamic.DynamicObject\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, object result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">変換操作についてを説明します。<c>binder.Type</c> プロパティは、オブジェクトの変換後の型を提供します。 たとえば、ステートメント <c>(String)sampleObject</c> C\# の場合 \(<c>CType(sampleObject, Type)</c> Visual Basic で\) ここで、 <c>sampleObject</c> から派生したクラスのインスタンス、 <see cref="T:System.Dynamic.DynamicObject" /> クラス、 <c>binder.Type</c> を返します、 <see cref="T:System.String" /> 型です。<c>binder.Explicit</c> プロパティが発生する変換の種類に関する情報を提供します。 返す <see langword="true" /> 明示的な変換のおよび <see langword="false" /> 暗黙の変換。</param>
        <param name="result">型変換操作の結果。</param>
        <summary>変換操作の種類の実装を提供します。 派生したクラス、 <see cref="T:System.Dynamic.DynamicObject" /> クラスは、オブジェクトを別の 1 つの型に変換する操作に動的な動作を指定するには、このメソッドをオーバーライドできます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスは、動的オブジェクトの型変換を実行する方法を指定するには、このメソッドをオーバーライドできます。 メソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。  
  
 C\# の場合は、このメソッドがオーバーライドされるは自動的に呼び出されます、明示的または暗黙的な変換をしたときに次のコード例に示すようにします。  
  
 Visual basic で明示的な変換のみがサポートされています。 使用して呼び出すこのメソッドをオーバーライドする場合、 <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> または <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> 関数です。  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## 例  
 数値、テキストと数値表現を格納するデータ構造を作成する必要があり、文字列および整数へのこのデータ構造体の変換を定義することを想定しています。  
  
 次のコード例を示しています、 `DynamicNumber` から派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスです。`DynamicNumber` 上書き、 <xref:System.Dynamic.DynamicObject.TryConvert%2A> 型変換を有効にします。 これも上書き、 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> と <xref:System.Dynamic.DynamicObject.TryGetMember%2A> データ要素へのアクセスを有効にするメソッドです。  
  
 この例では文字列と整数への変換のみがサポートされています。 オブジェクトをその他の型に変換しようとする場合、実行時に例外がスローされます。  
  
 [!code-csharp[System.Dynamic.DynamicObject\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, object result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">初期化操作についてを説明します。</param>
        <param name="args">初期化中に、オブジェクトに渡される引数。 たとえば、 <c>new SampleType(100)</c> 操作、ここで <c>SampleType</c> は型から派生して、 <see cref="T:System.Dynamic.DynamicObject" /> クラス、 <c>args[0]</c> が 100 にします。</param>
        <param name="result">初期化の結果です。</param>
        <summary>動的オブジェクトの新しいインスタンスを初期化する演算の実装を提供します。 このメソッドは、c\# または Visual Basic で使用するものはありません。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 [TryCreateInstance メソッド \(CreateInstanceBinder, Object\<xref:System.Dynamic.DynamicObject> クラスは、動的オブジェクトの新しいインスタンスを初期化する方法を指定するには、このメソッドをオーバーライドできます。 メソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。  
  
 C\# および Visual Basic コンパイラは、ファースト クラスの種類をサポートしていないために、このメソッドを使用するコードを生成しません。 このメソッドはのような構文を使用して動的オブジェクトの初期化をサポートする言語用、 `dynamic new`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">削除に関する情報を提供します。</param>
        <param name="indexes">削除するインデックス。</param>
        <summary>インデックスによってオブジェクトを削除する操作の実装を提供します。 このメソッドは、c\# または Visual Basic で使用するものはありません。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスを指定したインデックスを持つ値の削除方法を指定するには、このメソッドをオーバーライドします。 メソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。  
  
 C\# および Visual Basic コンパイラは、このような操作をサポートしていないため、このメソッドを使用してコードを生成しません。 このメソッドはなどをインデックスでオブジェクトを削除するための構文をサポートする言語用、 `del sampleObject[1,2]` Python でします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">削除に関する情報を提供します。</param>
        <summary>オブジェクトのメンバーを削除する操作の実装を提供します。 このメソッドは、c\# または Visual Basic で使用するものはありません。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスは、オブジェクトのメンバーの削除方法を指定するには、このメソッドをオーバーライドできます。 このメソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。  
  
 C\# および Visual Basic コンパイラは、このような操作をサポートしていないため、このメソッドを使用してコードを生成しません。 このメソッドはなど、メンバーを削除するための構文をサポートする言語用、 `del sampleObject.SampleMember` Python でします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, object result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">操作に関する情報を提供します。</param>
        <param name="indexes">操作で使用されているインデックスです。 たとえば、 <c>sampleObject[3]</c> c\# での操作 \(<c>sampleObject(3)</c> Visual Basic で\)、どこで <c>sampleObject</c> から派生した、 <see langword="DynamicObject" /> クラス、 <c>indexes[0]</c> が 3 に等しい。</param>
        <param name="result">インデックス操作の結果。</param>
        <summary>インデックスによって、値を取得する操作の実装を提供します。 派生したクラス、 <see cref="T:System.Dynamic.DynamicObject" /> クラスは、インデックス操作用の動的な動作を指定するには、このメソッドをオーバーライドできます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、実行時例外がスローされます\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 [TryGetIndex メソッド \(GetIndexBinder, Object\<xref:System.Dynamic.DynamicObject> クラスは、どのインデックスを使って値を取得で実行する動的オブジェクトを指定するには、このメソッドをオーバーライドできます。 メソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、実行時例外がスローされます\)。  
  
 このメソッドがオーバーライドされるは自動的に呼び出されますなどの演算がある場合 `sampleObject[3]` C\# の場合、または `sampleObject(3)` の Visual Basic、where `sampleObject` から派生した、 [TryGetIndex メソッド \(GetIndexBinder, Object\<xref:System.Dynamic.DynamicObject> クラスです。  
  
   
  
## 例  
 前提としています名前でいずれかなど、アクセスのプロパティができるオブジェクトを作成すること `Property0`, 、`Property1`, に、またはインデックスでように、たとえば、 `sampleObject.Property0` と等価 `sampleObject[0]` C\# の場合または `sampleObject(0)` Visual Basic でします。  
  
 次のコード例を示しています、 `SampleDynamicObject` から派生したクラス、 [TryGetIndex メソッド \(GetIndexBinder, Object\<xref:System.Dynamic.DynamicObject> クラスです。`SampleDynamicObject` クラスのオブジェクトを格納する、 `Dictionary<string, object>` 型 \(`Dictionary(Of String, Object)` Visual Basic で\) キーと値のペアを保存します。`SampleDynamicObject` 上書き、 [TryGetIndex メソッド \(GetIndexBinder, Object\<xref:System.Dynamic.DynamicObject.TrySetIndex%2A> と [TryGetIndex メソッド \(GetIndexBinder, Object\<xref:System.Dynamic.DynamicObject.TryGetIndex%2A> インデックスによってアクセスを有効にするメソッドです。 これは、上書き、 [TryGetIndex メソッド \(GetIndexBinder, Object\<xref:System.Dynamic.DynamicObject.TrySetMember%2A> と [TryGetIndex メソッド \(GetIndexBinder, Object\<xref:System.Dynamic.DynamicObject.TryGetMember%2A> プロパティ名でアクセスを有効にするメソッドです。  
  
 [!code-csharp[System.Dynamic.DynamicObject\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, object result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">動的操作を呼び出したオブジェクトに関する情報を提供します。<c>binder.Name</c> プロパティは、動的な操作の実行対象となるメンバーの名前を提供します。 たとえば、 <c>Console.WriteLine(sampleObject.SampleProperty)</c> ステートメント、ここで <c>sampleObject</c> から派生したクラスのインスタンス、 <see cref="T:System.Dynamic.DynamicObject" /> クラス、 <c>binder.Name</c> "SampleProperty"を返します。<c>binder.IgnoreCase</c> プロパティは、メンバー名が大文字小文字を区別するかどうかを指定します。</param>
        <param name="result">取得操作の結果です。 たとえば、プロパティ、メソッドが呼び出された場合は、プロパティの値を割り当てることができます <c>result</c>します。</param>
        <summary>メンバーの値を取得する操作の実装を提供します。 派生したクラス、 <see cref="T:System.Dynamic.DynamicObject" /> クラスは、プロパティの値を取得する場合などの動的な動作を指定するには、このメソッドをオーバーライドできます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、実行時例外がスローされます\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスは、動的オブジェクトのメンバーの値を取得する操作を実行する方法を指定するには、このメソッドをオーバーライドできます。 メソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、実行時例外がスローされます\)。  
  
 などのステートメントがある場合、このメソッドが呼び出されます `Console.WriteLine(sampleObject.SampleProperty)`, ここで、 `sampleObject` から派生したクラスのインスタンス、 <xref:System.Dynamic.DynamicObject> クラスです。  
  
 派生したクラスに、独自のメンバーを追加することも、 `DynamicObject` クラスです。 クラスのプロパティを定義し、も上書き、 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッド、動的言語ランタイム \(DLR\) 最初使用して、言語のバインダーをクラスのプロパティの静的な定義を検索します。 このようなプロパティがない場合は、DLR を呼び出す、 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドです。  
  
   
  
## 例  
 書き込みの代わりに、ディクショナリ内の値にアクセスするための代替構文を提供することを前提としています `sampleDictionary["Text"] = "Sample text"` \(`sampleDictionary("Text") = "Sample text"` Visual Basic で\)、記述する `sampleDictionary.Text = "Sample text"`です。 また、この構文が、大文字にする必要がありますように `sampleDictionary.Text` は `sampleDictionary.text`です。  
  
 次のコード例を示しています、 `DynamicDictionary` から派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスです。`DynamicDictionary` クラスのオブジェクトを格納する、 `Dictionary<string, object>` 型 \(`Dictionary(Of String, Object)` Visual Basic で\) キーと値のペアと上書きを格納する、 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> と <xref:System.Dynamic.DynamicObject.TryGetMember%2A> を新しい構文をサポートするメソッドです。 用意されています、 `Count` 数の動的なプロパティ ディクショナリを示しています。 プロパティが含まれています。  
  
 [!code-csharp[System.Dynamic.DynamicObject\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, object result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">呼び出し操作についてを説明します。</param>
        <param name="args">呼び出し操作中に、オブジェクトに渡される引数。 たとえば、 <c>sampleObject(100)</c> 操作、 <c>sampleObject</c> から派生した、 <see cref="T:System.Dynamic.DynamicObject" /> クラス、 <c>args[0]</c> が 100 にします。</param>
        <param name="result">オブジェクトの呼び出しの結果。</param>
        <summary>オブジェクトを呼び出す操作の実装を提供します。 派生したクラス、 <see cref="T:System.Dynamic.DynamicObject" /> クラスは、オブジェクトまたはデリゲートを呼び出す場合などの動的な動作を指定するには、このメソッドをオーバーライドできます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 [TryInvoke メソッド \(InvokeBinder, Object\<xref:System.Dynamic.DynamicObject> クラスは、動的オブジェクトのオブジェクトを呼び出す操作を実行する方法を指定するには、このメソッドをオーバーライドできます。 メソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、実行時例外がスローされます\)。  
  
 このメソッドがオーバーライドされるは自動的に呼び出されますなどの演算がある場合 `sampleObject(100)`, ここで、 `sampleObject` から派生した、 [TryInvoke メソッド \(InvokeBinder, Object\<xref:System.Dynamic.DynamicObject> クラスです。  
  
 オブジェクトを呼び出すための操作には、Visual Basic ではなく c\# ではサポートされています。 Visual Basic コンパイラは、このメソッドを使用するコードを出力し、Visual Basic 言語はのような構文をサポートしていない `sampleObject(100)`します。  
  
   
  
## 例  
 数値のテキストと数値表現を格納するデータ構造をする必要があると仮定します。 各プロパティの値を個別に指定し、単一のステートメントですべてのプロパティを初期化できるようにできるします。  
  
 次のコード例を示しています、 `DynamicNumber` から派生したクラス、 [TryInvoke メソッド \(InvokeBinder, Object\<xref:System.Dynamic.DynamicObject> クラスです。`DynamicNumber` 上書き、 [TryInvoke メソッド \(InvokeBinder, Object\<xref:System.Dynamic.DynamicObject.TryInvoke%2A> メソッドに一度にすべてのプロパティの初期化を可能にします。 これも上書き、 [TryInvoke メソッド \(InvokeBinder, Object\<xref:System.Dynamic.DynamicObject.TrySetMember%2A> と [TryInvoke メソッド \(InvokeBinder, Object\<xref:System.Dynamic.DynamicObject.TryGetMember%2A> 個々 のオブジェクトのプロパティへのアクセスを有効にするメソッドです。  
  
 [!code-csharp[System.Dynamic.DynamicObject\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, object result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">動的操作についてを説明します。<c>binder.Name</c> プロパティは、動的な操作の実行対象となるメンバーの名前を提供します。 たとえば、ステートメント <c>sampleObject.SampleMethod(100)</c>, ここで、 <c>sampleObject</c> から派生したクラスのインスタンス、 <see cref="T:System.Dynamic.DynamicObject" /> クラス、 <c>binder.Name</c> 「と」が返されます。<c>binder.IgnoreCase</c> プロパティは、メンバー名が大文字小文字を区別するかどうかを指定します。</param>
        <param name="args">呼び出し操作中にオブジェクトのメンバーに渡される引数。 たとえば、ステートメント <c>sampleObject.SampleMethod(100)</c>, ここで、 <c>sampleObject</c> から派生した、 <see cref="T:System.Dynamic.DynamicObject" /> クラス、 <c>args[0]</c> が 100 にします。</param>
        <param name="result">メンバーの呼び出しの結果。</param>
        <summary>メンバーを呼び出す操作の実装を提供します。 派生したクラス、 <see cref="T:System.Dynamic.DynamicObject" /> クラスは、メソッドの呼び出しなどの操作の動的な動作を指定するには、このメソッドをオーバーライドできます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 [TryInvokeMember メソッド \(InvokeMemberBinder, Object\<xref:System.Dynamic.DynamicObject> クラスは、動的オブジェクトのオブジェクト メンバーを呼び出す操作を実行する方法を指定するには、このメソッドをオーバーライドできます。 メソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。  
  
 このメソッドがオーバーライドされるは自動的に呼び出されますのような操作を実行するときに `sampleObject.SampleMethod(100)`, ここで、 `sampleObject` から派生した、 `DynamicObject` クラスです。  
  
 派生したクラスに、独自のメソッドを追加することも、 [TryInvokeMember メソッド \(InvokeMemberBinder, Object\<xref:System.Dynamic.DynamicObject> クラスです。 オーバーライドする場合など、 [TryInvokeMember メソッド \(InvokeMemberBinder, Object\<xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> メソッド、動的ディスパッチ システムまずしようクラスで指定されたメソッドが存在するかどうかを確認します。 メソッドが見つからない場合は、使用、 [TryInvokeMember メソッド \(InvokeMemberBinder, Object\<xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> 実装します。  
  
 この方法がサポートされていません `ref` と `out` パラメーター。 すべてのパラメーター、 `args` 配列が値によって渡されます。  
  
   
  
## 例  
 書き込みの代わりに、ディクショナリ内の値にアクセスするための代替構文を提供することを前提としています `sampleDictionary["Text"] = "Sample text"` \(`sampleDictionary("Text") = "Sample text"` Visual Basic で\)、記述する `sampleDictionary.Text = "Sample text"`です。 また、このディクショナリのすべての標準の辞書メソッドを呼び出すことができるします。  
  
 次のコード例を示しています、 `DynamicDictionary` から派生したクラス、 [TryInvokeMember メソッド \(InvokeMemberBinder, Object\<xref:System.Dynamic.DynamicObject> クラスです。`DynamicDictionary` クラスのオブジェクトを格納する、 `Dictionary<string, object>` 型 \(`Dictionary(Of String, Object)` Visual Basic で\) キーと値のペアを保存します。 も優先、 [TryInvokeMember メソッド \(InvokeMemberBinder, Object\<xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> メソッドのメソッドをサポートするために、 [TryInvokeMember メソッド \(InvokeMemberBinder, Object\<xref:System.Collections.Generic.Dictionary%602> クラスおよびオーバーライド、 [TryInvokeMember メソッド \(InvokeMemberBinder, Object\<xref:System.Dynamic.DynamicObject.TrySetMember%2A> と [TryInvokeMember メソッド \(InvokeMemberBinder, Object\<xref:System.Dynamic.DynamicObject.TryGetMember%2A> を新しい構文をサポートするメソッドです。 用意されています、 `Print` メソッドで、すべてのディクショナリのキーと値を出力します。  
  
 [!code-csharp[System.Dynamic.DynamicObject\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">操作に関する情報を提供します。</param>
        <param name="indexes">操作で使用されているインデックスです。 たとえば、 <c>sampleObject[3] = 10</c> c\# での操作 \(<c>sampleObject(3) = 10</c> Visual Basic で\)、どこで <c>sampleObject</c> から派生した、 <see cref="T:System.Dynamic.DynamicObject" /> クラス、 <c>indexes[0]</c> が 3 に等しい。</param>
        <param name="value">指定したインデックスを持つオブジェクトに設定する値。 たとえば、 <c>sampleObject[3] = 10</c> c\# での操作 \(<c>sampleObject(3) = 10</c> Visual Basic で\)、どこで <c>sampleObject</c> から派生した、 <see cref="T:System.Dynamic.DynamicObject" /> クラス、 <c>value</c> は 10 にします。</param>
        <summary>インデックスによって、値を設定する操作の実装を提供します。 派生したクラス、 <see cref="T:System.Dynamic.DynamicObject" /> クラスは、指定されたインデックスによってオブジェクトにアクセスする操作の動的な動作を指定するには、このメソッドをオーバーライドできます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 [TrySetIndex メソッド \(SetIndexBinder, Object\<xref:System.Dynamic.DynamicObject> クラスは、動的オブジェクトのインデックスによってオブジェクトにアクセスする操作を実行する方法を指定するには、このメソッドをオーバーライドできます。 メソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。  
  
 このメソッドがオーバーライドされるは自動的に呼び出されますなどの演算がある場合 `sampleObject[3] = 10` C\# の場合、または `sampleObject(3) = 10` の Visual Basic、where `sampleObject` から派生した、 [TrySetIndex メソッド \(SetIndexBinder, Object\<xref:System.Dynamic.DynamicObject> クラスです。  
  
   
  
## 例  
 前提としています名前でいずれかなど、アクセスのプロパティができるオブジェクトを作成すること `Property0`, 、`Property1`, に、またはインデックスでように、たとえば、 `sampleObject.Property0` と等価 `sampleObject[0]` C\# の場合または `sampleObject(0)` Visual Basic でします。  
  
 次のコード例を示しています、 `SampleDynamicObject` から派生したクラス、 [TrySetIndex メソッド \(SetIndexBinder, Object\<xref:System.Dynamic.DynamicObject> クラスです。`SampleDynamicObject` クラスのオブジェクトを格納する、 `Dictionary<string, object>` 型 \(`Dictionary(Of String, Object)` Visual Basic で\) キーと値のペアを保存します。`SampleDynamicObject` 上書き、 [TrySetIndex メソッド \(SetIndexBinder, Object\<xref:System.Dynamic.DynamicObject.TrySetIndex%2A> と [TrySetIndex メソッド \(SetIndexBinder, Object\<xref:System.Dynamic.DynamicObject.TryGetIndex%2A> インデックスによってアクセスを有効にするメソッドです。 これは、上書き、 [TrySetIndex メソッド \(SetIndexBinder, Object\<xref:System.Dynamic.DynamicObject.TrySetMember%2A> と [TrySetIndex メソッド \(SetIndexBinder, Object\<xref:System.Dynamic.DynamicObject.TryGetMember%2A> プロパティ名でアクセスを有効にするメソッドです。  
  
 [!code-csharp[System.Dynamic.DynamicObject\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">動的操作を呼び出したオブジェクトに関する情報を提供します。<c>binder.Name</c> プロパティ値が割り当てられているメンバーの名前を提供します。 たとえば、ステートメント <c>sampleObject.SampleProperty = "Test"</c>, ここで、 <c>sampleObject</c> から派生したクラスのインスタンス、 <see cref="T:System.Dynamic.DynamicObject" /> クラス、 <c>binder.Name</c> "SampleProperty"を返します。<c>binder.IgnoreCase</c> プロパティは、メンバー名が大文字小文字を区別するかどうかを指定します。</param>
        <param name="value">メンバーに設定する値。 たとえば、 <c>sampleObject.SampleProperty = "Test"</c>, ここで、 <c>sampleObject</c> から派生したクラスのインスタンス、 <see cref="T:System.Dynamic.DynamicObject" /> クラス、 <c>value</c> は"Test"です。</param>
        <summary>メンバーの値を設定する操作の実装を提供します。 派生したクラス、 <see cref="T:System.Dynamic.DynamicObject" /> クラスは、プロパティの値の設定などの操作の動的な動作を指定するには、このメソッドをオーバーライドできます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスは、動的オブジェクトのメンバーに値を設定する操作を実行する方法を指定するには、このメソッドをオーバーライドできます。 メソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。  
  
 などのステートメントがある場合、このメソッドが呼び出されます `sampleObject.SampleProperty = "Test"`, ここで、 `sampleObject` から派生したクラスのインスタンスには、 <xref:System.Dynamic.DynamicObject> クラスです。  
  
 派生したクラスに、独自のメンバーを追加することも、 `DynamicObject` クラスです。 クラスのプロパティを定義し、も上書き、 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッド、動的言語ランタイム \(DLR\) 最初使用して、言語のバインダーをクラスのプロパティの静的な定義を検索します。 このようなプロパティがない場合は、DLR を呼び出す、 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドです。  
  
   
  
## 例  
 書き込みの代わりに、ディクショナリ内の値にアクセスするための代替構文を提供することを前提としています `sampleDictionary["Text"] = "Sample text"` \(`sampleDictionary("Text") = "Sample text"` Visual Basic で\)、記述する `sampleDictionary.Text = "Sample text"`です。 また、この構文が、大文字にする必要がありますように `sampleDictionary.Text` は `sampleDictionary.text`です。  
  
 次のコード例を示しています、 `DynamicDictionary` から派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスです。`DynamicDictionary` クラスのオブジェクトを格納する、 `Dictionary<string, object>` 型 \(`Dictionary(Of String, Object)` Visual Basic で\) キーと値のペアと上書きを格納する、 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> と <xref:System.Dynamic.DynamicObject.TryGetMember%2A> を新しい構文をサポートするメソッドです。 用意されています、 `Count` 数の動的なプロパティ ディクショナリを示しています。 プロパティが含まれています。  
  
 [!code-csharp[System.Dynamic.DynamicObject\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, object result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">単項演算についてを説明します。<c>binder.Operation</c> プロパティを返します。、 <see cref="T:System.Linq.Expressions.ExpressionType" /> オブジェクトです。 たとえば、 <c>negativeNumber = -number</c> ステートメント、 <c>number</c> から派生した、 <see langword="DynamicObject" /> クラス、 <c>binder.Operation</c> 「正負の反転」を返します。</param>
        <param name="result">単項演算の結果。</param>
        <summary>単項演算の実装を提供します。 派生したクラス、 <see cref="T:System.Dynamic.DynamicObject" /> クラスは、否定、インクリメントなどの操作の動的な動作を指定または減分するには、このメソッドをオーバーライドできます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが戻る場合 <see langword="false" />, 、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスは、動的オブジェクトの単項演算を実行する方法を指定するには、このメソッドをオーバーライドできます。 メソッドがオーバーライドされていない場合、言語の実行時バインダーは、動作を決定します。 \(ほとんどの場合、言語固有の実行時例外がスローされます\)。  
  
 否定、インクリメントなどの単項演算子またはデクリメントしたときに、このメソッドが呼び出されます。 たとえば場合、 <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> メソッドがオーバーライドされてなどのステートメントに対して自動的にこのメソッドが呼び出される `negativeNumber = -number`, ここで、 `number` から派生した、 <xref:System.Dynamic.DynamicObject> クラスです。  
  
 単項演算の種類に関する情報を取得するにを使用して、 `Operation` のプロパティ、 `binder` パラメーター。  
  
 C\# および Visual Basic の場合にのみ、動的オブジェクトを使用する場合、 `binder.Operation` から次の値のいずれかのプロパティには、 <xref:System.Linq.Expressions.ExpressionType> 列挙します。 ただし、IronPython や IronRuby などの他の言語では、その他の値を設定できます。 詳細については <xref:System.Linq.Expressions.ExpressionType>, 、ドキュメントを参照して、 [CodePlex](http://go.microsoft.com/fwlink/?LinkId=141028) Web サイトです。  
  
|値|説明|C\#|Visual Basic|  
|-------|--------|---------|------------------|  
|`Decrement`|単項デクリメント演算します。|`a--`|サポートされていません。|  
|`Increment`|単項インクリメント演算します。|`a++`|サポートされていません。|  
|`Negate`|算術否定。|`-a`|`-a`|  
|`Not`|論理否定。|`!a`|`Not a`|  
|`OnesComplement`|1 の補数です。|`~a`|サポートされていません。|  
|`IsFalse`|False の条件値です。|`a && b`|サポートされていません。|  
|`IsTrue`|条件が真の値です。|`a &#124;&#124; b`|サポートされていません。|  
|`UnaryPlus`|単項プラスします。|`+a`|`+a`|  
  
> [!NOTE]
>  実装する `OrElse` \(`a || b`\) と `AndAlso` \(`a && b`\) を両方実装することがあります c\# で動的オブジェクトの操作で、 <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> メソッドおよび <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> メソッドです。  
>   
>  `OrElse` 操作では、単項 `IsTrue` 操作と、バイナリ `Or` 操作します。`Or` 場合にのみ操作が実行の結果、 `IsTrue` 操作が `false`です。  
>   
>  `AndAlso` 操作では、単項 `IsFalse` 操作と、バイナリ `And` 操作します。`And` 場合にのみ操作が実行の結果、 `IsFalse` 操作が `false`です。  
  
   
  
## 例  
 数値、テキストと数値表現を格納するデータ構造を作成する必要があり、このようなデータ、算術否定演算を定義することを想定しています。  
  
 次のコード例を示しています、 `DynamicNumber` から派生したクラス、 <xref:System.Dynamic.DynamicObject> クラスです。`DynamicNumber` 上書き、 <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> 算術否定演算を有効にします。 オーバーライドではまた、 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> と <xref:System.Dynamic.DynamicObject.TryGetMember%2A> 要素へのアクセスを有効にするメソッドです。  
  
 この例では算術否定演算のみがサポートされています。 ようなステートメントを記述しようとする場合は、 `negativeNumber = +number`, 、実行時例外が発生します。  
  
 [!code-csharp[System.Dynamic.DynamicObject\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>