<Type Name="Page" FullName="System.Web.UI.Page">
  <TypeSignature Language="C#" Value="public class Page : System.Web.UI.TemplateControl, System.Web.IHttpHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Web.UI.TemplateControl implements class System.Web.IHttpHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Page" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.TemplateControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.IHttpHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.WebFormCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.TypeCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Web.WebForms.WebFormDesigner, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("ASPXCodeBehind")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ASP.NET Web アプリケーションのホストであるサーバーから要求される .aspx ファイル \(Web フォーム ページとも呼ばれる\) を表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page> クラスは、拡張子が .aspx ファイルに関連付けられています。 としての実行時にこれらのファイルがコンパイルされた <xref:System.Web.UI.Page> オブジェクトおよびサーバーのメモリにキャッシュします。  
  
 コード ビハインド技法を使用して Web フォーム ページを作成する場合は、このクラスから派生します。 Microsoft Visual Studio などのアプリケーションの迅速な開発 \(RAD\) デザイナーは、Web フォーム ページを作成するのにこのモデルを自動的に使用します。  
  
 <xref:System.Web.UI.Page> オブジェクトは、ページを実装するものを除くすべてのサーバー コントロールの名前付けコンテナーとして機能、 <xref:System.Web.UI.INamingContainer> インターフェイスや、このインターフェイスを実装するコントロールの子コントロールです。  
  
 <xref:System.Web.UI.Page> クラスは、コントロールは、Web アプリケーションのユーザー インターフェイスとして機能し、そのため、行うセキュリティで保護されたコードを記述し、アプリケーションのセキュリティ保護が従ってためにの確実なベスト プラクティスに調査する必要があります。 これらのトピックの概要については、次を参照してください。 [Overview of Web Application Security Threats](http://msdn.microsoft.com/ja-jp/88d61678-f84e-4622-ae80-53128821855a), 、[NIB: セキュリティ ポリシーのベスト プラクティス](http://msdn.microsoft.com/ja-jp/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), 、および [Key Security Concepts](http://msdn.microsoft.com/ja-jp/3cfced4f-ea02-4e66-ae98-d69286363e98)です。 詳細については、次を参照してください。 [Securing Standard Controls](http://msdn.microsoft.com/ja-jp/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), 、[How to: Display Safe Error Messages](http://msdn.microsoft.com/ja-jp/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), 、[How to: Protect Against Script Exploits in a Web Application by Applying HTML Encoding to Strings](http://msdn.microsoft.com/ja-jp/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), 、および [Introduction to the Validation Controls](http://msdn.microsoft.com/ja-jp/3c0e7514-cff2-4bed-936d-ee3f7b740190)です。  
  
   
  
## 例  
 ソース コードの Visual Studio の Web サイト プロジェクトはこのトピック用に使用可能な: [Download](http://go.microsoft.com/fwlink/?LinkId=192425)します。  
  
 次のコード例を示していますが、どのように <xref:System.Web.UI.Page> クラスは、分離コード ページ モデルで使用します。 コードのソース ファイルがページの基本クラスから継承する部分クラスを宣言することに注意してください。 ベース ページ クラスを指定できます <xref:System.Web.UI.Page>, 、または別のクラスから派生したできます <xref:System.Web.UI.Page>します。 さらに、部分クラスは、フィールドのメンバーとして定義する必要はありません\] ページで定義されているコントロールを使用する分離コード ファイルに注意してください。  
  
 [!code-csharp[System.Web.UI.Page\_Overview\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx.cs#2)]
 [!code-vb[System.Web.UI.Page\_Overview\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx.vb#2)]  
  
 次のコード例では、上記のコードのソース ファイルに対応する .aspx ファイルを示します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[System.Web.UI.Page\_Overview\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx#1)]
 [!code-vb[System.Web.UI.Page\_Overview\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx#1)]  
  
 ディレクティブを使用して、使用する必要があります、 `Inherits` と `CodeFile` .aspx ファイルに分離コード ファイルをリンクする属性です。 この例では、 `Inherits` 属性を示します、 `MyCodeBehind` クラスおよび `CodeFile` 属性はクラスを含む言語固有ファイルへのパスを示します。  
  
 次のコード例では、単一ファイル ページ モデルにアクセスする方法、 <xref:System.Web.UI.Page.IsPostBack%2A> プロパティおよび <xref:System.Web.UI.Page.Response%2A> のプロパティ、 <xref:System.Web.UI.Page>です。  
  
 [!code-csharp[System.Web.UI.Page\_Overview2\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/cs/pageexample.aspx#1)]
 [!code-vb[System.Web.UI.Page\_Overview2\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/vb/pageexample.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Page" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定のコンス トラクターでは、すべてのフィールドを既定値を初期化します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddContentTemplate">
      <MemberSignature Language="C#" Value="protected void AddContentTemplate (string templateName, System.Web.UI.ITemplate template);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddContentTemplate(string templateName, class System.Web.UI.ITemplate template) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddContentTemplate(System.String,System.Web.UI.ITemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templateName" Type="System.String" />
        <Parameter Name="template" Type="System.Web.UI.ITemplate" />
      </Parameters>
      <Docs>
        <param name="templateName">追加するコンテンツのテンプレートの名前。</param>
        <param name="template">コンテンツのテンプレート</param>
        <summary>現在のページまたはマスター ページは、マスター ページを参照する場合は、マスター ページに渡される \(コンテンツ コントロール\) からのコンテンツのコレクションを作成するページの初期化中に呼び出されます。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">同じ名前を含むテンプレートが既に存在します。</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
      </Parameters>
      <Docs>
        <param name="beginHandler">デリゲート、 <see cref="T:System.Web.BeginEventHandler" /> メソッドです。</param>
        <param name="endHandler">デリゲート、 <see cref="T:System.Web.EndEventHandler" /> メソッドです。</param>
        <summary>非同期ページの状態情報を必要としない最初と最後のイベント ハンドラー デリゲートを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> 非同期 Web ページにハンドラーを追加します。  
  
 複数の非同期ハンドラーを登録します。ただし、一度に 1 つだけのハンドラーを実行します。 同時に複数の非同期メソッドを処理する場合、1 つを使用する必要があります <xref:System.Web.BeginEventHandler> メソッドとそのハンドラーから複数の非同期操作を起動します。  
  
 間で非同期のハンドラーが呼び出された、 <xref:System.Web.UI.Control.PreRender> と <xref:System.Web.UI.Page.PreRenderComplete> イベントです。  
  
 1 つは、すべて <xref:System.Web.UI.Page> イベント \(を通じて、 <xref:System.Web.UI.Control.PreRender> イベント\) は実行し、各登録 <xref:System.Web.BeginEventHandler> メソッドが呼び出されます。 ハンドラーが完了したとき、対応する <xref:System.Web.EndEventHandler> メソッドが呼び出されます。 複数の非同期ハンドラーがある場合は、次のハンドラーが呼び出されます。  
  
 登録済みの非同期イベント ハンドラーが呼び出された後、残りのページ イベントが呼び出された以降で、 <xref:System.Web.UI.Page.PreRenderComplete> イベントです。  
  
   
  
## 例  
 次のコード例で、ローカル Web サーバーの既定のページの HTML ソース コードを表示する非同期要求を使用して、 <xref:System.Web.UI.WebControls.TextBox> コントロールです。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[PageAddOnPreRenderCompleteAsync\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-vb[PageAddOnPreRenderCompleteAsync\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="&lt;async&gt;" /> Page ディレクティブに設定されていない <see langword="true" />します。  
  
 または  
  
 <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> メソッドは、 <see cref="E:System.Web.UI.Control.PreRender" /> イベントです。</exception>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> または <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginHandler">デリゲート、 <see cref="T:System.Web.BeginEventHandler" /> メソッドです。</param>
        <param name="endHandler">デリゲート、 <see cref="T:System.Web.EndEventHandler" /> メソッドです。</param>
        <param name="state">イベント ハンドラーの状態情報を格納するオブジェクト。</param>
        <summary>開始と終了時刻、非同期ページのイベント ハンドラー デリゲートを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> メソッドを非同期の Web ページに状態情報を必要とするハンドラーを追加します。 渡される、オブジェクト、 `state` パラメーターで指定されたイベント ハンドラー デリゲートの間で情報を転送するアプリケーションに必要な任意のオブジェクトを指定できます、 `beginHandler` と `endHandler` パラメーター。  
  
 複数の非同期ハンドラーを登録します。ただし、一度に 1 つだけのハンドラーを実行します。 同時に複数の非同期メソッドを処理する場合、1 つを使用する必要があります <xref:System.Web.BeginEventHandler> メソッドとそのハンドラーから複数の非同期操作を起動します。  
  
 間で非同期のハンドラーが呼び出された、 <xref:System.Web.UI.Control.PreRender> と <xref:System.Web.UI.Page.PreRenderComplete> イベントです。  
  
 1 つは、すべて <xref:System.Web.UI.Page> イベント \(を通じて、 <xref:System.Web.UI.Control.PreRender> イベント\) は実行し、各登録 <xref:System.Web.BeginEventHandler> メソッドが呼び出されます。 ハンドラーが完了したとき、対応する <xref:System.Web.EndEventHandler> メソッドが呼び出されます。 複数の非同期ハンドラーがある場合は、次のハンドラーが呼び出されます。  
  
 登録済みの非同期イベント ハンドラーが呼び出された後、残りのページ イベントが呼び出された以降で、 <xref:System.Web.UI.Page.PreRenderComplete> イベントです。  
  
   
  
## 例  
 次のコード例で、ローカル Web サーバーの既定のページの HTML ソース コードを表示する非同期要求を使用して、 <xref:System.Web.UI.WebControls.TextBox> コントロールです。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[PageAddOnPreRenderCompleteAsync\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-vb[PageAddOnPreRenderCompleteAsync\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="&lt;async&gt;" /> Page ディレクティブに設定されていない <see langword="true" />します。  
  
 または  
  
 <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> メソッドは、 <see cref="E:System.Web.UI.Control.PreRender" /> イベントです。</exception>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> または <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected void AddWrappedFileDependencies (object virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddWrappedFileDependencies(object virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddWrappedFileDependencies(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">
          <see cref="T:System.Object" /> ファイル名の一覧を格納しています。</param>
        <summary>現在のページを構成する依存ファイルの一覧に追加します。 このメソッドは、ASP.NET ページ フレームワークによって内部的に使用し、コードから直接使用するものではありません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.AddWrappedFileDependencies%2A> メソッドは、現在のページを構成するユーザー コントロール ファイルなどのファイルの一覧を追加します。 これらのページのいずれかを変更する場合、ページ全体には、要求時に、次はコンパイルされます。 このメソッドは、.NET Framework インフラストラクチャをサポートします。独自に作成したコードから直接使用するためのものではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Web.HttpApplicationState" /> Web 要求を現在のオブジェクト。</summary>
        <value>現在のデータを <see cref="T:System.Web.HttpApplicationState" /> クラスです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 [!code-csharp[Page.Application\_Sample1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Application_Sample1/CS/applicationcs.aspx#1)]
 [!code-vb[Page.Application\_Sample1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Application_Sample1/VB/applicationvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpApplicationState" />
      </Docs>
    </Member>
    <Member MemberName="AspCompatBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AspCompatBeginProcessRequest (System.Web.HttpContext context, AsyncCallback cb, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AspCompatBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback cb, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="cb" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> 現在の要求に関する情報を使用します。</param>
        <param name="cb">コールバック メソッド。</param>
        <param name="extraData">ASP 要求と同じ方法で要求を処理するために必要な追加データ。</param>
        <summary>Active Server Page \(ASP\) のリソースに対する要求を開始します。 このメソッドは、従来の ASP アプリケーションとの互換性を提供します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AspCompatEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AspCompatEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatEndProcessRequest(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">ASP ページは、要求が生成します。</param>
        <summary>Active Server Page \(ASP\) のリソースに対する要求を終了します。 このメソッドは、従来の ASP アプリケーションとの互換性を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatMode">
      <MemberSignature Language="C#" Value="protected bool AspCompatMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AspCompatMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AspCompatMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページをシングル スレッド アパートメント \(STA\) スレッドで実行できるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> ページは、Active Server Pages \(ASP\) のコードをサポートしている場合それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定すると `true`, 、このプロパティは、シングル スレッド アパートメント \(STA\) スレッドで実行するページを使用します。 これにより、ページから Visual Basic 6.0 で開発されたコンポーネントなどの STA コンポーネントを呼び出すことができます。 このプロパティを設定 `true` ページから、そのアンマネージ ASP 組み込みオブジェクトへのアクセスを必要とする COM \+ コンポーネントを呼び出すことができます。 これらは、ASP からアクセスできる `ObjectContext` オブジェクト、または `OnStartPage` メソッドです。  
  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `aspcompat` 属性を `true` .aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncMode">
      <MemberSignature Language="C#" Value="protected bool AsyncMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページが同期的または非同期的に処理されるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> ページが非同期的に処理される場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.AsyncMode%2A> プロパティで設定されて、 <xref:System.Web.UI.Page> パーサー ページのコードが生成されるとします。 使用して、 `Async` この値を設定するディレクティブ内の属性です。  
  
 非同期ページがうまくできない場合に、 `AspCompat` に属性が設定されている `true` または `Transaction` 属性が以外の値に設定されて `Disabled` ディレクティブにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AsyncPageBeginProcessRequest (System.Web.HttpContext context, AsyncCallback callback, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AsyncPageBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback callback, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> 要求します。</param>
        <param name="callback">プロセスが完了するときに通知するコールバック メソッド。</param>
        <param name="extraData">非同期のメソッドの状態データ。</param>
        <summary>非同期ページ要求の処理を開始します。</summary>
        <returns>非同期の要求を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AsyncPageEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AsyncPageEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageEndProcessRequest(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> 保留中の非同期要求を参照します。</param>
        <summary>非同期のページ要求の処理を終了します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan AsyncTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AsyncTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または非同期タスクを処理するときに使用されたタイムアウト期間を示す値を設定します。</summary>
        <value>A <see cref="T:System.TimeSpan" /> の非同期タスクの完了を許可された時間間隔を含みます。 既定の時間間隔は、45 秒です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ページの非同期のタイムアウトでは、非同期タスクを実行するページが待機する時間の時間を示します。 ほとんどの状況では、コードでこのプロパティを設定しないでください。 ページ非同期のタイムアウト間隔を使用して、設定、または Web 構成ファイルのディレクティブにします。 ページ ディレクティブでは、ページの \[構成\] セクションで設定された値が上書きされます。  
  
 使用して、非同期タスクを定義する、 <xref:System.Web.UI.PageAsyncTask> クラスし、開始、終了、およびタイムアウト ハンドラーを登録します。 指定された時間間隔で、非同期タスクが完了しない場合、タイムアウト ハンドラーは呼び出されます。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.Page.AsyncTimeout%2A> プロパティを <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> と <xref:System.Web.UI.Page.RegisterAsyncTask%2A> メソッドです。 開始、終了、およびタイムアウト ハンドラーの使用に注意してください。 指定されているタスクに割り当てられた時間を超える、非同期タスクの状況を示す例では、人為的な遅延が導入された、 <xref:System.Web.UI.Page.AsyncTimeout%2A> プロパティです。 実際のシナリオで非同期タスクは、データベースの呼び出しまたはイメージの生成を実行するために使用でしたやなどのタイムアウト ハンドラーは、一定の期間でタスクを実行していない場合に正常なパフォーマンス低下を提供します。 なお、 <xref:System.Web.UI.Page.AsyncTimeout%2A> プロパティは、page ディレクティブで設定します。  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このプロパティは、負の値に設定されました。</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="AutoPostBackControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control AutoPostBackControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control AutoPostBackControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AutoPostBackControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはコントロールをポストバックの実行に使用されるページに設定します。</summary>
        <value>ポストバックの実行に使用されるコントロール。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ出力がバッファリングされるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> ページ出力がバッファリングされる場合それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 <xref:System.Web.UI.Page.Buffer%2A> 属性を `true` .aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.Buffer%2A> プロパティを設定および取得、 <xref:System.Web.HttpResponse.BufferOutput%2A> プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Web.Caching.Cache" /> ページが存在するアプリケーションに関連付けられているオブジェクト。</summary>
        <value>
          <see cref="T:System.Web.Caching.Cache" /> ページのアプリケーションに関連付けられています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アプリケーションの <xref:System.Web.Caching.Cache> オブジェクトでは、後続する要求の任意のデータ格納および取得することができます。 キャッシュは、具体的には、ページまたはユーザーのセッションに関連付けがないです。 アプリケーションのパフォーマンスを強化するには、主に使用されます。 詳細については、「[Caching Application Data](http://msdn.microsoft.com/ja-jp/206f977d-7860-4d20-bdd5-c3b3d8479f3d)」を参照してください。 アプリケーションのキャッシュとページ出力キャッシュの違いの詳細については、次を参照してください。 [Introduction to Caching in ASP.NET](http://msdn.microsoft.com/ja-jp/5ec28012-4972-4dc3-b3e8-9d20401fe11d)します。  
  
   
  
## 例  
 次のコード例に 2 つの整数の合計の挿入、 <xref:System.Web.Caching.Cache?displayProperty=fullName> オブジェクトを使用して、 <xref:System.Web.UI.Page.Cache%2A?displayProperty=fullName> プロパティです。 さらを使用して値を取得、 <xref:System.Web.Caching.Cache.Get%2A?displayProperty=fullName> メソッドに書き込むと、 <xref:System.Web.UI.WebControls.Label> Web サーバー コントロール。  
  
 [!code-csharp[System.Web.Page.Cache\_Replacement\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/CS/pagecachecs.aspx#1)]
 [!code-vb[System.Web.Page.Cache\_Replacement\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/VB/pagecachevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">インスタンス <see cref="T:System.Web.Caching.Cache" /> は作成されません。</exception>
        <altmember cref="T:System.Web.Caching.Cache" />
      </Docs>
    </Member>
    <Member MemberName="ClientQueryString">
      <MemberSignature Language="C#" Value="public string ClientQueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientQueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientQueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求された URL のクエリ文字列の部分を取得します。</summary>
        <value>要求された URL のクエリ文字列部分。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.ClientQueryString%2A> プロパティには、ブラウザーによって要求された URL のクエリ文字列の部分が含まれています。 たとえば、要求された URL は"http:\/\/www.contoso.com\/default.aspx?id\=100"、 <xref:System.Web.UI.Page.ClientQueryString%2A> プロパティが格納されます"id \= 100" です。<xref:System.Web.UI.Page.ClientQueryString%2A> プロパティがエンコードされます。 を使用して、 <xref:System.Web.HttpServerUtility.UrlDecode%2A?displayProperty=fullName> メソッドをクエリ文字列をデコードします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.ClientScriptManager ClientScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ClientScriptManager ClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientScriptManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Web.UI.ClientScriptManager" /> 管理、登録、およびページにスクリプトを追加するために使用します。</summary>
        <value>
          <see cref="T:System.Web.UI.ClientScriptManager" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Page.ClientScript%2A> を取得するプロパティ、 <xref:System.Web.UI.ClientScriptManager> 管理、登録、およびスクリプトを Web ページに追加するために使用できるオブジェクト。 詳細については、<xref:System.Web.UI.ClientScriptManager> クラスを参照してください。  
  
 <xref:System.Web.UI.ClientScriptManager> クラスは新機能で [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] 置き換えます <xref:System.Web.UI.Page> クラスが廃止されるスクリプトを管理するためのメソッドです。  
  
   
  
## 例  
 例については、次を参照してください。、 <xref:System.Web.UI.ClientScriptManager> クラスの概要に関するトピック。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="ClientTarget">
      <MemberSignature Language="C#" Value="public string ClientTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientTarget" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはによりブラウザーの機能の自動検出をオーバーライドして、特定のブラウザー クライアント用のページのレンダリング方法を指定する値を設定します。</summary>
        <value>A <see cref="T:System.String" /> をオーバーライドするブラウザーの機能を指定します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定しない場合、 <xref:System.Web.UI.Page.ClientTarget%2A> プロパティには、 <xref:System.Web.HttpBrowserCapabilities> オブジェクトに関連付けられている、 <xref:System.Web.UI.Page.Request%2A?displayProperty=fullName> プロパティには、クライアント ブラウザーの機能が反映されます。 このプロパティを設定する場合は、クライアント ブラウザーの検出が無効になり、ページは、指定した値 \(エイリアス\) に関連付けられているブラウザーの機能を使用します。  
  
 Web サーバー コンピューター上のルート Web.config 構成ファイルには、一般的なユーザー エージェント文字列の代わりに使用できる次の既定のエイリアスを定義します。  
  
-   `uplevel`, 、Internet Explorer 6.0 と同じブラウザーの機能を指定します。  
  
-   `downlevel`, 、クライアント スクリプトをサポートしない古いブラウザーと同等のブラウザーの機能を指定します。 このエイリアスを使用すると、クライアント スクリプトが無効になっているブラウザーで Web ページがどのように作用するかを決定します。  
  
 このプロパティを使用してプログラムで別名を設定することも宣言的に使用するように設定、 `ClientTarget` ディレクティブの属性です。  
  
 その他のエイリアスを定義する、 `clientTarget` アプリケーション レベルの Web.config ファイルのセクションです。 詳細については、次を参照してください。 [clientTarget 要素 \(ASP.NET 設定スキーマ\)](http://msdn.microsoft.com/ja-jp/17a0fa6e-a065-49cc-b900-ef73eda6a922)します。  
  
   
  
## 例  
 次のコード例で定義、 `ie302` エイリアスと、Web.config ファイルでアプリケーションを構成するために必要なセクションが含まれています。 このエイリアスを使用することができます設定、 <xref:System.Web.UI.Page.ClientTarget%2A> プロパティを `ie302` インターネット エクスプ ローラー 3.02 ブラウザー専用のページをカスタマイズします。  
  
```  
<configuration>  
  <system.web>  
   <clientTarget>  
    <add alias="ie302" useragent="Mozilla/2.0 (compatible; MSIE 3.02; Windows NT 3.5)" />  
   </clientTarget>  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public int CodePage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のコード ページ id を設定 <see cref="T:System.Web.UI.Page" />します。</summary>
        <value>現在のコード ページ id を表す整数 <see cref="T:System.Web.UI.Page" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `CodePage` 属性を .aspx ファイルで、ディレクティブを使用する値にします。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP MIME タイプを設定、 <see cref="T:System.Web.HttpResponse" /> ページに関連付けられているオブジェクト。</summary>
        <value>現在のページに関連付けられている HTTP MIME タイプ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `ContentType` 属性の .aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected override System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Web.HttpContext" /> ページに関連付けられているオブジェクト。</summary>
        <value>
          <see cref="T:System.Web.HttpContext" /> 、現在のページに関連付けられている情報を含むオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、要求、応答、セッション、およびアプリケーションに関する情報を含む、ページが実行されるコンテキストにプログラムでアクセスを提供します。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.UI.Page.Context%2A> にアクセスするプロパティ、 <xref:System.Web.HttpContext.AddError%2A?displayProperty=fullName> と <xref:System.Web.HttpContext.ClearError%2A?displayProperty=fullName> メソッドおよび <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=fullName> プロパティです。 例を使用して次の 3 つのカスタム例外を作成し、 <xref:System.Web.HttpContext.AddError%2A> メソッドを使用して、 <xref:System.Web.HttpContext.AllErrors%2A> を配列にこれらの例外を読み込むプロパティをします。 次に、配列を含むページに書き込み、を使用して、 <xref:System.Web.HttpContext.ClearError%2A> からのすべてのエラーを消去する方法、 <xref:System.Web.UI.Page.Context%2A> プロパティです。  
  
 [!code-csharp[System.Web.UI.Page.Context\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Context/CS/pagecontextcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Context\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Context/VB/pagecontextvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.HtmlTextWriter CreateHtmlTextWriter (System.IO.TextWriter tw);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Web.UI.HtmlTextWriter CreateHtmlTextWriter(class System.IO.TextWriter tw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="tw">
          <see cref="T:System.IO.TextWriter" /> を作成するために使用する <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>作成、 <see cref="T:System.Web.UI.HtmlTextWriter" /> 、ページのコンテンツをレンダリングするオブジェクト。</summary>
        <returns>
          <see cref="T:System.Web.UI.HtmlTextWriter" /> または <see cref="T:System.Web.UI.Html32TextWriter" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> メソッドは、作成、 <xref:System.IO.TextWriter> を通じて、 <xref:System.Web.HttpRequest.Browser%2A> のプロパティ、 <xref:System.Web.HttpContext.Request%2A> ページ要求に関連付けられているオブジェクト。 参照を追加する、 <xref:System.Web.UI.HtmlTextWriter> で、 `browserCaps` 構成セクション。 オーバーライド、 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> カスタム検索を実行するメソッドです。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> 、カスタムのインスタンスを作成する方法 <xref:System.Web.UI.HtmlTextWriter> という名前のオブジェクト `MyHtmlTextWriter`します。<xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> でメソッドがオーバーライドされる、 `MyPage` から派生したクラス <xref:System.Web.UI.Page>, 、ように `MyHtmlTextWriter` ページが要求されたときに、ASP.NET サーバー コントロールをレンダリングします。 この例はアダプターしないようにすることに注意してください <xref:System.IO.TextWriter> 動作します。  
  
 [!code-csharp[Page\_CreateHtmlTextWriter\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/CS/page_createhtmltextwriter.cs#2)]
 [!code-vb[Page\_CreateHtmlTextWriter\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/VB/page_createhtmltextwriter.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Html32TextWriter" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriterFromType">
      <MemberSignature Language="C#" Value="public static System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType (System.IO.TextWriter tw, Type writerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType(class System.IO.TextWriter tw, class System.Type writerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
        <Parameter Name="writerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tw">
          <see cref="T:System.IO.TextWriter" /> を作成するために使用する <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <param name="writerType">作成するテキスト ライターの型。</param>
        <summary>指定された作成 <see cref="T:System.Web.UI.HtmlTextWriter" /> 、ページのコンテンツをレンダリングするオブジェクト。</summary>
        <returns>
          <see cref="T:System.Web.UI.HtmlTextWriter" /> ページのコンテンツを表示します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、ページ アダプターで内部的に使用されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="writerType" /> パラメーターが無効な型に設定します。</exception>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public string Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Culture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カルチャ ID を設定、 <see cref="T:System.Threading.Thread" /> ページに関連付けられているオブジェクト。</summary>
        <value>有効なカルチャ id。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定、 `Culture` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されたときに、動的に生成されたクラスは、このプロパティの値を設定します。 値を明示的に設定するさらに、 <xref:System.Web.UI.Page.Culture%2A> プロパティ プログラムを使用しても、要素、web.config ファイルのファイルです。  
  
 <xref:System.Web.UI.Page.Culture%2A> プロパティは、ページの内容をローカライズするために使用します。 任意の有効なカルチャ ID を設定することができます。 たとえば、 `en-us` カルチャ ID では、アメリカ英語、中にページを設定、 `fr` カルチャ ID では、フランス語にページを設定します。 値を設定することもできます。 `auto` の優先言語と設定は、ブラウザーの自動検出を実行します。 自動言語検出をなど、既定値で修飾できます `auto:en-us`します。  
  
 詳細については、次を参照してください。、 <xref:System.Globalization.CultureInfo> クラスの概要です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
      </Docs>
    </Member>
    <Member MemberName="DesignerInitialize">
      <MemberSignature Language="C#" Value="public void DesignerInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DesignerInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DesignerInitialize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>インスタンスの初期化を実行、 <see cref="T:System.Web.UI.Page" /> RAD デザイナーに必要なクラスです。 このメソッドは、デザイン時にのみ使用されます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.UserControl.DesignerInitialize" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackMode">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Specialized.NameValueCollection DeterminePostBackMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します。、 <see cref="T:System.Collections.Specialized.NameValueCollection" /> POST または GET コマンドを使用して、ページにポストバックされるデータ。</summary>
        <returns>A <see cref="T:System.Collections.Specialized.NameValueCollection" /> フォーム データを含むオブジェクト。 フォームの情報が返される、ポストバックが POST コマンドを使用する場合、 <see cref="P:System.Web.UI.Page.Context" /> オブジェクトです。 ポストバックでは、GET コマンドを使用する場合は、クエリ文字列の情報が返されます。 最初のページが要求されている場合は、 <see langword="null" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.DeterminePostBackMode%2A> メソッドが返される、 <xref:System.Collections.Specialized.NameValueCollection> ページにポストバックされるデータを格納しているオブジェクト。 ページの存在は、VIEWSTATE および EVENTTARGET がポストバック イベントが発生したかどうかを決定するために使用されるフィールドを非表示です。<xref:System.Web.UI.Page.IsPostBack%2A> 場合、プロパティが設定、 <xref:System.Web.UI.Page.DeterminePostBackMode%2A> メソッドが呼び出されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackModeUnvalidated">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackModeUnvalidated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要求で ASP.NET 要求の検証を実行しなくても、POST または GET コマンドのいずれかを使用してページが投稿されたデータの名前と値のコレクションを返します。</summary>
        <returns>検証されていないフォーム データを格納するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 詳細については、<xref:System.Web.UnvalidatedRequestValues> クラスを参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableEventValidation">
      <MemberSignature Language="C#" Value="public virtual bool EnableEventValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableEventValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableEventValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページがポストバックおよびコールバック イベントを検証するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> ページがポストバックおよびコールバック イベントを検証する場合それ以外の場合、 <see langword="false" />です。既定値は <see langword="true" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Web.UI.Page.EnableEventValidation%2A> にプロパティが設定されている `true`, 、ASP.NET では、そのコントロールのイベントがそのコントロールによって表示されたユーザー インターフェイスから送信されたことを検証します。 コントロールでは、レンダリング時にイベントを登録し、ポストバックまたはコールバックの処理中にイベントを検証します。 たとえば、リスト コントロールには、ページがレンダリングされると、ポストバック要求が受信した場合は、4 のオプション番号を指定する場合は、1、2、または 3 を示す番号付きのオプションが含まれている場合、ASP.NET には、例外が発生します。 ASP.NET イベントにより実行されるすべてのコントロールは、既定では、この機能を使用します。  
  
 実行時に、クライアントのコントロールを変更するクライアント スクリプトを記述する場合は、使用する必要があります、 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> false イベント検証エラーを回避するためにメソッドです。  
  
> [!IMPORTANT]
>  この機能は、ポストバック要求が承認されていない、または悪意のあるやコールバックのリスクを軽減します。 イベントの検証を無効にしないことを強くお勧めします。  
  
 設定する、 <xref:System.Web.UI.Page.EnableEventValidation%2A> プロパティを設定して、 `enableEventValidation` ディレクティブの属性または `enableEventValidation` Web.config ファイル内の要素の属性です。 コードでこのプロパティを設定した場合、ページが初期化される前に設定する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.EnableEventValidation" /> ページの初期化後にプロパティが設定されました。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
        <altmember cref="T:System.Web.UI.SupportsEventValidationAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public override bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定ページの表示状態を維持して、任意のサーバーのビュー ステートを制御してかどうかを示す値が含まれている現在のページ要求が終了するとします。</summary>
        <value>
          <see langword="true" /> ページ ビュー状態を保持する場合それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ビュー ステートを無効にする理由については、次を参照してください。 <xref:System.Web.UI.Control.EnableViewState%2A?displayProperty=fullName>します。  
  
 たとえ <xref:System.Web.UI.Page.EnableViewState%2A> は `false`, 、ページがポストバックを検出するために ASP.NET で使用される非表示のビュー ステート フィールドを含む可能性があります。  
  
   
  
## 例  
 次のコード例、 <xref:System.Web.UI.Page.EnableViewState%2A> プロパティを `false` ページが読み込まれるときにします。 ビュー ステートが無効になります、 <xref:System.Web.UI.Page> オブジェクト、ページのビュー ステート情報も、ページに含まれるすべてのコントロールが保存されたことを意味します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Page\_EnableViewState\_ReSubmit\_1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/CS/page_enableviewstate.cs#1)]
 [!code-vb[Page\_EnableViewState\_ReSubmit\_1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/VB/page_enableviewstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewStateMac" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewStateMac">
      <MemberSignature Language="C#" Value="public bool EnableViewStateMac { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewStateMac" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewStateMac" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または、クライアントからページがポストされたときに、ページのビュー ステートのメッセージ認証コード \(MAC\) をチェックするかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> ビュー ステートの MAC がチェックされ、エンコードされている必要がある場合それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ビュー ステート MAC は、ページがブラウザーに送信されるときに、ページのビュー ステートが保存されている非表示変数の暗号化されたバージョンです。 このプロパティに設定すると `true`, 、暗号化されたビュー ステートがオンになっていることが改ざんされていないクライアントのことを確認します。  
  
 コードでは、このプロパティを設定しないでください。 設定、 `EnableViewStateMac` 属性の .aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
> [!IMPORTANT]
>  この属性設定しないで `false` 、運用 Web サイトで、アプリケーションまたはページがビュー ステートを使用していない場合でも。 MAC は、ビュー ステートは、ビュー ステートに加えその他の ASP.NET 機能のセキュリティを確保します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewState" />
      </Docs>
    </Member>
    <Member MemberName="ErrorPage">
      <MemberSignature Language="C#" Value="public string ErrorPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ErrorPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページのハンドルされない例外が発生した場合、要求元ブラウザーのリダイレクト先のエラー ページを設定します。</summary>
        <value>ブラウザーがリダイレクトされるページ エラーです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 [!code-csharp[Page\_ErrorPage\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_ErrorPage/CS/page_errorpage.cs.aspx#1)]
 [!code-vb[Page\_ErrorPage\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_ErrorPage/VB/page_errorpage.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteRegisteredAsyncTasks">
      <MemberSignature Language="C#" Value="public void ExecuteRegisteredAsyncTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteRegisteredAsyncTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>非同期タスクの実行を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、非同期タスクを定義する、 <xref:System.Web.UI.PageAsyncTask> クラスです。 タスクが定義され、ページを使用して登録した後、 <xref:System.Web.UI.Page.RegisterAsyncTask%2A> 、メソッド、 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> 、非同期タスクを開始するメソッドを呼び出すことができます。  
  
 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> メソッドが呼び出される自動的に非非同期ページのいずれかの存在する場合に、非同期タスクが登録されたときにページの処理の時点は呼び出されます。 この自動呼び出しを <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> 直前に発生する、 <xref:System.Web.UI.Page.PreRenderComplete> イベントです。 呼び出す、 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> のタスクをこのメソッドが自動的に呼び出されないときに起動する方法です。 注意してください、非同期タスクはのみ 1 回も実行 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> 複数回呼び出すことができます。  
  
 <xref:System.Web.UI.Page.AsyncTimeout%2A> プロパティは呼び出しごとにリセット、 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> メソッドです。 最後の値、 <xref:System.Web.UI.Page.AsyncTimeout%2A> を呼び出す前に、 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> メソッドが優先されます。 非同期タスクを受け取る場合よりも多く <xref:System.Web.UI.Page.AsyncTimeout%2A>, 、後続のタスク中に呼び出される <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> 呼び出しがすぐにタイムアウトします。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.Page.AsyncTimeout%2A> プロパティを <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> と <xref:System.Web.UI.Page.RegisterAsyncTask%2A> メソッドです。 開始、終了、およびタイムアウト ハンドラーの使用に注意してください。 指定されているタスクに割り当てられた時間を超える、非同期タスクの状況を示す例では、人為的な遅延が導入された、 <xref:System.Web.UI.Page.AsyncTimeout%2A> プロパティです。 実際のシナリオで非同期タスクは、データベースの呼び出しまたはイメージの生成を実行するために使用でしたやなどのタイムアウト ハンドラーは、一定の期間でタスクを実行していない場合に正常なパフォーマンス低下を提供します。  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">非同期操作で、例外があります。</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="FileDependencies">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList FileDependencies { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList FileDependencies" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.FileDependencies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is HttpResponse.AddFileDependencies. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ファイルの配列を設定、現在 <see cref="T:System.Web.HttpResponse" /> オブジェクトが依存します。</summary>
        <value>配列をファイルには、現在 <see cref="T:System.Web.HttpResponse" /> オブジェクトが依存します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは推奨されていません。 使用して、 <xref:System.Web.HttpResponse.AddFileDependencies%2A> メソッドまたは <xref:System.Web.HttpResponse.AddFileDependency%2A> のメソッド、 <xref:System.Web.HttpResponse> クラスの代わりにします。  
  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `FileDependencies` 属性を `true` .aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public override System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FindControl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">検索するコントロールの識別子。</param>
        <summary>指定した識別子を持つサーバー コントロールのページの名前付けコンテナーを検索します。</summary>
        <returns>指定したコントロールまたは <see langword="null" /> 指定したコントロールが存在しない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.FindControl%2A> メソッドは、コントロールにアクセスするために使用できますが <xref:System.Web.UI.Control.ID%2A> デザイン時に使用できません。 メソッドのみ、ページの即時または最上位レベル、コンテナーを検索します。これは、ページに含まれている名前付けコンテナー内のコントロールも再帰的に検索されます。 下位の名前付けコンテナー内のコントロールにアクセスするには、呼び出し、 `FindControl` そのコンテナーのメソッドです。  
  
   
  
## 例  
 次のコード例では、使用して、 <xref:System.Web.UI.Page.FindControl%2A> テンプレート内のコントロールを検索します。 この例では 2 つ <xref:System.Web.UI.WebControls.Repeater> コントロールが定義されます。 各をキャッチする別の方法を示しています、 <xref:System.Web.UI.WebControls.LinkButton.Click> のイベント、 <xref:System.Web.UI.WebControls.LinkButton> repeater 項目テンプレートの中。  
  
 [!code-csharp[System.Web.UI.Page\_FindControl\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/cs/pagefindcontrolcs.aspx#1)]
 [!code-vb[System.Web.UI.Page\_FindControl\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/vb/pagefindcontrolvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlForm Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlForm Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlForm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの HTML フォームを取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> ページに関連付けられているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Page.Form%2A> プロパティ、メソッドとプロパティのアクセスを <xref:System.Web.UI.HtmlControls.HtmlForm> ページ コントロール階層の基本であるオブジェクト。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
      </Docs>
    </Member>
    <Member MemberName="FrameworkInitialize">
      <MemberSignature Language="C#" Value="protected override void FrameworkInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FrameworkInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FrameworkInitialize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページの宣言型の性質に基づいてページの生成中に、コントロール ツリーを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.FrameworkInitialize%2A> メソッドの初期化、 <xref:System.Web.UI.Page> オブジェクトし、ページの宣言型の性質に基づいてコントロール ツリーを作成します。<xref:System.Web.UI.Page.FrameworkInitialize%2A> メソッドは、ページの解析中のコード生成や、 <xref:System.Web.UI.Page> 宣言型のページのクラスです。 通常、このメソッドをオーバーライドする必要性を経由せず必要があります。 を上書きする場合は、を呼び出して、基本クラスのことを確認する <xref:System.Web.UI.Page.FrameworkInitialize%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="GetDataItem">
      <MemberSignature Language="C#" Value="public object GetDataItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetDataItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetDataItem" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>データ バインディング コンテキスト スタックの最上部にあるデータ項目を取得します。</summary>
        <returns>データ バインディング コンテキスト スタックの上部にあるオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">ページのデータ バインド コンテキストはありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientEvent">
      <MemberSignature Language="C#" Value="public string GetPostBackClientEvent (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientEvent(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientEvent(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">クライアント イベントのポストバックを受信するサーバー コントロール。</param>
        <param name="argument">
          <see cref="M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)" /> に渡される <see cref="T:System.String" />。</param>
        <summary>指定されたイベント引数を使用して指定したコントロールのサーバーにポストバックするクライアント イベントで使用できる参照を取得します。</summary>
        <returns>クライアント イベントを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 See the <xref:System.Web.UI.ClientScriptManager> class for alternatives to this deprecated member.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.Button.OnClientClick" />
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackClientHyperlink. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">ポストバックを処理するサーバー コントロール。</param>
        <param name="argument">サーバー コントロールに、パラメーターが渡されます。</param>
        <summary>持つ、参照を取得 <see langword="javascript:" /> 指定されたイベント引数を使用して指定したコントロールのサーバーにポストバック クライアント イベントで使用できるは、先頭に追加します。</summary>
        <returns>ターゲット コントロールの ID とイベントの引数を含むポストバック関数への JavaScript 呼び出しを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 参照してください、 <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> のこのメンバーを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">サーバーにポストバックを処理するサーバー コントロール。</param>
        <summary>サーバーへのポストバックが発生するクライアント イベントで使用できる文字列を返します。 参照文字列が定義されている、指定した <see cref="T:System.Web.UI.Control" /> オブジェクトです。</summary>
        <returns>文字列をクライアントでは、スクリプトとして扱われた場合、ポストバックを開始します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの使用は推奨されていません。 使用して、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> メソッドで、 <xref:System.Web.UI.ClientScriptManager> クラスの代わりにします。  
  
   
  
## 例  
 [!code-csharp[Page\_GetPostBackEventReference\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#2)]
 [!code-vb[Page\_GetPostBackEventReference\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">ポストバックを処理するサーバー コントロール。</param>
        <param name="argument">サーバー コントロールに、パラメーターが渡されます。</param>
        <summary>サーバーへのポストバックが発生するクライアント イベントで使用できる文字列を返します。 参照文字列は、ポストバックと追加のイベント情報の文字列引数を処理する指定したコントロールによって定義されます。</summary>
        <returns>文字列をクライアントでは、スクリプトとして扱われた場合、ポストバックを開始します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの使用は推奨されていません。 使用して、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> メソッドで、 <xref:System.Web.UI.ClientScriptManager> クラスの代わりにします。  
  
   
  
## 例  
 [!code-csharp[Page\_GetPostBackEventReference\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#1)]
 [!code-vb[Page\_GetPostBackEventReference\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetTypeHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetTypeHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetTypeHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>によって生成されるハッシュ コードを取得 <see cref="T:System.Web.UI.Page" /> に生成されたオブジェクトの実行時間。 一意のハッシュ コードです、 <see cref="T:System.Web.UI.Page" /> オブジェクトのコントロールの階層構造です。</summary>
        <returns>実行時に生成されたハッシュ コード。 既定値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドはオーバーライドできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValidators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection GetValidators (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.ValidatorCollection GetValidators(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetValidators(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">戻るには、検証グループまたは <see langword="null" /> を既定の検証グループを返します。</param>
        <summary>指定した検証グループの検証コントロールのコレクションを返します。</summary>
        <returns>A <see cref="T:System.Web.UI.ValidatorCollection" /> 指定した検証グループの検証コントロールを格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.GetValidators%2A> メソッドは、特定の検証グループに関連付けられているすべての検証オブジェクトを取得します。 既定の検証グループを返すことができます \(なしのコントロールに関連付けられているすべての検証コントロール、 `ValidationGroup` プロパティ セット\) を設定して、 `validationGroup` パラメーターを `null`します。  
  
 検証グループのメンバーを検証するには、コレクションと呼び出しを列挙することができます、 <xref:System.Web.UI.IValidator.Validate%2A> 各検証メソッドが返されます。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.UI.Page.GetValidators%2A> を既定の検証グループを返すメソッド。  
  
 [!code-csharp[PageGetValidators\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageGetValidators/CS/pagegetvalidatorscs.aspx#1)]
 [!code-vb[PageGetValidators\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageGetValidators/VB/pagegetvalidatorsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.Validate(System.String)" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
      </Docs>
    </Member>
    <Member MemberName="GetWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected object GetWrappedFileDependencies (string[] virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetWrappedFileDependencies(string[] virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetWrappedFileDependencies(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">仮想ファイルの場所の文字列配列。</param>
        <summary>仮想ファイルの場所のリストに対応する物理ファイル名の一覧を返します。</summary>
        <returns>物理ファイルの場所の一覧を含むオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.GetWrappedFileDependencies%2A> メソッドは、現在のページを構成するユーザー コントロール ファイルなどのファイルの一覧を取得します。 これらのページのいずれかが変更された場合、ページ全体には、要求時に、次はコンパイルされます。 このメソッドはオーバーライドできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Header">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlHead Header { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlHead Header" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Header" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlHead</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>場合に、ページのドキュメントのヘッダーを取得、 <see langword="head" /> に要素が定義されている、 <see langword="runat=server" /> ページの宣言でします。</summary>
        <value>
          <see cref="T:System.Web.UI.HtmlControls.HtmlHead" /> ページ ヘッダーを格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.Header%2A> プロパティへの参照を取得する、 <xref:System.Web.UI.HtmlControls.HtmlHead> ページのドキュメントのヘッダー情報を設定するのには使用できるオブジェクトします。<xref:System.Web.UI.HtmlControls.HtmlHead> スタイル シート、スタイル ルール、タイトル、およびメタデータをなどの情報を追加するため、 `head` 要素。  
  
> [!NOTE]
>  プログラムでのメソッドを使用してスタイルを追加する、 <xref:System.Web.UI.IStyleSheet> 非同期ポストバック時にインターフェイスがサポートされていません。 Web ページに AJAX 機能を追加すると、非同期ポストバックはページ全体を更新することがなくページの領域を更新します。 詳細については、「[ASP.NET AJAX Overview](http://msdn.microsoft.com/ja-jp/be84d9b3-b7cd-47d7-8494-be4abfaad9cb)」を参照してください。  
  
   
  
## 例  
 次のコード例は、アクセスする方法を説明、 <xref:System.Web.UI.HtmlControls.HtmlHead> を使用したプログラムの制御、 <xref:System.Web.UI.Page.Header%2A> プロパティです。 A `title` 要素と `style` に要素を追加、 `head` ページの要素。  
  
 [!code-csharp[System.Web.UI.HtmlControls.HtmlHeadClass\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/CS/htmlheadclasscs.aspx#1)]
 [!code-vb[System.Web.UI.HtmlControls.HtmlHeadClass\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/VB/htmlheadclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlHead" />
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlLink" />
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public override string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の特定のインスタンスの識別子、 <see cref="T:System.Web.UI.Page" /> クラスです。</summary>
        <value>インスタンスの識別子、 <see cref="T:System.Web.UI.Page" /> クラスです。 既定値は、'\_Page' です。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="public virtual char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ上のコントロールの一意の ID を作成するときに、コントロールの id を区別するために使用する文字を取得します。</summary>
        <value>コントロールの識別子を区切るために使用する文字。 既定値を設定、 <see cref="T:System.Web.UI.Adapters.PageAdapter" /> 、ページをレンダリングするインスタンス。<see cref="P:System.Web.UI.Page.IdSeparator" /> サーバー側のフィールドは、変更しないようにします。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.ID" />
      </Docs>
    </Member>
    <Member MemberName="InitComplete">
      <MemberSignature Language="C#" Value="public event EventHandler InitComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InitComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.InitComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの初期化が完了すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.InitComplete> イベントは、ページの初期化ステージの最後に呼び出されます。 ページのライフ サイクルのこの段階で、ページ上のコントロールが初期化されますが、ページの状態がまだ設定すべて宣言します。 サーバー コントロールにアクセスできますが、これらがまだ含まれていませんユーザーから返される情報には。  
  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/ja-jp/01e4f1bc-e55e-413f-98c7-6588493e5f67)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="InitializeCulture">
      <MemberSignature Language="C#" Value="protected virtual void InitializeCulture ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeCulture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitializeCulture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>セット、 <see cref="P:System.Web.UI.Page.Culture" /> と <see cref="P:System.Web.UI.Page.UICulture" /> 、ページの現在のスレッドにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.InitializeCulture%2A> メソッドにコーディング ロジックが含まれていません。 機能を拡張する開発者の制御、 <xref:System.Web.UI.Page> クラスをオーバーライドできる、 <xref:System.Web.UI.Page.InitializeCulture%2A> 初期化するメソッドを <xref:System.Web.UI.Page.Culture%2A> と <xref:System.Web.UI.Page.UICulture%2A> ページの情報です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.Web.UI.Page.FrameworkInitialize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InitOutputCache">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のページ要求の出力キャッシュを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コードから直接使用するものでありません。 を有効にして、ページの出力キャッシュを操作するには、これらのアプローチの 1 つを使用します。  
  
-   .Aspx ファイルで宣言によって、ディレクティブを使用してオプションを設定します。  
  
-   メソッドとプロパティを使用して、 <xref:System.Web.HttpCachePolicy> によって公開されるクラス、 `Response.Cache` ページのコード内のオブジェクト。  
  
 詳細については、「[Caching ASP.NET Pages](http://msdn.microsoft.com/ja-jp/e9666a1b-88df-4931-af0b-a754fc65660b)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (System.Web.UI.OutputCacheParameters cacheSettings);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void InitOutputCache(class System.Web.UI.OutputCacheParameters cacheSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Web.UI.OutputCacheParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheSettings" Type="System.Web.UI.OutputCacheParameters" />
      </Parameters>
      <Docs>
        <param name="cacheSettings">
          <see cref="T:System.Web.UI.OutputCacheParameters" /> キャッシュの設定値を格納します。</param>
        <summary>現在のページ要求の出力キャッシュがに基づいて初期化、 <see cref="T:System.Web.UI.OutputCacheParameters" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは呼び出さないでください。 を有効にして、ページの出力キャッシュを操作するには、.aspx ファイル、またはメソッドとプロパティのいずれかのディレクティブを使って、 <xref:System.Web.HttpCachePolicy> クラスです。 後者はを通してアクセス `Response.Cache` 、ページのコード宣言ブロックまたは分離コード ファイル内の構文です。 詳細については、「[Caching ASP.NET Pages](http://msdn.microsoft.com/ja-jp/e9666a1b-88df-4931-af0b-a754fc65660b)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">キャッシュ プロファイルが見つかりませんでした。  
  
 または  
  
 不足しているディレクティブまたは構成の設定は、プロファイルの属性です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">出力キャッシュ設定の場所が正しくありません。</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">出力キャッシュに格納されているオブジェクトが有効の量。</param>
        <param name="varyByHeader">出力キャッシュからコンテンツ ヘッダーをセミコロンで区切ってによって異なります。</param>
        <param name="varyByCustom">
          <see langword="Vary" /> HTTP ヘッダー。</param>
        <param name="location">
          <see cref="T:System.Web.UI.OutputCacheLocation" /> 値のいずれか 1 つ。</param>
        <param name="varyByParam">GET または POST メソッドによって、出力キャッシュからコンテンツが異なる場合が受け取るパラメーターのセミコロンで区切った一覧。</param>
        <summary>現在のページ要求の出力キャッシュを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは呼び出さないでください。 を有効にして、ページの出力キャッシュを操作するには、.aspx ファイル、またはメソッドとプロパティのいずれかのディレクティブを使って、 <xref:System.Web.HttpCachePolicy> クラスです。 後者はを通してアクセス `Response.Cache` ページのコードの構文です。 詳細については、「[Caching ASP.NET Pages](http://msdn.microsoft.com/ja-jp/e9666a1b-88df-4931-af0b-a754fc65660b)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">無効な値が指定されて <paramref name="location" />します。</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByContentEncoding" Type="System.String" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">出力キャッシュに格納されているオブジェクトが有効の量。</param>
        <param name="varyByContentEncoding">文字セット \(コンテンツのエンコード方式\)、出力キャッシュからコンテンツをセミコロンで区切ってによって異なります。</param>
        <param name="varyByHeader">出力キャッシュからコンテンツ ヘッダーをセミコロンで区切ってによって異なります。</param>
        <param name="varyByCustom">
          <see langword="Vary" /> HTTP ヘッダー。</param>
        <param name="location">
          <see cref="T:System.Web.UI.OutputCacheLocation" /> 値のいずれか 1 つ。</param>
        <param name="varyByParam">GET または POST メソッドによって、出力キャッシュからコンテンツが異なる場合が受け取るパラメーターのセミコロンで区切った一覧。</param>
        <summary>現在のページ要求の出力キャッシュを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは呼び出さないでください。 を有効にして、ページの出力キャッシュを操作するには、.aspx ファイル、またはメソッドとプロパティのいずれかのディレクティブを使って、 <xref:System.Web.HttpCachePolicy> クラスです。 後者はを通してアクセス `Response.Cache` ページのコードの構文です。 詳細については、「[Caching ASP.NET Pages](http://msdn.microsoft.com/ja-jp/e9666a1b-88df-4931-af0b-a754fc65660b)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">無効な値が指定されて <paramref name="location" />します。</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページが非同期的に処理されるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> ページが非同期モードである場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Page.IsAsync%2A> Web ページが非同期モードで実行されているかどうかを決定するプロパティです。 この情報は、ページのコントロールまたはコード ページが非同期かに応じて、動作を変更する必要がある場合に便利です。 非同期プログラミングについて詳しくは、「[Performing Asynchronous Operations](http://msdn.microsoft.com/ja-jp/e7d32c3c-bf78-4bfc-a357-c9e82e4a4b3c)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCallback">
      <MemberSignature Language="C#" Value="public bool IsCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ要求がコールバックの結果であるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> ページ要求がコールバックの結果である場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 詳細については、「[Implementing Client Callbacks Programmatically Without Postbacks in ASP.NET Web Pages](http://msdn.microsoft.com/ja-jp/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsClientScriptBlockRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsClientScriptBlockRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">検索対象のクライアント スクリプトの文字列のキー。</param>
        <summary>指定したキーをクライアント スクリプト ブロックがページに登録されているかどうかを決定します。</summary>
        <returns>
          <see langword="true" /> スクリプト ブロックが登録されている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す前に <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A?displayProperty=fullName> を不必要にクライアント側スクリプトをまとめることを回避します。 これは、スクリプトを作成するサーバーのリソースの消費量を必要な場合に特に重要です。  
  
 <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> メソッドの使用は推奨されていません。 使用して、 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> メソッドで、 <xref:System.Web.UI.ClientScriptManager> クラスです。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> メソッドと組み合わせて、 <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> メソッドです。 コード宣言ブロックで記述された ECMAScript が既に登録されていない場合、によって決定される <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, 、 <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> 呼び出しが行われます。  
  
 [!code-csharp[System.Web.UI.Page.RegisterClientScriptBlock\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.RegisterClientScriptBlock\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsCrossPagePostBack">
      <MemberSignature Language="C#" Value="public bool IsCrossPagePostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCrossPagePostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クロスページ ポストバック、ページが含まれているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> ページがページ間の要求; に参加している場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET では、別の 1 つのページから制御を転送するための 2 つのメカニズムを提供します。 使用することができます、 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドを使用して処理するか、ページ間では、ページの URL を割り当てることでページ間の要求が行える、 <xref:System.Web.UI.WebControls.IButtonControl.PostBackUrl%2A> を実装するボタン コントロールのプロパティ、 <xref:System.Web.UI.WebControls.IButtonControl> インターフェイスです。  
  
 いずれの場合、 <xref:System.Web.UI.Page.PreviousPage%2A> ページのプロパティには、前または送信元のページを表すオブジェクトが含まれています。 たとえば、ページ A 投稿ページ B まで、ページ A の場合は、 <xref:System.Web.UI.Page.IsCrossPagePostBack%2A> プロパティ \(からアクセスできる、 <xref:System.Web.UI.Page.PreviousPage%2A> プロパティ\) は `true` ページ b の <xref:System.Web.UI.Page.PreviousPage%2A> プロパティ ページ A の名前が付けられます  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.IButtonControl.PostBackUrl" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBack">
      <MemberSignature Language="C#" Value="public bool IsPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページが最初に表示しているか、ポストバックへの応答内に読み込まれているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> クライアント ポストバックへの応答内のページに読み込まれている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ポストバックおよびコールバックの相違点の詳細については、次を参照してください。 [Implementing Client Callbacks Programmatically Without Postbacks in ASP.NET Web Pages](http://msdn.microsoft.com/ja-jp/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)します。  
  
   
  
## 例  
 次の例の値をテストする方法を示しています、 <xref:System.Web.UI.Page.IsPostBack%2A> プロパティ ページが最初に表示しているかがポストバックに応答してかを判断するために、ページが読み込まれるとします。 コードを呼び出す場合は、最初に、ページを表示している、 <xref:System.Web.UI.Page.Validate%2A?displayProperty=fullName> メソッドです。  
  
 \(非表示\)、ページのマークアップを含む <xref:System.Web.UI.WebControls.RequiredFieldValidator> 必要な入力フィールドのエントリが行われなかった場合は、アスタリスクを表示するコントロール。 呼び出す <xref:System.Web.UI.Page.Validate%2A?displayProperty=fullName> ページが表示された場合、\[送信\] ボタンをクリックするまで待機せずにすぐに表示するには、アスタリスクを発生します。 ポストバック後にを呼び出す必要はない <xref:System.Web.UI.Page.Validate%2A?displayProperty=fullName>, の一部としてそのメソッドが呼び出されるため、 <xref:System.Web.UI.Page> ライフ サイクルです。  
  
 [!code-csharp[System.Web.UI.Page.Validate\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.Page.IsCallback" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBackEventControlRegistered">
      <MemberSignature Language="C#" Value="public bool IsPostBackEventControlRegistered { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBackEventControlRegistered" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ポストバックを実行するページのコントロールが登録されているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> コントロールに登録されています。それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReusable">
      <MemberSignature Language="C#" Value="public bool IsReusable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReusable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsReusable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Web.UI.Page" /> オブジェクトを再利用できます。</summary>
        <value>常に <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.IHttpHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsStartupScriptRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsStartupScriptRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">検索対象のスタートアップ スクリプトの文字列のキー。</param>
        <summary>クライアントのスタートアップ スクリプトが登録されているかどうかを判断、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
        <returns>
          <see langword="true" /> スタートアップ スクリプトが登録されている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す前に <xref:System.Web.UI.Page.RegisterStartupScript%2A?displayProperty=fullName> を不必要にクライアント側スクリプトをまとめることを回避します。 これは、スクリプトを作成するサーバーのリソースの消費量を必要な場合に特に重要です。  
  
 <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> メソッドの使用は推奨されていません。 使用して、 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> メソッドで、 <xref:System.Web.UI.ClientScriptManager> クラスです。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.Page.RegisterStartupScript%2A> メソッドと組み合わせて、 <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> メソッドです。 コード宣言ブロックで記述された ECMAScript が既に登録されていない場合、によって決定される <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>, 、 <xref:System.Web.UI.Page.RegisterStartupScript%2A> 呼び出しが行われます。  
  
 [!code-csharp[System.Web.UI.Page.RegisterClientScriptBlock\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.RegisterClientScriptBlock\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの検証が成功したかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> ページの検証が成功した場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを返す `true`, 、現在の検証グループ内のすべての検証サーバー コントロールが正常に検証する必要があります。 呼び出した後にのみ、このプロパティを確認する必要があります、 <xref:System.Web.UI.Page.Validate%2A?displayProperty=fullName> メソッド、またはセット、 `CausesValidation` プロパティを `true` で、 `OnServerClick` フォーム処理を開始する ASP.NET サーバー コントロールのイベント ハンドラーです。 これらのサーバー コントロールを含める、 <xref:System.Web.UI.WebControls.Button>, 、<xref:System.Web.UI.HtmlControls.HtmlButton>, 、<xref:System.Web.UI.HtmlControls.HtmlInputButton>, 、<xref:System.Web.UI.HtmlControls.HtmlInputImage>, 、<xref:System.Web.UI.WebControls.ImageButton>, 、および <xref:System.Web.UI.WebControls.LinkButton> クラスです。  
  
 使用して検証グループの検証を強制する場合、 <xref:System.Web.UI.Page.Validate%2A> メソッドを指定した検証グループ内のすべての検証コントロールも検証する必要がありますが正常にします。  
  
   
  
## 例  
 次のコード例では、使用方法を示します、 <xref:System.Web.UI.Page.IsValid%2A> プロパティを条件付きステートメントを設定します。 プロパティを返す場合 `true`, 、 `Text` のプロパティ、 `lblOutput` 「ページが正しく\!」に設定します。 「いくつかの必須フィールドが空です」に設定されている場合は、  
  
 [!code-csharp[System.Web.UI.Page.Validate\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Validate\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.UI.Page.IsValid" /> プロパティは、検証が実行されるまで呼び出されます。</exception>
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="M:System.Web.UI.Page.Validate" />
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページのコンテキストに格納されているオブジェクトの一覧を取得します。</summary>
        <value>参照、 <see cref="T:System.Collections.IDictionary" /> ページのコンテキストに格納されたオブジェクトします。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Page.Items%2A> プロパティ ページの要求と同じ有効期間を持つオブジェクトを格納します。 このプロパティは読み取り専用です。ただし、オブジェクトを追加できる、 <xref:System.Collections.IDictionary> オブジェクトが返されます。  
  
 追加されたオブジェクト、 <xref:System.Web.UI.Page.Items%2A> プロパティをページの有効期間を通じて利用できるオブジェクトを追加できるため、 <xref:System.Web.UI.Page.Items%2A> ページ ライフ サイクルの早い段階でイベントのプロパティは、サイクルし、後続のイベントでこれらのオブジェクトにアクセスします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.LCID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ロケール識別子を設定、 <see cref="T:System.Threading.Thread" /> ページに関連付けられているオブジェクト。</summary>
        <value>ロケール識別子を渡す、 <see cref="T:System.Threading.Thread" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。`LCID` .Aspx ファイルのディレクティブで属性を設定することができます、ただし、ロケール識別子の設定の推奨方法を使用すると、 <xref:System.Web.UI.Page.Culture%2A> と <xref:System.Web.UI.Page.UICulture%2A> プロパティです。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
        <altmember cref="P:System.Web.UI.Page.UICulture" />
      </Docs>
    </Member>
    <Member MemberName="LoadComplete">
      <MemberSignature Language="C#" Value="public event EventHandler LoadComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LoadComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.LoadComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページのライフ サイクルの読み込み段階の最後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.LoadComplete> 後のすべてのポストバック データ イベントが発生し、ページを前後にビュー ステート データが読み込まれる、 <xref:System.Web.UI.Control.OnLoad%2A> 、ページのすべてのコントロールのメソッドが呼び出されました。  
  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/ja-jp/01e4f1bc-e55e-413f-98c7-6588493e5f67)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="LoadPageStateFromPersistenceMedium">
      <MemberSignature Language="C#" Value="protected virtual object LoadPageStateFromPersistenceMedium ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object LoadPageStateFromPersistenceMedium() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>負荷のビュー状態に関する情報を保存、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
        <returns>保存されたビュー ステート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> メソッドの使用方法、 <xref:System.Web.UI.PageStatePersister.Load%2A> のメソッド、 <xref:System.Web.UI.PageStatePersister?displayProperty=fullName> によって参照されるオブジェクト、 <xref:System.Web.UI.Page.PageStatePersister%2A> をロード プロパティのビュー状態情報の保存、 <xref:System.Web.UI.Page> オブジェクトです。  
  
 ASP.NET には、2 つの子孫が含まれています、 <xref:System.Web.UI.PageStatePersister> クラス、 <xref:System.Web.UI.HiddenFieldPageStatePersister> ASP.NET ページに含まれる非表示フィールドに状態情報を保存するクラスと <xref:System.Web.UI.SessionPageStatePersister> で状態を保存するクラス、 <xref:System.Web.UI.Page.Session%2A> 要求に関連付けられているオブジェクト。  
  
 任意の場所で状態を保存する必要があります新規に作成するの子孫、 <xref:System.Web.UI.PageStatePersister> クラスを保存し、任意の永続化中に状態を読み込みます。 新しいを作成する例については <xref:System.Web.UI.PageStatePersister> オブジェクトを参照してください、 <xref:System.Web.UI.PageStatePersister> クラスです。  
  
 .NET Framework version 1.0 または 1.1 では、負荷をする場合は、このメソッドをオーバーライドを使用している場合、 <xref:System.Web.UI.Page> 状態から非表示フィールド以外のものです。 オーバーライドするように選択した場合、 <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="MaintainScrollPositionOnPostBack">
      <MemberSignature Language="C#" Value="public bool MaintainScrollPositionOnPostBack { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ポストバック後に、クライアント ブラウザー内の同じ位置にユーザーを返すかどうかを示す値を取得または設定します。 このプロパティは、使用が推奨されなくなった <see cref="P:System.Web.UI.Page.SmartNavigation" /> プロパティに代わるものです。</summary>
        <value>クライアントの位置を維持する必要がある場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サーバーには、Web ページがポストバックされる、ユーザーがページの上部に返されます。 つまり長い Web ページで、ユーザーがページ上の最後の位置に戻るページをスクロールします。  
  
 ときに、 <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> にプロパティが設定されている `true`, 、ユーザーは代わりに返される最後の位置\] ページでします。  
  
 設定する、 <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> プロパティに、 [@ Page](http://msdn.microsoft.com/ja-jp/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) ディレクティブです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.MapPath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">A <see cref="T:System.String" /> を表す仮想パス。</param>
        <summary>仮想パス、絶対または相対パス、またはアプリケーションの相対パスにマップされる物理パスを取得します。</summary>
        <returns>仮想パスまたはアプリケーションの相対パスに関連付けられている物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!CAUTION]
>  <xref:System.Web.UI.Page.MapPath%2A> プロパティはホスティング環境に関する機密情報を含める可能性があることができます。 戻り値をユーザーに表示しない必要があります。  
  
   
  
## 例  
 次の例では、 <xref:System.Web.UI.Page.MapPath%2A> サブフォルダーの物理パスを取得します。 読み取られるファイル名を追加し、 <xref:System.Web.UI.WebControls.TextBox.Text%2A> のプロパティ、 <xref:System.Web.UI.WebControls.TextBox> コントロールです。 そのファイルへの絶対物理パスになります。  
  
 [!code-csharp[Page\_MapPath\_ResponseEncoding\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/CS/page_mappath_responseencoding.cs.aspx#1)]
 [!code-vb[Page\_MapPath\_ResponseEncoding\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/VB/page_mappath_responseencoding.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Master">
      <MemberSignature Language="C#" Value="public System.Web.UI.MasterPage Master { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.MasterPage Master" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Master" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.MasterPage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの全体的な外観を決定するマスター ページを取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.MasterPage" /> が存在する場合は、このページに関連付けられていない場合は <see langword="null" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.Master%2A> プロパティを返します。、 <xref:System.Web.UI.MasterPage> このページに関連付けられているオブジェクト。 このプロパティは読み取り専用です。ただしでプロパティを設定することができます、 <xref:System.Web.UI.MasterPage> オブジェクトが返されます。  
  
 <xref:System.Web.UI.Page.Master%2A> プロパティはマスター ページを参照するページでのみ有効ですが、 <xref:System.Web.UI.Page.MasterPageFile%2A> プロパティです。 アクセスする場合、 <xref:System.Web.UI.Page.Master%2A> マスター ページを参照しないページのプロパティを `null` が返されます。 マスター ページの内容が後までご利用いただけません、 <xref:System.Web.UI.Page.PreInit> イベントが発生しました。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.MasterPageFile" />
      </Docs>
    </Member>
    <Member MemberName="MasterPageFile">
      <MemberSignature Language="C#" Value="public virtual string MasterPageFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MasterPageFile" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MasterPageFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはマスター ページの仮想パスを設定します。</summary>
        <value>マスター ページの仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.MasterPageFile%2A> プロパティは、このページに関連付けられているマスター ページのファイルのルートから、アプリケーションの\) 仮想パス。<xref:System.Web.UI.Page.MasterPageFile%2A> でのみプロパティを設定することができます、 <xref:System.Web.UI.Page.PreInit> イベント; を設定しようとすると、 <xref:System.Web.UI.Page.MasterPageFile%2A> 後プロパティ、 <xref:System.Web.UI.Page.PreInit> イベントがスローされます、 <xref:System.InvalidOperationException> 例外です。 場合、 <xref:System.Web.UI.Page.MasterPageFile%2A> プロパティが有効でない型の例外 <xref:System.Web.HttpException> ページのライフ サイクルの後半にスローされるプロパティが設定された場合に例外がスローされませんが、 <xref:System.Web.UI.Page.PreInit> イベントです。  
  
 持つページ、 <xref:System.Web.UI.Page.MasterPageFile%2A> プロパティ セットのコンテンツ ページし、は最上位レベルのみのコントロールを含めることができます <xref:System.Web.UI.WebControls.Content> コントロールです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.MasterPageFile" /> 後にプロパティが設定されて、 <see cref="E:System.Web.UI.Page.PreInit" /> イベントが完了します。</exception>
        <exception cref="T:System.Web.HttpException">指定されたファイル、 <see cref="P:System.Web.UI.Page.MasterPageFile" /> プロパティが存在しません。  
  
 または  
  
 ページがない、 <see cref="T:System.Web.UI.WebControls.Content" /> コントロールをトップレベル コントロールとして。</exception>
        <altmember cref="P:System.Web.UI.Page.Master" />
      </Docs>
    </Member>
    <Member MemberName="MaxPageStateFieldLength">
      <MemberSignature Language="C#" Value="public int MaxPageStateFieldLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPageStateFieldLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページの \[状態\] フィールドの最大の長さを設定します。</summary>
        <value>\(バイト単位\)、ページの状態\] フィールドの最大長。 既定値は \-1 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> プロパティが正の数値に設定し、クライアント ブラウザーに送信されるビュー ステートは、複数の非表示フィールドに分割し、各フィールドの値がで指定されたサイズより小さい、 <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> プロパティです。  
  
 設定、 <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> 負の数 \(既定値\) をプロパティでは、ビュー ステート フィールドをチャンクに分割しないことを示します。 設定、 <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> いくつかのパフォーマンスが低下あります。  
  
 値を設定、 <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> プロパティに、Web.config ファイルのです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> プロパティが\-1 または正の数と等しくありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> ページの初期化後にプロパティが設定されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaDescription">
      <MemberSignature Language="C#" Value="public string MetaDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>「説明」のコンテンツ設定を取得または <see langword="meta" /> 要素。</summary>
        <value>「説明」のコンテンツ <see langword="meta" /> 要素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 HTML `meta` 要素を検索エンジンの検索結果を向上させるために使用できます。 「説明」 `meta` 要素は一覧のプレビューを向上させるために一部の検索エンジンによって使用されます。  
  
 「説明」がある場合 `meta` 内の要素、 `head` ページ マークアップの要素、 `meta` ページがレンダリングされる要素がページに追加します。 ページのマークアップが"description"場合、 `meta` 要素では、このプロパティを取得または設定、 `content` の属性、 `meta` 要素。  
  
 ディレクティブに、このプロパティを設定することもできます。  
  
   
  
## 例  
 設定した場合、 <xref:System.Web.UI.Page.MetaDescription%2A> \[ASP.NET の概要\] ページのプロパティは、次の要素は、レンダリングされる HTML に表示されます。  
  
 `<meta name="description" content="ASP.NET Overview" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ページには、ヘッダー コントロールはありません \(、 <see langword="head" /> を持つ要素、 <see langword="runat" /> 属性は、"server"に設定\)。</exception>
        <altmember cref="P:System.Web.UI.Page.MetaKeywords" />
      </Docs>
    </Member>
    <Member MemberName="MetaKeywords">
      <MemberSignature Language="C#" Value="public string MetaKeywords { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaKeywords" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaKeywords" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>「キーワード」のコンテンツ設定を取得または <see langword="meta" /> 要素。</summary>
        <value>「キーワード」のコンテンツ <see langword="meta" /> 要素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 HTML `meta` 要素を検索エンジンの検索結果を向上させるために使用できます。 「キーワード」 `meta` 要素か、まったく使用されていないまたは、主な検索エンジンではごくわずかな重みを指定します。  
  
 「キーワード」がある場合 `meta` 内の要素、 `head` ページ マークアップの要素、 `meta` ページがレンダリングされる要素がページに追加します。 ページのマークアップには既に「キーワード」 `meta` 要素では、このプロパティを取得または設定、 `content` の属性、 `meta` 要素。  
  
 ディレクティブに、このプロパティを設定することもできます。  
  
   
  
## 例  
 設定した場合、 <xref:System.Web.UI.Page.MetaKeywords%2A> 「HTML、CSS、JavaScript、XML」をページのプロパティは、次の要素は、レンダリングされる HTML に表示されます。  
  
 `<meta name="keywords" content=" HTML,CSS,XML,JavaScript" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ページには、ヘッダー コントロールはありません \(、 <see langword="head" /> を持つ要素、 <see langword="runat" /> 属性は、"server"に設定\)。</exception>
        <altmember cref="P:System.Web.UI.Page.MetaDescription" />
      </Docs>
    </Member>
    <Member MemberName="ModelBindingExecutionContext">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelBindingExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モデル バインディングの実行コンテキストを取得します。</summary>
        <value>モデル バインディングの実行コンテキスト。 モデル バインディングの実行コンテキストは場合 <see langword="null" />, 、新しいが作成され、返されるいずれかです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModelState">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelStateDictionary ModelState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelStateDictionary ModelState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelStateDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モデルおよびモデル バインディングの検証の状態を含むモデル状態ディクショナリ オブジェクトを取得します。</summary>
        <value>モデルの状態のディクショナリ オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web フォームでモデルのバインディングの使用に関するチュートリアル シリーズは、次を参照してください。 [Model Binding and Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.Control.Init" /> イベント ページを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.OnInit%2A> メソッドを作成するために必要な初期化とセットアップの手順を実行、 <xref:System.Web.UI.Page> インスタンス。 ページのライフ サイクルのこの段階で、ページに宣言されたサーバー コントロールがその既定の状態に初期化されます。ただし、各コントロールのビュー ステートはまだは設定されません。 ページ上のコントロールが \[中\] ページには、他のサーバー コントロールにアクセスできない、 `Page_Init` フェーズでは、その他のコントロールの子または親コントロールがかどうかに関係なく。 他のサーバー コントロールでは、作成されたアクセスできる状態に限りません。  
  
 <xref:System.Web.UI.Page.OnInit%2A> メソッドは、 <xref:System.Web.UI.Page.OnPreInit%2A> メソッドとの前に、 <xref:System.Web.UI.Page.OnInitComplete%2A> メソッドです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnInit%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInitComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInitComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.Page.InitComplete" /> ページの初期化後のイベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.OnInitComplete%2A> ページの初期化が完了したら、メソッドが呼び出されます。 ページのライフ サイクルのこの段階で、ページ上のコントロールが初期化されますが、ページのビュー ステートがまだ設定すべて宣言します。 サーバー コントロールにアクセスできますが、これらがまだ含まれていませんユーザーから返される情報には。  
  
 <xref:System.Web.UI.Page.OnInitComplete%2A> の最後にメソッドが呼び出される、 <xref:System.Web.UI.Page> 初期化ステージと読み込み段階の前にします。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnInitComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLoadComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.Page.LoadComplete" /> ページ読み込みの段階の最後のイベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.OnLoadComplete%2A> ページ読み込みの段階の最後に呼び出されます。 この時点でページのライフ サイクルのすべてのポストバック データとビューステート データが読み込まれるページ上のコントロールにします。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/ja-jp/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)します。  
  
 <xref:System.Web.UI.Page.OnLoadComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreInit">
      <MemberSignature Language="C#" Value="protected virtual void OnPreInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.Page.PreInit" /> ページの初期化の先頭にあるイベント。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.OnPreInit%2A> ページの初期段階の先頭にあるメソッドが呼び出されます。  
  
 後に、 <xref:System.Web.UI.Page.OnPreInit%2A> メソッドが呼び出され、パーソナル化情報が読み込まれ、ページのテーマが存在する場合は、初期化します。 これは動的に定義優先の段階ではまた、 <xref:System.Web.UI.PageTheme> または <xref:System.Web.UI.MasterPage> ページのです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnPreInit%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnPreLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.Page.PreLoad" /> イベントの前にポストバック データをページのサーバー コントロールに読み込まれた後、 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> イベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.OnPreLoad%2A> メソッドは、ユーザーから返されるすべてのポストバック データが読み込まれます。 ページのライフ サイクルのこの段階では、ビュー状態情報およびのポストバック データ宣言コントロールと初期段階で作成されたコントロールがページのコントロールに読み込まれます。  
  
 作成されたコントロール、 <xref:System.Web.UI.Page.OnPreLoad%2A> メソッドは、ビュー ステートとポストバックのデータも読み込まれます。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnPreLoad%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreRenderComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRenderComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreRenderComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.Page.PreRenderComplete" /> の後のイベント、 <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> イベント、ページがレンダリングされる前にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.OnPreRenderComplete%2A> ページのライフ サイクルのプリレンダ リング段階が完了すると、メソッドが呼び出されます。 ページのライフ サイクルのこの段階ですべてのコントロールを作成し、ページは、出力を表示する準備します。  
  
 これは、最後のページのビュー ステートを保存する前に呼び出すイベントです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnPreRenderComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSaveStateComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSaveStateComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSaveStateComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> イベント データを格納するオブジェクト。</param>
        <summary>発生させる、 <see cref="E:System.Web.UI.Page.SaveStateComplete" /> ページの状態を永続化に使用するメディアに保存した後のイベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.OnSaveStateComplete%2A> コントロールの状態情報がページの永続化中に書き込まれたときに、メソッドが呼び出されます。 永続化中に呼び出すことによって状態情報が書き込まれる、 <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> メソッドです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 <xref:System.Web.UI.Page.OnSaveStateComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="public System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の要求元ブラウザーのページをレンダリングするアダプターを取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.Adapters.PageAdapter" /> ページを表示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.PageAdapter%2A> プロパティは、固有の仕様を返します <xref:System.Web.UI.Adapters.PageAdapter> の動作が変更されるオブジェクト、 <xref:System.Web.UI.Page> 要求元のブラウザーのオブジェクト。  
  
 特定の <xref:System.Web.UI.Adapters.PageAdapter> オブジェクトは、入力方向の特性を調べることによって決まります <xref:System.Web.UI.Page.Request%2A> オブジェクトです。 要求のライフ サイクル イベントのアダプターが選択した場合、 <xref:System.Web.UI.Adapters.PageAdapter> オブジェクトの対応するイベントをオーバーライドする、 <xref:System.Web.UI.Page> オブジェクトです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageStatePersister">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.PageStatePersister PageStatePersister { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.PageStatePersister PageStatePersister" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageStatePersister" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.PageStatePersister</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Web.UI.PageStatePersister" /> ページに関連付けられているオブジェクト。</summary>
        <value>A <see cref="T:System.Web.UI.PageStatePersister" /> ページに関連付けられています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 HTTP 要求と応答は、本質的にステートレスです。 HTTP 要求の間で状態を維持するために、ASP.NET サーバー ページを格納できます <xref:System.Web.UI.Page> 状態です。 ビュー ステートと呼ばれる、この状態は、ページとコントロールの設定、およびページとコントロールと場合では、ユーザーがページに最後のラウンド トリップでの相互作用し、ものと同じものを表示できるようにするデータで構成されます。 同じページに後続の要求の間でのビュー ステートを格納するいくつかのメカニズムが存在します。 抽象 <xref:System.Web.UI.PageStatePersister> クラスは、これらの状態の記憶域メカニズムの基本クラスを表します。  
  
 ページの開発者は通常不要を使用して、 <xref:System.Web.UI.Page.PageStatePersister%2A> プロパティです。<xref:System.Web.UI.Page.PageStatePersister%2A> の機能を拡張するコントロールの開発者によって、主にプロパティが使用される、 <xref:System.Web.UI.Page> クラスです。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="postEventArgumentID">
      <MemberSignature Language="C#" Value="public const string postEventArgumentID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventArgumentID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventArgumentID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レンダリングされたページ EVENTARGUMENT の非表示フィールドを定義する文字列。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventSourceID" />
      </Docs>
    </Member>
    <Member MemberName="postEventSourceID">
      <MemberSignature Language="C#" Value="public const string postEventSourceID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventSourceID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventSourceID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レンダリングされたページ EVENTTARGET の非表示フィールドを定義する文字列。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventArgumentID" />
      </Docs>
    </Member>
    <Member MemberName="PreInit">
      <MemberSignature Language="C#" Value="public event EventHandler PreInit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreInit" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreInit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの初期化の前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントでは、ポストバックへの応答で、ページが読み込まれているかどうかなど、ページ要求の状況を確認することができます。 また、プロファイル プロパティの値を確認することができます。  
  
 イベントでは、ページ ライフ サイクルの後半で使用される値を設定することができます。 動的にマスター ページや、要求されたページのテーマを設定し、ダイナミック コントロールを作成できます。  
  
 方法の詳細については <xref:System.Web.UI.Page.PreInit> ASP.NET のライフ サイクル位置付けられているイベントは、「 [Introduction to the ASP.NET Page Life Cycle](http://msdn.microsoft.com/ja-jp/7949d756-1a79-464e-891f-904b1cfc7991)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
      </Docs>
    </Member>
    <Member MemberName="PreLoad">
      <MemberSignature Language="C#" Value="public event EventHandler PreLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreLoad" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreLoad" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの前に発生する <see cref="E:System.Web.UI.Control.Load" /> イベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.PreLoad> イベントはすべてのポストバック データ処理との前に、 <xref:System.Web.UI.Control.Load> イベントです。 2 回目の試行する前にポストバック データを読み込むには、 <xref:System.Web.UI.Page.OnLoadComplete%2A> イベントです。 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/ja-jp/01e4f1bc-e55e-413f-98c7-6588493e5f67)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
      </Docs>
    </Member>
    <Member MemberName="PreRenderComplete">
      <MemberSignature Language="C#" Value="public event EventHandler PreRenderComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRenderComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreRenderComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページのコンテンツがレンダリングされる前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.PreRenderComplete> ページのライフ サイクルのプリレンダ リング段階が完了すると、イベントが発生します。 ページのライフ サイクルのこの段階ですべてのコントロールを作成、必要なすべての改ページを完了すると、およびページは、出力を表示する準備します。  
  
 これは、ページのビュー ステートを保存する前に発生した最後のイベントです。  
  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/ja-jp/01e4f1bc-e55e-413f-98c7-6588493e5f67)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
      </Docs>
    </Member>
    <Member MemberName="PreviousPage">
      <MemberSignature Language="C#" Value="public System.Web.UI.Page PreviousPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page PreviousPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PreviousPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のページにコントロールを移動するページを取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.Page" /> コントロールを現在のページに転送のページを表示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用すると、 <xref:System.Web.HttpServerUtility.Transfer%2A> 発生元のページにはメソッドまたは処理の 1 つの ASP.NET ページの転送を使用してページ間ポスティングは先のページに必要な可能性のある情報要求にはが含まれています。 使用することができます、 <xref:System.Web.UI.Page.PreviousPage%2A> プロパティをその情報にアクセスします。  
  
 \(、転送または別のページからのクロス投稿\)、直接の要求の結果として、現在のページを表示しているかどうか、 <xref:System.Web.UI.Page.PreviousPage%2A> プロパティを含む `null`します。  
  
   
  
## 例  
 次の例は、2 つの部分があります。 1 つは、使用する ASP.NET ページ、 <xref:System.Web.HttpServerUtility.Transfer%2A> としてページ モデルで公開されているメソッド `Server.Transfer("path")`します。 2 つ目を使用するターゲット ページ、 <xref:System.Web.UI.Page.PreviousPage%2A> 最初のページのタイトルを取得するプロパティです。  
  
 [!code-csharp[System.Web.UI.Page.PreviousPage\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Main.aspx#1)]
 [!code-vb[System.Web.UI.Page.PreviousPage\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Main.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.PreviousPage\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Notify.aspx#2)]
 [!code-vb[System.Web.UI.Page.PreviousPage\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Notify.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在のユーザーは、前のページにアクセスは許可されません。  
  
 または  
  
 ASP.NET ルーティングが使用されており、前のページの URL は、ルーティングの URL。 ASP.NET は、アクセス許可をチェックし、URL がファイルへの実際のパスであると仮定します。 これはルーティングの URL を使用してケースではないため、チェックは失敗します。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void ProcessRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Web.HttpContext" /> 組み込みサーバー オブジェクトへの参照を提供するオブジェクト \(たとえば、 <see cref="P:System.Web.HttpContext.Request" />, 、<see cref="P:System.Web.HttpContext.Response" />, 、および <see cref="P:System.Web.HttpContext.Session" />\) HTTP 要求を処理するために使用します。</param>
        <summary>組み込みのサーバー オブジェクトを設定、 <see cref="T:System.Web.UI.Page" /> などのオブジェクト、 <see cref="P:System.Web.UI.Page.Context" />, 、<see cref="P:System.Web.UI.Page.Request" />, 、<see cref="P:System.Web.UI.Page.Response" />, 、および <see cref="P:System.Web.UI.Page.Application" /> プロパティです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは呼び出さないでください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Context" />
        <altmember cref="P:System.Web.UI.Page.Request" />
        <altmember cref="P:System.Web.UI.Page.Response" />
        <altmember cref="P:System.Web.UI.Page.Application" />
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(class System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RaisePostBackEvent(System.Web.UI.IPostBackEventHandler,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceControl" Type="System.Web.UI.IPostBackEventHandler" />
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceControl">ポストバックを発生させた ASP.NET サーバー コントロール。 このコントロールを実装する必要があります、 <see cref="T:System.Web.UI.IPostBackEventHandler" /> インターフェイスです。</param>
        <param name="eventArgument">ポストバックの引数。</param>
        <summary>ポストバックを発生させたサーバー コントロールに通知受信ポストバック イベントを処理する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page> オブジェクトの呼び出し、 <xref:System.Web.UI.Page.RaisePostBackEvent%2A> ポストバックが発生した場合は、メソッドです。 この呼び出しは、事前に行われる前に、読み込みおよび変更通知が完了した後、ページのライフ サイクルで発生します。  
  
   
  
## 例  
 次の例では、 <xref:System.Web.UI.Page.RaisePostBackEvent%2A> とカスタム ポストバック イベントが発生するように ASP.NET を通知するメソッドを `userButton` サーバー コントロールがクリックされました。  
  
 [!code-csharp[Page\_RaisePostBackEvent\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page\_RaisePostBackEvent\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterArrayDeclaration(string arrayName, string arrayValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">値を宣言する配列の名前。</param>
        <param name="arrayValue">配列に格納する値。</param>
        <summary>ページがレンダリングされるように ECMAScript 配列宣言として宣言されている値を宣言します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この方法は、クライアント スクリプト ライブラリを同じ種類のすべてのコントロールで処理できるように、配列内における自体を宣言するスクリプト ベースのコントロールで使用できます。  
  
 <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> メソッドの使用は推奨されていません。 使用して、 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> メソッドで、 <xref:System.Web.UI.ClientScriptManager> クラスです。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> 、配列を宣言するメソッド `myArray`, 、という 3 つのオブジェクトを含む `x`, 、`y`, 、および `z`です。 例で定義して登録を使用してスタートアップ スクリプト、 <xref:System.Web.UI.Page.RegisterStartupScript%2A> メソッドです。 ときに、ECMAScript `doClick` 関数は次のコードが含まれるページから呼び出されますが、配列とそのオブジェクトを初期化します。  
  
 [!code-csharp[Page\_RegisterArrayDeclaration\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/CS/page_registerarraydeclaration.cs.aspx#1)]
 [!code-vb[Page\_RegisterArrayDeclaration\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/VB/page_registerarraydeclaration.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncTask">
      <MemberSignature Language="C#" Value="public void RegisterAsyncTask (System.Web.UI.PageAsyncTask task);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterAsyncTask(class System.Web.UI.PageAsyncTask task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Web.UI.PageAsyncTask" />
      </Parameters>
      <Docs>
        <param name="task">A <see cref="T:System.Web.UI.PageAsyncTask" /> 、非同期タスクを定義します。</param>
        <summary>ページの新しい非同期タスクを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、非同期タスクを定義する、 <xref:System.Web.UI.PageAsyncTask> クラスです。 タスクが定義されている場合に使用して、 <xref:System.Web.UI.Page.RegisterAsyncTask%2A> ページで、タスクを登録します。 タスクを登録すると、起動、 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> 、非同期タスクを開始するメソッドです。  
  
 <xref:System.Web.UI.Page.RegisterAsyncTask%2A> メソッドは、同期および非同期のページで使用できます。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.Page.AsyncTimeout%2A> プロパティを <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> と <xref:System.Web.UI.Page.RegisterAsyncTask%2A> メソッドです。 開始、終了、およびタイムアウト ハンドラーの使用に注意してください。 指定されているタスクに割り当てられた時間を超える、非同期タスクの状況を示す例では、人為的な遅延が導入された、 <xref:System.Web.UI.Page.AsyncTimeout%2A> プロパティです。 実際のシナリオで非同期タスクは、データベースの呼び出しまたはイメージの生成を実行するために使用でしたやなどのタイムアウト ハンドラーは、一定の期間でタスクを実行していない場合に正常なパフォーマンス低下を提供します。  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">非同期操作は <see langword="null" />です。</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public virtual void RegisterClientScriptBlock (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterClientScriptBlock(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterClientScriptBlock(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">スクリプト ブロックを識別する一意のキー。</param>
        <param name="script">クライアントに送信されるスクリプトの内容。</param>
        <summary>クライアント側\-スクリプト ブロックの応答を出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クライアント側スクリプトの出力の開始タグの直後に、 <xref:System.Web.UI.Page> オブジェクトの `<form runat= server>` 要素。 タグと終了を含めるようにしてください `<script>` スクリプトの周りに要素をブロックに指定された文字列、 `script` パラメーター。  
  
 このメソッドは、スクリプト ブロックを識別するために、キーを使用するため、スクリプト ブロックが別のサーバー コントロールのインスタンスから要求されるたびに、出力ストリームに出力する必要はありません。 キーを使用すると、別のコントロールのスクリプト ブロックが互いに干渉する可能性も低下します。  
  
 いずれかのスクリプトでは、同じブロック `key` パラメーターの値が重複と見なされます。  
  
> [!NOTE]
>  要求元のブラウザーがスクリプトをサポートしていない場合は表示しないように、HTML コメント タグでスクリプトを囲んでおいてください。  
  
 <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> メソッドの使用は推奨されていません。 使用して、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> メソッドで、 <xref:System.Web.UI.ClientScriptManager> クラスの代わりにします。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> メソッドと組み合わせて、 <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> メソッドです。 コード宣言ブロックで ECMAScript が既に登録されていない場合、によって決定される <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, 、 <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> 呼び出しが行われます。  
  
 [!code-csharp[System.Web.UI.Page.RegisterClientScriptBlock\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.RegisterClientScriptBlock\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public virtual void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">レンダリングされる非表示フィールドの一意の名前。</param>
        <param name="hiddenFieldInitialValue">非表示のフォームに出力される値です。</param>
        <summary>フォーム上の隠しフィールドを自動的に登録するサーバー コントロールを使用します。 フィールドに送信される、 <see cref="T:System.Web.UI.Page" /> オブジェクトと、 <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> サーバー コントロールを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.RegisterHiddenField%2A> メソッドの使用は推奨されていません。 使用して、 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> メソッドで、 <xref:System.Web.UI.ClientScriptManager> クラスです。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.UI.Page.RegisterHiddenField%2A> ECMAScript コードを作成するためにメソッドが要求元のブラウザーに渡されます。 非表示フィールドの名前に設定されている `myHiddenField` し、その値が「Microsoft へようこそ\!」に設定<xref:System.Web.UI.Page.RegisterStartupScript%2A> メソッドの呼び出し、 `myHiddenField` 値のユーザーがページ上のボタンをクリックするとします。  
  
> [!IMPORTANT]
>  この例には、潜在的なセキュリティ上の脅威が非表示フィールドがあります。 既定では、テキスト ボックスの値を同じように、非表示フィールドの値を検証する必要があります。 ASP.NET Web ページでは、ユーザー入力にスクリプトまたは HTML 要素が含まれていないことを検証します。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Page\_RegisterHiddenField\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#1)]
 [!code-vb[Page\_RegisterHiddenField\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterOnSubmitStatement(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterOnSubmitStatement(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">スクリプト ブロックを識別する一意のキー。</param>
        <param name="script">クライアントに送信するクライアント側スクリプトです。</param>
        <summary>ページにアクセスして、クライアントは、 <see langword="OnSubmit" /> イベントです。 スクリプトには、他の場所で登録されているクライアント コードの関数呼び出しを指定する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> メソッドの使用は推奨されていません。 使用して、 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> メソッドで、 <xref:System.Web.UI.ClientScriptManager> クラスです。  
  
   
  
## 例  
 次のコード例では、使用方法を示します、 <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> クライアント側の送信\] ボタンがクリックされたときに応答するスクリプトにアクセスします。 このイベントが発生したときは、登録済みの ECMAScript コードがクライアントで実行されます。  
  
> [!IMPORTANT]
>  この例には、潜在的なセキュリティ上の脅威が非表示フィールドがあります。 既定では、テキスト ボックスの値を同じように、非表示フィールドの値を検証する必要があります。 ASP.NET Web ページでは、ユーザー入力にスクリプトまたは HTML 要素が含まれていないことを検証します。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Page\_RegisterHiddenField\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#2)]
 [!code-vb[Page\_RegisterHiddenField\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void RegisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">登録するコントロール。</param>
        <summary>コントロールの状態を永続化する必要がありますとしてコントロールを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロールの状態を使用するカスタム サーバー コントロールを呼び出す必要があります、 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> メソッド要求のたびにコントロールの状態のための登録が引き継がれません要求からの要求にポストバック イベントの中であるためです。 登録が発生することをお勧めしますが、 <xref:System.Web.UI.Control.Init> イベントです。  
  
   
  
## 例  
 次のコード例は、カスタム サーバー コントロールの呼び出しを示しています、 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> メソッドです。  
  
 [!code-csharp[ControlState\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">登録するコントロールは <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" /> メソッドを呼び出す前にのみ、または中に、 <see cref="E:System.Web.UI.Control.PreRender" /> イベントです。</exception>
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresPostBack">
      <MemberSignature Language="C#" Value="public void RegisterRequiresPostBack (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresPostBack(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">登録するコントロール。</param>
        <summary>ページがサーバーにポストされたときにポストバック処理を必要とする 1 つとして、コントロールを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 登録するコントロールを実装する必要があります、 <xref:System.Web.UI.IPostBackDataHandler> インターフェイスまたは <xref:System.Web.HttpException> が発生します。 コントロールによって実装された場合、 <xref:System.Web.UI.IPostBackDataHandler> インターフェイスによりのポストバック データの処理と任意の投稿の発生が変更されたデータのイベントをバックアップします。 サーバー コントロールのイベント モデルの詳細については、次を参照してください。 [ASP.NET Server Control Event Model](http://msdn.microsoft.com/ja-jp/6304bff7-1b0e-4641-8acb-6d3b0badc4a3)します。  
  
 以前のページにコントロールを登録、 `Page_PreRender` ページのライフ サイクルのイベントです。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.UI.Page.RegisterRequiresPostBack%2A> メソッドをテキスト ボックス コントロールを必要とする `myTextBox`, 、テキスト ボックスに関連付けられたコードを実行前に戻るの投稿をします。<xref:System.Web.UI.WebControls.TextBox> コントロールで、実装、 <xref:System.Web.UI.IPostBackDataHandler> インターフェイスです。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Page\_RegisterRequiresPostBack\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/CS/page_registerrequirespostback.cs.aspx#1)]
 [!code-vb[Page\_RegisterRequiresPostBack\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/VB/page_registerrequirespostback.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">登録するコントロールが実装していません、 <see cref="T:System.Web.UI.IPostBackDataHandler" /> インターフェイスです。</exception>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresRaiseEvent">
      <MemberSignature Language="C#" Value="public virtual void RegisterRequiresRaiseEvent (System.Web.UI.IPostBackEventHandler control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterRequiresRaiseEvent(class System.Web.UI.IPostBackEventHandler control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresRaiseEvent(System.Web.UI.IPostBackEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.IPostBackEventHandler" />
      </Parameters>
      <Docs>
        <param name="control">登録するコントロール。</param>
        <summary>1 つのコントロールが処理されるときに発生するイベントが必要とする ASP.NET サーバー コントロールを登録、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ページ要求ごとに 1 台のサーバー コントロールを登録できます。<xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> コントロールがフォーム内の ID データを送信する、コントロールが含まれない場合に使用する必要があります。 また、登録されているコントロールを実装する必要があります、 <xref:System.Web.UI.IPostBackEventHandler> インターフェイスです。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> を登録するメソッド、 <xref:System.Web.UI.WebControls.Button> Web サーバー コントロールでイベントを発生させる必要であるとします。 最初の登録が完了する <xref:System.Web.UI.WebControls.Button> コントロール、2 つ目になる <xref:System.Web.UI.WebControls.Button> 最初のボタンの結果を投稿するコードで宣言されたコントロールがページにイベントをクリックします。  
  
 [!code-csharp[Page\_RaisePostBackEvent\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page\_RaisePostBackEvent\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresViewStateEncryption">
      <MemberSignature Language="C#" Value="public void RegisterRequiresViewStateEncryption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresViewStateEncryption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>1 つが必要なビュー ステートの暗号化とコントロールをページに登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 可能性のある機密情報を処理するカスタム コントロールを開発している場合、 <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A> メソッドは、ページにコントロールを登録し、ビュー ステートをコントロールの暗号化を確認します。  
  
 場合、ページ全体の状態が暗号化されることは、 <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> に設定されている <xref:System.Web.UI.ViewStateEncryptionMode.Auto> または <xref:System.Web.UI.ViewStateEncryptionMode.Always>です。  
  
   
  
## 例  
 ビュー ステートの暗号化モードを設定する次のコード例を示します、 <xref:System.Web.UI.Page> オブジェクトとをビュー ステートの暗号化を要求している <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>します。 この例では、ビュー ステートをデータベースから顧客情報を取得時に暗号化されます。  
  
 [!code-csharp[System.Web.UI.ViewStateEncryptionMode\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/CS/encryptViewState.cs.aspx#1)]
 [!code-vb[System.Web.UI.ViewStateEncryptionMode\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/VB/encryptViewState.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" /> 前に、またはページの中に、メソッドを呼び出す必要があります <see langword="PreRender" />ページ ライフ サイクルのフェーズです。</exception>
        <altmember cref="P:System.Web.UI.Page.ViewStateEncryptionMode" />
        <altmember cref="T:System.Web.UI.WebControls.GridView" />
        <altmember cref="T:System.Web.UI.WebControls.DetailsView" />
        <altmember cref="T:System.Web.UI.WebControls.FormView" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public virtual void RegisterStartupScript (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterStartupScript(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterStartupScript(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">スクリプト ブロックを識別する一意のキー。</param>
        <param name="script">クライアントに送信されるスクリプトの内容。</param>
        <summary>ページの応答内のクライアント側のスクリプト ブロックを出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ような <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> 、メソッド、 <xref:System.Web.UI.Page.RegisterStartupScript%2A> メソッドの終了タグの直前に、スクリプトの生成、 <xref:System.Web.UI.Page> オブジェクトの `<form runat= server>` 要素。 タグと終了を含めるようにしてください `<script>` スクリプトの周りに要素をブロックに指定された文字列、 `script` パラメーター。  
  
 このメソッドは、スクリプト ブロックを識別するために、キーを使用するため、スクリプト ブロックが別のサーバー コントロールのインスタンスから要求されるたびに、出力ストリームに出力するには  
  
 いずれかのスクリプトでは、同じブロック `key` パラメーターの値が重複と見なされます。  
  
> [!NOTE]
>  要求元のブラウザーがスクリプトをサポートしていない場合は表示しないように、HTML コメント タグでスクリプトを囲んでおいてください。  
  
 <xref:System.Web.UI.Page.RegisterStartupScript%2A> メソッドの使用は推奨されていません。 使用して、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> メソッドで、 <xref:System.Web.UI.ClientScriptManager> クラスの代わりにします。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.Page.RegisterStartupScript%2A> メソッドと組み合わせて、 <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> メソッドです。 コード宣言ブロックで記述された ECMAScript が既に登録されていない場合、によって決定される、 <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> 、メソッド、 <xref:System.Web.UI.Page.RegisterStartupScript%2A> 呼び出しが行われます。  
  
 [!code-csharp[System.Web.UI.Page.RegisterClientScriptBlock\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.RegisterClientScriptBlock\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterViewStateHandler">
      <MemberSignature Language="C#" Value="public void RegisterViewStateHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterViewStateHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterViewStateHandler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>永続化するページのビュー ステートと呼ばれる場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.RegisterViewStateHandler%2A> 経由メソッドで自動的に呼び出され、 <xref:System.Web.UI.HtmlControls.HtmlForm> サーバー コントロール。 このメソッドが呼び出されなかった場合、ページのビュー状態は保持されません。  
  
> [!NOTE]
>  通常、のみ、 <xref:System.Web.UI.HtmlControls.HtmlForm> ページのサーバー コントロールは、このメソッドを呼び出します。  
  
   
  
## 例  
 [!code-csharp[Page\_RegisterViewStateHandler\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterViewStateHandler/CS/page_registerviewstatehandler.cs#1)]
 [!code-vb[Page\_RegisterViewStateHandler\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterViewStateHandler/VB/page_registerviewstatehandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> ページ内容を受け取る。</param>
        <summary>初期化、 <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトとの子コントロールでの呼び出し、 <see cref="T:System.Web.UI.Page" /> をレンダリングします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.Render%2A> メソッドは、テキスト、およびクライアントのブラウザーに送信されるマークアップを作成するために行います。 既定値 <xref:System.Web.UI.Page.Render%2A> メソッドの呼び出し <xref:System.Web.UI.Control.RenderChildren%2A> テキストと、ページに含まれるコントロールのマークアップを記述します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Web.HttpRequest" /> 、要求されたページのオブジェクト。</summary>
        <value>現在 <see cref="T:System.Web.HttpRequest" /> ページに関連付けられています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.HttpRequest> オブジェクトには、現在の HTTP 要求に関する情報が含まれています。  
  
   
  
## 例  
 次の例では、取得、 <xref:System.Web.HttpRequest.Headers%2A> コレクションから、 <xref:System.Web.HttpRequest> オブジェクト、ASP.NET ページに書き込みます。  
  
 [!code-csharp[Classic HttpRequest.Headers Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">発生したときに、 <see cref="T:System.Web.HttpRequest" /> オブジェクトは使用できません。</exception>
        <altmember cref="T:System.Web.HttpException" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequiresControlState">
      <MemberSignature Language="C#" Value="public bool RequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> コントロールの状態の要件を確認します。</param>
        <summary>決定するかどうか、指定した <see cref="T:System.Web.UI.Control" /> コントロール状態管理に参加するオブジェクトを登録します。</summary>
        <returns>
          <see langword="true" /> 場合は、指定した <see cref="T:System.Web.UI.Control" /> 制御が必要です状態以外の場合、 <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロールの状態は、Web サーバー コントロールが機能するために必要な重要なのビュー ステート データから成るオブジェクトこれは通常のビュー ステートから別のオブジェクトに含まれています。  
  
 コントロールの状態を使用してカスタム コントロールを呼び出す必要があります、 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> コントロールの状態を保存する前にメソッドです。 使用して、 <xref:System.Web.UI.Page.RequiresControlState%2A> ページ コントロールの状態を要求するように登録されているコントロールをチェックするメソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.PageStatePersister.ControlState" />
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Page" /> オブジェクトに関連付けられている <see cref="T:System.Web.HttpResponse" /> オブジェクトを取得します。 このオブジェクトは、HTTP 応答データをクライアントに送信することができます、その応答に関する情報が含まれています。</summary>
        <value>現在 <see cref="T:System.Web.HttpResponse" /> ページに関連付けられています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例は、cookie を作成してを使用して、ページの HTTP 出力への追加を示しています、 <xref:System.Web.HttpResponse> オブジェクトです。  
  
 [!code-csharp[Classic HttpResponse.Cookies Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="T:System.Web.HttpResponse" /> オブジェクトは使用できません。</exception>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="ResponseEncoding">
      <MemberSignature Language="C#" Value="public string ResponseEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResponseEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ResponseEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のエンコーディングの言語設定 <see cref="T:System.Web.HttpResponse" /> オブジェクトです。</summary>
        <value>現在のエンコーディングの言語を表す文字列 <see cref="T:System.Web.HttpResponse" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `ResponseEncoding` 属性を .aspx ファイルで、ディレクティブを使用する値にします。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData RouteData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteData RouteData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.RouteData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="P:System.Web.Routing.RequestContext.RouteData" /> 、現在の <see cref="T:System.Web.Routing.RequestContext" /> インスタンス。</summary>
        <value>
          <see cref="P:System.Web.Routing.RequestContext.RouteData" /> 、現在の <see cref="T:System.Web.Routing.RequestContext" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ページが ASP.NET ルーティングを通じて行われた要求への応答で実行されている場合、このプロパティは、ルート データとして渡された URL パラメーターの値へのアクセスを提供します。 このプロパティは、実行する場合、ページのルート URL ではなく物理的な URL への応答で、 `null`です。 次の例は、名前は、URL パラメーターの値を抽出する方法を示しています。 `year`します。  
  
 \[Visual Basic\]  
  
```  
Dim year As Integer = Convert.ToInt32(Page.RouteData.Values("year"))  
```  
  
 \[C\#\]  
  
```  
int year = Convert.ToInt32(Page.RouteData.Values["year"])  
```  
  
 URL パターンを使用して、ルートが定義されているかどうかは `{locale}/{year}` ドメインの `contoso.com`, 、および要求された URL が `contoso.com/US/2010`, 、`year` 「2010」が実行されるコードでこの値が含まれます。  
  
 ASP.NET のルーティングの詳細については、次を参照してください。 [ASP.NET Routing](http://msdn.microsoft.com/ja-jp/892441af-8f1d-483e-ab5f-b82c23576f5a)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Routing.RequestContext.RouteData" />
      </Docs>
    </Member>
    <Member MemberName="SavePageStateToPersistenceMedium">
      <MemberSignature Language="C#" Value="protected virtual void SavePageStateToPersistenceMedium (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> ビューステート情報を格納します。</param>
        <summary>ページのビュー ステートとコントロールの状態情報を保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> メソッドの使用方法、 <xref:System.Web.UI.PageStatePersister.Save%2A> のメソッド、 <xref:System.Web.UI.PageStatePersister?displayProperty=fullName> によって参照されるオブジェクト、 <xref:System.Web.UI.Page.PageStatePersister%2A> プロパティ ページのビュー ステートとコントロールの状態の情報を保存します。  
  
 ASP.NET には、2 つの子孫が含まれています、 <xref:System.Web.UI.PageStatePersister> クラス、 <xref:System.Web.UI.HiddenFieldPageStatePersister> ASP.NET ページに含まれる非表示フィールドに状態情報を保存するクラスと <xref:System.Web.UI.SessionPageStatePersister> で状態を保存するクラス、 <xref:System.Web.UI.Page.Session%2A> 要求に関連付けられているオブジェクト。 使用する場合、 <xref:System.Web.UI.SessionPageStatePersister> ポスト バックを決定するのに使用すると、VIEWSTATE の非表示フィールドがまだ表示されるクラスです。  
  
 任意の場所で状態を保存する必要があります新規に作成するの子孫、 <xref:System.Web.UI.PageStatePersister> クラスを保存し、任意の永続化中に状態を読み込みます。 新しいを作成する例については <xref:System.Web.UI.PageStatePersister> オブジェクトを参照してください、 <xref:System.Web.UI.PageStatePersister> クラスです。  
  
 .NET Framework version 1.0 または 1.1 では、保存する場合は、このメソッドをオーバーライドを使用している場合、 <xref:System.Web.UI.Page> 状態で非表示フィールド以外のものです。 オーバーライドするように選択した場合、 <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="SaveStateComplete">
      <MemberSignature Language="C#" Value="public event EventHandler SaveStateComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SaveStateComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.SaveStateComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページには、すべての状態とコントロールのビューステート情報は、ページの保存が完了した後に発生し、ページを制御します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 後に Web ページのコントロールの状態情報が保存された、 <xref:System.Web.UI.Page.PreRenderComplete> イベントです。<xref:System.Web.UI.Page.SaveStateComplete> ビュー ステートとページのコントロールの状態の後にイベントが発生し、ページ上のコントロールは、永続化に使用するメディアに保存します。  
  
 これは、最後のイベント、ページが要求元のブラウザーにレンダリングされる前に発生します。  
  
 イベント処理の詳細については、「[Handling and Raising Events](http://msdn.microsoft.com/ja-jp/b6f65241-e0ad-4590-a99f-200ce741bb1f)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see langword="Server" /> インスタンスであるオブジェクトの <see cref="T:System.Web.HttpServerUtility" /> クラスです。</summary>
        <value>現在 <see langword="Server" /> ページに関連付けられているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、頻繁に使用されるへのアクセスを提供 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> と <xref:System.Web.HttpServerUtility.MapPath%2A> の他の方法です。  
  
   
  
## 例  
 次のコード例を使用して、サーバーからエラー情報にアクセスする方法を示しています、 `Server` オブジェクトです。 具体的には、例がから要求された URL を取得、 `Request` オブジェクトから最新のエラー、 `Server` オブジェクト \(を使用して、 <xref:System.Web.HttpServerUtility.GetLastError%2A> メソッド\) と、その両方をクライアントによって表示される文字列に変換します。 1 回、 `message` 変数は、クライアントへの書き込みを使用して、エラーを削除、 <xref:System.Web.HttpServerUtility.ClearError%2A> メソッドです。  
  
 [!code-csharp[System.Web.UI.Page\_Error method\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Error method/CS/sourcecs.aspx#1)]
 [!code-vb[System.Web.UI.Page\_Error method\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Error method/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpServerUtility" />
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public virtual System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の取得 <see langword="Session" /> ASP.NET によって提供されるオブジェクト。</summary>
        <value>現在のセッション状態データ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、現在の要求のセッションに関する情報を提供します。 A `Session` ASP.NET アプリケーションからのページまたはドキュメントを要求するユーザーごとにオブジェクトが保持されます。 変数に格納されている、 `Session` 、ユーザーがアプリケーションでページ間を移動すると、オブジェクトが破棄されません。 ユーザーは、アプリケーション内のページにアクセスする限り、その代わりに、これらの変数を永続化します。 セッション状態の詳細については、次を参照してください。 [ASP.NET Session State Overview](http://msdn.microsoft.com/ja-jp/6d60d381-6521-4e1d-9089-da6464f2a9bc)します。  
  
   
  
## 例  
 次のコード例を作成、 `GetStyle` Web フォーム ページのセッション状態に格納されたキーを取得し、その値を文字列に変換する関数。  
  
 [!code-csharp[Page.Session\_Samples1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Session_Samples1/CS/sessioncs.aspx#1)]
 [!code-vb[Page.Session\_Samples1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Session_Samples1/VB/sessionvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">セッション情報が設定されているときに発生 <see langword="null" />します。</exception>
        <altmember cref="T:System.Web.HttpException" />
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">フォーカスを設定するコントロールの ID。</param>
        <summary>指定した識別子を持つコントロールには、ブラウザーのフォーカスを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Page.SetFocus%2A> 、ブラウザーで表示される Web ページのアクティブなコントロールの文字列を指定した ID を持つコントロールを作成するメソッドです。<xref:System.Web.UI.Page.SetFocus%2A> ページがクライアントにレンダリング用に準備する前に、メソッドを呼び出す必要があります、 <xref:System.Web.UI.Control.PreRender> イベントです。  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A> メソッドは ECMAScript 1.3 またはそれ以降のバージョンをサポートするブラウザーでのみ機能します。  
  
   
  
## 例  
 次のコード例は、Web ページで、2 つ目のテキスト ボックスに、フォーカスを設定します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[PageSetFocus\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbyidcs.aspx#1)]
 [!code-vb[PageSetFocus\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbyidvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="clientID" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> コントロールは、Web フォーム ページの一部ではないときに呼び出されます。  
  
 または  
  
 <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> 後に呼び出されますが、 <see cref="E:System.Web.UI.Control.PreRender" /> イベントです。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">フォーカスを受け取るコントロール。</param>
        <summary>ブラウザーのフォーカスを、指定したコントロールに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Page.SetFocus%2A> を指定したコントロールのブラウザーで表示する Web ページ上のアクティブ コントロールを作成するメソッドです。<xref:System.Web.UI.Page.SetFocus%2A> ページがクライアントにレンダリング用に準備する前に、メソッドを呼び出す必要があります、 <xref:System.Web.UI.Control.PreRender> イベントです。  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A> メソッドは ECMAScript 1.3 またはそれ以降のバージョンをサポートするブラウザーでのみ機能します。  
  
   
  
## 例  
 次のコード例は、Web ページで、2 つ目のテキスト ボックスに、フォーカスを設定します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[PageSetFocus\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbycontrolcs.aspx#2)]
 [!code-vb[PageSetFocus\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbycontrolvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> コントロールは、Web フォーム ページの一部ではないときに呼び出されます。  
  
 または  
  
 <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> 後に呼び出されますが、 <see cref="E:System.Web.UI.Control.PreRender" /> イベントです。</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipFormActionValidation">
      <MemberSignature Language="C#" Value="public bool SkipFormActionValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipFormActionValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SkipFormActionValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはクエリ文字列の値を検証するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> クエリ文字列の検証をスキップする必要がある場合 \(クエリ文字列を検証しない\) です。それ以外の場合、 <see langword="false" /> クエリ文字列の検証が実行している場合は、通常どおり配置します。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SmartNavigation">
      <MemberSignature Language="C#" Value="public bool SmartNavigation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SmartNavigation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SmartNavigation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is Page.SetFocus and Page.MaintainScrollPositionOnPostBack. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スマート移動できるかどうかを示す値を取得または設定します。 このプロパティの使用は推奨されていません。</summary>
        <value>スマート移動が有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`SmartNavigation`属性を`true`.aspx ファイルでは、ディレクティブにします。 ページが要求されると、動的に生成されたクラスは、このプロパティを設定します。  
  
> [!NOTE]
>  ASP.NET version 2.0 では、<xref:System.Web.UI.Page.SmartNavigation%2A>プロパティは推奨されなくなりました。 使用して、<xref:System.Web.UI.Page.SetFocus%2A>メソッドおよび<xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A>プロパティ代わりにします。  
  
 ページが Internet Explorer 5.5 ブラウザー、または後で、スマート ナビゲーションによって要求された場合は次を実行してページのユーザーのエクスペリエンスが向上します。  
  
-   ナビゲーションの原因となった flash を排除することです。  
  
-   ページ間を移動するときは、スクロール位置を保持します。  
  
-   ナビゲーションの間で要素のフォーカスを保持します。  
  
-   ブラウザーの履歴の最後のページ状態のみを保持します。  
  
 戻り時に大幅に変化しない visual のコンテンツが頻繁なポストバックを必要とする ASP.NET ページで、スマート ナビゲーションが最も適しています。 このプロパティを設定するかどうかを決定する際に慎重に検討この`true`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.Page.SetFocus" />
        <altmember cref="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      </Docs>
    </Member>
    <Member MemberName="StyleSheetTheme">
      <MemberSignature Language="C#" Value="public virtual string StyleSheetTheme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StyleSheetTheme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.StyleSheetTheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページのライフ サイクルの早い段階で、ページに適用されているテーマの名前を設定します。</summary>
        <value>ページのライフ サイクルの早い段階で、ページに適用されているテーマの名前です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、カスケード スタイル シート \(CSS\) に直接参照していません。 プロパティには、その中の CSS ファイルを含めることができる ASP.NET のテーマの名前が含まれています。  
  
 <xref:System.Web.UI.Page.StyleSheetTheme%2A> プロパティは、一方にページのライフ サイクルの早い段階で、ページに適用されているテーマの名前を指定、 <xref:System.Web.UI.Page.Theme%2A> プロパティ ページのライフ サイクルの後半のページに適用されているテーマの名前を指定します。 これは、\[ページ設定優先されるスタイル シートのテーマでの設定を意味します。 詳細については、「[ASP.NET Themes and Skins Overview](http://msdn.microsoft.com/ja-jp/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)」を参照してください。  
  
 通常、page ディレクティブまたはプロパティをオーバーライドすることでは、このプロパティの値を設定します。 については、次のトピックを参照してください。  
  
-   [How to: Apply ASP.NET Themes](http://msdn.microsoft.com/ja-jp/f9d72364-4d77-4b73-84be-7630dc63e0fe)  
  
-   [How to: Apply ASP.NET Themes Programmatically](http://msdn.microsoft.com/ja-jp/02eed7c3-01e8-4e20-8358-df47dbd4f148)\)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">設定しようとしましたが、 <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> 後プロパティ、 <see cref="M:System.Web.UI.Page.FrameworkInitialize" /> メソッドが呼び出されました。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> 無効なテーマの名前に設定されます。 この例外がスローされたときに、 <see cref="M:System.Web.UI.Page.FrameworkInitialize" /> プロパティ set アクセス操作子ではなく、メソッドが呼び出されます。</exception>
        <altmember cref="P:System.Web.UI.Page.Theme" />
      </Docs>
    </Member>
    <Member MemberName="Theme">
      <MemberSignature Language="C#" Value="public virtual string Theme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Theme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Theme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページのテーマの名前を設定します。</summary>
        <value>ページのテーマの名前です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.Theme%2A> プロパティ ページの使用されているテーマの名前を設定します。 テーマの設定よりも優先するために、ページ設定する場合は、使用、 <xref:System.Web.UI.Page.StyleSheetTheme%2A> プロパティです。 詳細については、「[ASP.NET Themes and Skins Overview](http://msdn.microsoft.com/ja-jp/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)」を参照してください。  
  
 <xref:System.Web.UI.Page.Theme%2A> 前にプロパティを設定する必要があります、 <xref:System.Web.UI.Page.PreInit> イベント; の設定、 <xref:System.Web.UI.Page.Theme%2A> 後プロパティ、 <xref:System.Web.UI.Page.PreInit> イベントが発生する、 <xref:System.InvalidOperationException> 例外です。  
  
 指定されたテーマは、アプリケーションまたはグローバルのテーマのいずれかとして存在する必要があります。 テーマが存在しない場合、 <xref:System.Web.HttpException> 例外がスローされます。  
  
   
  
## 例  
 次のコード例、 <xref:System.Web.UI.Page.Theme%2A> クエリ文字列に名前をプロパティに渡されます。  
  
 [!code-csharp[PageTheme\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageTheme/CS/pagethemecs.aspx#1)]
 [!code-vb[PageTheme\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageTheme/VB/pagethemevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">設定しようとした <see cref="P:System.Web.UI.Page.Theme" /> 後、 <see cref="E:System.Web.UI.Page.PreInit" /> イベントが発生しました。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.Theme" /> 無効なテーマの名前に設定されます。</exception>
        <altmember cref="P:System.Web.UI.Page.StyleSheetTheme" />
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページのタイトルを設定します。</summary>
        <value>ページのタイトルです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Page.Title%2A> プロパティを要求しているブラウザーに送信される HTML ヘッダーにページのタイトルを設定します。  
  
> [!NOTE]
>  含める必要があります、 `head` 要素、属性を持つ `runat="server"`, 、それ以外の場合、タイトルが表示されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.Title" /> プロパティ ページにヘッダー コントロールが必要です。</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlTitle" />
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Web.TraceContext" /> Web 要求を現在のオブジェクト。</summary>
        <value>データ、 <see cref="T:System.Web.TraceContext" /> Web 要求を現在のオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 トレースは、追跡し、Web 要求に関する実行の詳細を表示します。 ページに表示されるように、トレース データのページまたはアプリケーション レベルでトレースを有効にする必要があります。  
  
 既定では、ページのトレースが無効です。 ページのトレースを有効にするには、ディレクティブを使用して `<% @ Page trace="true" %>`します。 アプリケーション全体のトレースを有効にするには、アプリケーションの構成ファイル、アプリケーションのルート ディレクトリに配置され、web.config ファイルで有効にする必要があります。 詳細については、「[ASP.NET Tracing Overview](http://msdn.microsoft.com/ja-jp/1552561d-887c-4002-8770-f92662cdf416)」を参照してください。  
  
   
  
## 例  
 アクセスするコード例を次に示します、 <xref:System.Web.TraceContext.IsEnabled%2A?displayProperty=fullName> プロパティおよび <xref:System.Web.TraceContext.Write%2A?displayProperty=fullName> メソッドによって、 <xref:System.Web.UI.Page.Trace%2A> プロパティです。 このコードを呼び出し、 <xref:System.Diagnostics.Trace.Write%2A> メソッドをトレースする場合にのみが有効になって、 <xref:System.Web.UI.Page> オブジェクトです。 有効でない場合は、このコードは実行されません、アプリケーションのオーバーヘッドの削減に役立ちます。  
  
 [!code-csharp[System.Web.UI.Page.Trace\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Trace/CS/trace1cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Trace\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Trace/VB/trace1vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceEnabled">
      <MemberSignature Language="C#" Value="public bool TraceEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TraceEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>トレースが有効になっているかどうかを示す値を設定、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
        <value>
          <see langword="true" /> ページのトレースが有効になっている場合それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `Trace` 属性を `true` .aspx ファイルのディレクティブでします。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceModeValue" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceModeValue">
      <MemberSignature Language="C#" Value="public System.Web.TraceMode TraceModeValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.TraceMode TraceModeValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceModeValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>トレース ステートメントが、ページに表示されるモードを設定します。</summary>
        <value>いずれか、 <see cref="T:System.Web.TraceMode" /> 列挙型のメンバーです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `TraceMode` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceEnabled" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TransactionMode">
      <MemberSignature Language="C#" Value="protected int TransactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TransactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TransactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページのサポートのトランザクションのレベルを設定します。</summary>
        <value>いずれかを表す整数、 <see cref="T:System.EnterpriseServices.TransactionOption" /> 列挙型のメンバーです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `Transaction` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryUpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値プロバイダーから値を使用して、指定したモデルのインスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web フォームでモデルのバインディングの使用に関するチュートリアル シリーズは、次を参照してください。 [Model Binding and Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <summary>データ バインド コントロールから値を使用して、指定したモデルのインスタンスを更新します。</summary>
        <returns>
          <see langword="true" /> モデルのバインディングが成功した場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、データ バインド コントロールのによって指定されるメソッドからのみ呼び出す必要があります `UpdateMethod` または `InsertMethod` プロパティです。  
  
 Web フォームでモデルのバインディングの使用に関するチュートリアル シリーズは、次を参照してください。 [Model Binding and Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <param name="valueProvider">値プロバイダー。</param>
        <summary>指定した値プロバイダーから値を使用して、モデルのインスタンスを更新します。</summary>
        <returns>
          <see langword="true" /> モデルのバインディングが成功した場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web フォームでモデルのバインディングの使用に関するチュートリアル シリーズは、次を参照してください。 [Model Binding and Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UICulture">
      <MemberSignature Language="C#" Value="public string UICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UICulture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザー インターフェイス \(UI\) の ID を設定、 <see cref="T:System.Threading.Thread" /> ページに関連付けられているオブジェクト。</summary>
        <value>UI の id。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、ショートカットを <xref:System.Threading.Thread.CurrentThread%2A> プロパティです。 カルチャは、実行中のスレッドのプロパティ  
  
 設定、 `UICulture` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されたときに、動的に生成されたクラスは、このプロパティの値を設定します。 値を明示的に設定するさらに、 <xref:System.Web.UI.Page.UICulture%2A> プロパティに、Web.config ファイルのです。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
      </Docs>
    </Member>
    <Member MemberName="UniqueFilePathSuffix">
      <MemberSignature Language="C#" Value="protected virtual string UniqueFilePathSuffix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueFilePathSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブラウザーでキャッシュ ファイルのパスに追加する一意のサフィックスを取得します。</summary>
        <value>ファイル パスに追加する一意のサフィックスです。 既定値は"\_ufps \="さらに 6 桁の一意の数字です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.UniqueFilePathSuffix%2A> プロパティ ブラウザーのキャッシュに必要な場合は、ファイル パスの末尾に付加される文字列を返します。 この文字列は、特定の要求に関連付けられているファイルのパスを識別するために使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnobtrusiveValidationMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.UnobtrusiveValidationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または控え目な JavaScript をクライアント側の検証に使用するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> 控え目な JavaScript を使用する場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void UnregisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UnregisterRequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> コントロールの状態の永続化を停止します。</param>
        <summary>指定したコントロールのコントロールの状態の永続化を停止します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロールの状態を使用するカスタム サーバー コントロールを呼び出す必要があります、 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> 要求のたびに、状態が永続化します。 コントロールの状態のための登録が引き継がれません要求から要求をポストバック時にします。 使用して、 <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> ポストバックの永続化する必要がなくなったコントロールに対して、コントロールの状態が永続化されないことを確認します。  
  
 内部的には、 <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> を使用する場合、メソッドが呼び出される、 <xref:System.Web.UI.Control.RemovedControl%2A> controls コレクションから、コントロールを削除する方法です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Web.UI.Control" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値プロバイダーから値を使用して、指定したモデルのインスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web フォームでモデルのバインディングの使用に関するチュートリアル シリーズは、次を参照してください。 [Model Binding and Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <summary>データ バインド コントロールから値を使用して、指定したモデルのインスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、データ バインド コントロールのによって指定されるメソッドからのみ呼び出す必要があります `UpdateMethod` または `InsertMethod` プロパティです。  
  
 Web フォームでモデルのバインディングの使用に関するチュートリアル シリーズは、次を参照してください。 [Model Binding and Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <param name="valueProvider">値プロバイダー。</param>
        <summary>指定した値プロバイダーから値を使用して指定されたモデル インスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web フォームでモデルのバインディングの使用に関するチュートリアル シリーズは、次を参照してください。 [Model Binding and Web Forms](http://go.microsoft.com/fwlink/?LinkId=286117)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ要求を行っているユーザーに関する情報を取得します。</summary>
        <value>
          <see cref="T:System.Security.Principal.IPrincipal" /> ページ要求を行っているユーザーを表します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Security.Principal.IPrincipal> オブジェクトはそのユーザーの id を含め、コードが実行されている対象のユーザーや所属するロールのセキュリティ コンテキストを表します。  
  
 このプロパティを使用して、 <xref:System.Web.HttpContext> オブジェクトの <xref:System.Web.HttpContext.User%2A> 要求が行われた操作を決定するプロパティです。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.UI.Page.User%2A> プロパティを現在のユーザーの認証と id 情報にアクセスします。 ユーザーが認証されていない場合にログイン ページにリダイレクトします。  
  
 [!code-csharp[Page\_User\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_User/CS/page_user.cs.aspx#1)]
 [!code-vb[Page\_User\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_User/VB/page_user.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Security.Principal.IPrincipal" />
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>割り当てられている情報を検証するページに含まれる検証コントロールに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ユーザーが任意の ASP.NET サーバー コントロールがクリックしたときに、このメソッドが呼び出され、 `CausesValidation` プロパティに設定 `true`, 、既定であります。 含まれます、 <xref:System.Web.UI.WebControls.Button>, 、<xref:System.Web.UI.WebControls.ImageButton>, 、および <xref:System.Web.UI.WebControls.LinkButton> Web サーバー コントロール、 <xref:System.Web.UI.HtmlControls.HtmlInputButton>, 、<xref:System.Web.UI.HtmlControls.HtmlInputImage>, 、および <xref:System.Web.UI.HtmlControls.HtmlButton> HTML サーバー コントロール、およびが自動的にポストバック サーバーなどのコントロール、 <xref:System.Web.UI.WebControls.TextBox>, 、<xref:System.Web.UI.WebControls.CheckBox>, 、<xref:System.Web.UI.WebControls.ListControl>, と <xref:System.Web.UI.WebControls.BulletedList> コントロールです。  
  
 ページのすべてのボタン コントロールの検証を無効にする設定、ボタン コントロールの `CausesValidation` プロパティを `false`します。  
  
 含まれる検証コントロールを反復処理にこのメソッドが呼び出されたときに、 <xref:System.Web.UI.ValidatorCollection> オブジェクトに関連付けられている、 <xref:System.Web.UI.Page.Validators%2A?displayProperty=fullName> プロパティの現在の検証グループ内の各検証コントロールの検証ロジックを呼び出すとします。 検証グループは、サーバーにページをポストしたコントロールによって決定されます。 検証グループが指定されていない場合は、検証グループは使用されません。  
  
> [!NOTE]
>  ページの検証の動作が変更されました。[!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], 、通話を制御できなく、 <xref:System.Web.UI.Page.Validate?displayProperty=fullName> メソッドをそれらを使用して、 <xref:System.Web.UI.Page.Validate%28System.String%29?displayProperty=fullName> メソッド代わりにします。 使用する場合、 <xref:System.Web.UI.Page.Validate?displayProperty=fullName> メソッドを [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] \] ページで、検証グループは無視され、すべてのコントロールが検証されます。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.UI.Page.Validate%2A> をいくつかの異なる検証グループ シナリオではページ上のメソッドを定義します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[System.Web.UI.Page.Validate2\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate2\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The <see cref="M:System.Web.UI.Page.Validate" /> method is not used by [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)]. When you are using [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], override the <see cref="M:System.Web.UI.Page.Validate(System.String)" /> method to change page validation behavior.</para>
        </block>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">検証するためにコントロールの検証グループ名。</param>
        <summary>割り当てられている情報を検証する、指定した検証グループで、検証コントロールに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ユーザーが任意の ASP.NET サーバー コントロールがクリックしたときに、このメソッドが呼び出され、 `CausesValidation` プロパティに設定 `true`, 、既定であります。 含まれます、 <xref:System.Web.UI.WebControls.Button>, 、<xref:System.Web.UI.WebControls.ImageButton>, 、および <xref:System.Web.UI.WebControls.LinkButton> Web サーバー コントロール、 <xref:System.Web.UI.HtmlControls.HtmlInputButton>, 、<xref:System.Web.UI.HtmlControls.HtmlInputImage>, 、および <xref:System.Web.UI.HtmlControls.HtmlButton> HTML サーバー コントロール、およびが自動的にポストバック サーバーなどのコントロール、 <xref:System.Web.UI.WebControls.TextBox>, 、<xref:System.Web.UI.WebControls.CheckBox>, 、<xref:System.Web.UI.WebControls.ListControl>, と <xref:System.Web.UI.WebControls.BulletedList> コントロールです。  
  
 ページのすべてのボタン コントロールの検証を無効にする設定、ボタン コントロールの `CausesValidation` プロパティを `false`します。  
  
 <xref:System.Web.UI.Page.Validate%2A> メソッドは、指定した検証グループを検証します。 呼び出した後、 <xref:System.Web.UI.Page.Validate%2A> 検証グループ上のメソッド、 <xref:System.Web.UI.Page.IsValid%2A> メソッドから返される `true` 指定した検証グループと、サーバーへの投稿をページの原因となったコントロールの検証グループの両方が有効な場合にのみです。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Web.UI.Page.Validate%2A> をいくつかの異なる検証グループ シナリオではページ上のメソッドを定義します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[System.Web.UI.Page.Validate2\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate2\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはページが危険性のある値のブラウザーからのクライアントの入力をチェックするかどうかを示す値を設定します。</summary>
        <value>ページがクライアントの入力をチェックするかどうかを示す値です。 既定値は、<see cref="F:System.Web.UI.ValidateRequestMode.Enabled" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値 <xref:System.Web.UI.ValidateRequestMode.Inherit> で使用されていない、 <xref:System.Web.UI.Page> クラスから継承するものを使用する必要があるためです。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Validators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection Validators { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ValidatorCollection Validators" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Validators" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求されたページに含まれるすべての検証コントロールのコレクションを取得します。</summary>
        <value>検証コントロールのコレクションです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを使用するには、メソッドとプロパティを操作する、 <xref:System.Web.UI.ValidatorCollection> オブジェクトに現在関連付けられている <xref:System.Web.UI.Page> インスタンス。 このコレクションには、ページに含まれるすべての検証サーバー コントロールが含まれています。  
  
 呼び出す、 <xref:System.Web.UI.Page.Validate%2A?displayProperty=fullName> メソッドは、現在の検証グループ内の各検証サーバー コントロールで実行するための検証ロジックです。 これらのコントロールのいずれかに失敗した場合、 <xref:System.Web.UI.Page.IsValid%2A?displayProperty=fullName> プロパティを返します。 `false`します。  
  
 検証コントロールの詳細については、次を参照してください。 [Validation ASP.NET Controls](http://msdn.microsoft.com/ja-jp/fa2aa14d-a461-492e-9a79-c990904613ef)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
      </Docs>
    </Member>
    <Member MemberName="VerifyRenderingInServerForm">
      <MemberSignature Language="C#" Value="public virtual void VerifyRenderingInServerForm (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void VerifyRenderingInServerForm(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.VerifyRenderingInServerForm(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">ASP.NET サーバー コントロールで必要となる、 <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> コントロールです。</param>
        <summary>いることを確認、 <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> 実行時に指定された ASP.NET サーバー コントロールにコントロールを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロール内に配置するために必要な `<form runat=server>` タグの外側に配置かどうか、エラー メッセージが表示されるように、表示する前に、タグはこのメソッドを呼び出すことができます。 オーバーライドでこのメソッドを呼び出す必要がありますがポスト バックまたは登録されているスクリプト ブロックに依存できるコントロール、 <xref:System.Web.UI.Control.Render%2A?displayProperty=fullName> メソッドです。 サーバーのフォーム要素の表示方法が異なるページには、さまざまな条件で例外をスローするには、このメソッドをオーバーライドできます。  
  
 含まれていない場合、ポストバックまたはクライアント側スクリプトを使用するサーバー コントロールは機能しません、 <xref:System.Web.UI.HtmlControls.HtmlForm> サーバー コントロール \(\<`form runat="server">`\) タグ。 ない囲まれている場合、明らかなエラー メッセージを表示するときに、これらのコントロールはこのメソッドを呼び出すことができます、 <xref:System.Web.UI.HtmlControls.HtmlForm> コントロールです。  
  
 カスタム サーバー コントロールを開発する場合をオーバーライドする場合は、このメソッドを呼び出す一般的な `Render` input タグのあらゆる種類の方法です。 これは、入力コントロールを呼び出す場合に特に重要 <xref:System.Web.UI.Page.GetPostBackEventReference%2A>, 、またはクライアント スクリプトを出力します。 複合サーバー コントロールは、この呼び出しを行う必要はありません。  
  
   
  
## 例  
 次のコード例の上書き、 <xref:System.Web.UI.Page.Render%2A?displayProperty=fullName> カスタム サーバー コントロールのメソッドです。 このコントロールは、そのコンテンツをページに書き込むと、使用して、 <xref:System.Web.UI.Page.VerifyRenderingInServerForm%2A> 開始タグと終了タグの間、コントロールが表示されることを確認するメソッド、 <xref:System.Web.UI.HtmlControls.HtmlForm> コントロールです。  
  
 [!code-csharp[System.Web.UI.Page\_VerifyRenderingInServerForm\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#3)]
 [!code-vb[System.Web.UI.Page\_VerifyRenderingInServerForm\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/vb/testlinkbutton.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">開始タグと終了タグの間、指定されたサーバー コントロールが含まれていない、 <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> 実行時にサーバー コントロール。</exception>
        <exception cref="T:System.ArgumentNullException">検証するコントロールは <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateEncryptionMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateEncryptionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはビューステートの暗号化モードを設定します。</summary>
        <value>
          <see cref="T:System.Web.UI.ViewStateEncryptionMode" /> 値のいずれか。 既定値は <see cref="F:System.Web.UI.ViewStateEncryptionMode.Auto" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> コードでプロパティを設定することはできません。 のみ設定できますかディレクティブで、\< 構成ファイルの要素。 値は、ディレクティブのオーバーライドで、構成ファイルで設定された値を設定します。  
  
 ディレクティブにこのプロパティを設定するための構文は次のとおりです。  
  
```vb  
<%@ Page Language="VB" ViewStateEncryptionMode="Always" %>  
  
```  
  
```csharp  
<%@ Page Language="C#" ViewStateEncryptionMode="Always" %>  
```  
  
 構成ファイルでこのプロパティを設定するための構文は次のとおりです。  
  
```vb  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
  
```  
  
```csharp  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
 カスタム コントロールの開発者は、コントロールの状態を表示する可能性のある機密データを保存する前にコードでは、このプロパティの値を確認してみてください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定されている値がのメンバーではない、 <see cref="T:System.Web.UI.ViewStateEncryptionMode" /> 列挙します。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.ViewStateEncryptionMode" /> に限定するか、ページの前に、プロパティを設定できる <see langword="PreRender" />ページ ライフ サイクルのフェーズです。</exception>
        <altmember cref="T:System.Web.UI.ViewStateEncryptionMode" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateUserKey">
      <MemberSignature Language="C#" Value="public string ViewStateUserKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ViewStateUserKey" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateUserKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のページに関連付けられているビュー ステートの変数に個々 のユーザー id を割り当てます。</summary>
        <value>個々 のユーザーの識別子です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定、 <xref:System.Web.UI.Page.ViewStateUserKey%2A> プロパティを使用して、悪意のあるユーザーから、アプリケーションに対する攻撃を防止できます。 この機能を使用するに攻撃を生成する、変数が使用できないように、識別子を個々 のユーザーにビュー ステートの変数に割り当てられるようにします。 Web 攻撃およびそれらを防ぐために何ができるについての詳細については、次を参照してください。 [Take Advantage of ASP.NET Built\-in Features to Fend Off Web Attacks](http://go.microsoft.com/fwlink/?LinkId=163557)します。  
  
 ユーザーの名前が認証されるよう、このプロパティを任意の文字列値に設定することができますか <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> 値。  
  
> [!NOTE]
>  中にこのプロパティを設定する必要があります、 `Page_Init` ページ処理の段階です。 中にこのプロパティの設定、 `Page_Load` フェーズが例外をスローします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.UI.Page.ViewStateUserKey" /> ページ処理中にプロパティが遅すぎますアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうか、 <see cref="T:System.Web.UI.Page" /> オブジェクトが表示されます。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Web.UI.Page" /> レンダリング。 それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例のセット、 <xref:System.Web.UI.Page.Visible%2A> プロパティを `false` ページのレンダリングされたコンテンツを非表示にします。 このページが最初に要求されたデータ ソースが設定され、ページに表示されます。 ユーザーがクリックすると、 `HideButton_Click` イベント ハンドラーには、レンダリングされたページのコンテンツ全体が非表示にします。  
  
 [!code-csharp[Page\_Visible\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_Visible/CS/page_visible.cs.aspx#1)]
 [!code-vb[Page\_Visible\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_Visible/VB/page_visible.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.UI.TemplateControl" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ブラウザーのフォーカスを、指定したコントロールに設定します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="AddOnPreRenderCompleteAsync">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始と終了時刻、非同期ページのイベント ハンドラー デリゲートを登録します。</summary>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>割り当てられている情報を検証するページに含まれる検証コントロールに指示します。</summary>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>サーバーへのポストバックが発生するクライアント イベントで使用できる文字列を返します。 このメソッドの使用は推奨されていません。 使用して、 <see cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" /> メソッドで、 <see cref="T:System.Web.UI.ClientScriptManager" /> クラスの代わりにします。</summary>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </MemberGroup>
  </Members>
</Type>