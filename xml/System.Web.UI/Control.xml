<Type Name="Control" FullName="System.Web.UI.Control">
  <TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IControlBuilderAccessor, System.Web.UI.IControlDesignerAccessor, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IExpressionsAccessor, System.Web.UI.IParserAccessor, System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IControlBuilderAccessor, class System.Web.UI.IControlDesignerAccessor, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IExpressionsAccessor, class System.Web.UI.IParserAccessor, class System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Control" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlBuilderAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlDesignerAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataBindingsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IExpressionsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IParserAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IUrlResolutionService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ID")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Code")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.UI", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>すべての ASP.NET サーバー コントロールによって共有されるプロパティ、メソッド、およびイベントを定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 This is the primary class that you derive from when you develop custom ASP.NET server controls. <xref:System.Web.UI.Control> does not have any user interface \(UI\) specific features. If you are authoring a control that does not have a UI, or combines other controls that render their own UI, derive from <xref:System.Web.UI.Control>. If you are authoring a control that does have a UI, derive from <xref:System.Web.UI.WebControls.WebControl> or any control in the <xref:System.Web.UI.WebControls> namespace that provides an appropriate starting point for your custom control.  
  
 The <xref:System.Web.UI.Control> class is the base class for all ASP.NET server controls, including custom controls, user controls, and pages. ASP.NET pages are instances of the <xref:System.Web.UI.Page> class, which inherits from the <xref:System.Web.UI.Control> class, and that handle requests for files that have an .aspx extension.  
  
 The <xref:System.Web.UI.Control> class can directly or indirectly be used as part of the user interface for your Web application, and as such should be scrutinized to make sure best practices for writing secure code and securing applications are followed.  
  
 For general information on these topics, see [Overview of Web Application Security Threats](http://msdn.microsoft.com/ja-jp/88d61678-f84e-4622-ae80-53128821855a), [NIB: Security Policy Best Practices](http://msdn.microsoft.com/ja-jp/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), and [Key Security Concepts](http://msdn.microsoft.com/ja-jp/3cfced4f-ea02-4e66-ae98-d69286363e98). For more specific information, see [Securing Standard Controls](http://msdn.microsoft.com/ja-jp/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [How to: Display Safe Error Messages](http://msdn.microsoft.com/ja-jp/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [How to: Protect Against Script Exploits in a Web Application by Applying HTML Encoding to Strings](http://msdn.microsoft.com/ja-jp/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), and [Introduction to the Validation Controls](http://msdn.microsoft.com/ja-jp/3c0e7514-cff2-4bed-936d-ee3f7b740190).  
  
   
  
## 例  
 The following example demonstrates a custom server control that derives from the <xref:System.Web.UI.Control> class. The `InnerContent` class overrides the <xref:System.Web.UI.Control.Render%2A?displayProperty=fullName> method, checks to see if the class has any child controls on the page and determines whether the first child of the control is a literal control. If both of these conditions are met, the overridden method writes the HTML string \<H2\>Your Message:, the contents of the literal control, and a closing \<\/H2\> tag to the Web Forms page.  
  
> [!IMPORTANT]
>  This example has a text box that accepts user input, which is a potential security threat. By default, ASP.NET Web pages validate that user input does not include script or HTML elements. For more information, see [Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Classic Control Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control Example/CS/source.cs#1)]
 [!code-vb[Classic Control Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="T:System.Web.UI.TemplateControl" />
    <altmember cref="T:System.Web.UI.LiteralControl" />
    <altmember cref="T:System.Web.UI.WebControls.WebControl" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Control" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.ControlAdapter Adapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.ControlAdapter Adapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Adapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのブラウザー固有のアダプターを取得します。</summary>
        <value>A <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> このコントロールにします。 対象のブラウザーにアダプターが必要としない場合は、返す <see langword="null" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET Web ページは、デバイスと、Web から情報を要求しているブラウザーの広範囲にわたって使用できます。<xref:System.Web.UI.Control.Adapter%2A> プロパティを返します。、 <xref:System.Web.UI.Adapters.ControlAdapter> 要求元のデバイスまたはブラウザーの画面上のコントロールを描画するオブジェクト。  
  
 アダプターの詳細については、次を参照してください。 [Architectural Overview of Adaptive Control Behavior](http://msdn.microsoft.com/ja-jp/4ff05ae9-4109-4352-929e-ad893895dbff)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
      </Docs>
    </Member>
    <Member MemberName="AddedControl">
      <MemberSignature Language="C#" Value="protected virtual void AddedControl (System.Web.UI.Control control, int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void AddedControl(class System.Web.UI.Control control, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> が追加されました。</param>
        <param name="index">内のコントロールのインデックス、 <see cref="P:System.Web.UI.Control.Controls" /> コレクションです。</param>
        <summary>子コントロールに追加した後と呼ばれる、 <see cref="P:System.Web.UI.Control.Controls" /> のコレクション、 <see cref="T:System.Web.UI.Control" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.AddedControl%2A> メソッドは、コントロールに追加した直後に、 <xref:System.Web.UI.Control.Controls%2A> コレクションです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="control" /> <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AddParsedSubObject">
      <MemberSignature Language="C#" Value="protected virtual void AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddParsedSubObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Object" /> 解析された要素を表します。</param>
        <summary>XML または HTML のいずれかの要素が解析されたことをサーバー コントロールに通知し、サーバー コントロールの <see cref="T:System.Web.UI.ControlCollection" /> オブジェクトに要素を追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは自動的に追加メソッドをオーバーライドする場合を除き、 <xref:System.Web.UI.LiteralControl> オブジェクトをサーバー コントロールの <xref:System.Web.UI.ControlCollection> オブジェクトです。 このコレクションは <xref:System.Web.UI.Control.Controls%2A?displayProperty=fullName> プロパティです。  
  
   
  
## 例  
 次の例は、使用するカスタム サーバー コントロール、 <xref:System.Web.UI.Control.AddParsedSubObject%2A> 開始タグと終了タグのこのコントロールの間の要素が宣言されているかどうかを決定する方法は <xref:System.Web.UI.WebControls.TextBox> Web サーバー コントロール。 追加される場合は、 <xref:System.Collections.ArrayList> オブジェクト、 `items`です。 ときに、オーバーライドされた <xref:System.Web.UI.Control.CreateChildControls%2A> を反復処理メソッドが呼び出されると、 <xref:System.Collections.ArrayList> に各オブジェクトを追加し、 <xref:System.Web.UI.ControlCollection> カスタム サーバー コントロールのです。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Control\_AddParsedSubObject\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_AddParsedSubObject/CS/control_addparsedsubobject.cs#1)]
 [!code-vb[Control\_AddParsedSubObject\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_AddParsedSubObject/VB/control_addparsedsubobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ApplyStyleSheetSkin">
      <MemberSignature Language="C#" Value="public virtual void ApplyStyleSheetSkin (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyStyleSheetSkin(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">
          <see cref="T:System.Web.UI.Page" /> コントロールを含みます。</param>
        <summary>コントロールをページのスタイル シートで定義されているスタイル プロパティを適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> メソッドは、テーマ ディレクトリで定義されているスキン プロパティに基づいて、コントロールのスタイル プロパティを設定します。 スキンの適用は、コントロールの既定スキンかで指定されたスキン、 <xref:System.Web.UI.Control.SkinID%2A> プロパティです。<xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> ASP.NET によって、ページに配置されている宣言型のコントロールのメソッドが呼び出されます。 呼び出す必要があります、 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> でプログラムによって作成されたコントロールに対してメソッドの実行時間のスタイル シートのスキンをコントロールに適用します。 テーマのスキンは、自動的に適用されます。 テーマやカスケード スタイル シートの違いの詳細については、次を参照してください。 [ASP.NET Themes Overview](http://msdn.microsoft.com/ja-jp/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">スタイル シートは既に適用されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeTemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public string AppRelativeTemplateSourceDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定のアプリケーションの相対仮想ディレクトリ、 <see cref="T:System.Web.UI.Page" /> または <see cref="T:System.Web.UI.UserControl" /> このコントロールを格納しているオブジェクト。</summary>
        <value>このコントロールを含むページやユーザー コントロールのアプリケーションの相対仮想ディレクトリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> プロパティには、現在のコントロールを含むページやユーザー コントロールへのアプリケーションの相対パスが含まれています。 Web ページが http:\/\/www.contoso.com\/application\/subdirectory に配置されている場合など、 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> プロパティを返します。"~\/サブディレクトリ"です。  
  
 仮想パス \(「アプリケーション\/サブディレクトリ」\) を返すを使用して、 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenderTracing">
      <MemberSignature Language="C#" Value="protected void BeginRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BeginRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">このオブジェクトは、トレース データを書き込みます。</param>
        <param name="traceObject">Trace オブジェクトです。</param>
        <summary>表示データのデザイン時のトレースを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control BindingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control BindingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.BindingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールのデータ バインディングを格納しているコントロールを取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.Control" /> このコントロールのデータ バインディングを格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.BindingContainer%2A> プロパティへの参照を格納する、 <xref:System.Web.UI.Control> を現在のコントロールのデータ バインド情報を含むオブジェクト。  
  
 <xref:System.Web.UI.Control.BindingContainer%2A> プロパティと同じ、 <xref:System.Web.UI.Control.NamingContainer%2A> プロパティには、コントロールがテンプレートの一部場合を除いて、します。 その場合は、 <xref:System.Web.UI.Control.BindingContainer%2A> プロパティに設定されて、 <xref:System.Web.UI.Control> テンプレートを定義します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="BuildProfileTree">
      <MemberSignature Language="C#" Value="protected void BuildProfileTree (string parentId, bool calcViewState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BuildProfileTree(string parentId, bool calcViewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentId" Type="System.String" />
        <Parameter Name="calcViewState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parentId">コントロールの親の識別子。</param>
        <param name="calcViewState">ビュー ステートのサイズを計算するかどうかを示すブール値。</param>
        <summary>サーバー コントロールに関する情報を収集し、配信する、 <see cref="P:System.Web.UI.Page.Trace" /> ページに対してトレースを有効にすると表示されるプロパティです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティ ページの UI の階層構造に関する必要な情報を収集し、これをページの [\<trace\> Element](http://msdn.microsoft.com/ja-jp/7931c942-63c1-47c3-a045-9d9de3cacdbf) プロパティです。 この情報を表示、ページまたは、アプリケーションのトレースを有効にすると、 `Control Tree` トレース出力のセクションです。 ページのトレース出力は、ページの末尾に追加されます。中に、アプリケーションのトレース出力は、アプリケーションのルート ディレクトリに格納されているトレース ビューアー \(trace.axd ファイル\) から表示できます。 トレースの詳細については、「[ASP.NET Tracing Overview](http://msdn.microsoft.com/ja-jp/1552561d-887c-4002-8770-f92662cdf416)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildControlsCreated">
      <MemberSignature Language="C#" Value="protected bool ChildControlsCreated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChildControlsCreated" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ChildControlsCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールの子コントロールが作成されたかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 子コントロールが作成された場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、オーバーライド、 <xref:System.Web.UI.Control.OnDataBinding%2A> カスタム メソッド <xref:System.Web.UI.WebControls.Repeater> コントロールです。 ここでも、データ バインドが行われるまで子コントロールが作成しないことを確認する、 <xref:System.Web.UI.Control.ChildControlsCreated%2A> にプロパティが設定されている `true` 後、 <xref:System.Web.UI.WebControls.RepeaterItem> オブジェクトが作成され、コントロールの追加 <xref:System.Web.UI.ControlCollection> オブジェクトです。  
  
 [!code-csharp[TemplatedDataBoundControl3\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/customrepeater.cs#1)]
 [!code-vb[TemplatedDataBoundControl3\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/customrepeater.vb#1)]  
  
 次の例では、Web ページで、カスタム repeater コントロールを使用する方法を示します。  
  
 [!code-csharp[TemplatedDataBoundControl3\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/default.aspx#2)]
 [!code-vb[TemplatedDataBoundControl3\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/default.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="ClearCachedClientID">
      <MemberSignature Language="C#" Value="protected void ClearCachedClientID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearCachedClientID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearCachedClientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キャッシュされた設定 <see cref="P:System.Web.UI.Control.ClientID" /> 値を <see langword="null" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildControlState">
      <MemberSignature Language="C#" Value="protected void ClearChildControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildControlState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールの子コントロールのコントロールの状態情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.ClearChildControlState%2A> メソッドは、データ バインディングの子をテンプレート化されたデータ バインド サーバー コントロールにコントロールするときなど、新しい子コントロールが作成されると、親コントロールのコントロールの状態に書き込まれた子コントロールの状態情報がオーバーライドされた場合に使用します。 呼び出す、 <xref:System.Web.UI.Control.ClearChildControlState%2A> メソッドを呼び出す前に空の子コントロールに、 <xref:System.Web.UI.Control.SaveControlState%2A> メソッドは、格納または転送される必要があるコントロールの状態情報のサイズを縮小します。  
  
 子コントロールを再作成する場合、 <xref:System.Web.UI.Control> オブジェクトを使用、 <xref:System.Web.UI.Control.ClearChildControlState%2A> メソッドには適用されないように、取得、新しいコントロールを誤って子コントロールの状態をオフにします。  
  
 両方を削除する子コントロールの状態とビュー ステートを使用して、 <xref:System.Web.UI.Control.ClearChildState%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildState">
      <MemberSignature Language="C#" Value="protected void ClearChildState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールのすべての子コントロールのビュー ステートとコントロールの状態情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.ClearChildState%2A> メソッドは、子コントロールのすべてのビュー ステートとコントロールの状態情報をクリアします。 これは両方を呼び出すことと同じ、 <xref:System.Web.UI.Control.ClearChildViewState%2A> メソッドおよび <xref:System.Web.UI.Control.ClearChildControlState%2A> メソッドです。  
  
 子コントロールを再作成する場合、 <xref:System.Web.UI.Control> オブジェクトを使用、 <xref:System.Web.UI.Control.ClearChildState%2A> メソッドには適用されないように、取得、新しいコントロールを誤って子の状態をオフにします。  
  
   
  
## 例  
 次のコード例では、オーバーライド、 <xref:System.Web.UI.Control.OnDataBinding%2A> template 宣言されたデータ バインド コントロールのメソッドです。 コントロールがバインドされるデータ ソースが設定されている場合、コントロールの <xref:System.Web.UI.ControlCollection> を使用して、コレクションが空に、 <xref:System.Web.UI.ControlCollection.Clear%2A> メソッド、および <xref:System.Web.UI.Control.ClearChildState%2A> 子コントロールの保存されていたすべての状態情報を削除するメソッドを使用します。  
  
 [!code-csharp[TemplatedDataBoundControl2\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl2/cs/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl2\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl2/vb/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildViewState">
      <MemberSignature Language="C#" Value="protected void ClearChildViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildViewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールのすべての子コントロールのビュー ステート情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバーライドする場合、このメソッドは通常使用、 <xref:System.Web.UI.Control.DataBind%2A> メソッド テンプレート化されたデータ バインド サーバー コントロールを開発する場合。 このメソッドが呼び出されない場合、データがバインドされている場合に上書きするためだけの親サーバー コントロールに子コントロールのビューステート情報を書き込むことができます。  
  
 子コントロールを再作成する場合、 <xref:System.Web.UI.Control>, を使用して、 <xref:System.Web.UI.Control.ClearChildViewState%2A> メソッドには適用されないように、取得、新しいコントロールを誤って子ビュー ステートをオフにします。  
  
 詳細については、このメソッドを使用して、次を参照してください。 [How to: Create Templated User Controls](http://msdn.microsoft.com/ja-jp/07664410-02dd-4494-af53-a9259741d4f2)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
      </Docs>
    </Member>
    <Member MemberName="ClearEffectiveClientIDMode">
      <MemberSignature Language="C#" Value="protected void ClearEffectiveClientIDMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearEffectiveClientIDMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearEffectiveClientIDMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>セット、 <see cref="P:System.Web.UI.Control.ClientIDMode" /> コントロールの現在のインスタンスとする場合は、その子コントロールのプロパティ <see cref="F:System.Web.UI.ClientIDMode.Inherit" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public virtual string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET によって生成される HTML マークアップのコントロール ID を取得します。</summary>
        <value>ASP.NET によって生成される HTML マークアップのコントロール ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Web サーバー コントロールは、HTML 要素としてレンダリングされるとき、 `id` の値に HTML 要素の属性が設定されている、 <xref:System.Web.UI.Control.ClientID%2A> プロパティです。<xref:System.Web.UI.Control.ClientID%2A> を使用してクライアント スクリプトで HTML 要素にアクセスする値が使用される多くの場合、 `document.getElementById` メソッドです。 多くの場合も、ID は、要素のスタイルを指定する CSS ルールが使用されます。 たとえば、次の CSS スタイル規則がすべて選択 `span` を持つ要素、 `id` 属性の値の `ProductIDLabel` 設定とその `background-color` 属性を `white`:  
  
```  
span#ProductIDLabel { background-color: white; }  
```  
  
 ASP.NET には、生成する方法についての複数のアルゴリズムが用意されています、 <xref:System.Web.UI.Control.ClientID%2A> プロパティの値。 コントロールに設定して使用するアルゴリズムを選択する、 <xref:System.Web.UI.Control.ClientIDMode%2A> プロパティです。 アルゴリズムがで識別される、 <xref:System.Web.UI.ClientIDMode> 次の表に記載されている列挙値。  
  
|値|説明|  
|-------|--------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A> 値が連結して生成、 <xref:System.Web.UI.Control.ID%2A> 各親の名前付けコンテナー、 <xref:System.Web.UI.Control.ID%2A> コントロールの値。 コントロールの複数のインスタンスが表示されるデータ バインディングのシナリオで、増分する値がコントロールの前に挿入された <xref:System.Web.UI.Control.ID%2A> 値。 各セグメントは、アンダー スコア文字 \(\_\) で区切られます。 このアルゴリズムは、ASP.NET 4 より前のバージョンの ASP.NET で使用されました。|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> の値に値が設定されている、 <xref:System.Web.UI.Control.ID%2A> プロパティです。 コントロールが名前付けコンテナーの場合は、コントロールがそれに含まれるすべてのコントロールの名前付けコンテナーの階層の最上位として使用されます。|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|このアルゴリズムは、データ バインド コントロール内にあるコントロールに使用されます。<xref:System.Web.UI.Control.ClientID%2A> 値が連結して生成、 <xref:System.Web.UI.Control.ClientID%2A> と親の名前付けコンテナーの値、 <xref:System.Web.UI.Control.ID%2A> コントロールの値。 データ フィールドの値が指定されたコントロールが複数の行を生成するデータ バインド コントロールの場合、 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> プロパティが末尾に追加します。<xref:System.Web.UI.WebControls.GridView> を制御する複数のデータ フィールドを指定することができます。 場合、 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> プロパティが空白の場合にシーケンス番号がデータ フィールドの値ではなく末尾に追加します。 各セグメントは、アンダー スコア文字 \(\_\) で区切られます。|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|コントロールの継承、 <xref:System.Web.UI.ClientIDMode> の設定、 <xref:System.Web.UI.Control.NamingContainer%2A> コントロールです。|  
  
 既定値の <xref:System.Web.UI.Control.ClientIDMode%2A> ページは <xref:System.Web.UI.ClientIDMode.Predictable>です。 既定値の <xref:System.Web.UI.Control.ClientIDMode%2A> コントロールは <xref:System.Web.UI.ClientIDMode.Inherit>です。 コントロールの既定値はため <xref:System.Web.UI.ClientIDMode.Inherit>, モードは既定の生成、 <xref:System.Web.UI.ClientIDMode.Predictable>です。 \(ただし、Visual Studio を使用して Web プロジェクトを以前のバージョンの ASP.NET 4 に変換する場合は、Visual Studio に自動的にサイトの既定値を設定 <xref:System.Web.UI.ClientIDMode.AutoID> Web.config ファイルにします\)。  
  
 詳細については、「[ASP.NET Control Identification](http://msdn.microsoft.com/ja-jp/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)」を参照してください。  
  
   
  
## 例  
 次の例では、マスター ページのコンテンツ ページ内にある Web ユーザー コントロールを示します。 ユーザー コントロールに含まれる、 <xref:System.Web.UI.WebControls.DropDownList> コントロールと <xref:System.Web.UI.WebControls.Label> コントロールです。 表示されるテキスト、 <xref:System.Web.UI.WebControls.Label> コントロールがユーザーから選択する値によって決まる、 <xref:System.Web.UI.WebControls.DropDownList> コントロールです。 Web ページがこの値を設定するのには、サーバーにポストバックする必要があるないように、クライアント スクリプトをテキスト値が設定します。 レンダリングされた HTML 要素への参照を取得する、 <xref:System.Web.UI.WebControls.Label> コントロール、クライアント スクリプトでは、コントロールの値を知る必要があります <xref:System.Web.UI.Control.ClientID%2A> プロパティです。 ただし、ユーザー コントロールは、Web ページにどこにでも配置できるから、どの名前付けコンテナーは、コントロールを含む事前に知っておくことはできません。 ことを確認して、 <xref:System.Web.UI.Control.ClientID%2A> と同じ値になります、 <xref:System.Web.UI.Control.ID%2A> 値に設定するコードのセット、 <xref:System.Web.UI.Control.ClientIDMode%2A> 値を <xref:System.Web.UI.WebControls.ValidatorDisplay.Static>します。  
  
 次の例では、ユーザー コントロールを示します。  
  
  
  
 次の例では、ユーザー コントロールを含むコンテンツ ページを示します。  
  
  
  
 次の例では、コンテンツのページが含まれているマスター ページを示します。  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="ClientIDMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ClientIDMode ClientIDMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ClientIDMode ClientIDMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientIDMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の値を生成するために使用するアルゴリズム、 <see cref="P:System.Web.UI.Control.ClientID" /> プロパティです。</summary>
        <value>示す値が、どのように <see cref="P:System.Web.UI.Control.ClientID" /> プロパティを生成します。 既定値は、<see cref="F:System.Web.UI.ClientIDMode.Inherit" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET には、生成する方法についての複数のアルゴリズムが用意されています、 <xref:System.Web.UI.Control.ClientID%2A> プロパティの値。 コントロールに設定して使用するアルゴリズムを選択する、 <xref:System.Web.UI.Control.ClientIDMode%2A> プロパティです。 アルゴリズムがで識別される、 <xref:System.Web.UI.ClientIDMode> 次の表に記載されている列挙値。  
  
|値|説明|  
|-------|--------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A> 値が連結して生成、 <xref:System.Web.UI.Control.ID%2A> 各親の名前付けコンテナー、 <xref:System.Web.UI.Control.ID%2A> コントロールの値。 コントロールの複数のインスタンスが表示されるデータ バインディングのシナリオで、増分する値がコントロールの前に挿入された <xref:System.Web.UI.Control.ID%2A> 値。 各セグメントは、アンダー スコア文字 \(\_\) で区切られます。 このアルゴリズムは、ASP.NET 4 より前のバージョンの ASP.NET で使用されました。|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> の値に値が設定されている、 <xref:System.Web.UI.Control.ID%2A> プロパティです。 コントロールが名前付けコンテナーの場合は、コントロールがそれに含まれるすべてのコントロールの名前付けコンテナーの階層の最上位として使用されます。|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|このアルゴリズムは、データ バインド コントロール内にあるコントロールに使用されます。<xref:System.Web.UI.Control.ClientID%2A> 値が連結して生成、 <xref:System.Web.UI.Control.ClientID%2A> と親の名前付けコンテナーの値、 <xref:System.Web.UI.Control.ID%2A> コントロールの値。 データ フィールドの値が指定されたコントロールが複数の行を生成するデータ バインド コントロールの場合、 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> プロパティが末尾に追加します。<xref:System.Web.UI.WebControls.GridView> を制御する複数のデータ フィールドを指定することができます。 場合、 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> プロパティが空白の場合にシーケンス番号がデータ フィールドの値ではなく末尾に追加します。 この番号は 0 から始まるされ、行ごとに 1 ずつインクリメントされます。 各セグメントは、アンダー スコア文字 \(\_\) で区切られます。|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|コントロールの継承、 <xref:System.Web.UI.ClientIDMode> の設定、 <xref:System.Web.UI.Control.NamingContainer%2A> コントロールです。|  
  
 既定値の <xref:System.Web.UI.Control.ClientIDMode%2A> ページは <xref:System.Web.UI.ClientIDMode.Predictable>です。 既定値の <xref:System.Web.UI.Control.ClientIDMode%2A> コントロールは <xref:System.Web.UI.ClientIDMode.Inherit>です。 コントロールの既定値はため <xref:System.Web.UI.ClientIDMode.Inherit>, モードは既定の生成、 <xref:System.Web.UI.ClientIDMode.Predictable>です。 \(ただし、Visual Studio を使用して Web プロジェクトを以前のバージョンの ASP.NET 4 に変換する場合は、Visual Studio に自動的にサイトの既定値を設定 <xref:System.Web.UI.ClientIDMode.AutoID> Web.config ファイルにします\)。  
  
 詳細については、「[ASP.NET Control Identification](http://msdn.microsoft.com/ja-jp/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)」を参照してください。  
  
   
  
## 例  
 例を次に <xref:System.Web.UI.WebControls.Label> に含まれているコントロール、 <xref:System.Web.UI.WebControls.ListView> コントロールです。<xref:System.Web.UI.WebControls.ListView> コントロール、 <xref:System.Web.UI.Control.ClientIDMode%2A> プロパティに設定されて <xref:System.Web.UI.ClientIDMode.Predictable> と <xref:System.Web.UI.WebControls.ListView.ClientIDRowSuffix%2A> にプロパティが設定されている `ProductID`します。 3 つのレンダリングされた html 形式で作成この `span` 3 に対応する要素 `ProductIDLabel` コントロールです。 ページを実行すると、 `id` の属性を `span` 要素は、次の値に設定します。  
  
-   `ListView1_ProductIDLabel_1`  
  
-   `ListView1_ProductIDLabel_34`  
  
-   `ListView1_ProductIDLabel_43`  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientIDSeparator">
      <MemberSignature Language="C#" Value="protected char ClientIDSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char ClientIDSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用する区切り文字を表す文字値を取得、 <see cref="P:System.Web.UI.Control.ClientID" /> プロパティです。</summary>
        <value>常に下線 \(\_\) を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.ClientID%2A> 値が連結して生成、 <xref:System.Web.UI.Control.ID%2A> コントロールの値と <xref:System.Web.UI.Control.UniqueID%2A> 、親コントロールの値。 各部分を生成された <xref:System.Web.UI.Control.ID%2A> プロパティがで区切られた、 <xref:System.Web.UI.Control.ClientIDSeparator%2A> プロパティの値。 値は、常にアンダー スコア \(\_\) を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.ClientID" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected virtual System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Web.HttpContext" /> 現在の Web 要求に対するサーバー コントロールに関連付けられているオブジェクト。</summary>
        <value>指定した <see cref="T:System.Web.HttpContext" /> 現在の要求に関連付けられているオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティにアクセスする、 <xref:System.Web.HttpContext> Web 要求を現在のオブジェクト。 オブジェクトにアクセスするプロパティを提供する、 <xref:System.Web.HttpContext.Application%2A>, 、<xref:System.Web.HttpContext.Session%2A>, 、<xref:System.Web.HttpContext.Request%2A>, 、<xref:System.Web.HttpContext.Response%2A> と現在の HTTP 要求に関する情報を含むその他のオブジェクト。 また、構成情報とセットや要求のエラーのクリアを取得するためのメソッドも提供します。  
  
   
  
## 例  
 [!code-csharp[System.Web.UI.Control\_Context\_OnInit\_ResolveUrl\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#1)]
 [!code-vb[System.Web.UI.Control\_Context\_OnInit\_ResolveUrl\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Web.HttpApplication" />
        <altmember cref="T:System.Web.HttpServerUtility" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Web.UI.ControlCollection" /> UI 階層に指定されたサーバー コントロールの子コントロールを表すオブジェクト。</summary>
        <value>指定されたサーバー コントロールの子コントロールのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 \[ASP.NET\] ページでは、開始タグと終了タグのサーバー コントロールの間のコントロールを宣言して追加するときに ASP.NET に自動的に追加のコントロールを含むサーバー コントロールの <xref:System.Web.UI.ControlCollection>です。 任意の HTML タグやサーバーで処理されないテキスト文字列として扱われます <xref:System.Web.UI.LiteralControl> オブジェクトです。 これらは、その他のサーバー コントロールと同様に、コレクションに追加されます。  
  
 <xref:System.Web.UI.Control.Controls%2A> プロパティを使用するのインスタンスにプログラムでアクセス、 <xref:System.Web.UI.ControlCollection> 任意のサーバー コントロールのクラスです。 コレクションにコントロールを追加、コントロールをコレクションから削除、またはコレクション内のサーバー コントロールを反復処理することができます。  
  
   
  
## 例  
 次の例は、サーバー コントロールの子コントロールを追加する方法を示します <xref:System.Web.UI.ControlCollection> オブジェクトを通じて、 <xref:System.Web.UI.Control.Controls%2A> プロパティです。  
  
 [!code-csharp[Classic Control.Controls Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Controls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Controls Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Controls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding the <see cref="P:System.Web.UI.Control.Controls" /> property, be sure to call the <see cref="M:System.Web.UI.Control.EnsureChildControls" /> method. Furthermore, if you are planning to add controls to the controls collection programmatically, consider adding the controls in an overridden <see cref="M:System.Web.UI.Control.CreateChildControls" /> method.</para>
        </block>
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateChildControls" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ASP.NET ページ フレームワークによって呼び出され、ポストバックまたはレンダリングの準備として、合成ベースの実装を使うサーバー コントロールに対し、それらのコントロールに含まれる子コントロールを作成するように通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 When you develop a composite or templated server control, you must override this method. Controls that override the <xref:System.Web.UI.Control.CreateChildControls%2A> method should implement the <xref:System.Web.UI.INamingContainer> interface to avoid naming conflicts.  
  
 For more information, see [ASP.NET Web Server Controls Templates](http://msdn.microsoft.com/ja-jp/f769d290-fd04-4084-85fc-4ea30dd2e8ae) and [Developing Custom ASP.NET Server Controls](http://msdn.microsoft.com/ja-jp/fbe26c16-cff4-4089-b3dd-877411f0c0ef).  
  
   
  
## 例  
 The following example demonstrates an overridden version of the <xref:System.Web.UI.Control.CreateChildControls%2A> method. In this implementation, the composite control displays a <xref:System.Web.UI.WebControls.TextBox> control enclosed in two literal controls that render HTML.  
  
> [!IMPORTANT]
>  This example has a text box that accepts user input, which is a potential security threat. By default, ASP.NET Web pages validate that user input does not include script or HTML elements. For more information, see [Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#2)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateControlCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新しい <see cref="T:System.Web.UI.ControlCollection" /> サーバー コントロールの子コントロール \(リテラルとサーバーの両方\) を保持するオブジェクト。</summary>
        <returns>A <see cref="T:System.Web.UI.ControlCollection" /> を現在のサーバー コントロールの子サーバー コントロールを格納するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したコレクション オブジェクトを作成した場合は、カスタム サーバー コントロールでは、このメソッドをオーバーライド、 <xref:System.Web.UI.ControlCollection> クラスです。 このメソッドのオーバーライドでコレクション クラスをインスタンス化できます。  
  
   
  
## 例  
 次のコード例の上書き、 <xref:System.Web.UI.Control.CreateControlCollection%2A> のインスタンスを作成する方法、 `CustomControlCollection` から継承されるクラス、 <xref:System.Web.UI.ControlCollection> クラスです。  
  
 [!code-csharp[System.Web.UI.ControlCollection\_CTor\_Owner\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/cs/controlcollection_7.cs#2)]
 [!code-vb[System.Web.UI.ControlCollection\_CTor\_Owner\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/VB/controlcollection_7.vb#2)]  
  
 次のコード例では、 <xref:System.Web.UI.Control.CreateControlCollection%2A> のカスタム サーバー コントロールのメソッドのオーバーライド、 <xref:System.Web.UI.Control.CreateChildControls%2A> メソッドです。 新しいコレクションが作成され、2 つの子コントロールを持つ値が入力されます `firstControl` と `secondControl`です。  
  
 [!code-csharp[Control\_Sample\_1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#1)]
 [!code-vb[Control\_Sample\_1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="public virtual void DataBind ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DataBind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出されたサーバー コントロールとそのすべての子コントロールにデータ ソースをバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use this method to bind data from a source to a server control. This method is commonly used after retrieving a dataset through a database query. Most controls perform data binding automatically, which means that you typically do not need to call this method explicitly.  
  
 This method is commonly overridden when you create a custom templated data\-bound control. For more information, see [How to: Create Templated User Controls](http://msdn.microsoft.com/ja-jp/07664410-02dd-4494-af53-a9259741d4f2) and [Developing Custom Data\-Bound Web Server Controls](http://msdn.microsoft.com/ja-jp/88fe02a3-957f-4ff7-84f5-2d7ab78db4c1). When called on a server control, this method resolves all data\-binding expressions in the server control and in any of its child controls.  
  
   
  
## 例  
 The following example overrides the <xref:System.Web.UI.Control.DataBind%2A> method in a custom ASP.NET server control. It begins by calling the base <xref:System.Web.UI.Control.OnDataBinding%2A> method and then uses the <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=fullName> method to delete all the child controls and the <xref:System.Web.UI.Control.ClearChildViewState%2A> method to delete any saved view\-state settings for those child controls. Finally, the <xref:System.Web.UI.Control.ChildControlsCreated%2A> property is set to **languageKeyword tag is not supported!!!!**  
 and the control is instructed to track any changes to the view state of the newly created controls with the <xref:System.Web.UI.Control.TrackViewState%2A> method. This is a common technique when binding data to a control to ensure that new data does not conflict with data stored from a previous <xref:System.Web.UI.Control.DataBind%2A> method call.  
  
 [!code-csharp[Control\_StateManagement\#6](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#6)]
 [!code-vb[Control\_StateManagement\#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="protected virtual void DataBind (bool raiseOnDataBinding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBind(bool raiseOnDataBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="raiseOnDataBinding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="raiseOnDataBinding">
          <see langword="true" /> 場合、 <see cref="E:System.Web.UI.Control.DataBinding" /> イベントが発生した以外の場合、 <see langword="false" />です。</param>
        <summary>呼び出されたサーバー コントロールとさせるオプションがすべての子コントロールをデータ ソースをバインド、 <see cref="E:System.Web.UI.Control.DataBinding" /> イベントです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=fullName> メソッドにカスタム コントロールをオーバーライドすると、シナリオ、 <xref:System.Web.UI.Control.DataBind%2A> メソッドを実装、 <xref:System.Web.UI.IDataItemContainer> インターフェイスです。 このシナリオでカスタム コントロールを呼び出し、 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=fullName> メソッドを `raiseOnDataBinding` に設定 `false` 、基本クラスのことを確認する <xref:System.Web.UI.Control.DataBind%2A> メソッドが呼び出されます。  
  
 <xref:System.Web.UI.Control.DataBind?displayProperty=fullName> メソッドを呼び出す、 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=fullName> メソッドを `raiseOnDataBinding` 設定 `true`します。  
  
> [!NOTE]
>  呼び出す、 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=fullName> メソッドを `raiseOnDataBinding` に設定 `false` 任意の子コントロールを使用してバインドされたデータの発生、 <xref:System.Web.UI.Control.DataBind?displayProperty=fullName> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
      </Docs>
    </Member>
    <Member MemberName="DataBindChildren">
      <MemberSignature Language="C#" Value="protected virtual void DataBindChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBindChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBindChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>データ ソースをサーバー コントロールの子コントロールにバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Control.DataBindChildren%2A> サーバー コントロールの子コントロールにデータ ソースをバインドするメソッドです。  
  
> [!NOTE]
>  サーバー コントロールで呼び出されると、このメソッドは、コントロールにデータをバインドできません。 サーバー コントロールとそのすべての子コントロールをバインドするには、呼び出し、 <xref:System.Web.UI.Control.DataBind%2A> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBinding">
      <MemberSignature Language="C#" Value="public event EventHandler DataBinding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataBinding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.DataBinding" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがデータ ソースに連結すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントに書き込まれたデータ バインディング ロジックを実行するサーバー コントロールに通知します。  
  
   
  
## 例  
 [!code-csharp[ITemplate\_Interface\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ITemplate_Interface/CS/itemplate.cs#1)]
 [!code-vb[ITemplate\_Interface\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ITemplate_Interface/VB/itemplate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DataItemContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataItemContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataItemContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前付けコンテナーを実装する場合は、名前付けコンテナーへの参照を取得 <see cref="T:System.Web.UI.IDataItemContainer" />します。</summary>
        <value>名前付けコンテナーです。 名前付けを実装するコンテナーの階層では <see cref="T:System.Web.UI.IDataItemContainer" />, 、このプロパティには、階層の上部にある名前付けコンテナーが返されます。 または <see langword="null" /> 場合、現在 <see cref="T:System.Web.UI.Control" /> を実装する名前付けコンテナーにオブジェクトがない <see cref="T:System.Web.UI.IDataItemContainer" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataKeysContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataKeysContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataKeysContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataKeysContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前付けコンテナーを実装する場合は、名前付けコンテナーへの参照を取得 <see cref="T:System.Web.UI.IDataKeysControl" />します。</summary>
        <value>名前付けコンテナーです。 名前付けを実装するコンテナーの階層では <see cref="T:System.Web.UI.IDataKeysControl" />, 、プロパティには、階層の上部にある名前付けコンテナーが返されます。 または <see langword="null" /> 場合は、現在 <see cref="T:System.Web.UI.Control" /> を実装する名前付けコンテナーにオブジェクトがない <see cref="T:System.Web.UI.IDataKeysControl" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignMode">
      <MemberSignature Language="C#" Value="protected bool DesignMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DesignMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デザイン画面でコントロールを使用しているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> デザイナーでコントロールを使用している場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.DesignMode%2A> プロパティを返します。 `true` をコントロールがデザイナーのコンテキストで使用されていることを示します。 カスタム コントロールは、デザイン時の動作が実行時の動作と異なる場合、このプロパティを使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メモリから解放される前に、最終的なクリーンアップを実行するサーバー コントロールを有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.Dispose%2A> を使い終わったら <xref:System.Web.UI.Control> を呼び出します。<xref:System.Web.UI.Control.Dispose%2A> メソッドによって、<xref:System.Web.UI.Control> は使用不可の状態になります。 このメソッドを呼び出した後が使用していたメモリをガベージ コレクションによって解放できるようにコントロールへのすべての参照を解放する必要があります。  
  
   
  
## 例  
 次のコード例の上書き、 <xref:System.Web.UI.Control.Dispose%2A> を終了するメソッド、 <xref:System.Web.UI.HtmlTextWriter> コントロール、および呼び出しに関連付けられているオブジェクト、 <xref:System.Web.UI.Control.Dispose%2A> メソッドを <xref:System.Web.UI.WebControls.Button> という名前のコントロール `myButton`します。 場合、 <xref:System.Exception> 場合にスローされるは、このバージョン、 <xref:System.Web.UI.Control.Dispose%2A> メソッドが呼び出されると、コントロール メッセージを現在 <xref:System.Web.HttpResponse> オブジェクトです。  
  
 [!code-csharp[Control\_Dispose\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Dispose/CS/control_disposemethod.cs#1)]
 [!code-vb[Control\_Dispose\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Dispose/VB/control_disposemethod.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Disposed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールが ASP.NET ページが要求されたときに、サーバー コントロールのライフ サイクルの最後のステージは、メモリからリリースされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントには、データベース接続などの大量のプロセッサ時間を必要とするリソースを解放する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public virtual bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはこのコントロールにテーマを適用するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> テーマを使用するにはそれ以外の場合、 <see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.EnableTheming%2A> プロパティは、指定したコントロールのテーマが有効かどうかを示します。 ときに、 <xref:System.Web.UI.Control.EnableTheming%2A> プロパティは、 `true`, 、コントロール スキンを適用するテーマのアプリケーションのディレクトリが検索されます。 特定のコントロールのスキンがテーマ ディレクトリに存在しない場合、スキンは適用されません。  
  
 ときに、 <xref:System.Web.UI.Control.EnableTheming%2A> プロパティは、 `false`, 、テーマ ディレクトリは検索されずのコンテンツ、 <xref:System.Web.UI.Control.SkinID%2A> プロパティは使用されません。  
  
 テーマは、ページ、コンテナー、または制御レベルで有効にすることができます。 オーバーライド、 <xref:System.Web.UI.Control.EnableTheming%2A> 値、親コントロールまたはコントロールを含むページのセットです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="Page_PreInit" /> イベントが既に発生します。  
  
 または  
  
 コントロールは既にに追加されて、 <see langword="Controls" /> コレクションです。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public virtual bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求元クライアントに対して、サーバー コントロールがそのビュー状態と、そこに含まれる任意の子のコントロールのビュー状態を保持するかどうかを示す値を取得または設定します。</summary>
        <value>サーバー コントロールがビュー状態を保持する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 View state enables a server control to maintain its state across HTTP requests. View state for a control is enabled if all of the following conditions are met:  
  
-   The <xref:System.Web.UI.Control.EnableViewState%2A> property for the page is set to **languageKeyword tag is not supported!!!!**  
    .  
  
-   The <xref:System.Web.UI.Control.EnableViewState%2A> property for the control is set to **languageKeyword tag is not supported!!!!**  
    .  
  
-   The <xref:System.Web.UI.Control.ViewStateMode%2A> property for the control is set to <xref:System.Web.UI.ViewStateMode.Enabled> or inherits the <xref:System.Web.UI.ViewStateMode.Enabled> setting.  
  
 For more information, see the <xref:System.Web.UI.Control.ViewStateMode%2A> property.  
  
 A server control's view state is the accumulation of all its property values. In order to preserve these values across HTTP requests, ASP.NET uses an instance of the <xref:System.Web.UI.StateBag> class to store the property values. The values are then passed as a variable to a hidden field when subsequent requests are processed. For more information about view state, see [ASP.NET View State Overview](http://msdn.microsoft.com/ja-jp/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818).  
  
 There are times when it is appropriate to disable view state, particularly to improve application performance. For example, if you are loading a database request into a server control, set this property to **languageKeyword tag is not supported!!!!**  
. If you do not, processor time will be wasted loading view state into the server control that will only be overridden by the database query. If <xref:System.Web.UI.Control.EnableViewState%2A> is **languageKeyword tag is not supported!!!!**  
, you can use the control state to persist property information that is specific to a control and cannot be turned off like the view state property. For more information on the difference between control state and view state, see [Control State vs. View State Example](http://msdn.microsoft.com/ja-jp/9e98c7de-a888-48df-b14e-02ec8bef7681).  
  
 For information about how to enable or disable view state declaratively for an ASP.NET page, see .  
  
   
  
## 例  
 The following example sets the <xref:System.Web.UI.Control.EnableViewState%2A> property to **languageKeyword tag is not supported!!!!**  
.  
  
 [!code-csharp[Control\_StateManagement\#7](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_statemanagement.cs.aspx#7)]
 [!code-vb[Control\_StateManagement\#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_statemanagement.vb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
      </Docs>
    </Member>
    <Member MemberName="EndRenderTracing">
      <MemberSignature Language="C#" Value="protected void EndRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">このオブジェクトは、トレース データを書き込みます。</param>
        <param name="traceObject">Trace オブジェクトです。</param>
        <summary>表示データのデザイン時のトレースを終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureChildControls">
      <MemberSignature Language="C#" Value="protected virtual void EnsureChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void EnsureChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureChildControls" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールに子コントロールが含まれているかどうかを判断します。 そうでない場合、子コントロールを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、最初の現在の値をチェック、 <xref:System.Web.UI.Control.ChildControlsCreated%2A> プロパティです。 この値が場合 `false`, 、 <xref:System.Web.UI.Control.CreateChildControls%2A> メソッドが呼び出されます。  
  
 <xref:System.Web.UI.Control.EnsureChildControls%2A> メソッドがこれらのコントロールのいくつかの子コントロールを使用する複合コントロールで通常使用されるか、すべての機能です。<xref:System.Web.UI.Control.EnsureChildControls%2A> 子コントロールが作成されているし、データ バインドを実行する、またはその他のタスクを実行している入力を処理する準備ができなかどうかを確認するために呼び出されます。  
  
 <xref:System.Web.UI.WebControls.GridView> コントロール複合コントロールの例に示します。 子コントロールを作成など、 <xref:System.Web.UI.WebControls.Table>, 、<xref:System.Web.UI.WebControls.TableRow>, 、<xref:System.Web.UI.WebControls.TableCell>, 、<xref:System.Web.UI.WebControls.Label>, 、および <xref:System.Web.UI.WebControls.TextBox> HTML を表示するためのコントロールがテーブルを <xref:System.Web.UI.WebControls.GridView> が生成されます。  
  
 ほとんどの場合、カスタム サーバー コントロールの開発者はこのメソッドをオーバーライドしてありません。 このメソッドをオーバーライドした場合は、既定の動作と同様の方法で使用します。  
  
   
  
## 例  
 次の例では、 <xref:System.Web.UI.Control.EnsureChildControls%2A> メソッドを現在のサーバー コントロールに子コントロールがあることを確認します。 次を取得または設定、 <xref:System.Web.UI.WebControls.TextBox.Text%2A> 子に対してプロパティ <xref:System.Web.UI.WebControls.TextBox> Web コントロールを現在のサーバー コントロールの <xref:System.Web.UI.ControlCollection> オブジェクトです。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#1)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="EnsureID">
      <MemberSignature Language="C#" Value="protected void EnsureID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>割り当てられた識別子がないコントロールの id を作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.EnsureID%2A> メソッドは、別のコントロールに含まれているコントロールの id を生成します。 識別子に割り当てられた値がないコントロールに対してのみ生成、 <xref:System.Web.UI.Control.ID%2A> プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.EventHandlerList Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.EventHandlerList Events" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Events" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventHandlerList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのイベント ハンドラー デリゲートの一覧を取得します。 このプロパティは読み取り専用です。</summary>
        <value>イベント ハンドラー デリゲートの一覧。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの型は <xref:System.ComponentModel.EventHandlerList>, 、一方向の検索アルゴリズムを使用して、デリゲートの一覧でエントリを検索します。 多数のエントリを使用する場合、一方向の検索アルゴリズムは効率的ではありません。 そのため、大きい一覧を確認したら、このプロパティを持つエントリが遅くなりますを検索します。  
  
   
  
## 例  
 次の例は、という名前のイベントを作成 `Click`, を追加し、コントロールからハンドラーを削除する <xref:System.ComponentModel.EventHandlerList> コレクション ページから、イベントが呼び出されるとします。  
  
 **注** この例は、コントロールで追加する方法と、イベントをコントロールが維持するそれらのリストから削除する方法を最適化します。 カスタム コントロールを作成してイベントを定義する場合は、次のようなコードを使用します。 Visual Basic ではなく、C\# の場合に、この手法を使用できます。  
  
 [!code-csharp[System.Web.UI.Page\_VerifyRenderingInServerForm\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventHandlerList" />
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">検索するコントロールの識別子。</param>
        <summary>指定したサーバー コントロールの現在の名前付けコンテナーを検索 <paramref name="id" /> パラメーター。</summary>
        <returns>指定したコントロールまたは <see langword="null" /> 指定したコントロールが存在しない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用 <xref:System.Web.UI.Control.FindControl%2A> 分離コード ページの別のコンテナー内のコントロールにアクセスする、または対象のコントロールが、呼び出し元に直接アクセスしない他の状況では、関数からコントロールにアクセスします。 このメソッドは、コントロールを見つけるコントロールが指定されたコンテナーに直接入っている場合にのみつまり、メソッドでは、コントロール内のコントロールの階層全体で検索しません。 その直接のコンテナーを識別できないときに、コントロールを検索する方法については、次を参照してください。 [How to: Access Server Controls by ID](http://msdn.microsoft.com/ja-jp/59964ef8-72ef-4159-9f1a-5b230ff46fb3)します。  
  
   
  
## 例  
 次の例、 `Button1_Click` イベント ハンドラーです。 このハンドラーを使用して、呼び出されたときに、 <xref:System.Web.UI.Control.FindControl%2A> を使用して、コントロールを探す方法、 <xref:System.Web.UI.Control.ID%2A> の `TextBox2` コンテナー ページです。 使用して、親を判断する、コントロールが見つかった場合、 <xref:System.Web.UI.Control.Parent%2A> プロパティと、親コントロールの <xref:System.Web.UI.Control.ID%2A> 、ページに書き込まれます。 場合 `TextBox2` が検出されなければ、「コントロールが見つかりません」が、ページに書き込まれます。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[Script Exploits Overview](http://msdn.microsoft.com/ja-jp/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[System.Web.UI.Page.Parent\_FindControl\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent\_FindControl\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Control FindControl (string id, int pathOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id, int32 pathOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="pathOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">検索するコントロールの識別子。</param>
        <param name="pathOffset">名前付けコンテナーに到達するために必要なページ コントロール階層までのコントロールの数。</param>
        <summary>指定したサーバー コントロールの現在の名前付けコンテナーを検索 <paramref name="id" /> および整数で指定された、 <paramref name="pathOffset" /> パラメーターで、検索を支援します。 このバージョンのオーバーライドしないでください、 <see cref="Overload:System.Web.UI.Control.FindControl" /> メソッドです。</summary>
        <returns>指定したコントロールまたは <see langword="null" /> 指定したコントロールが存在しない場合。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public virtual void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>入力コントロールにフォーカスを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Control.Focus%2A> コントロールに、Web ページの初期フォーカスを設定します。 ページが開き、ブラウザーでコントロールを選択します。  
  
 <xref:System.Web.UI.Control.Focus%2A> メソッドにより、スクリプトの呼び出しをページ フォーカス表示されたページに出力されます。 ページに HTML を持つコントロールが含まれていないかどうかは `ID` コントロールと一致する属性を <xref:System.Web.UI.Control.Focus%2A> メソッドが呼び出されたし、ページのフォーカスは設定されません。 これは発生する例は、ユーザー コントロールの子コントロールにフォーカスを設定する代わりにユーザー コントロールにフォーカスを設定する場合です。 このシナリオで使用することができます、 <xref:System.Web.UI.Control.FindControl%2A> メソッド呼び出しをユーザー コントロールの子コントロールを検索してその <xref:System.Web.UI.Control.Focus%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.FindControl(System.String)" />
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IDictionary GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetDesignModeState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールのデザイン時のデータを取得します。</summary>
        <returns>
          <see cref="T:System.Collections.IDictionary" /> コントロールのデザイン時データを格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.GetDesignModeState%2A> メソッドは、コントロールのデザイン時のデータを返します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The <see cref="M:System.Web.UI.Control.GetDesignModeState" /> method returns <see langword="null" /> by default. You must override this method to provide the design-time data your control requires.</para>
        </block>
        <altmember cref="T:System.Web.UI.IControlDesignerAccessor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRouteUrl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>および必要に応じて一連のルートのパラメーターに、ルート名に対応する URL を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeParameters">ルートのパラメーターです。</param>
        <summary>ルートのパラメーターのセットに対応する URL を取得します。</summary>
        <returns>指定したルート パラメーターに対応する URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=fullName> メソッドです。 このメソッドに渡されるオブジェクトは変換 `routeParameters` に、 <xref:System.Web.Routing.RouteValueDictionary> オブジェクトを使用して、 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=fullName> コンス トラクターです。  
  
   
  
## 例  
 次の例を呼び出す方法を示します、 <xref:System.Web.UI.Control.GetRouteUrl%2A?displayProperty=fullName> はという名前のパラメーターを持つルートの URL を取得するメソッド `productid` と `category`です。 この例では、作成した、 <xref:System.Web.UI.WebControls.HyperLink> という名前は、コントロールを `HyperLink1`します。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeParameters">ルートのパラメーターです。</param>
        <summary>ルートのパラメーターのセットに対応する URL を取得します。</summary>
        <returns>指定したルート パラメーターに対応する URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=fullName> メソッドです。  
  
   
  
## 例  
 次の例はという名前のパラメーターを持つルートの URL を取得するには、このメソッドを呼び出す方法を示しています。 `productid` と `category`です。 この例では、作成した、 <xref:System.Web.UI.WebControls.HyperLink> という名前は、コントロールを `HyperLink1`します。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeParameters">ルートのパラメーターです。</param>
        <summary>一連のルートのパラメーターとルート名に対応する URL を取得します。</summary>
        <returns>指定したルート パラメーターとルート名に対応する URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=fullName> メソッドです。 このメソッドに渡されるオブジェクトは変換 `routeParameters` に、 <xref:System.Web.Routing.RouteValueDictionary> オブジェクトを使用して、 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=fullName> コンス トラクターです。  
  
   
  
## 例  
 次の例は、というルートの URL を取得するには、このメソッドを呼び出す方法を示しています。 `Product` パラメーターに名前が付けられる `productid` と `category`です。 この例では、作成した、 <xref:System.Web.UI.WebControls.HyperLink> という名前は、コントロールを `HyperLink1`します。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeParameters">ルートのパラメーターです。</param>
        <summary>一連のルートのパラメーターとルート名に対応する URL を取得します。</summary>
        <returns>指定したルート パラメーターとルート名に対応する URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと同じである、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=fullName> メソッドです。  
  
   
  
## 例  
 次の例は、というルートの URL を取得するには、このメソッドを呼び出す方法を示しています。 `Product` パラメーターに名前が付けられる `productid` と `category`です。 この例では、作成した、 <xref:System.Web.UI.WebControls.HyperLink> という名前は、コントロールを `HyperLink1`します。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueIDRelativeTo">
      <MemberSignature Language="C#" Value="public string GetUniqueIDRelativeTo (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetUniqueIDRelativeTo(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">名前付けコンテナー内にあるコントロール。</param>
        <summary>プレフィックスの付いた部分を返す、 <see cref="P:System.Web.UI.Control.UniqueID" /> 指定されたコントロールのプロパティです。</summary>
        <returns>プレフィックスの付いた部分、 <see cref="P:System.Web.UI.Control.UniqueID" /> 指定されたコントロールのプロパティです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.UniqueID%2A> コントロールのプロパティがコントロールのプレフィックスを追加することによって生成される <xref:System.Web.UI.Control.ID%2A> プロパティです。 プレフィックスから成るは、 <xref:System.Web.UI.Control.UniqueID%2A> コントロールのプロパティの名前付けコンテナーの区切り記号に連結します。 名前付けコンテナーが、ページの場合、プレフィックスはありません。 このメソッドは、プレフィックス文字列を返します。 返すかどうかは、プレフィックス文字列がない、 <xref:System.Web.UI.Control.UniqueID%2A> コントロールの値。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="control" /> の <see cref="P:System.Web.UI.Control.NamingContainer" /> プロパティは <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasChildViewState">
      <MemberSignature Language="C#" Value="protected bool HasChildViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.HasChildViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のサーバー コントロールの子コントロールが、保存されているビュー ステートの設定を持つかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> すべての子コントロールがビュー状態情報を保存した場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 不要な呼び出しを避けることができます、 <xref:System.Web.UI.Control.ClearChildViewState%2A> メソッドを使用してこのプロパティをサーバー コントロールの子コントロールのビューステート情報が保存されていることを確認します。  
  
   
  
## 例  
 [!code-csharp[Control\_StateManagement\#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control\_StateManagement\#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="HasControls">
      <MemberSignature Language="C#" Value="public virtual bool HasControls ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasControls" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールに子コントロールが含まれるかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> コントロールには、その他のコントロールにコントロールが含まれている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 パフォーマンスを向上させる、不要なを回避することにより、子コントロールが存在する場合、このメソッドが単に判断するため <xref:System.Web.UI.ControlCollection.Count%2A> プロパティの呼び出しです。 このプロパティへの呼び出しを必要とする <xref:System.Web.UI.ControlCollection> インスタンス化するオブジェクト。 子が存在しない場合、このオブジェクトの作成は、サーバーのリソースを浪費します。  
  
   
  
## 例  
 次の例では、 <xref:System.Web.UI.Control.HasControls%2A> の制御を使用する前に存在するかどうかを決定する方法、 <xref:System.Web.UI.ControlCollection.Count%2A> プロパティを反復処理する、 <xref:System.Web.UI.ControlCollection> オブジェクトです。  
  
 [!code-csharp[Classic Control.HasControls Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.HasControls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.HasControls Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.HasControls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>The <see cref="M:System.Web.UI.Control.HasControls" /> method should be overridden only to change metadata attributes such as <see cref="T:System.ComponentModel.EditorBrowsableAttribute" />. For more information about using attributes, see [Attributes](http://msdn.microsoft.com/library/30386922-1e00-4602-9ebf-526b271a8b87).</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="HasEvents">
      <MemberSignature Language="C#" Value="protected bool HasEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールまたはその子コントロールのイベントを登録するかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> イベントは登録されている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public virtual string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはサーバー コントロールに割り当てられたプログラム id を設定します。</summary>
        <value>コントロールに割り当てられているプログラム id。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サーバー コントロールでこのプロパティを設定するサーバー コントロールのプロパティ、イベント、およびメソッドにプログラムでアクセスを提供します。 このプロパティは、宣言することを Web 開発者によって設定できる、 <xref:System.Web.UI.Control.ID%2A> ASP.NET サーバー コントロールの開始タグの属性です。  
  
 宣言またはプログラムによってこのプロパティは、サーバー コントロールの場合に指定しない場合、親コントロールの使用してコントロールへの参照を取得できます <xref:System.Web.UI.Control.Controls%2A> プロパティです。  
  
> [!NOTE]
>  英数字とアンダー スコア文字 \(\_\) の組み合わせだけは、このプロパティの有効な値です。 スペースやその他の無効な文字を含めると、ASP.NET ページ パーサー エラーが発生します。  
  
   
  
## 例  
 [!code-csharp[Control\_Sample\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs.aspx#2)]
 [!code-vb[Control\_Sample\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="protected char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの識別子を区切るために使用する文字を取得します。</summary>
        <value>区切り記号。 既定では、「$」は。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 含まれる文字、 <xref:System.Web.UI.Control.IdSeparator%2A> プロパティを使用して、子コントロールのコントロール id を区別します。 識別子の区切り記号の文字に追加されます、 <xref:System.Web.UI.Control.ID%2A> プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public event EventHandler Init;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Init" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Init" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ライフ サイクルの最初の手順は、サーバー コントロールが初期化時に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サーバー コントロールは、インスタンスを作成および設定に必要な初期化の手順を実行する必要があります。 このイベント内のビュー状態情報を使用することはできません。値を返さないまだです。 別のサーバー コントロールは、子ドメインまたはこのコントロールの親であるかどうかにかかわらず、このイベント中にアクセスしないでください。 その他のサーバー コントロールの作成、アクセスの準備が完了するではありません。 サーバー コントロールのイベントの詳細については、次を参照してください。 [ASP.NET Web Server Control Event Model](http://msdn.microsoft.com/ja-jp/6304bff7-1b0e-4641-8acb-6d3b0badc4a3)します。  
  
   
  
## 例  
 次の例では、カスタム イベント ハンドラー `Calendar_Init`, を `Init` のイベント、 <xref:System.Web.UI.WebControls.Calendar> コントロールです。  
  
 [!code-csharp[Control\_Sample\#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples2.cs.aspx#4)]
 [!code-vb[Control\_Sample\#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples2.vb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsChildControlStateCleared">
      <MemberSignature Language="C#" Value="protected bool IsChildControlStateCleared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsChildControlStateCleared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールに含まれるコントロールがコントロールの状態を保持するかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> このコントロールの子コントロールの状態を使用しない場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteralContent">
      <MemberSignature Language="C#" Value="protected bool IsLiteralContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsLiteralContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.IsLiteralContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールにリテラルの内容のみが保持しているかを決定します。</summary>
        <returns>
          <see langword="true" /> サーバー コントロールには、リテラルな内容だけが含まれている場合それ以外の場合 <see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る `true`, 、サーバー コントロールのコレクションは単一のリテラル コントロールを保持します。  
  
   
  
## 例  
 次の例では、サーバー コントロールを含むページがポストバックされたかどうかを確認します。 呼び出す場合に、 <xref:System.Web.UI.Control.IsLiteralContent%2A> コントロールがリテラルだけのコンテンツを含むまたは他のサーバー コントロールを親コントロールかどうかを決定する方法です。 リテラルの内容だけが含まれている場合、 <xref:System.Web.UI.Control.UniqueID%2A> のプロパティ、 <xref:System.Web.UI.LiteralControl> を表す内容が応答を書き込む。  
  
 [!code-csharp[System.Web.UI.Control\_ViewStateIgnoresCase\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#1)]
 [!code-vb[System.Web.UI.Control\_ViewStateIgnoresCase\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.HasControls" />
        <altmember cref="T:System.Web.UI.LiteralControl" />
      </Docs>
    </Member>
    <Member MemberName="IsTrackingViewState">
      <MemberSignature Language="C#" Value="protected bool IsTrackingViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTrackingViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsTrackingViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールのビュー ステートへ変更を保存するかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> コントロールがその状態を保存するマークされている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを使用する、サンプル カスタム サーバー コントロールには、次を参照してください。 [Templated Server Control and Designer Sample](http://msdn.microsoft.com/ja-jp/986f63b8-6b50-42b9-a62d-a2f13cafa88b)  
  
   
  
## 例  
 次の例では、オーバーライド、 <xref:System.Web.UI.Control.DataBind%2A> カスタム ASP.NET サーバー コントロール。 ベースの呼び出しでは、まず、 <xref:System.Web.UI.Control.OnDataBinding%2A> メソッドし、使用して、 `ControlCollection` オブジェクトです。<xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=fullName> すべての子コントロールを削除する方法、および <xref:System.Web.UI.Control.ClearChildViewState%2A> 削除するためのメソッドがそれらの子コントロールのビュー ステートの設定を保存します。 最後に、 <xref:System.Web.UI.Control.ChildControlsCreated%2A> にプロパティが設定されている `true`します。 コントロールを使用し、 <xref:System.Web.UI.Control.IsTrackingViewState%2A> プロパティをコントロールのビュー ステートの変更の追跡が有効になっているかどうかを判断します。 有効でない場合、 <xref:System.Web.UI.Control.TrackViewState%2A> メソッドが呼び出されます。  
  
 [!code-csharp[Control\_StateManagement\#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#4)]
 [!code-vb[Control\_StateManagement\#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="IsViewStateEnabled">
      <MemberSignature Language="C#" Value="protected bool IsViewStateEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewStateEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsViewStateEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールのビュー ステートが有効になっているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> コントロールのビュー ステートが有効になっている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ビュー ステートは、ページ、コンテナー、または制御レベルで有効にすることができます。 ページまたはコンテナー レベルでは、ビュー ステートが無効である場合は、ページまたはコンテナーに含まれるすべてのコントロールのビュー ステートが無効になります。<xref:System.Web.UI.Control.IsViewStateEnabled%2A> プロパティは、ページ、コンテナー、またはコントロールでのビュー ステートが有効になっているかどうかを示します。  
  
 できます、 <xref:System.Web.UI.Control.EnableViewState%2A> プロパティおよび <xref:System.Web.UI.Control.IsViewStateEnabled%2A> 別にするプロパティです。 たとえば場合、 <xref:System.Web.UI.Page> 無効にすると表示状態を持つコントロールを含む、 <xref:System.Web.UI.Control.EnableViewState%2A> プロパティを指定できます `true` 中に、 <xref:System.Web.UI.Control.IsViewStateEnabled%2A> プロパティは `false`です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Page developers will set the <see cref="P:System.Web.UI.Control.EnableViewState" /> property and the <see cref="P:System.Web.UI.Control.ViewStateMode" /> property to indicate whether they are using view state with your control. Use the <see cref="P:System.Web.UI.Control.IsViewStateEnabled" /> property and the <see cref="P:System.Web.UI.Control.ViewStateMode" /> property in your code to determine whether view state is enabled for your control and for all containers.</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Load" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールが読み込まれるときに発生する、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各ページ要求に対して発生する可能性に設定されている処理手順を実行するサーバー コントロールに通知します。 状態情報を表示し、Web フォームの POST データは、このイベントからアクセスできます。 ページのコントロールの階層構造内の他のサーバー コントロールを表示することもできます。  
  
> [!NOTE]
>  中にコントロールのカスタム テンプレートを設定するかどうか、 `Page_Load` イベント、カスタム テンプレートで子コントロールのテキスト値は失われます。 これは、フォームの値が既に読み込まれているために発生します。  
  
   
  
## 例  
 [!code-csharp[System.Web.UI.Control\_Load\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Load/CS/control_load.cs#2)]
 [!code-vb[System.Web.UI.Control\_Load\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Load/VB/control_load.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected virtual void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">復元するコントロールの状態を表す <see cref="T:System.Object" />。</param>
        <summary>によって保存された前のページ要求からのコントロールの状態情報の復元、 <see cref="M:System.Web.UI.Control.SaveControlState" /> メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 カスタム サーバー コントロールがコントロールの状態を復元する方法を指定する必要がある場合は、このメソッドをオーバーライドします。 詳細については、「[ASP.NET State Management Overview](http://msdn.microsoft.com/ja-jp/0218d965-5d30-445b-b6a6-8870e70e63ce)」を参照してください。  
  
   
  
## 例  
 次のコード例の上書き、 <xref:System.Web.UI.Control.LoadControlState%2A> カスタム ASP.NET コントロールのメソッドです。 このメソッドが呼び出されるかどうが決定コントロールの状態以前に保存したコントロールの内部プロパティを設定 `currentIndex` 保存されている値にします。  
  
 <xref:System.Web.UI.Control.OnInit%2A> メソッドをオーバーライドしてを呼び出す、 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> メソッドを <xref:System.Web.UI.Control.Page%2A> にカスタム コントロールがコントロールの状態を使用するように指定します。  
  
 [!code-csharp[ControlState\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadViewState(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">復元するコントロールの状態を表す <see cref="T:System.Object" />。</param>
        <summary>によって保存された前のページ要求からビューステート情報を復元する、 <see cref="M:System.Web.UI.Control.SaveViewState" /> メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、主に、.NET Framework インフラストラクチャによって使用され、コードから直接使用するものではありません。 ただし、コントロールの開発者は、カスタム サーバー コントロールがそのビューステートを復元する方法を指定するには、このメソッドをオーバーライドすることができます。 詳細については、「[ASP.NET State Management Overview](http://msdn.microsoft.com/ja-jp/0218d965-5d30-445b-b6a6-8870e70e63ce)」を参照してください。  
  
   
  
## 例  
 次の例では、オーバーライド、 <xref:System.Web.UI.Control.LoadViewState%2A> カスタム ASP.NET サーバー コントロールのメソッドです。 作成、 <xref:System.Object> に渡されたビュー状態情報を格納する配列、 `savedState` パラメーターの基本実装を呼び出すと、 <xref:System.Web.UI.Control.LoadViewState%2A> 配列の最初のインデックス位置のメソッドです。 という名前の変数には、次の 2 つのインデックス位置に格納値を `UserText` と `PasswordText`, 、それぞれします。  
  
 [!code-csharp[Control\_StateManagement\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#1)]
 [!code-vb[Control\_StateManagement\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="LoadViewStateByID">
      <MemberSignature Language="C#" Value="protected bool LoadViewStateByID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadViewStateByID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.LoadViewStateByID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが、そのビュー ステートの読み込み中に含めるかどうかを示す値を取得 <see cref="P:System.Web.UI.Control.ID" /> インデックスではなく。</summary>
        <value>
          <see langword="true" /> コントロールは、ビューステートを読み込む場合 <see cref="P:System.Web.UI.Control.ID" />。 そうしないと、 <see langword="false" />です。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、親コントロールによって作成される子コントロールのビューステートの読み込み時にこれは、親コントロールの各子コントロールの位置によって <xref:System.Web.UI.Control.Controls%2A> コレクションです。 ビュー ステートが最初に適用されるすべての子コントロールがありますが作成されていません。 この場合、作成されていないコントロールのビュー ステートが保存され、子コントロールは、後で作成するときに適用。  
  
 親コントロールのビュー ステートをコントロールの子コントロールに適用するには、2 つの条件を満たす必要があります。  
  
-   ポストバックで、親コントロールする必要があります、子コントロールを作成、前回の要求とまったく同じ順序ではコントロールの順序が変わらないようにします。  
  
-   ポストバックの後に、親コントロールの末尾に作成されたすべての子コントロールを追加 <xref:System.Web.UI.Control.Controls%2A> コレクションです。  
  
 子コントロールの遅延作成する場合に、これら 2 つの条件を満たすことができない、親コントロールを使用してビューステートを読み込むことができます <xref:System.Web.UI.Control.ID%2A>します。 設定する、 <xref:System.Web.UI.Control.LoadViewStateByID%2A> プロパティを `true`, を使用して、 <xref:System.Web.UI.ViewStateModeByIdAttribute> 親コントロールのメタデータ属性です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.ViewStateModeByIdAttribute" />
      </Docs>
    </Member>
    <Member MemberName="MapPathSecure">
      <MemberSignature Language="C#" Value="protected string MapPathSecure (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string MapPathSecure(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.MapPathSecure(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">相対パスまたは相対 URL をルートします。</param>
        <summary>仮想パス、絶対または相対パスのいずれかにマップされる物理パスを取得します。</summary>
        <returns>要求されたファイルの物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、ファイルを読み取るアクセス許可を持ち、System.Web.dll など、完全に信頼された .dll ファイルの一部であるサーバー コントロールによってのみ使用できます。 これにより、セキュリティ侵害を防止できます。  
  
   
  
## 例  
 次の例では、 <xref:System.Web.UI.Control.MapPathSecure%2A> メソッドを含むの仮想ディレクトリの物理パスを取得する <xref:System.Web.UI.Page> または <xref:System.Web.UI.UserControl> オブジェクトです。  
  
 [!code-csharp[Control\_MapPathSecure\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_MapPathSecure/CS/control_templatesourcedirectory.cs#1)]
 [!code-vb[Control\_MapPathSecure\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_MapPathSecure/VB/control_templatesourcedirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="virtualPath" /> <see langword="null" /> または空の文字列 \(""\) です。</exception>
      </Docs>
    </Member>
    <Member MemberName="NamingContainer">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control NamingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control NamingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.NamingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、サーバー コントロールへの参照の名前付けでは、同じサーバー コントロールの違いの一意の名前空間を作成するコンテナー <see cref="P:System.Web.UI.Control.ID" /> プロパティの値。</summary>
        <value>サーバー コントロールには、コンテナーの名前付けします。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET Web アプリケーション内の各ページには、コントロールの階層構造が含まれています。 この階層は、コントロールが、ユーザーに表示される UI を生成するかどうかに依存しません。 特定のコントロールの名前付けコンテナーは、親コントロールを実装する階層で、 <xref:System.Web.UI.INamingContainer> インターフェイスです。 このインターフェイスを実装するサーバー コントロールの一意の名前空間の作成、 <xref:System.Web.UI.Control.ID%2A> 子サーバー コントロールのプロパティ値です。 使用することができます、 <xref:System.Web.UI.Control.NamingContainer%2A> 名前付けコンテナーの子コントロールを親コンテナーへの参照を取得します。  
  
 サーバー コントロールの一意の名前空間の作成は、特に重要など、データに Web サーバー コントロールをバインドすると、 <xref:System.Web.UI.WebControls.Repeater> と <xref:System.Web.UI.WebControls.DataList> サーバー コントロール。 データ ソースに複数のエントリは、コントロールの子であるサーバー コントロールの複数のインスタンスを作成するときに、名前付けコンテナーのにより、これらの子コントロールの各インスタンスがいる <xref:System.Web.UI.Control.UniqueID%2A> 競合しないプロパティ値です。 ページの既定の名前付けコンテナーは、のインスタンス、 <xref:System.Web.UI.Page> そのページが要求されたときに生成されるクラスです。  
  
 <xref:System.Web.UI.Control.ClientID%2A> プロパティには、要素のとして表示されている値が含まれています。 `id` HTML マークアップ内の属性です。 割り当てられる値に応じて、 <xref:System.Web.UI.Control.ClientIDMode%2A> プロパティ、値に対して生成される、 <xref:System.Web.UI.Control.ClientID%2A> プロパティの ID を含めることがあります、 <xref:System.Web.UI.Control.NamingContainer%2A> オブジェクトです。 設定すると <xref:System.Web.UI.Control.ClientIDMode%2A> に <xref:System.Web.UI.ClientIDMode.Static>, 、 <xref:System.Web.UI.Control.ClientID%2A> 値の ID が含まれていない、 <xref:System.Web.UI.Control.NamingContainer%2A> オブジェクトです。 設定すると <xref:System.Web.UI.Control.ClientIDMode%2A> いずれかに <xref:System.Web.UI.ClientIDMode.AutoID> または <xref:System.Web.UI.ClientIDMode.Predictable>, 、 <xref:System.Web.UI.Control.ClientID%2A> から ID が含まれます、 <xref:System.Web.UI.Control.NamingContainer%2A> オブジェクトです。 詳細については、「[ASP.NET Control Identification](http://msdn.microsoft.com/ja-jp/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)」を参照してください。  
  
   
  
## 例  
 次の例を使用して、 <xref:System.Web.UI.Control.NamingContainer%2A> プロパティです。  
  
 [!code-csharp[Control\_NamingContainer\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_NamingContainer/CS/control_namingcontainer.cs.aspx#1)]
 [!code-vb[Control\_NamingContainer\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_NamingContainer/VB/control_namingcontainer.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="OnBubbleEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">イベントのソース。</param>
        <param name="args">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>サーバー コントロールのイベントをページの UI サーバー コントロールの階層構造に渡すかどうかを決定します。</summary>
        <returns>イベントがキャンセルされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET サーバー コントロールなど、 <xref:System.Web.UI.WebControls.Repeater>, 、<xref:System.Web.UI.WebControls.DataList> と <xref:System.Web.UI.WebControls.GridView> Web コントロールがイベントを発生させる子コントロールを含めることができます。 たとえば、行ごと、 <xref:System.Web.UI.WebControls.GridView> コントロールは、テンプレートで動的に作成された 1 つまたは複数のボタンを含めることができます。 個別にイベントを発生させる各ボタンではなく、入れ子になったコントロールからのイベントは「バブル イベント」、つまり、名前付けコンテナーに送信します。 名前付けコンテナーは、一般的なイベントと呼ばれる順番を発生させます。 <xref:System.Web.UI.WebControls.GridView.RowCommand> パラメーター値を使用します。 これらの値を使用すると、元のイベントを発生させたコントロールを決定できます。 この単一のイベントに応答して、子コントロールの個々 のイベント処理メソッドを記述することを回避できます。  
  
   
  
## 例  
 次の例では、オーバーライド、 <xref:System.Web.UI.Control.OnBubbleEvent%2A> カスタムの ASP.NET サーバー コントロール `ParentControl`します。 子コントロールにある場合、このメソッドが呼び出される `ParentControl` 呼び出し、 <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> メソッドです。 この場合、 `ParentControl` クラスは、最初のことを示す、ASP.NET ページを 2 つの文字列を書き込みますをその <xref:System.Web.UI.Control.OnBubbleEvent%2A> メソッドが呼び出された、2 つ目の特定のソース管理、 <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> メソッドです。  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent\_OnBubbleEvent\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#1)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent\_OnBubbleEvent\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataBinding">
      <MemberSignature Language="C#" Value="protected virtual void OnDataBinding (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataBinding(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.DataBinding" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドでは、それに関連付けられたデータをバインドするためのロジックを実行するサーバー コントロールに通知します。  
  
 処理する場合、 <xref:System.Web.UI.Control.DataBinding> イベントでは、このイベント処理メソッドをオーバーライドする必要があります。 これにより、すべてのデリゲートに接続されている、 <xref:System.Web.UI.Control.DataBinding> イベントが呼び出されます。  
  
   
  
## 例  
 次の例では、オーバーライド、 <xref:System.Web.UI.Control.OnDataBinding%2A> データ ソースから、親コントロールに子コントロールを追加します。  
  
 [!code-csharp[TemplatedDataBoundControl\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl/CS/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl/VB/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.Init" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET を発生させるには、このメソッドを呼び出し、 <xref:System.Web.UI.Control.Init> イベントです。 カスタム コントロールを開発する場合は、追加の処理を提供するためにこのメソッドをオーバーライドできます。 このメソッドをオーバーライドする場合は、その基本コントロールを呼び出す <xref:System.Web.UI.Control.OnInit%2A> イベントにサブスクライバーに通知するメソッドです。  
  
   
  
## 例  
 [!code-csharp[System.Web.UI.Control\_Context\_OnInit\_ResolveUrl\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#3)]
 [!code-vb[System.Web.UI.Control\_Context\_OnInit\_ResolveUrl\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> イベント データを格納するオブジェクト。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.Load" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET を発生させるには、このメソッドを呼び出し、 <xref:System.Web.UI.Control.Load> イベントです。 カスタム コントロールを開発する場合は、追加の処理を提供するためにこのメソッドをオーバーライドできます。 このメソッドをオーバーライドする場合は、その基本コントロールを呼び出す <xref:System.Web.UI.Control.OnLoad%2A> イベントにサブスクライバーに通知するメソッドです。  
  
   
  
## 例  
 [!code-csharp[Control\_OnUnload\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#3)]
 [!code-vb[Control\_OnUnload\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.PreRender" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET を発生させるには、このメソッドを呼び出し、 <xref:System.Web.UI.Control.PreRender> イベントです。 カスタム コントロールを開発する場合は、追加の処理を提供するためにこのメソッドをオーバーライドできます。 このメソッドをオーバーライドする場合は、その基本コントロールを呼び出す <xref:System.Web.UI.Control.OnPreRender%2A> イベントにサブスクライバーに通知するメソッドです。  
  
   
  
## 例  
 [!code-csharp[Control\_Sample\_1\_snipper\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1_snipper/CS/control_sample_1.cs#1)]
 [!code-vb[Control\_Sample\_1\_snipper\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1_snipper/VB/control_sample_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> イベント データを格納するオブジェクト。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.Unload" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET を発生させるには、このメソッドを呼び出し、 <xref:System.Web.UI.Control.Unload> イベントです。 カスタム コントロールを開発する場合は、追加の処理を提供するためにこのメソッドをオーバーライドできます。 このメソッドをオーバーライドする場合は、その基本コントロールを呼び出す <xref:System.Web.UI.Control.OnUnload%2A> イベントにサブスクライバーに通知するメソッドです。  
  
   
  
## 例  
 [!code-csharp[Control\_OnUnload\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#2)]
 [!code-vb[Control\_OnUnload\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.Unload" />
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="protected System.IO.Stream OpenFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.IO.Stream OpenFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OpenFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">目的のファイルへのパス。</param>
        <summary>取得、 <see cref="T:System.IO.Stream" /> ファイルを読み取るために使用します。</summary>
        <returns>A <see cref="T:System.IO.Stream" /> 、目的のファイルを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.OpenFile%2A> メソッドが返される、 <xref:System.IO.Stream> で指定されたファイルの内容を読み取るために使用できるオブジェクト、 `path` パラメーター。 Path パラメーターは、相対化したり、ルート URL をプロトコルなし \(など"~\/mySite\/myFile.txt\)、または、物理パス \("c:\\mySite\\myFile.txt"\) をローカルまたは UNC \("\\\\myServer\\myFile.txt"\) のいずれかです。  
  
 <xref:System.Web.UI.Control.OpenFile%2A> メソッドでは、ファイル アクセスのセキュリティを使用して、指定したファイルへのアクセスを制御します。 現在の ASP.NET ユーザーが、ファイルへのアクセスを持っていない場合、ファイルが開かれていませんし、 <xref:System.Web.HttpException> アクセスが拒否されたことを示すために例外がスローされます。 場合、 `path` パラメーターは、相対パスを指定すると、例外では、要求されたファイルへの物理パスに関する情報は含まれません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">指定したファイルへのアクセスが拒否されました。</exception>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Page Page { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照を取得、 <see cref="T:System.Web.UI.Page" /> サーバー コントロールを格納しているインスタンス。</summary>
        <value>
          <see cref="T:System.Web.UI.Page" /> サーバー コントロールを格納しているインスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの値には、サーバー コントロールを格納する .aspx ファイルの名前が反映されます。  
  
   
  
## 例  
 <xref:System.Web.UI.Control.Render%2A?displayProperty=fullName> メソッドをオーバーライドする例を次に示します。 使用して、 <xref:System.Web.UI.Page> にアクセスするプロパティ、 <xref:System.Web.UI.Page.IsPostBack%2A?displayProperty=fullName> プロパティをこのコントロールを含むページがだけが読み込まれた最初にまたはポストバックの結果であるかどうかを判断します。  
  
 [!code-csharp[Control\_Sample\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs#1)]
 [!code-vb[Control\_Sample\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが、 <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ コントロール階層内のサーバー コントロールの親コントロールへの参照を取得します。</summary>
        <value>サーバー コントロールの親コントロールへの参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ページが要求されるたびに、そのページ上のサーバー コントロールの階層が構築されています。 このプロパティでは、その階層では、それに対してプログラムは、現在のサーバー コントロールの親コントロールを決定することができます。  
  
   
  
## 例  
 次の例では、新しい設定 <xref:System.Web.UI.Control> ページでは、オブジェクト `myControl1`, で指定したコントロールを <xref:System.Web.UI.Control.FindControl%2A> メソッドの呼び出しです。 コードを使用して、呼び出しが、コントロールを返す場合、 <xref:System.Web.UI.Control.Parent%2A> を含むコントロールを使用するには `myControl1`です。 連結されて、親コントロールが存在する場合は、文字列"テキスト ボックスの親 is"、 <xref:System.Web.UI.Control.ID%2A> 親コントロールのプロパティに書き込まれると、 <xref:System.Web.UI.Control.Page%2A>です。 親コントロールが見つからない場合、文字列「コントロール見つかりません」が書き込まれます。  
  
 [!code-csharp[System.Web.UI.Page.Parent\_FindControl\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent\_FindControl\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRender">
      <MemberSignature Language="C#" Value="public event EventHandler PreRender;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRender" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.PreRender" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以降、 <see cref="T:System.Web.UI.Control" /> オブジェクトが読み込まれたが、レンダリングする前にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントを使用すると、サーバー コントロールがページにレンダリングされる前に、更新プログラムを実行できます。 このイベント中には、サーバー コントロールのビュー ステートの変更を保存できます。 レンダリング フェーズで行われた変更は保存されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseBubbleEvent">
      <MemberSignature Language="C#" Value="protected void RaiseBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">イベントのソース。</param>
        <param name="args">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>イベントとその情報のソースをコントロールの親に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET サーバー コントロールなど、 <xref:System.Web.UI.WebControls.Repeater>, 、<xref:System.Web.UI.WebControls.DataList> と <xref:System.Web.UI.WebControls.GridView> Web コントロールがイベントを発生させる子コントロールを含めることができます。 たとえば、行ごと、 <xref:System.Web.UI.WebControls.GridView> コントロールは、テンプレートで動的に作成された 1 つまたは複数のボタンを含めることができます。 個別にイベントを発生させる各ボタンではなく、入れ子になったコントロールからのイベントは「バブル イベント」、つまり、コントロールの親に送信します。 親は、一般的なイベントと呼ばれる順番を発生させます。 <xref:System.Web.UI.WebControls.GridView.RowCommand> パラメーター値を使用します。 これらの値を使用すると、元のイベントを発生させたコントロールを決定できます。 この単一のイベントに応答して、子コントロールの個々 のイベント処理メソッドを記述することを回避できます。  
  
 コントロールを作成することができますを処理またはオーバーライドすることによってバブル イベントを発生させるときに、このメソッドをオーバーライドすることはできません、 <xref:System.Web.UI.Control.OnBubbleEvent%2A> メソッドです。  
  
   
  
## 例  
 次のコード例は、カスタム クラスを作成する方法をデモンストレーション `ChildControl`, 、オーバーライド、 <xref:System.Web.UI.WebControls.Button.OnClick%2A?displayProperty=fullName> メソッドを呼び出す、 <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> を送信するメソッド、 <xref:System.Web.UI.WebControls.Button.Click?displayProperty=fullName> その親の ASP.NET サーバー コントロールにイベントです。 インスタンスを含む ASP.NET ページにボタンをクリックすると `ChildControl`, を生成、 <xref:System.Web.UI.Control.OnBubbleEvent%2A> メソッドのインスタンスを含む親コントロールを `ChildControl` し、文字列「ChildControl クラス OnClick メソッドが呼び出されます」ページに書き込みます。  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent\_OnBubbleEvent\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#2)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent\_OnBubbleEvent\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemovedControl">
      <MemberSignature Language="C#" Value="protected virtual void RemovedControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RemovedControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.Control" /> は削除されました。</param>
        <summary>削除されると、子コントロールと呼ばれる、 <see cref="P:System.Web.UI.Control.Controls" /> のコレクション、 <see cref="T:System.Web.UI.Control" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.RemovedControl%2A> からコントロールが削除された直後後に、メソッドが呼び出されますが、 <xref:System.Web.UI.Control.Controls%2A> コレクションです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが、 <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">サーバー コントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクト。</param>
        <summary>提供されたクライアントに表示される内容を書き込む <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトに、サーバー コントロールの内容を送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 カスタム サーバー コントロールを開発する場合は、ASP.NET ページのコンテンツを生成するには、このメソッドをオーバーライドできます。  
  
   
  
## 例  
 次のコード例では、オーバーライドを示しています、 <xref:System.Web.UI.Control.Render%2A> メソッドです。<xref:System.Web.UI.Control.HasControls%2A> メソッドを使用して、サーバー コントロールがその子コントロールに格納されているかどうかをその <xref:System.Web.UI.ControlCollection> を通じてアクセス可能なオブジェクト、 <xref:System.Web.UI.Control.Controls%2A?displayProperty=fullName> プロパティです。 場合 <xref:System.Web.UI.Control.HasControls%2A> true およびコレクションの最初のサーバー コントロールは、リテラル テキストから HTML 文字列にリテラルのテキストが追加されます。  
  
 [!code-csharp[Classic Control.Render Example\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Render Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Render Example\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Render Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> 、レンダリングされたコンテンツを受け取るオブジェクトです。</param>
        <summary>指定されたサーバー コントロールの子の内容を出力 <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトをクライアントに表示される内容を書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、ページ上の任意の Active Server Pages \(ASP\) コードをレンダリングする ASP.NET を通知します。 ページ上の ASP コードが存在しない場合このメソッドは、サーバー コントロールのコントロールの子をレンダリングします。 このメソッドは、 <xref:System.Web.UI.Control.Render%2A> メソッドです。  
  
   
  
## 例  
 次の例では、オーバーライド、 <xref:System.Web.UI.Control.RenderChildren%2A> カスタム サーバー コントロールのメソッドです。 現在のコントロール子コントロールがあるかどうかを決定してその <xref:System.Web.UI.ControlCollection> オブジェクトです。 使用されている場合は、 <xref:System.Web.UI.ControlCollection.Count%2A> プロパティをコレクションを反復処理します。 各子コントロールを検出すると、それを使用して、 <xref:System.Web.UI.Control.RenderControl%2A> コントロール、およびそのすべてを含むページにその子コントロールの親をレンダリングするメソッドです。  
  
 オーバーライドされた <xref:System.Web.UI.Control.Render%2A> メソッドを呼び出します、オーバーライドされた <xref:System.Web.UI.Control.RenderChildren%2A> メソッドです。  
  
 [!code-csharp[Control\_Sample\_1\#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#4)]
 [!code-vb[Control\_Sample\_1\#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="public virtual void RenderControl (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> コントロールの内容を受け取るオブジェクトです。</param>
        <summary>指定されたサーバー コントロールの内容を出力 <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトし、トレースが有効になっている場合は、コントロールに関するトレース情報を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サーバー コントロールの場合 <xref:System.Web.UI.Control.Visible%2A> にプロパティが設定されている `true`, 、このメソッドは、ページのトレースが有効になっているかどうかを判断します。 場合は、コントロールに関連付けられたトレース情報を格納し、ページにサーバー コントロールの内容を表示します。  
  
 このメソッドは、表示中に、そのページによって自動的に呼び出されますが、カスタム コントロールの開発者によってオーバーライドされることができます。  
  
   
  
## 例  
 次の例では、オーバーライド、 <xref:System.Web.UI.Control.RenderChildren%2A> カスタム サーバー コントロールのメソッドです。 現在のコントロール子コントロールがあるかどうかを決定してその <xref:System.Web.UI.ControlCollection> オブジェクトです。 使用されている場合は、 <xref:System.Web.UI.ControlCollection.Count%2A> プロパティをコレクションを反復処理します。 各子コントロールを検出すると、それを使用して、 <xref:System.Web.UI.Control.RenderControl%2A> コントロール、およびコントロールを含むページにその子コントロールのすべての子を表示するメソッドです。<xref:System.Web.UI.XhtmlTextWriter> がこのメソッドに渡されるオブジェクトをインスタンス化、 <xref:System.Web.UI.Page.Render%2A> メソッドです。  
  
 [!code-csharp[Control\_Sample\_1\#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#3)]
 [!code-vb[Control\_Sample\_1\#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="protected void RenderControl (System.Web.UI.HtmlTextWriter writer, System.Web.UI.Adapters.ControlAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer, class System.Web.UI.Adapters.ControlAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
        <Parameter Name="adapter" Type="System.Web.UI.Adapters.ControlAdapter" />
      </Parameters>
      <Docs>
        <param name="writer">コントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <param name="adapter">
          <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> レンダリングを定義します。</param>
        <summary>指定されたサーバー コントロールの内容を出力 <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトの指定を使用して <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET Web ページは、デバイスと、Web から情報を要求しているブラウザーの広範囲にわたって使用できます。<xref:System.Web.UI.Control.Adapter%2A> プロパティを返します。、 <xref:System.Web.UI.Adapters.ControlAdapter> 要求元のデバイスまたはブラウザーの画面上のコントロールを描画するオブジェクト。  
  
 アダプターの詳細については、次を参照してください。 [Architectural Overview of Adaptive Control Behavior](http://msdn.microsoft.com/ja-jp/4ff05ae9-4109-4352-929e-ad893895dbff)します。  
  
 サーバー コントロールの場合 <xref:System.Web.UI.Control.Visible%2A> にプロパティが設定されている `true` 、ページに対してトレースを有効にし、コントロールに関連付けられているトレース情報をキャプチャします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding the <see cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" /> method in custom controls, call the base class method to ensure trace information is correctly captured.</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <altmember cref="P:System.Web.HttpContext.Trace" />
      </Docs>
    </Member>
    <Member MemberName="RenderingCompatibility">
      <MemberSignature Language="C#" Value="public virtual Version RenderingCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version RenderingCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.RenderingCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>互換性のある HTML をレンダリングする ASP.NET のバージョンを指定する値を取得します。</summary>
        <value>HTML をレンダリングする ASP.NET のバージョンは、互換性があります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの値に設定して ASP.NET、 `controlRenderingCompatibilityVersion` の属性、 `pages` Web.config ファイル内の要素。 場合、 `controlRenderingCompatibilityVersion` 属性は、Web.config ファイルで設定されておらず、既定値は、現在のバージョンの ASP.NET です。  
  
> [!CAUTION]
>  このプロパティのパブリックの set アクセサーがあるが、set アクセサーは、.NET Framework インフラストラクチャをサポートしているし、コードから直接使用するものではありません。 コードでこの値を設定する場合は、効果は予測できません。  
  
 ASP.NET の各リリースでは、以前のリリースから、HTML を異なる方法で表示可能性があります。 たとえば、ASP.NET 3.5 で場合、 <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> のプロパティ、 <xref:System.Web.UI.WebControls.Label> コントロールが `false`, 、ASP.NET では既定では、 `span` 要素が `disabled` 属性が"disabled"に設定します。 既定では、ASP.NET 4 で、 `span` 要素はカスケード スタイル シート \(CSS\) でレンダリングされて `class` 属性の代わりに、 `disabled` 属性です。 無効になっているコントロールの外観を指定することができ、無効な HTML の表示を回避できます。 \(HTML 4.0 および XHTML 1.1 で、 `span` 要素はサポートしていません、 `disabled` 属性です\)。  
  
 Web アプリケーションに正しく動作しない場合は、HTML レンダリングが変更されたコードがあります。 この問題を回避するには設定、 `controlRenderingCompatibilityVersion` の属性、 `pages` との互換性を保持したい旧バージョンを示すために Web.config ファイル内の要素。 設定する場合など、 <xref:System.Web.UI.Control.RenderingCompatibility%2A> プロパティを `3.5`, 、無効な <xref:System.Web.UI.WebControls.Label> コントロールがレンダリングされます、 `disabled` 属性と CSS クラスではありません。  
  
> [!NOTE]
>  このプロパティを設定する最も古いバージョンが `3.5`です。  
  
 Visual Studio を使用して、以前のバージョンの ASP.NET 4 Web プロジェクトをアップグレードするときに、旧バージョンとの互換性を維持、する Visual Studio が自動的に設定、 `controlRenderingCompatibilityVersion` に Web.config ファイル内の属性 `3.5`します。 アップグレード済みの Web サイトで ASP.NET 4 で導入されたアルゴリズムを使用して HTML をレンダリングする場合は、変更または削除、 `controlRenderingCompatibilityVersion` 属性です。  
  
 ほとんどの場合、このプロパティによって制御される動作は、自動とを確認する必要はありません、 <xref:System.Web.UI.Control.RenderingCompatibility%2A> 、コードでプロパティです。 ただし、カスタム コントロールをプログラミングしている場合は、このプロパティの設定に基づくコントロールの動作を変更するコードを追加する必要があります。 たとえば、ASP.NET 4 用のカスタム コントロールがで構成されている <xref:System.Web.UI.WebControls.Label> コントロール、およびカスタム コントロールを変更する JavaScript コードを生成することによって無効になっているコントロールの外観を指定可能性があります、 `aspNetDisabled` クラスです。 これは、必要な場合として動作 <xref:System.Web.UI.Control.RenderingCompatibility%2A> は `4.0` またはそれ以降。 されるときに有効ですが、同じを取得する <xref:System.Web.UI.Control.RenderingCompatibility%2A> は `3.5`, 、カスタム コントロールのコードは、コントロールを設定する必要があります `CssClass` プロパティを"aspNetDisabled"ときに、 <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> プロパティは `false`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion" />
      </Docs>
    </Member>
    <Member MemberName="ResolveAdapter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Adapters.ControlAdapter ResolveAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Adapters.ControlAdapter ResolveAdapter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveAdapter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指定したコントロールのレンダリングを担当するコントロール アダプターを取得します。</summary>
        <returns>A <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> コントロールがレンダリングされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ASP.NET Web ページは、Web ページが要求の対応するデバイスの広範囲にわたって表示できます。<xref:System.Web.UI.Control.ResolveAdapter%2A> メソッドを返しますコントロール アダプター担当の ASP.NET ページを要求する特定のブラウザーまたはデバイス上のコントロールを表示します。  
  
 特定のアダプターの種類の子孫の種類によって異なりますが返される、 <xref:System.Web.UI.Control> を表示しているクラス。  
  
 アダプターの詳細については、次を参照してください。 [Architectural Overview of Adaptive Control Behavior](http://msdn.microsoft.com/ja-jp/4ff05ae9-4109-4352-929e-ad893895dbff)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="ResolveClientUrl">
      <MemberSignature Language="C#" Value="public string ResolveClientUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveClientUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveClientUrl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">現在のページに対する相対 URL です。</param>
        <summary>ブラウザーで使用できる URL を取得します。</summary>
        <returns>ブラウザーでの使用に適した指定のリソースへの完全修飾 URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Control.ResolveClientUrl%2A> を返す URL 文字列の使用に適したクライアントがリソースにアクセスするイメージ ファイルなどの Web サーバー上のメソッドを他のページにリンクします。  
  
> [!NOTE]
>  このメソッドから返された URL では、コントロールがインスタンス化されたソース ファイルを含むフォルダーの相対パスです。 このプロパティを継承するコントロール <xref:System.Web.UI.UserControl> と <xref:System.Web.UI.MasterPage>, は、コントロールに対する相対的な完全修飾 URL を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relativeUrl" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveUrl">
      <MemberSignature Language="C#" Value="public string ResolveUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ResolveUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">URL に関連付けられている、 <see cref="P:System.Web.UI.Control.TemplateSourceDirectory" /> プロパティです。</param>
        <summary>1 つの要求元のクライアントで使用できる URL を変換します。</summary>
        <returns>変換後の URL です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 `relativeUrl` パラメーターに絶対 URL が含まれている URL は、そのまま返されます。 場合、 `relativeUrl` パラメーターには、相対 URL が含まれる、URL をブラウザーで URL を解決できるように、現在の要求パスに適した相対 URL に変更されます。  
  
 たとえば、次のシナリオがあるとします。  
  
-   クライアントはそれに関連付けられているイメージを持つユーザー コントロールを含む ASP.NET ページを要求しました。  
  
-   ASP.NET ページは\/Store\/page1.aspx にあります。  
  
-   ユーザー コントロールは\/Store\/UserControls\/UC1.ascx にあります。  
  
-   イメージ ファイルは\/UserControls\/Images\/Image1.jpg です。  
  
 ユーザー コントロールにイメージ \(つまり、\/Store\/UserControls\/Images\/Image1.jpg\) への相対パスを渡す場合、 <xref:System.Web.UI.Control.ResolveUrl%2A> メソッド、メソッドは値を返します\/Images\/Image1.jpg します。  
  
 このメソッドを使用して、 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 絶対 URL を解決するプロパティです。 返された URL はクライアント使用されます。  
  
 Web サイトのリソース パスの詳細については、次を参照してください。 [ASP.NET Web Site Paths](http://msdn.microsoft.com/ja-jp/2447f50c-b849-483c-8093-85ed53e7a5bd)します。  
  
> [!NOTE]
>  モバイル Web ページに関してのみ、アプリケーションはクッキーなしのセッションに依存または cookie なしのセッションを必要とするモバイル ブラウザーから要求を受信する可能性がありますを使用して、チルダ \("~"\) パスのために新しいセッションが誤って作成し、セッション データが失われる可能性があります。 パスを使用してプロパティを設定する"~\/*パス"*, を呼び出して、パスを解決するには、 <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> のように argument"~\/*パス"* プロパティに割り当てる前にします。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Web.UI.WebControls.Image> Web サーバー コントロールのオブジェクトと使用、 <xref:System.Web.UI.Control.ResolveUrl%2A> で格納されているイメージへのパスを設定するメソッドを <xref:System.Web.UI.WebControls.Image.ImageUrl%2A> プロパティです。  
  
 [!code-csharp[Control\_ResolveUrl\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_ResolveUrl/CS/control_resolveurl.cs#1)]
 [!code-vb[Control\_ResolveUrl\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_ResolveUrl/VB/control_resolveurl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合に発生、 <paramref name="relativeUrl" /> パラメーターが含まれる <see langword="null" />です。</exception>
        <altmember cref="P:System.Web.UI.Control.TemplateSourceDirectory" />
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected virtual object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveControlState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページがサーバーにポスト バックされた時間以降に発生したすべてのサーバー コントロール状態の変化を保存します。</summary>
        <returns>サーバー コントロールの現在の状態を返します。 このコントロールに関連付けられている状態がない場合、このメソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.Control.SaveControlState%2A> メソッドの特定のコントロールの操作に必要な状態情報を保存します。 このコントロールの状態データは、コントロールのビュー ステート データから個別に格納されます。  
  
 コントロールの状態を使用してカスタム コントロールを呼び出す必要があります、 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> メソッドを <xref:System.Web.UI.Control.Page%2A> コントロールの状態を保存する前にします。  
  
   
  
## 例  
 次のコード例の上書き、 <xref:System.Web.UI.Control.SaveControlState%2A> カスタム ASP.NET コントロールのメソッドです。 このメソッドが呼び出され、時に決定するかどうか内部プロパティ `currentIndex` と、既定以外の値に設定されている場合は、コントロールの状態に値を保存します。  
  
 <xref:System.Web.UI.Control.OnInit%2A> メソッドをオーバーライドしてを呼び出す、 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> メソッドを <xref:System.Web.UI.Control.Page%2A> にカスタム コントロールがコントロールの状態を使用するように指定します。  
  
 [!code-csharp[ControlState\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When control state is saved, a string object is returned to the client as a variable that is stored in an HTML <see langword="HIDDEN" /> element. Override this method to extract the state information to use in your control.  
  
 Control state is intended for small amounts of critical data, such as a page index or a keyword. Using control state for large amounts of data can adversely affect page performance. For more information, see [ASP.NET State Management Overview](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce).</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveViewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページがサーバーにポスト バックされた時間以降に発生した、サーバー コントロールのビューステートの変更を保存します。</summary>
        <returns>サーバー コントロールの現在のビューステートを返します。 コントロールに関連付けられているビューステートがない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ビュー ステートは、サーバー コントロールのプロパティの値を累積したものです。 これらの値が自動的に、サーバー コントロールの配置 <xref:System.Web.UI.Control.ViewState%2A> インスタンスであるプロパティの <xref:System.Web.UI.StateBag> クラスです。 このプロパティの値は、この保存状態のサーバー コントロールのライフ サイクルの段階後も、文字列オブジェクトを永続化します。 詳細については、「[Introduction to the ASP.NET Page Life Cycle](http://msdn.microsoft.com/ja-jp/7949d756-1a79-464e-891f-904b1cfc7991)」を参照してください。  
  
 この文字列オブジェクトが、HTML に格納されている変数と、クライアントに返されるビューステートを保存すると `HIDDEN` 要素。 カスタムのビュー ステートにカスタム サーバー コントロールを作成するときにビュー ステートを明示的に管理できる、 <xref:System.Web.UI.Control.SaveViewState%2A> と <xref:System.Web.UI.Control.LoadViewState%2A> メソッドです。 詳細については、「[ASP.NET State Management Overview](http://msdn.microsoft.com/ja-jp/0218d965-5d30-445b-b6a6-8870e70e63ce)」を参照してください。 カスタム セッション状態プロバイダーを実装する方法の詳細については、次を参照してください。 [Implementing a Session\-State Store Provider](http://msdn.microsoft.com/ja-jp/baadfec5-c881-468a-9681-7d8796b05a66)します。  
  
   
  
## 例  
 次の例では、オーバーライド、 <xref:System.Web.UI.Control.SaveViewState%2A> カスタム ASP.NET サーバー コントロール。 このメソッドが呼び出されるかどうが決定コントロールに子コントロールがあるかどうかを含む、 <xref:System.Web.UI.Page> オブジェクトがポストバックの結果。 両方に当てはまる場合に変更、 <xref:System.Web.UI.WebControls.Label.Text%2A> のプロパティ、 <xref:System.Web.UI.WebControls.Label> Web サーバー コントロールを読み取る `Custom Control Has Saved State`します。 という名前のオブジェクトの配列として、コントロールのビューステートを保存 `allStates`します。  
  
 [!code-csharp[Control\_StateManagement\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#2)]
 [!code-vb[Control\_StateManagement\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
      </Docs>
    </Member>
    <Member MemberName="SetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual void SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">
          <see cref="T:System.Collections.IDictionary" /> コントロールのデザイン時データを格納します。</param>
        <summary>コントロールのデザイン時データを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.SetDesignModeState%2A> メソッドは、コントロールのデザイン時のデータを保存します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>You must override this method to save the design-time data your control requires.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetRenderMethodDelegate">
      <MemberSignature Language="C#" Value="public void SetRenderMethodDelegate (System.Web.UI.RenderMethod renderMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRenderMethodDelegate(class System.Web.UI.RenderMethod renderMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="renderMethod" Type="System.Web.UI.RenderMethod" />
      </Parameters>
      <Docs>
        <param name="renderMethod">サーバー コントロールを表示するために、デリゲートに渡すために必要な情報です。</param>
        <summary>親コントロールに、サーバー コントロールとそのコンテンツをレンダリングするイベント ハンドラー デリゲートを割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドに指定の実装の目的でのみ使用できます。直接呼び出す必要があることはありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="traceDataKey">トレース データのキー。</param>
        <param name="traceDataValue">トレース データの値。</param>
        <summary>セットは、デザイン時の表示データのトレース、トレース データのキーとトレースのデータ値を使用してデータをトレースします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object tracedObject, object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object tracedObject, object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tracedObject" Type="System.Object" />
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tracedObject">トレースされるオブジェクトです。</param>
        <param name="traceDataKey">トレース データのキー。</param>
        <param name="traceDataValue">トレース データの値。</param>
        <summary>セットは、デザイン時の表示データのトレース、トレース オブジェクト、トレース データのキー、およびトレース データの値を使用してデータをトレースします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デザイン サーフェイスにレンダリングされるときに、現在のコントロールをホストしているコンテナーに関する情報を取得します。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> でコントロールがホストされているコンテナーに関する情報を格納します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サイトのバインド、 <xref:System.ComponentModel.Component> オブジェクトを <xref:System.ComponentModel.Container> オブジェクトし、2 つの間の通信を有効にします。 コンテナーのコンポーネントを管理するための手段も提供します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが、 <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="T:System.ComponentModel.ISite" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public virtual string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに適用するスキンを取得または設定します。</summary>
        <value>コントロールに適用するスキンの名前。 既定値は、<see cref="F:System.String.Empty" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コントロールで使用できるスキンは、テーマ ディレクトリ内の 1 つまたは複数のスキン ファイルに格納されます。<xref:System.Web.UI.Control.SkinID%2A> プロパティには、これらのコントロールに適用するスキンのどれを指定します。 スキンは、特定のコントロールに固有異なる種類のコントロール間のスキンの設定を共有することはできません。  
  
 設定しない場合、 <xref:System.Web.UI.Control.SkinID%2A> プロパティには、コントロールを使用して既定のスキンが定義されている場合。 などの場合、スキンなし ID の定義、 <xref:System.Web.UI.WebControls.Image> コントロールすべてにそのスキンを適用し、 <xref:System.Web.UI.WebControls.Image> コントロールを明示的に参照しない ID を使用して、スキンおよびテーマを無効にするには設定されていません。 ID を使用して、スキンが定義されている場合、 <xref:System.Web.UI.WebControls.Image> し、そのスキンの適用にのみ、制御 <xref:System.Web.UI.WebControls.Image> 制御の <xref:System.Web.UI.Control.SkinID%2A> プロパティがその ID に設定されています。  
  
 テーマ ディレクトリ内のスキン ファイルは、指定したスキンを含んでいない場合に <xref:System.Web.UI.Control.SkinID%2A> 、プロパティ、 <xref:System.ArgumentException> 実行時に例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">スタイル シートは既に適用されています。  
  
 または  
  
 <see langword="Page_PreInit" /> イベントが既に発生します。  
  
 または  
  
 既に追加したコントロール、 <see langword="Controls" /> コレクションです。</exception>
        <altmember cref="P:System.Web.UI.Control.EnableTheming" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlBuilderAccessor.ControlBuilder">
      <MemberSignature Language="C#" Value="System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IControlBuilderAccessor.ControlBuilder" />」を参照してください。</summary>
        <value>
          <see cref="T:System.Web.UI.ControlBuilder" /> コントロールを構築する。 そうしないと、 <see langword="null" /> ビルダーが使用されていない場合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlBuilderAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.GetDesignModeState">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary IControlDesignerAccessor.GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState" />」を参照してください。</summary>
        <returns>
          <see cref="T:System.Collections.IDictionary" /> コントロールの状態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetDesignModeState">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">
          <see cref="T:System.Collections.IDictionary" /> コントロールのデザイン時データを格納します。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetOwnerControl">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetOwnerControl (System.Web.UI.Control owner);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(class System.Web.UI.Control owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="owner">コントロールの所有者です。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスは、コントロールのデザイン時の操作を実行するコントロールのデザイナーで使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="owner" /> 現在のコントロールに設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.UserData">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IControlDesignerAccessor.UserData" />」を参照してください。</summary>
        <value>
          <see cref="T:System.Collections.IDictionary" /> コントロールに関する情報を格納します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.DataBindings">
      <MemberSignature Language="C#" Value="System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IDataBindingsAccessor.DataBindings" />」を参照してください。</summary>
        <value>データ バインディングのコレクションです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IDataBindingsAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.HasDataBindings">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IDataBindingsAccessor.HasDataBindings" />」を参照してください。</summary>
        <value>
          <see langword="true" /> コントロールにデータ バインディング ロジックが含まれている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IDataBindingsAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.Expressions">
      <MemberSignature Language="C#" Value="System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ExpressionBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IExpressionsAccessor.Expressions" />」を参照してください。</summary>
        <value>
          <see cref="T:System.Web.UI.ExpressionBindingCollection" /> を含む <see cref="T:System.Web.UI.ExpressionBinding" /> プロパティとコントロールの式を表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IExpressionsAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.HasExpressions">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IExpressionsAccessor.HasExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IExpressionsAccessor.HasExpressions" />」を参照してください。</summary>
        <value>
          <see langword="true" /> コントロールに式を介して設定されたプロパティがある場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IExpressionsAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IParserAccessor.AddParsedSubObject">
      <MemberSignature Language="C#" Value="void IParserAccessor.AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IParserAccessor.AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">追加するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IParserAccessor> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.TemplateControl TemplateControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.TemplateControl TemplateControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.TemplateControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはこのコントロールを格納しているテンプレートへの参照を設定します。</summary>
        <value>
          <see cref="T:System.Web.UI.TemplateControl" /> このコントロールを格納しているインスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに、 <xref:System.Web.UI.Control> インスタンスがコントロール テンプレートの一部で、 <xref:System.Web.UI.Control.TemplateControl%2A> プロパティに含まれるコントロールへの参照が含まれています。 詳細については、次を参照してください。、 <xref:System.Web.UI.TemplateControl?displayProperty=fullName> ドキュメントです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public virtual string TemplateSourceDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>仮想ディレクトリを取得、 <see cref="T:System.Web.UI.Page" /> または <see cref="T:System.Web.UI.UserControl" /> を現在のサーバー コントロールが含まれています。</summary>
        <value>サーバー コントロールが含まれているページまたはユーザー コントロールの仮想ディレクトリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> プロパティは、現在のコントロールを含むページやユーザー コントロールへのパスを指定します。 Web ページが http:\/\/www.contoso.com\/application\/subdirectory に配置されている場合など、 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> プロパティが「アプリケーション\/サブディレクトリ」を返します。  
  
 アプリケーションの相対仮想パスを取得する \("~\/サブディレクトリ"\) を使用して、 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> プロパティです。  
  
   
  
## 例  
 次の例では、 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> プロパティを 2 回クリックします。 使用されて初めて、 <xref:System.Web.UI.Control.MapPathSecure%2A?displayProperty=fullName> コントロールが存在するディレクトリへのパスを取得するためのメソッド呼び出しです。 2 回目では、 <xref:System.IO.Directory.GetFiles%2A?displayProperty=fullName> メソッドの呼び出しをそのディレクトリ内に含まれるすべてのファイルの一覧を取得します。  
  
 [!code-csharp[Control\_TemplateSourceDirectory\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_TemplateSourceDirectory/CS/control_templatesourcedirectory.cs#2)]
 [!code-vb[Control\_TemplateSourceDirectory\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_TemplateSourceDirectory/VB/control_templatesourcedirectory.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected virtual void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.TrackViewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールの保存するようにサーバー コントロールにビュー ステートの変更の追跡をにより <see cref="T:System.Web.UI.StateBag" /> オブジェクトです。 このオブジェクトは、<see cref="P:System.Web.UI.Control.ViewState" /> プロパティによってアクセスできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 最後にこのメソッドが自動的と呼ばれる、 <xref:System.Web.UI.Control.Init> サーバー コントロールのライフ サイクルのイベントです。  
  
 テンプレート化されたデータ バインド コントロールを開発する場合は、このメソッドを呼び出します。 このメソッドをオーバーライドする場合に必要なサーバー コントロールのビュー ステートの変更を監視する ASP.NET のアラート、 <xref:System.Web.UI.Control.DataBind%2A?displayProperty=fullName> メソッドです。  
  
   
  
## 例  
 次の例では、オーバーライド、 <xref:System.Web.UI.Control.DataBind%2A> カスタム ASP.NET サーバー コントロール。 ベースの呼び出しでは、まず、 <xref:System.Web.UI.Control.OnDataBinding%2A> メソッドし、使用して、 <xref:System.Web.UI.ControlCollection.Clear%2A> メソッドはすべての子コントロールを削除して、 <xref:System.Web.UI.Control.ClearChildViewState%2A> 削除するためのメソッドがそれらの子コントロールのビュー ステートの設定を保存します。 最後に、 <xref:System.Web.UI.Control.ChildControlsCreated%2A> にプロパティが設定されている `true`します。 コントロールを使用し、 <xref:System.Web.UI.Control.IsTrackingViewState%2A> プロパティをコントロールのビュー ステートの変更の追跡が有効になっているかどうかを判断します。 有効でない場合、 <xref:System.Web.UI.Control.TrackViewState%2A> メソッドが呼び出されます。  
  
 [!code-csharp[Control\_StateManagement\#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control\_StateManagement\#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IStateManager" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="UniqueID">
      <MemberSignature Language="C#" Value="public virtual string UniqueID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.UniqueID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールの階層的に修飾された一意の id を取得します。</summary>
        <value>サーバー コントロールの完全修飾識別子です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティとは異なります、 <xref:System.Web.UI.Control.ID%2A> でのプロパティ、 <xref:System.Web.UI.Control.UniqueID%2A> サーバー コントロールの名前付けコンテナーのプロパティには識別子が含まれます。 この識別子は、ページ要求が処理されるときに自動的に生成されます。  
  
 このプロパティは、繰り返される、データ バインド サーバー コントロールに含まれるサーバー コントロールを区別する場合に特に重要です。 繰り返しのコントロールは、 <xref:System.Web.UI.WebControls.Repeater>, 、<xref:System.Web.UI.WebControls.DataList>, 、<xref:System.Web.UI.WebControls.DetailsView>, 、<xref:System.Web.UI.WebControls.FormView>, 、および <xref:System.Web.UI.WebControls.GridView> Web サーバー コントロール \(または作成したカスタムのサーバーのコントロールで、データがバインドされている場合は、機能を繰り返しを含む\) の子コントロールの名前付けコンテナーとして機能します。 つまり、それが作成される一意の名前空間の子のコントロールできるように、 <xref:System.Web.UI.Control.ID%2A> プロパティの値が競合しません。  
  
 たとえば、ASP.NET が含まれます <xref:System.Web.UI.WebControls.Label> Web サーバー コントロールで、 <xref:System.Web.UI.WebControls.Repeater> サーバー コントロール、および割り当て、 <xref:System.Web.UI.WebControls.Label> コントロール、 <xref:System.Web.UI.Control.ID%2A> のプロパティの値 `MyLabel`, 、および <xref:System.Web.UI.WebControls.Repeater> 、 <xref:System.Web.UI.Control.ID%2A> の `MyRepeater`です。 データをバインドする場合、 <xref:System.Web.UI.WebControls.Repeater> に、 <xref:System.Collections.ArrayList> 、その結果、3 つのエントリを持つオブジェクト <xref:System.Web.UI.Control.UniqueID%2A> の各インスタンスのプロパティ、 <xref:System.Web.UI.WebControls.Label> サーバー コントロールは、 `MyRepeater$ctl00$MyLabel`, 、`MyRepeater$ctl01$MyLabel`, 、および `MyRepeater$ctl02$MyLabel`です。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Collections.ArrayList> オブジェクト、3 つのテキスト文字列をそこに格納し、バインド、 <xref:System.Web.UI.WebControls.Repeater> Web サーバー コントロール内のデータを <xref:System.Collections.ArrayList> ページが読み込まれるときにします。 このコードを取得、 <xref:System.Web.UI.Control.UniqueID%2A> データ バインド中に生成された各子コントロールのプロパティです。 コードは、3 つのバージョンの生成、 <xref:System.Web.UI.WebControls.Label> コントロールおよび書き込みの `UniqueID` ページにプロパティ値です。  
  
 [!code-csharp[AccessingAspNetControlsProgramaticallyConcepts\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/CS/WebFormsControlIdResolution12.aspx#2)]
 [!code-vb[AccessingAspNetControlsProgramaticallyConcepts\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/VB/WebFormsControlIdResolution12.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event EventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Unload" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがメモリからアンロードされるときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サーバー コントロールは、最終的なクリーンアップ、ファイル、データベース接続を閉じると、インスタンスが読み込まれる前に、コントロールのライフ サイクルのこの段階で、オブジェクトの破棄などを実行する必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはコントロールが、危険性のある値のブラウザーからの入力をクライアントをチェックするかどうかを示す値を設定します。</summary>
        <value>コントロールがクライアントの入力を確認するかどうかを決定する値。 オプションがあります。 <see cref="F:System.Web.UI.ValidateRequestMode.Disabled" />, 、<see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />, 、および <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />です。 既定値は <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />, 、つまり、コントロールがその親から値を取得します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要求の検証の詳細については、次を参照してください。 <xref:System.Web.UnvalidatedRequestValues>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewState">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.StateBag ViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.StateBag ViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.StateBag</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>状態情報を保存し、同じページに対する複数の要求でサーバー コントロールのビューステートを復元できるようにするのディクショナリを取得します。</summary>
        <value>インスタンス、 <see cref="T:System.Web.UI.StateBag" /> サーバー コントロールのビュー ステート情報を含むクラスです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サーバー コントロールのビュー ステートは、すべてのプロパティ値を累積したものです。 HTTP 要求間でこれらの値を保持するために、ASP.NET サーバー コントロールがインスタンスでは、このプロパティを使用しての <xref:System.Web.UI.StateBag> クラスにプロパティ値を格納します。 値は、後続の要求が処理されるときに、変数として HTML の非表示入力要素に渡されます。 サーバー コントロールのビューステートを保存する方法の詳細については、次を参照してください。 [ASP.NET State Management Overview](http://msdn.microsoft.com/ja-jp/0218d965-5d30-445b-b6a6-8870e70e63ce)します。  
  
 既定では、すべてのサーバー コントロールのビュー ステートが有効になっているが、無効にする必要がある場合があります。 詳細については、「[Performance Overview](http://msdn.microsoft.com/ja-jp/f882bf1b-a009-4312-ac06-74370ffabc0b)」を参照してください。  
  
 ディクショナリとその使用方法については、次を参照してください。 [Collections and Data Structures](http://msdn.microsoft.com/ja-jp/60cc581f-1db5-445b-ba04-a173396bf872)します。  
  
   
  
## 例  
 次の例では、実装することを示しています、 `Text` プロパティを格納し、そのコントロールからその値を取得する <xref:System.Web.UI.Control.ViewState%2A> プロパティです。  
  
 [!code-csharp[SysWebUIControlViewState\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SysWebUIControlViewState/CS/controlviewstate.cs#2)]
 [!code-vb[SysWebUIControlViewState\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SysWebUIControlViewState/VB/controlviewstate.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateIgnoresCase">
      <MemberSignature Language="C#" Value="protected virtual bool ViewStateIgnoresCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewStateIgnoresCase" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、<see cref="T:System.Web.UI.StateBag" />オブジェクト小文字は区別されません。</summary>
        <value>
          <see langword="true" />場合、<see cref="T:System.Web.UI.StateBag" />インスタンスが大文字と小文字、それ以外の<see langword="false" />します。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合を考慮せず、ビュー状態を保存するカスタム サーバー コントロールを作成する場合は、このメソッドをオーバーライドします。 格納できる、同じキーではなく、大文字小文字が異なるので、複数のオブジェクトの操作を実行すると、<xref:System.Web.UI.StateBag>に関連付けられている、<xref:System.Web.UI.Control.ViewState%2A>プロパティです。  
  
   
  
## 例  
 次の例では、オーバーライドする方法、<xref:System.Web.UI.Control.ViewStateIgnoresCase%2A>返されるプロパティを`true`です。  
  
 [!code-csharp[System.Web.UI.Control\_ViewStateIgnoresCase\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#2)]
 [!code-vb[System.Web.UI.Control\_ViewStateIgnoresCase\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ViewStateMode ViewStateMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateMode ViewStateMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはこのコントロールのビュー ステート モードを設定します。</summary>
        <value>このコントロールのビュー ステート モード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することができます、 <xref:System.Web.UI.Control.ViewStateMode%2A> プロパティ ページのビュー ステートが無効になっている場合でも、個々 のコントロールのビュー ステートを有効にします。 ビュー ステートとコントロールの状態の詳細については、次を参照してください。、 <xref:System.Web.UI.Control.EnableViewState%2A> プロパティです。  
  
 ページのビュー ステートを無効にし、ページ上の特定のコントロールを有効にするには、設定、 <xref:System.Web.UI.Control.EnableViewState%2A> ページおよびコントロールのプロパティ `true`, 、設定、 <xref:System.Web.UI.Control.ViewStateMode%2A> にページのプロパティ <xref:System.Web.UI.ViewStateMode.Disabled>, 、設定と、 <xref:System.Web.UI.Control.ViewStateMode%2A> するコントロールのプロパティ <xref:System.Web.UI.ViewStateMode.Enabled>します。  
  
 既定値、 <xref:System.Web.UI.Control.ViewStateMode%2A> ページのプロパティは <xref:System.Web.UI.ViewStateMode.Enabled>です。 既定値、 <xref:System.Web.UI.Control.ViewStateMode%2A> ページで Web サーバー コントロールのプロパティが <xref:System.Web.UI.ViewStateMode.Inherit>です。 その結果、ページまたはコントロール レベルの値のいずれかでこのプロパティを設定しない場合、 <xref:System.Web.UI.Control.EnableViewState%2A> プロパティは、ビュー ステートの動作を決定します。  
  
 <xref:System.Web.UI.Control.ViewStateMode%2A> ページまたはコントロールのプロパティがの場合のみ有効、 <xref:System.Web.UI.Control.EnableViewState%2A> にプロパティが設定されている `true`します。 場合、 <xref:System.Web.UI.Control.EnableViewState%2A> にプロパティが設定されている `false`, 、ビュー ステートがあっても無効になります、 <xref:System.Web.UI.Control.ViewStateMode%2A> にプロパティが設定されている <xref:System.Web.UI.ViewStateMode.Enabled>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このプロパティに含まれていない値を設定しようとしましたが、 <see cref="T:System.Web.UI.ViewStateMode" /> 列挙します。</exception>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがページ上の UI としてレンダリングされているかどうかを示す値を取得または設定します。</summary>
        <value>コントロールをページに表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティが場合 `false`, 、サーバー コントロールは表示されません。 ページのレイアウトを整理する際のアカウントに注意する必要があります。  
  
> [!NOTE]
>  設定した場合でもそれに含まれるすべてのコントロールが表示されない場合は、コンテナー コントロールが表示されません、 <xref:System.Web.UI.Control.Visible%2A> に個々 のコントロールのプロパティ `true`します。 その場合は、個々 の制御が戻された `false` の <xref:System.Web.UI.Control.Visible%2A> プロパティ明示的に設定した場合でも `true`します。 \(されている場合、 `Visible` に親コントロールのプロパティが設定されている `false`, 、子コントロールはその設定が継承および設定がローカル設定より優先されます\)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetTraceData">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>セットの表示データのデザイン時のトレース データをトレースします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="FindControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したサーバー コントロールの現在の名前付けコンテナーを検索します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RenderControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>サーバー コントロールの内容を出力し、トレースが有効になっている場合は、コントロールに関するトレース情報を格納します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="DataBind">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>呼び出されたサーバー コントロールとそのすべての子コントロールにデータ ソースをバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>