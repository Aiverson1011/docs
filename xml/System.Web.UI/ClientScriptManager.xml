<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Web アプリケーションのクライアント スクリプトを管理する方法を定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.ClientScriptManager> クライアント スクリプトを管理し、Web アプリケーションに追加するクラスを使用します。 参照を取得できます、 <xref:System.Web.UI.ClientScriptManager> クラスからの <xref:System.Web.UI.Page.ClientScript%2A> のプロパティ、 <xref:System.Web.UI.Page> オブジェクトです。  
  
 できるスクリプトを追加するクライアント Web ページに宣言によってページの HTML マークアップに、スクリプトを含めることによってです。 ただし、クライアント スクリプトを動的に追加することが必要な場合があります。 スクリプトを動的に追加するには、使用、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> メソッド、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> メソッド、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> メソッド、または <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> スクリプトを追加するタイミングと方法に応じて、メソッドです。 詳細については、「[How to: Add Client Script Dynamically to ASP.NET Web Pages](http://msdn.microsoft.com/ja-jp/e89f1306-e43d-49ae-a66a-e18b71007666)」を参照してください。  
  
 <xref:System.Web.UI.ClientScriptManager> クラスは、キーのスクリプトを一意に識別する <xref:System.String> と <xref:System.Type>です。 同じキーよぶ型を使用してスクリプトでは、重複と見なされます。 スクリプトの種類を使用するとは、ページ上で使用可能性のある別のユーザー コントロールからの混乱を招くようなスクリプトの回避に役立ちます。  
  
 <xref:System.Web.UI.ClientScriptManager> ポストバックを実行せず、クライアントからサーバー コードを実行する必要がある場合の状況でのクライアントのコールバックを呼び出すためにクラスを使用することができます。 これは、サーバーへの帯域外のコールバックの実行と呼ばれます。 クライアントのコールバックでは、クライアント スクリプト関数は、ASP.NET Web ページに非同期要求を送信します。 Web ページには、コールバックを処理する通常のライフ サイクルの変更済みバージョンが実行されます。 使用して、 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 呼び出されると、クライアント関数への参照を取得するメソッドは、サーバー イベントへのクライアント コールバックを開始します。 詳細については、「[Client Callbacks Without Postbacks in ASP.NET Pages](http://msdn.microsoft.com/ja-jp/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)」を参照してください。  
  
> [!NOTE]
>  スクリプト コールバックはドキュメント オブジェクト モデル \(DOM\) をサポートしない古いブラウザーで動作しないと、ECMAScript がクライアントで有効になっているを必要とします。 ブラウザーがコールバックをサポートしているかを確認するには、使用、 <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> を通じてアクセス可能なプロパティ、 <xref:System.Web.HttpRequest.Browser%2A> 組み込みの ASP.NET のプロパティ <xref:System.Web.HttpContext.Request%2A> オブジェクトです。  
  
 使用して、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> メソッドおよび <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> クライアント ポストバック イベントを定義するメソッドです。 これらのメソッドでは、サーバーのページにポストバックを呼び出されたときに、クライアント スクリプト機能が有効にします。 クライアント ポストバック イベントが異なるクライアント コールバックで Web ページがクライアント ポストバック イベントを処理する通常のライフ サイクルを完了します。  
  
> [!NOTE]
>  使用している場合、 <xref:System.Web.UI.WebControls.Button> コントロールと <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> にプロパティが設定されている `false`, を使用して、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 、クライアントを返すメソッドのポストバック イベントを <xref:System.Web.UI.WebControls.Button> コントロールです。  
  
 <xref:System.Web.UI.WebControls.Button.OnClientClick%2A> のプロパティ、 <xref:System.Web.UI.WebControls.Button> コントロール、 <xref:System.Web.UI.WebControls.ImageButton> コントロール、および <xref:System.Web.UI.WebControls.LinkButton> コントロールを使用して、クライアント スクリプトを実行します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> のメソッド、 <xref:System.Web.UI.ClientScriptManager> クラスです。 2 つのクライアント スクリプトが、ページで定義されている: `PopupScript`, 、ページが読み込まれると、警告メッセージが表示されますと `ButtonClickScript`, 、クライアント、HTML ボタンのハンドラーを定義する `onClick` イベントです。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
  </Docs>
  <Members>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">サーバー <see cref="T:System.Web.UI.Control" /> クライアント コールバックを処理します。 コントロールを実装する必要があります、 <see cref="T:System.Web.UI.ICallbackEventHandler" /> でき、インターフェイス、 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> メソッドです。</param>
        <param name="argument">クライアント スクリプトからサーバーに渡された引数  
  
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> メソッド。</param>
        <param name="clientCallback">正常なサーバー イベントの結果を受け取るクライアントのイベント ハンドラーの名前。</param>
        <param name="context">クライアント スクリプト コールバックを開始する前にクライアント上で評価されます。 スクリプトの結果は、クライアントのイベント ハンドラーに渡されます。</param>
        <summary>クライアント関数が、呼び出されると、クライアントが通信を開始にコールバックして、サーバー イベントへの参照を取得します。 このオーバー ロードされたメソッドに対するクライアント関数には、指定したコントロール、引数、クライアント スクリプト、およびコンテキストが含まれています。</summary>
        <returns>クライアント コールバックを呼び出すクライアント関数の名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> メソッドは、ページの通常のライフ サイクルの変更済みバージョンは、サーバーへの帯域外のコールバックを実行します。 詳細については、「[Client Callbacks Without Postbacks in ASP.NET Pages](http://msdn.microsoft.com/ja-jp/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)」を参照してください。  
  
> [!NOTE]
>  ブラウザーが Microsoft Internet Explorer \(バージョン 5.0 以降\) の場合は、スクリプトのコールバック機構はよう COM オブジェクトを使用して実装されており、ブラウザーで ActiveX コントロールの実行を設定する必要があります。 その他のブラウザーでは、ブラウザーのローカル ドキュメント オブジェクト モデル \(DOM\) を使用して、XMLHttpRequest を使用します。 確認するには、ブラウザーがクライアントのコールバックをサポートしているかどうかを使用して、 <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> プロパティです。 ブラウザーが HTTP 経由での XML をサポートしているかどうかを確認するには、使用、 <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> プロパティです。 両方のプロパティはを通してアクセス、 <xref:System.Web.HttpRequest.Browser%2A> 組み込みの ASP.NET のプロパティ <xref:System.Web.HttpContext.Request%2A> オブジェクトです。  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> のオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> メソッドは同期的に HTTP 経由で XML を使用して、コールバックを実行します。 コールバックのシナリオでデータを同期的に送信するとき、同期コールバックをすぐに返すし、ブラウザーはブロックされません。 2 つの同期コールバックをブラウザーで同時に実行することはできます。 1 つは現在保留中に 2 つ目の同期コールバックが発生した場合は、コールバックが 1 つ目をキャンセルし、2 番目のコールバックのみが返されます。  
  
 データを非同期的に送信するを取るオーバー ロードのいずれかの操作を使用して、 `useAsync` は、boolean 型パラメーターは、この動作を制御する値。 非同期のシナリオでは、複数の保留中のコールバック; を設定することがただし、返される順序は、開始された順序と同じは保証されません。  
  
 さらに、このオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> メソッドには、クライアントによって生成されたエラーの状態のケースを処理する関数は指定しません、 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> メソッドです。 クライアント エラーのコールバック ハンドラーを指定するを取るオーバー ロードのいずれかの操作を使用して、 `clientErrorCallback` パラメーター。  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> メソッドは省略可能な文字列 `argument` パラメーター文字列を返します。 渡すまたは複数の値を受信するには、入力内の値を連結したり、それぞれの文字列が返されます。  
  
> [!NOTE]
>  スクリプト コールバック操作中に更新する必要があるページまたはコントロールのプロパティの実装での表示状態を使用しないでください。 プロパティは、ページ要求の復旧は、セッション状態を使用することができます。  
  
   
  
## 例  
 次のコード例では、2 つのオーバー ロードを使用して、 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> クライアント コールバックのシナリオの整数をインクリメントする方法です。  
  
 2 つのコールバック機構が表示されます。これらの違いは、使用、 `context` パラメーター。 A `ReceiveServerData1` を使用してクライアントのコールバック関数を提供、 `context` パラメーター。 これに対し、 `ReceiveServerData2` でクライアントのコールバック関数が定義されている、 `<script>` \] ページでブロックされます。 A <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> メソッドは、サーバー ハンドラーに渡された値をインクリメントして、 <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> メソッドを文字列としてインクリメントされた値を返します。 場合、 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> メソッドがエラーを返す、 `ProcessCallBackError` クライアント関数が呼び出されます。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager7\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager7\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.Control" /> が指定されている <see langword="null" />します。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.Control" /> 指定が実装していない、 <see cref="T:System.Web.UI.ICallbackEventHandler" /> インターフェイスです。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">サーバー <see cref="T:System.Web.UI.Control" /> クライアント コールバックを処理します。 コントロールを実装する必要があります、 <see cref="T:System.Web.UI.ICallbackEventHandler" /> でき、インターフェイス、 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> メソッドです。</param>
        <param name="argument">クライアント スクリプトからサーバーに渡された引数  
  
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> メソッド。</param>
        <param name="clientCallback">正常なサーバー イベントの結果を受け取るクライアントのイベント ハンドラーの名前。</param>
        <param name="context">クライアント スクリプト コールバックを開始する前にクライアント上で評価されます。 スクリプトの結果は、クライアントのイベント ハンドラーに渡されます。</param>
        <param name="useAsync">
          <see langword="true" /> コールバックを非同期的に実行するには <see langword="false" /> コールバックを同期的に実行します。</param>
        <summary>クライアント関数が、呼び出されると、クライアントが初期化にコールバックするサーバー イベントへの参照を取得します。 このオーバー ロードされたメソッドに対するクライアント関数には、指定したコントロール、引数、クライアント スクリプト、コンテキスト、およびブール値が含まれています。</summary>
        <returns>クライアント コールバックを呼び出すクライアント関数の名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> メソッドが必要です、 `useAsync` パラメーター値を設定して、クライアントのコールバックを非同期的に実行することができます `true`します。 このメソッドのオーバー ロード バージョンを必要としない、 `useAsync` パラメーターに値を設定する `false` 既定です。  
  
 このメソッドの詳細については、オーバー ロードは、「解説」を参照してください。 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.Control" /> が指定されている <see langword="null" />します。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.Control" /> 指定が実装していない、 <see cref="T:System.Web.UI.ICallbackEventHandler" /> インターフェイスです。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">サーバーの名前 <see cref="T:System.Web.UI.Control" /> クライアント コールバックを処理します。 コントロールを実装する必要があります、 <see cref="T:System.Web.UI.ICallbackEventHandler" /> でき、インターフェイス、 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> メソッドです。</param>
        <param name="argument">クライアント スクリプトからサーバーに渡された引数  
  
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> メソッド。</param>
        <param name="clientCallback">正常なサーバー イベントの結果を受け取るクライアントのイベント ハンドラーの名前。</param>
        <param name="context">クライアント スクリプト コールバックを開始する前にクライアント上で評価されます。 スクリプトの結果は、クライアントのイベント ハンドラーに渡されます。</param>
        <param name="clientErrorCallback">サーバー イベント ハンドラーでエラーが発生したときに結果を受信するクライアントのイベント ハンドラーの名前。</param>
        <param name="useAsync">
          <see langword="true " /> コールバックを非同期的に実行するには <see langword="false" /> コールバックを同期的に実行します。</param>
        <summary>クライアント関数が、呼び出されると、クライアントが初期化にコールバックするサーバー イベントへの参照を取得します。 このオーバー ロードされたメソッドに対するクライアント関数には、指定されたターゲット、引数、クライアント スクリプト、コンテキスト、エラー ハンドラー、およびブール値が含まれています。</summary>
        <returns>クライアント コールバックを呼び出すクライアント関数の名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> メソッドには、 `target` 文字列パラメーターの代わりに、 <xref:System.Web.UI.Control> パラメーター。 含む文字列以外に戻るにコールバックする場合は、このオーバー ロードを使用して、 <xref:System.Web.UI.Control.UniqueID%2A> コントロールのです。  
  
 さらに、このオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> メソッドが必要です、 `useAsync` と `clientErrorCallback` パラメーター。`useAsync` パラメーター値を設定して、クライアントのコールバックを非同期的に実行できます。 `true`します。 このメソッドのオーバー ロード バージョンを必要としない、 `useAsync` パラメーターに値を設定する `false` 既定です。`clientErrorCallback` パラメーターを使用する場合に呼び出されるクライアント関数の名前を定義するサーバー ハンドラー、 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> メソッドは、エラーを返します。 このメソッドのオーバー ロード バージョンを必要としない、 `clientErrorCallback` パラメーターが null 値を設定します。  
  
 このメソッドの詳細については、オーバー ロードは、「解説」を参照してください。 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> メソッドです。  
  
   
  
## 例  
 次のコード例では、2 つのオーバー ロードを使用して、 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> クライアント コールバックのシナリオの整数をインクリメントする方法です。  
  
 2 つのコールバック機構が表示されます。これらの違いは、使用、 `context` パラメーター。 A `ReceiveServerData1` を使用してクライアントのコールバック関数を提供、 `context` パラメーター。 これに対し、 `ReceiveServerData2` でクライアントのコールバック関数が定義されている、 `<script>` \] ページでブロックされます。 A <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> メソッドは、サーバー ハンドラーに渡された値をインクリメントして、 <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> メソッドを文字列としてインクリメントされた値を返します。 場合、 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> メソッドは、エラーが発生し、クライアントの関数を返します。 `ProcessCallBackError` が呼び出されます。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager7\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager7\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">サーバー <see cref="T:System.Web.UI.Control" /> クライアント コールバックを処理します。 コントロールを実装する必要があります、 <see cref="T:System.Web.UI.ICallbackEventHandler" /> でき、インターフェイス、 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> メソッドです。</param>
        <param name="argument">サーバーにクライアント スクリプトから引数が渡される <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> メソッドです。</param>
        <param name="clientCallback">正常なサーバー イベントの結果を受け取るクライアントのイベント ハンドラーの名前。</param>
        <param name="context">クライアント スクリプト コールバックを開始する前にクライアント上で評価されます。 スクリプトの結果は、クライアントのイベント ハンドラーに渡されます。</param>
        <param name="clientErrorCallback">サーバー イベント ハンドラーでエラーが発生したときに結果を受信するクライアントのイベント ハンドラーの名前。</param>
        <param name="useAsync">
          <see langword="true " />コールバックを非同期的に実行するには <see langword="false" /> コールバックを同期的に実行します。</param>
        <summary>クライアント関数が、呼び出されると、クライアントが初期化にコールバックするサーバー イベントへの参照を取得します。 このオーバー ロードされたメソッドに対するクライアント関数には、指定したコントロール、引数、クライアント スクリプト、コンテキスト、エラー ハンドラー、およびブール値が含まれています。</summary>
        <returns>クライアント コールバックを呼び出すクライアント関数の名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> メソッドが必要です、 `useAsync` と `clientErrorCallback` パラメーター。`useAsync` パラメーター値を設定して、クライアントのコールバックを非同期的に実行できます。 `true`します。 このメソッドのオーバー ロード バージョンを必要としない、 `useAsync` パラメーターに値を設定する `false` 既定です。`clientErrorCallback` パラメーターを使用する場合に呼び出されるクライアント関数の名前を定義するサーバー ハンドラー \(、 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> メソッド\) エラーが返されます。 このメソッドのオーバー ロード バージョンを必要としない、 `clientErrorCallback` パラメーターが null 値を設定します。  
  
 このメソッドの詳細については、オーバー ロードは、「解説」を参照してください。 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.Control" /> が指定されている <see langword="null" />します。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Web.UI.Control" /> 指定が実装していない、 <see cref="T:System.Web.UI.ICallbackEventHandler" /> インターフェイスです。</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">ポストバックを処理するサーバー コントロール。</param>
        <param name="argument">サーバー コントロールに、パラメーターが渡されます。</param>
        <summary>持つ、参照を取得 <see langword="javascript:" /> 指定されたイベント引数を使用して指定したコントロールのサーバーにポストバック クライアント イベントで使用できるは、先頭に追加します。</summary>
        <returns>ターゲット コントロールの ID とイベントの引数を含むポストバック関数への JavaScript 呼び出しを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> メソッドを実装するポストバックを処理するコントロールが必要です、 <xref:System.Web.UI.IPostBackEventHandler> インターフェイスです。 実装する、 <xref:System.Web.UI.IPostBackEventHandler> のためのインターフェイス、 <xref:System.Web.UI.Page>,  、ディレクティブを使用します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> メソッドです。 カスタム コントロール `MyControl`, 、実装、 <xref:System.Web.UI.IPostBackEventHandler> インターフェイスです。 ページの HTML アンカー要素がクリックされたときに、 <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> カスタム コントロールのメソッドが呼び出されます。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager8\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager8\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 次のコード例は、カスタム コントロールでは、代わりに、前のものと同じ機能を持ち、 <xref:System.Web.UI.Page> クラスが実装する、 <xref:System.Web.UI.IPostBackEventHandler> インターフェイスです。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager8\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-vb[System.Web.UI.ClientScriptManager8\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">ポストバックを処理するサーバー コントロール。</param>
        <param name="argument">サーバー コントロールに、パラメーターが渡されます。</param>
        <param name="registerForEventValidation">
          <see langword="true" /> 検証のポストバック イベントを登録するには <see langword="false" /> 検証のためにポストバック イベントを登録しません。</param>
        <summary>持つ、参照を取得 <see langword="javascript:" /> 、指定したコントロールを指定されたイベント引数とブール値を示す値イベントの検証元に戻す、通知を登録するかどうかのサーバーにポストバックするクライアントのイベントで使用できる先頭に追加します。</summary>
        <returns>ターゲット コントロールの ID とイベントの引数を含むポストバック関数への JavaScript 呼び出しを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> メソッドを実装するポストバックを処理するコントロールが必要です、 <xref:System.Web.UI.IPostBackEventHandler> インターフェイスです。 実装する、 <xref:System.Web.UI.IPostBackEventHandler> のためのインターフェイス、 <xref:System.Web.UI.Page>, 、ディレクティブを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">A<see cref="T:System.Web.UI.PostBackOptions" />ポストバックを定義します。</param>
        <summary>サーバーへのポストバックが発生するクライアント イベントで使用できる文字列を返します。 参照文字列が定義されている指定した<see cref="T:System.Web.UI.PostBackOptions" />インスタンス。</summary>
        <returns>文字列をクライアントでスクリプトとして扱われたときに、クライアントのポストバックを開始します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 実装する、<xref:System.Web.UI.IPostBackEventHandler>のためのインターフェイス、<xref:System.Web.UI.Page>ディレクティブを使用します。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>メソッドを使用できます、<xref:System.Web.UI.WebControls.Button>タイミングを制御、<xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>プロパティは`false`します。 このシナリオでは、<xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>メソッドを返しますが、クライアントはポストバック イベントを<xref:System.Web.UI.WebControls.Button>コントロール。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.PostBackOptions" />パラメーターは、<see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">サーバー <see cref="T:System.Web.UI.Control" /> サーバーにポストバックを処理します。</param>
        <param name="argument">ポストバックを処理するコントロールに渡される省略可能な引数の文字列です。</param>
        <summary>サーバーへのポストバックが発生するクライアント イベントで使用できる文字列を返します。 参照文字列は、ポストバックと追加のイベント情報の文字列引数を処理する指定したコントロールによって定義されます。</summary>
        <returns>文字列をクライアントでは、スクリプトとして扱われた場合、ポストバックを開始します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 実装する、 <xref:System.Web.UI.IPostBackEventHandler> のためのインターフェイス、 <xref:System.Web.UI.Page>,  、ディレクティブを使用します。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> メソッドを使用できます、 <xref:System.Web.UI.WebControls.Button> タイミングを制御、 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> プロパティは `false`です。 このシナリオでは、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> クライアント ポストバック イベントをメソッドが返される、 <xref:System.Web.UI.WebControls.Button> コントロールです。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> メソッドです。 カスタム コントロール `MyControl`, 、実装、 <xref:System.Web.UI.IPostBackEventHandler> インターフェイスです。 ページ上のボタンがクリックされたときに、 <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> カスタム コントロールのメソッドが呼び出されます。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager8\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager8\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 次のコード例は、カスタム コントロールでは、代わりに、前のものと同じ機能を持ち、 <xref:System.Web.UI.Page> クラスが実装する、 <xref:System.Web.UI.IPostBackEventHandler> インターフェイスです。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager8\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-vb[System.Web.UI.ClientScriptManager8\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定した <see cref="T:System.Web.UI.Control" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Web.UI.PostBackOptions" /> ポストバックを定義します。</param>
        <param name="registerForEventValidation">
          <see langword="true" /> 検証のイベントの参照を登録するにはそれ以外の場合、 <see langword="false" />です。</param>
        <summary>サーバーへのポストバックが発生するクライアント イベントで使用できる文字列を返します。 参照文字列が定義されている、指定した <see cref="T:System.Web.UI.PostBackOptions" /> オブジェクトです。 必要に応じて、検証のためのイベントの参照を登録します。</summary>
        <returns>文字列をクライアントでスクリプトとして扱われた場合、クライアント ポストバックを開始します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 実装する、 <xref:System.Web.UI.IPostBackEventHandler> のためのインターフェイス、 <xref:System.Web.UI.Page> オブジェクト、ディレクティブを使用します。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> メソッドを使用できます、 <xref:System.Web.UI.WebControls.Button> タイミングを制御、 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> プロパティは `false`です。 このシナリオでは、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> クライアント ポストバック イベントをメソッドが返される、 <xref:System.Web.UI.WebControls.Button> コントロールです。  
  
 場合 `registerForEventValidation` は `true`, 、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> メソッドの呼び出し、 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> イベントを生成するクライアント コントロールを表す一意のコントロール ID の検証のためのイベントの参照を登録します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.PostBackOptions" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">サーバー <see cref="T:System.Web.UI.Control" /> サーバーにポストバックを処理します。</param>
        <param name="argument">渡される省略可能な引数の文字列 <c>control</c>します。</param>
        <param name="registerForEventValidation">
          <see langword="true" /> 検証のイベントの参照を登録するにはそれ以外の場合、 <see langword="false" />です。</param>
        <summary>サーバーへのポストバックが発生する、クライアント イベントで使用する文字列を返します。 参照文字列は、ポストバックと追加のイベント情報の文字列引数を処理する指定したコントロールによって定義されます。 必要に応じて、検証のためのイベントの参照を登録します。</summary>
        <returns>文字列をクライアントでは、スクリプトとして扱われた場合、ポストバックを開始します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 実装する、 <xref:System.Web.UI.IPostBackEventHandler> のためのインターフェイス、 <xref:System.Web.UI.Page>, 、ディレクティブを使用します。  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> メソッドを使用できます、 <xref:System.Web.UI.WebControls.Button> タイミングを制御、 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> プロパティは `false`です。 このシナリオでは、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> クライアント ポストバック イベントをメソッドが返される、 <xref:System.Web.UI.WebControls.Button> コントロールです。  
  
 場合 `registerForEventValidation` が true の場合、 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> メソッドの呼び出し、 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> イベントを生成するクライアント コントロールを表す一意のコントロール ID の検証のためのイベントの参照を登録します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定した <see cref="T:System.Web.UI.Control" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">リソースの種類。</param>
        <param name="resourceName">アセンブリ内のリソースの完全修飾名。</param>
        <summary>アセンブリ内のリソースへの URL 参照を取得します。</summary>
        <returns>リソースへの URL 参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> メソッドは、アセンブリに埋め込まれているリソースへの URL 参照を返します。 返される参照は、エンコードされた URL ではありません。 リソースは、スクリプト ファイル、画像、または任意の静的ファイルを使用できます。 リソースにアクセスして、オブジェクトに基づく種類を指定します。  
  
 ページに登録されている Web リソースは、その型と名前によって一意に識別します。 指定された型と名前のペアを持つ 1 つだけのリソースは、ページに登録できます。 既に登録されているリソースを登録しようとして、登録済みのリソースの複製が作成されることはできません。  
  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> と組み合わせてメソッドを使用、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> リソースにアクセスするためのメソッドがアセンブリに埋め込まれています。 アプリケーションでリソースの使用の詳細については、次を参照してください。 [ASP.NET Web Page Resources Overview](http://msdn.microsoft.com/ja-jp/0936b3b2-9e6e-4abe-9c06-364efef9dbbd)します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> メソッドです。*型* リソースを含むアセンブリ内のクラスの型にこの例ではパラメーターを設定します。`resourceName` パラメーターが既定の名前空間を含むリソースへの完全修飾パスで指定します。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager4\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 次のコード例では、プログラムによって適用する、 <xref:System.Web.UI.WebResourceAttribute> 提供されるリソースのアセンブリをマークするメタデータ属性です。 既定の名前空間に設定して、クラス ライブラリでは、次のクラスをコンパイル `Samples.AspNet.CS.Controls` または `Samples.AspNet.VB.Controls`, を使用している言語によって異なります。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 この例には、という名前の JavaScript ファイルが必要です。 `Script_include.js`します。 .Js ファイルを含むアセンブリの埋め込みリソースである、 `ClientScriptResourceLabel` オブジェクトです。 使用している場合は、 [!INCLUDE[vs_current_short](~/includes/vs-current-short-md.md)], 、クラス ライブラリ プロジェクトの \[プロパティ\] ウィンドウで次のように設定します。 **ビルド アクション** に **埋め込まれたリソース** スクリプト ファイルを選択するとします。 コマンドラインでライブラリをコンパイルする場合は、リソースを埋め込むには、スイッチを使用します。  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Web リソース名が <see langword="null" />です。  
  
 または  
  
 Web リソース名では、長さが 0 を持ちます。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">検索対象のクライアント スクリプト ブロックのキー。</param>
        <summary>クライアント スクリプト ブロックが登録されているかどうかを判断、 <see cref="T:System.Web.UI.Page" /> オブジェクトの指定のキーを使用します。</summary>
        <returns>
          <see langword="true" /> クライアント スクリプト ブロックの場合は登録します。それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す前に、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> を重複しているスクリプトの登録を回避するためです。 これは、スクリプトを作成するサーバーのリソースの消費量を必要な場合に特に重要です。  
  
 クライアント スクリプトは、そのキーとその型で一意に識別します。 同じキーよぶ型を使用してスクリプトでは、重複と見なされます。  
  
 このオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> メソッドは、両方を受け取るオーバー ロードを呼び出し、 `key` と `type` 、型のパラメーターを設定、 <xref:System.Web.UI.Page> オブジェクト  
  
   
  
## 例  
 [!code-csharp[System.Web.UI.ClientScriptManager1\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-vb[System.Web.UI.ClientScriptManager1\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">検索対象のクライアント スクリプト ブロックの型。</param>
        <param name="key">検索対象のクライアント スクリプト ブロックのキー。</param>
        <summary>クライアント スクリプト ブロックが登録されているかどうかを判断、 <see cref="T:System.Web.UI.Page" /> オブジェクトのキーおよび種類を使用しています。</summary>
        <returns>
          <see langword="true" /> クライアント スクリプト ブロックの場合は登録します。それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す前に、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> を重複しているスクリプトの登録を回避するためです。 これは、スクリプトを作成するサーバーのリソースの消費量を必要な場合に特に重要です。  
  
 クライアント スクリプトは、そのキーとその型で一意に識別します。 同じキーよぶ型を使用してスクリプトでは、重複と見なされます。 リソースにアクセスして、オブジェクトに基づく種類を指定します。 たとえばを使用する場合、 `Page` を指定する、リソースにアクセスするインスタンス、 `Page` 型です。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> メソッドです。 、既存のクライアント スクリプト ブロックをチェックするロジックが削除された場合がありますはない含まれている 2 つの重複したクライアント スクリプト レンダリングされるページの HTML ソース コードのため、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> メソッドは、重複データをチェックします。 チェックの利点は、不要な計算処理です。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">クライアント スクリプトの種類が <see langword="null" />です。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">検索するクライアント スクリプトのキーが含まれます。</param>
        <summary>決定クライアント スクリプトに含めるかどうかに登録された、 <see cref="T:System.Web.UI.Page" /> オブジェクトの指定のキーを使用します。</summary>
        <returns>
          <see langword="true" /> クライアント スクリプトに含める場合は、登録されています。それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す前に、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> を重複しているスクリプトの登録を回避するためです。 これは、スクリプトを作成するサーバーのリソースの消費量を必要な場合に特に重要です。  
  
 クライアント スクリプトに含めるそのキーとその型では一意に識別します。 同じキーよぶ型を使用してスクリプトでは、重複と見なされます。  
  
 このオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> メソッドは、両方を受け取るオーバー ロードを呼び出し、 `key` と `type` 、型のパラメーターを設定、 <xref:System.Web.UI.Page> オブジェクトです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">検索するクライアント スクリプトの種類が含まれます。</param>
        <param name="key">検索するクライアント スクリプトのキーが含まれます。</param>
        <summary>決定クライアント スクリプトに含めるかどうかに登録された、 <see cref="T:System.Web.UI.Page" /> オブジェクトのキーおよび種類を使用しています。</summary>
        <returns>
          <see langword="true" /> クライアント スクリプトに含める場合は、登録されています。それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す前に、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 重複したクライアント スクリプトの登録を防ぐためにメソッドが含まれています。 これは、スクリプトを作成するサーバーのリソースの消費量を必要な場合に特に重要です。  
  
 クライアント スクリプトに含めるそのキーとその型では一意に識別します。 同じキーよぶ型を使用してスクリプトでは、重複と見なされます。 リソースにアクセスして、オブジェクトに基づく種類を指定します。 たとえば、ページ インスタンスを使用して、リソースにアクセスする、指定した、 `Page` 型です。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> メソッドです。 、既存のクライアント スクリプトに含まれているを確認するロジックが削除された場合がありますいないになります 2 つの重複したクライアント スクリプト レンダリングされるページの HTML ソース コードのため、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> メソッドは、重複データをチェックします。 チェックの利点は、不要な計算処理です。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager2\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager2\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 この例には、という名前の JavaScript ファイルが必要です。 `Script_include.js`, 、次の内容。  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">クライアント スクリプトに含める型は <see langword="null" />です。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">検索する OnSubmit ステートメントのキー。</param>
        <summary>OnSubmit ステートメントに登録されているかどうかを判断、 <see cref="T:System.Web.UI.Page" /> オブジェクトの指定のキーを使用します。</summary>
        <returns>
          <see langword="true" /> OnSubmit ステートメントは、登録されている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す前に、 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> OnSubmit ステートメントが重複している登録を回避するためです。 これは、ステートメントを作成するサーバーのリソースの消費量が必要な場合に特に重要です。  
  
 ステートメントは、そのキーとその型で一意に識別します。 同じキーよぶ型指定されたステートメントは、重複と見なされます。  
  
 このオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> メソッドは、両方を受け取るオーバー ロードを呼び出し、 `key` と `type` 、型のパラメーターを設定、 <xref:System.Web.UI.Page> オブジェクト  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">検索する OnSubmit ステートメントの種類。</param>
        <param name="key">検索する OnSubmit ステートメントのキー。</param>
        <summary>OnSubmit ステートメントに登録されているかどうかを判断、 <see cref="T:System.Web.UI.Page" /> オブジェクトの指定したキーと型を使用します。</summary>
        <returns>
          <see langword="true" /> OnSubmit ステートメントは、登録されている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す前に、 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> ステートメントが重複している登録を回避するためです。 これは、ステートメントを作成するサーバーのリソースの消費量が必要な場合に特に重要です。  
  
 ステートメントは、そのキーとその型で一意に識別します。 同じキーよぶ型指定されたステートメントは、重複と見なされます。 リソースにアクセスして、オブジェクトに基づく種類を指定します。 たとえばを使用する場合、 `Page` を指定する、リソースにアクセスするインスタンス、 `Page` 型です。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> メソッドです。 という名前のスクリプト `OnSubmitScript` に登録されて、 <xref:System.Web.UI.Page> 、ページのフォームが送信されると、スクリプトが呼び出されるようにします。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager3\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager3\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">OnSubmit ステートメントの種類が <see langword="null" />です。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">検索対象のスタートアップ スクリプトのキー。</param>
        <summary>スタートアップ スクリプトが登録されているかどうかを判断、 <see cref="T:System.Web.UI.Page" /> オブジェクトの指定のキーを使用します。</summary>
        <returns>
          <see langword="true" /> スタートアップ スクリプトが登録されている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す前に、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> を重複しているスクリプトの登録を回避するためです。 これは、スクリプトを作成するサーバーのリソースの消費量を必要な場合に特に重要です。  
  
 スタートアップ スクリプトは、そのキーとその型で一意に識別します。 同じキーよぶ型を使用してスクリプトでは、重複と見なされます。  
  
 このオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> メソッドは、両方の文字列を受け取るオーバー ロードを呼び出す `key` と `type` 、型のパラメーターを設定、 <xref:System.Web.UI.Page> オブジェクト  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">検索対象のスタートアップ スクリプトの種類。</param>
        <param name="key">検索対象のスタートアップ スクリプトのキー。</param>
        <summary>スタートアップ スクリプトが登録されているかどうかを判断、 <see cref="T:System.Web.UI.Page" /> オブジェクトの指定したキーと型を使用します。</summary>
        <returns>
          <see langword="true" /> スタートアップ スクリプトが登録されている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出す前に、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> を重複しているスクリプトの登録を回避するためです。 これは、スクリプトを作成するサーバーのリソースの消費量を必要な場合に特に重要です。  
  
 クライアントのスタートアップ スクリプトは、そのキーとその型で一意に識別します。 同じキーよぶ型を使用してスクリプトでは、重複と見なされます。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> メソッドです。 、既存のスタートアップ スクリプト ブロックをチェックするロジックが削除された場合がありますがいない含まれている 2 つの重複するスタートアップ スクリプト レンダリングされるページの HTML ソース コードのため、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> メソッドは、重複データをチェックします。 チェックの利点は、不要な計算処理です。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">スタートアップ スクリプトの種類が <see langword="null" />です。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">登録する配列の名前。</param>
        <param name="arrayValue">登録する配列値。</param>
        <summary>JavaScript 配列宣言を登録、 <see cref="T:System.Web.UI.Page" /> オブジェクト、配列の名前と値の配列を使用しています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> で指定した名前と同じ名前の登録済みの配列が存在するかどうかをチェック、 `arrayName` パラメーターで指定された値を追加し、 `arrayValue` パラメーター。 基になるストレージ メカニズムが基づいているため、 <xref:System.Collections.ArrayList>, 、重複は許可されています。 同じ名前で登録されている配列の場合、 `arrayName` パラメーターが存在しないか、作成したと内の値、 `arrayValue` パラメーターを追加します。  
  
 単一引用符 \('\) を含めるか、二重引用符をエスケープする場合は、結果の JavaScript 配列の文字列リテラル、\(\\"\) で、 `arrayValue` パラメーター。 値、 `arrayValue` パラメーターが 1 つの要素にする必要があります。 使用して複数の呼び出しを行う場合は 1 つ以上の値は、配列に追加する必要がある、 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> メソッドです。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> と <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> メソッドです。 例では、配列と非表示の値を登録し、定義、 `OnClick` のイベント、 `<input>` 配列の 2 つの値と非表示の値の合計を計算するボタンをクリックします。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager5\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager5\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayName" /> は <see langword="null" /> です。</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">登録するクライアント スクリプトの種類。</param>
        <param name="key">登録するクライアント スクリプトのキー。</param>
        <param name="script">クライアント スクリプトを登録するリテラルです。</param>
        <summary>クライアント スクリプトを登録、 <see cref="T:System.Web.UI.Page" /> オブジェクトの種類、キー、およびスクリプト リテラルを使用しています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クライアント スクリプトは、そのキーとその型で一意に識別します。 同じキーよぶ型を使用してスクリプトでは、重複と見なされます。 ページには、指定された型とキーのペアを持つ 1 つだけのスクリプトを登録できます。 既に登録されているスクリプトを登録しようとしても、重複したスクリプトは作成されません。  
  
 呼び出す、 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> メソッドを指定したキーと型のペアでクライアント スクリプトは既に登録されているかどうかを判断し、スクリプトを追加しようとして不要なを回避します。  
  
 このオーバー ロードで、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> メソッドを確認してくださいでスクリプトが提供されること、 `script` にパラメーターがラップされて、 `<script>` 要素ブロックします。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> メソッドは、レンダリングされたページの上部にスクリプト ブロックを追加します。 スクリプト ブロックは、登録されている順序で出力されるとは限りません。 スクリプト ブロックの順序が重要な場合を使用して、 <xref:System.Text.StringBuilder> オブジェクトを 1 つの文字列で、スクリプトを収集し、すべて 1 台のクライアント スクリプト ブロック内に登録します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> メソッドです。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager12\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager12\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">登録するクライアント スクリプトの種類。</param>
        <param name="key">登録するクライアント スクリプトのキー。</param>
        <param name="script">クライアント スクリプトを登録するリテラルです。</param>
        <param name="addScriptTags">スクリプト タグを追加するかどうかを示すブール値。</param>
        <summary>クライアントを使用してスクリプトを登録、<see cref="T:System.Web.UI.Page" />オブジェクトの種類、キー、スクリプト タグを追加するかどうかを示すスクリプト リテラル、およびブール値を使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クライアント スクリプトは、そのキーとその型で一意に識別します。 同じキーおよび種類を使用してスクリプトは、重複と見なされます。 ページには、指定された型とキー ペアを持つ 1 つだけのスクリプトを登録できます。 既に登録されているスクリプトを登録しようとしています。 重複したスクリプトは作成されません。  
  
 呼び出す、<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>指定したキーおよび種類のペアでクライアント スクリプトは既に登録されているかどうかを調べます。 これにより、スクリプトを追加しようとして不要なを回避することができます。  
  
 このオーバー ロードで、<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>メソッドで、スクリプトが提供されるかどうか示すことができます、`script`でパラメーターがラップされて、`<script>`要素ブロックを使用して、`addScriptTags`パラメーター。 設定`addScriptTags`を`true`スクリプト タグが自動的に追加することを示します。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>メソッドは、レンダリングされるページの上部にスクリプト ブロックを追加します。 スクリプト ブロックは、登録されている順序で出力されるとは限りません。 スクリプト ブロックの順序が重要な場合を使用して、<xref:System.Text.StringBuilder>オブジェクトを 1 つの文字列で、スクリプトを収集し、それらすべてを 1 つのクライアント スクリプト ブロック内に登録します。  
  
   
  
## 例  
 使用を次のコード例に示します、<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>メソッドです。 注意してください、`addScriptTags`にパラメーターが設定されている`true`開始タグと終了スクリプト タグに含まれていないため、`script`パラメーター。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">クライアント スクリプト ブロックの型は<see langword="null" />します。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">登録するクライアント スクリプトのキーが含まれます。</param>
        <param name="url">クライアント スクリプトの URL には、登録が含まれます。</param>
        <summary>クライアント スクリプトを登録、 <see cref="T:System.Web.UI.Page" /> オブジェクト キーと、クライアントから呼び出されるスクリプトを使用する URL を使用しています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クライアント スクリプトに含めるそのキーとその型では一意に識別します。 同じキーよぶ型を使用してスクリプトでは、重複と見なされます。 ページには、指定された型とキーのペアを持つ 1 つだけのスクリプトを登録できます。 既に登録されているスクリプトを登録しようとしても、重複したスクリプトは作成されません。  
  
 呼び出す、 <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> クライアント スクリプトは、指定されたキーに含めるし、型のペアは既に登録されてでスクリプトを追加しようとするは不必要に回避いるかどうかを決定する方法です。  
  
> [!NOTE]
>  クライアントの URL を解決するを使用して、 <xref:System.Web.UI.Control.ResolveClientUrl%2A> メソッドです。 このメソッドは、パスを解決するのには呼び出さ、対象の URL のコンテキストを使用します。  
  
 このオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> メソッドが使用するオーバー ロードを呼び出し、 `key`, 、 `URL`, 、および `type` パラメーター。  
  
 メソッドは、レンダリングされるページの上部にあるスクリプト ブロックを追加します。  
  
   
  
## 例  
 関連情報については、構文、使用状況、および例についてなどを参照してください。 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">クライアント スクリプトの種類には、登録が含まれます。</param>
        <param name="key">登録するクライアント スクリプトのキーが含まれます。</param>
        <param name="url">クライアント スクリプトの URL には、登録が含まれます。</param>
        <summary>クライアント スクリプト インクルード レジスタ、 <see cref="T:System.Web.UI.Page" /> オブジェクト型、キー、および URL を使用しています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロード、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> メソッドには *キー* と *url* 、スクリプトを識別するパラメーターと同様に、 `type` クライアント スクリプトの id を指定するパラメーターが含まれます。 リソースにアクセスして、オブジェクトに基づく種類を指定します。 たとえばを使用する場合、 `Page` を指定する、リソースにアクセスするインスタンス、 `Page` 型です。  
  
> [!NOTE]
>  クライアントの URL を解決するを使用して、 <xref:System.Web.UI.Control.ResolveClientUrl%2A> メソッドです。 このメソッドは、パスを解決するのには呼び出さ、対象の URL のコンテキストを使用します。  
  
 このメソッドは、レンダリングされるページの上部にあるスクリプト ブロックを追加します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> メソッドです。 既存のクライアント スクリプトに含まれているを確認するロジックが削除された場合もないあると重複しているクライアント スクリプト、レンダリングされたページのために注意してください、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> メソッドは、重複データをチェックします。 チェックの利点は、不要な計算処理です。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager2\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager2\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 この例では、内容を次のようなをという名前の JavaScript ファイルが必要です。  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">クライアント スクリプトに含める型は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">URL は <see langword="null" />です。  
  
 または  
  
 URL が空です。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">登録するクライアント スクリプト リソースの種類。</param>
        <param name="resourceName">登録するクライアント スクリプト リソースの名前。</param>
        <summary>クライアント スクリプト リソースの登録、 <see cref="T:System.Web.UI.Page" /> オブジェクト型とリソース名を使用しています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> WebResource.axd HTTP ハンドラーのアセンブリのコンパイル時のリソースにアクセスするときにメソッドを使用します。<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> メソッドを含むスクリプトの登録、 <xref:System.Web.UI.Page> オブジェクトし、重複するスクリプトを防止します。 このメソッドは、リソース URL での内容をラップする `<script>` 要素ブロックします。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> メソッドです。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager4\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 次のコード例では、プログラムによって適用する、 <xref:System.Web.UI.WebResourceAttribute> 提供されるリソースのアセンブリをマークするメタデータ属性です。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 この例には、という名前の JavaScript ファイルが必要です。 `Script_include.js`, 、次の内容。  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 コンパイル、 `Script_include.js` ファイル内のリソースとして、 `Samples.AspNet.CS.Controls` を含むアセンブリ、 `ClientScriptResourceLabel` クラスです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">クライアント リソースの名前は <see langword="null" />です。  
  
 または  
  
 クライアントのリソース名は、長さが 0 を持ちます。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">
          <see cref="T:System.Web.UI.Control" /> カスタム属性を含むページにします。</param>
        <param name="attributeName">登録するカスタム属性の名前。</param>
        <param name="attributeValue">カスタム属性の値。</param>
        <summary>コントロールの ID、属性名、および属性値を指定して指定したコントロールのカスタム \(expando\) 属性として名前\/値ペアを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> メソッドは、指定したカスタム \(expando\) 属性として名前\/値ペアを登録 <xref:System.Web.UI.Control>します。 Expando 属性が、レンダリングされたコントロールのマークアップの XHTML の互換性を保つための JavaScript から動的に設定されます。 二重引用符とカスタム \(expando\) 属性の値の円記号はエスケープされます。 引用符と円記号をエスケープしない場合、 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> メソッドをオーバー ロードし、設定、 `encode` パラメーターを `false`します。  
  
 Expando 属性が見つからないか、expando 属性を追加するコントロールが存在しない場合は、クライアント スクリプトが生成されますが、コントロールには影響しません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">
          <see cref="T:System.Web.UI.Control" /> カスタム属性を含むページにします。</param>
        <param name="attributeName">登録するカスタム属性の名前。</param>
        <param name="attributeValue">カスタム属性の値。</param>
        <param name="encode">登録するカスタム属性をエンコードするかどうかを示すブール値。</param>
        <summary>コントロールの ID、属性名、属性値、および属性値をエンコードするかどうかを示すブール値を指定して指定したコントロールのカスタム \(expando\) 属性として名前\/値ペアを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> メソッドは、指定したカスタム \(expando\) 属性として名前\/値ペアを登録 <xref:System.Web.UI.Control>します。 Expando 属性が、レンダリングされたコントロールのマークアップの XHTML の互換性を保つための JavaScript から動的に設定されます。 設定、 `encode` パラメーターを `true` 引用符、expando 属性の値の円記号をエスケープする必要がある場合。  
  
 Expando 属性が見つからないか、expando 属性を追加するコントロールが存在しない場合は、クライアント スクリプトが生成されますが、コントロールには影響しません。  
  
   
  
## 例  
 次のコード例では、使用して、 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> のメソッド、 <xref:System.Web.UI.ClientScriptManager> クラスです。 表示されたページのセット内のクライアント スクリプト、 `title` の属性、 `<span>` 要素。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager6\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager6\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">イベントを生成するクライアントのコントロールを表す一意の ID。</param>
        <summary>イベントを生成するクライアントのコントロールを表す一意のコントロール ID を検証用のイベントの参照を登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 詳細と例については、「、 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> メソッドです。  
  
   
  
## 例  
 使用する例を次に示します、 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> メソッドおよび <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> 検証、およびページから、コールバックが送られたことを検証する方法のコールバックを登録するためのメソッドです。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager9\#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-vb[System.Web.UI.ClientScriptManager9\#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Web.UI.PostBackOptions" /> ポストバック イベントを開始するクライアントの JavaScript を生成する方法を指定するオブジェクト。</param>
        <summary>使用した検証のイベントの参照を登録 <see cref="T:System.Web.UI.PostBackOptions" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 詳細と例については、「、 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">イベントを生成するクライアントのコントロールを表す一意の ID。</param>
        <param name="argument">クライアント イベントとイベントの引数が渡されます。</param>
        <summary>イベントを生成するクライアントのコントロールを表す一意のコントロール ID とイベントの引数を検証用のイベントの参照を登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次のコード例では、使用方法を示します、 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> メソッドおよび <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> 検証用のコールバックを登録して、コールバックがページから送られたことを検証する方法です。 例に示すように検証を改善するには、検証を変更する可能性があります `argument` id やロールなどのユーザーに固有の情報を格納します。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager9\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager9\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 次のコード例では、使用方法を示します、 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 検証用のコールバックを登録します。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager10\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager10\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メソッドは前に、 <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" /> メソッドです。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">登録する隠しフィールドの名前。</param>
        <param name="hiddenFieldInitialValue">登録するフィールドの初期値。</param>
        <summary>登録を非表示の値、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> メソッドは、非表示を作成 `<input>` レンダリングされた HTML ページ上の要素。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> と <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> メソッドです。 例では、配列と非表示の値を登録し、定義、 `OnClick` のイベント、 `<input>` 配列の 2 つの値と非表示の値の合計を計算するボタンをクリックします。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager5\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager5\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hiddenFieldName" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">登録する OnSubmit ステートメントの種類。</param>
        <param name="key">登録する OnSubmit ステートメントのキー。</param>
        <param name="script">登録する OnSubmit ステートメントのスクリプトのリテラルです。</param>
        <summary>OnSubmit ステートメントでの登録、 <see cref="T:System.Web.UI.Page" /> オブジェクト型、キー、およびスクリプトのリテラルを使用しています。 ステートメントを実行したときに、 <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> を送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 OnSubmit ステートメントは、そのキーとその型で一意に識別します。 同じキーよぶ型指定されたステートメントは、重複と見なされます。 指定された型とキー ペアを持つ 1 つだけのステートメントは、ページに登録できます。 既に登録されているステートメントを登録しようとしても、重複したステートメントは作成されません。  
  
 呼び出す、 <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> OnSubmit ステートメントが特定のキーおよび種類のペアに既に登録されているかどうかを判断し、スクリプトを追加しようとして不要なを回避する方法です。  
  
 `script` のパラメーター、 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> メソッドが適切には、セミコロン \(;\) で区切られている限り、複数のスクリプト コマンドを含めることができます。  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> ページが送信され、使用すると、送信を取り消す前に実行されるスクリプトを追加します。  
  
 HTML フォームの詳細については、 `OnSubmit` 属性を参照してください、 [World Wide Web Consortium \(W3C\) Web site](http://go.microsoft.com/fwlink/?linkid=37125)します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> メソッドです。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager3\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager3\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">登録するスタートアップ スクリプトの種類。</param>
        <param name="key">登録するスタートアップ スクリプトのキー。</param>
        <param name="script">スタートアップ スクリプトを登録するリテラルです。</param>
        <summary>スタートアップ スクリプトを登録、 <see cref="T:System.Web.UI.Page" /> オブジェクト型、キー、およびスクリプトのリテラルを使用しています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クライアント スクリプトは、そのキーとその型で一意に識別します。 同じキーよぶ型を使用してスクリプトでは、重複と見なされます。 ページには、指定された型とキーのペアを持つ 1 つだけのスクリプトを登録できます。 既に登録されているスクリプトを登録しようとしても、重複したスクリプトは作成されません。  
  
 呼び出す、 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> メソッドを指定したキーと型のペアでスタートアップ スクリプトは既に登録されているかどうかを判断し、スクリプトを追加しようとして不要なを回避します。  
  
 このオーバー ロードで、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> メソッドを確認してくださいでスクリプトが提供されること、 `script` によってパラメーターがラップされた、 `<script>` 要素ブロックします。  
  
 によって追加スクリプト ブロック、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> メソッドは、ページ読み込みが完了したときに、ページの前に、実行 <xref:System.Web.UI.Control.OnLoad%2A> イベントが発生します。 スクリプト ブロックは、登録されている順序で出力されるとは限りません。 スクリプト ブロックの順序が重要な場合を使用して、 <xref:System.Text.StringBuilder> オブジェクトを 1 つの文字列で、スクリプトを収集し、すべて 1 台のクライアント スクリプト ブロック内に登録します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> メソッドです。 ノート内で、開始タグと終了タグのスクリプトが含まれている、 `script` パラメーター。 追加されたタグを参照してください、追加のパラメーター設定に基づいてスクリプトを使用して、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> メソッドです。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager11\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager11\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">登録するスタートアップ スクリプトの種類。</param>
        <param name="key">登録するスタートアップ スクリプトのキー。</param>
        <param name="script">スタートアップ スクリプトを登録するリテラルです。</param>
        <param name="addScriptTags">スクリプト タグを追加するかどうかを示すブール値。</param>
        <summary>スタートアップ スクリプトを登録、 <see cref="T:System.Web.UI.Page" /> オブジェクト型、キー、スクリプトのリテラル、およびスクリプト タグを追加するかどうかを示すブール値を使用しています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スタートアップ スクリプトは、そのキーとその型で一意に識別します。 同じキーよぶ型を使用してスクリプトでは、重複と見なされます。 ページには、指定された型とキーのペアを持つ 1 つだけのスクリプトを登録できます。 既に登録されているスクリプトを登録しようとしても、重複したスクリプトは作成されません。  
  
 呼び出す、 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> メソッドを指定したキーと型のペアでスタートアップ スクリプトは既に登録されているかどうかを判断し、スクリプトを追加しようとして不要なを回避します。  
  
 このオーバー ロードで、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> メソッドで、スクリプトが用意されているかどうか示すことができます、 `script` によってパラメーターがラップされた、 `<script>` 要素のブロックを使用して、 `addScriptTags` パラメーター。 設定 `addScriptTags` に `true` スクリプト タグが自動的に追加されることを示します。  
  
 によって追加スクリプト ブロック、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> メソッドは、ページ読み込みが完了したときに、ページの前に、実行 <xref:System.Web.UI.Control.OnLoad%2A> イベントが発生します。 スクリプト ブロックは、登録されている順序で出力されるとは限りません。 スクリプト ブロックの順序が重要な場合を使用して、 <xref:System.Text.StringBuilder> オブジェクトを 1 つの文字列で、スクリプトを収集し、すべて 1 台のクライアント スクリプト ブロック内に登録します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> メソッドです。 注意してください、 `addScriptTags` にパラメーターが設定されている `false` 開始タグと終了タグのスクリプトが含まれていますので、 `script` パラメーター。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager1\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager1\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">イベントを生成するクライアントのコントロールを表す一意の ID。</param>
        <summary>イベントの検証を使用するために登録されたクライアント イベントを検証、 <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" /> メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">イベントを生成するクライアントのコントロールを表す一意の ID。</param>
        <param name="argument">クライアント イベントとイベントの引数が渡されます。</param>
        <summary>イベントの検証を使用するために登録されたクライアント イベントを検証、 <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" /> メソッドです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次のコード例では、使用方法を示します、 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> メソッドおよび <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> 検証用のコールバックを登録して、コールバックがページから送られたことを検証する方法です。 を次に示すの検証を向上させるのには、検証を変更する可能性があります `argument` id やロールなどのユーザーに固有の情報を格納します。  
  
 [!code-csharp[System.Web.UI.ClientScriptManager9\#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-vb[System.Web.UI.ClientScriptManager9\#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uniqueId" /> <see langword="null" /> または空の文字列 \(""\) です。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>サーバーへのポストバックが発生するクライアント イベントで使用できる文字列を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>OnSubmit ステートメントに登録されているかどうかを判断、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>クライアント スクリプトを登録、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>クライアントのイベントを検証します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>クライアント関数が、呼び出されると、クライアントが通信を開始にコールバックして、サーバー イベントへの参照を取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>クライアント スクリプト インクルード レジスタ、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>決定クライアント スクリプトに含めるかどうかに登録された、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>スタートアップ スクリプトが登録されているかどうかを判断、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>持つ、参照を取得 <see langword="javascript:" /> サーバーにポストバック クライアント イベントで使用できるは、先頭に追加します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>クライアント スクリプト ブロックが登録されているかどうかを判断、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>スタートアップ スクリプトを登録、 <see cref="T:System.Web.UI.Page" /> オブジェクトです。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>検証のためのイベントの参照を登録します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたコントロールのカスタム \(expando\) 属性として名前\/値ペアを登録します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>