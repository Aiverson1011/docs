<Type Name="Queue&lt;T&gt;" FullName="System.Collections.Generic.Queue&lt;T&gt;">
  <TypeSignature Language="C#" Value="public class Queue&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Queue`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Queue`1" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_QueueDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">キュー内の要素の型を指定します。</typeparam>
    <summary>オブジェクトの先入れ先出しコレクションを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 このクラスは、循環配列として汎用キューを実装します。 オブジェクトに格納されている、 <xref:System.Collections.Generic.Queue%601> 一方の end が挿入され、もう一方から削除します。 キューおよびスタックは便利ですが必要な一時記憶域の情報つまり、可能性がありますをする場合、値を取得した後でその要素を破棄します。 使用 <xref:System.Collections.Generic.Queue%601> かどうかには、コレクションに格納される順序と同じ順序での情報にアクセスする必要があります。 使用 <xref:System.Collections.Generic.Stack%601> 逆の順序で、情報にアクセスする必要がある場合。 使用 <xref:System.Collections.Concurrent.ConcurrentQueue%601> または <xref:System.Collections.Concurrent.ConcurrentStack%601> 同時に複数のスレッドからコレクションにアクセスする必要がある場合。  
  
 次の 3 つの主要な操作を実行できる、 <xref:System.Collections.Generic.Queue%601> とその要素。  
  
-   <xref:System.Collections.Generic.Queue%601.Enqueue%2A> 末尾に要素を追加、 <xref:System.Collections.Generic.Queue%601>です。  
  
-   <xref:System.Collections.Generic.Queue%601.Dequeue%2A> 先頭から最も古い要素を削除、 <xref:System.Collections.Generic.Queue%601>です。  
  
-   <xref:System.Collections.Generic.Queue%601.Peek%2A> ピークの開始位置にある最も古い要素を取得する、 <xref:System.Collections.Generic.Queue%601> からは削除されませんが、 <xref:System.Collections.Generic.Queue%601>です。  
  
 容量、 <xref:System.Collections.Generic.Queue%601> 要素の数が、 <xref:System.Collections.Generic.Queue%601> を保持できます。 要素が追加されると、 <xref:System.Collections.Generic.Queue%601>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>です。  
  
 <xref:System.Collections.Generic.Queue%601> 受け入れる `null` 参照の有効な値型し、重複する要素を使用します。  
  
   
  
## 例  
 次のコード例をいくつかの方法を示しています、 <xref:System.Collections.Generic.Queue%601> ジェネリック クラスです。 このコード例は、既定の容量を持つ文字列のキューを作成し、使用して、 <xref:System.Collections.Generic.Queue%601.Enqueue%2A> 5 つの文字列のキューにします。 キューの要素が表示され、キューの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Queue%601.Dequeue%2A> メソッドを使用して、最初の文字列をキューから削除します。<xref:System.Collections.Generic.Queue%601.Peek%2A> メソッドを使用して、キューでは、次の項目を確認し、 <xref:System.Collections.Generic.Queue%601.Dequeue%2A> がデキューするメソッドを使用します。  
  
 <xref:System.Collections.Generic.Queue%601.ToArray%2A> 配列を作成し、キューの要素をコピーするメソッドを使用しに渡した配列、 <xref:System.Collections.Generic.Queue%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、キューのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、キューのサイズが作成、および <xref:System.Collections.Generic.Queue%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Queue%601.%23ctor%2A> コンス トラクターは先頭に次の 3 つの null 要素を含むキューの 2 つ目のコピーを作成するにはもう一度使用されます。  
  
 <xref:System.Collections.Generic.Queue%601.Contains%2A> メソッドを使用して、表示するまで、キューの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Queue%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Queue%601.Count%2A> キューが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Queue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 \(<see langword="Shared" /> Visual Basic では\) この型のメンバーは、スレッド セーフであります。 インスタンス メンバーの場合は、スレッド セーフであるとは限りません。  
  
 A <see cref="T:System.Collections.Generic.Queue`1" /> コレクションが変更されない限り、複数のリーダーを同時にサポートできます。  それでも、コレクションの列挙は、本質的には、スレッド セーフなプロシージャでは。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>空で、既定の初期量を備えた、<see cref="T:System.Collections.Generic.Queue`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 容量、 <xref:System.Collections.Generic.Queue%601> は要素の数を <xref:System.Collections.Generic.Queue%601> を保持できます。 要素が追加されると、 <xref:System.Collections.Generic.Queue%601>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.Generic.Queue%601>です。  
  
 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>です。  
  
 このコンス トラクターは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、このコンス トラクターの他のいくつかの方法、 <xref:System.Collections.Generic.Queue%601> ジェネリック クラスです。 このコード例は、既定の容量を持つ文字列のキューを作成し、使用して、 <xref:System.Collections.Generic.Queue%601.Enqueue%2A> 5 つの文字列のキューにします。 キューの要素が表示され、キューの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Queue%601.Dequeue%2A> メソッドを使用して、最初の文字列をキューから削除します。<xref:System.Collections.Generic.Queue%601.Peek%2A> メソッドを使用して、キューでは、次の項目を確認し、 <xref:System.Collections.Generic.Queue%601.Dequeue%2A> がデキューするメソッドを使用します。  
  
 <xref:System.Collections.Generic.Queue%601.ToArray%2A> 配列を作成し、キューの要素をコピーするメソッドを使用しに渡した配列、 <xref:System.Collections.Generic.Queue%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、キューのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、キューのサイズが作成、および <xref:System.Collections.Generic.Queue%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Queue%601.%23ctor%2A> コンス トラクターは先頭に次の 3 つの null 要素を含むキューの 2 つ目のコピーを作成するにはもう一度使用されます。  
  
 <xref:System.Collections.Generic.Queue%601.Contains%2A> メソッドを使用して、表示するまで、キューの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Queue%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Queue%601.Count%2A> キューが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Queue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">新しい <see cref="T:System.Collections.Generic.Queue`1" /> に要素がコピーされたコレクション。</param>
        <summary>指定したコレクションからコピーした要素を格納し、コピーされる要素の数を格納できるだけの容量を備えた、<see cref="T:System.Collections.Generic.Queue`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 容量、 <xref:System.Collections.Generic.Queue%601> は要素の数を <xref:System.Collections.Generic.Queue%601> を保持できます。 要素が追加されると、 <xref:System.Collections.Generic.Queue%601>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.Generic.Queue%601>です。  
  
 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>です。  
  
 要素の上にコピー、 <xref:System.Collections.Generic.Queue%601> によって読み取られる順序と同じ順序で、 <xref:System.Collections.Generic.IEnumerator%601> のコレクション。  
  
 このコンス トラクターは、O \(`n`\) 操作の場合、 `n` 内の要素の数は、 `collection`です。  
  
   
  
## 例  
 次のコード例では、このコンス トラクターの他のいくつかの方法、 <xref:System.Collections.Generic.Queue%601> ジェネリック クラスです。 このコード例は、既定の容量を持つ文字列のキューを作成し、使用して、 <xref:System.Collections.Generic.Queue%601.Enqueue%2A> 5 つの文字列のキューにします。 キューの要素が表示され、キューの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Queue%601.Dequeue%2A> メソッドを使用して、最初の文字列をキューから削除します。<xref:System.Collections.Generic.Queue%601.Peek%2A> メソッドを使用して、キューでは、次の項目を確認し、 <xref:System.Collections.Generic.Queue%601.Dequeue%2A> がデキューするメソッドを使用します。  
  
 <xref:System.Collections.Generic.Queue%601.ToArray%2A> 配列を作成し、キューの要素をコピーするメソッドを使用しに渡した配列、 <xref:System.Collections.Generic.Queue%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、キューのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、キューのサイズが作成、および <xref:System.Collections.Generic.Queue%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Queue%601.%23ctor%2A> コンス トラクターは先頭に次の 3 つの null 要素を含むキューの 2 つ目のコピーを作成するにはもう一度使用されます。  
  
 <xref:System.Collections.Generic.Queue%601.Contains%2A> メソッドを使用して、表示するまで、キューの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Queue%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Queue%601.Count%2A> キューが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Queue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Generic.Queue`1" /> が格納できる要素数の初期値。</param>
        <summary>空で、指定した初期量を備えた、<see cref="T:System.Collections.Generic.Queue`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 容量、 <xref:System.Collections.Generic.Queue%601> は要素の数を <xref:System.Collections.Generic.Queue%601> を保持できます。 要素が追加されると、 <xref:System.Collections.Generic.Queue%601>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.Generic.Queue%601>です。  
  
 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>です。  
  
 このコンス トラクターは、O \(`n`\) 操作の場合、 `n` は `capacity`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Queue`1" /> からすべてのオブジェクトを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.Queue%601.Count%2A> is set to zero, and references to other objects from elements of the collection are also released.  
  
 The capacity remains unchanged. To reset the capacity of the <xref:System.Collections.Generic.Queue%601>, call <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>. Trimming an empty <xref:System.Collections.Generic.Queue%601> sets the capacity of the <xref:System.Collections.Generic.Queue%601> to the default capacity.  
  
 This method is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## 例  
 The following code example demonstrates several methods of the <xref:System.Collections.Generic.Queue%601> generic class, including the <xref:System.Collections.Generic.Queue%601.Clear%2A> method.  
  
 The code example creates a queue of strings with default capacity and uses the <xref:System.Collections.Generic.Queue%601.Enqueue%2A> method to queue five strings. The elements of the queue are enumerated, which does not change the state of the queue. The <xref:System.Collections.Generic.Queue%601.Dequeue%2A> method is used to dequeue the first string. The <xref:System.Collections.Generic.Queue%601.Peek%2A> method is used to look at the next item in the queue, and then the <xref:System.Collections.Generic.Queue%601.Dequeue%2A> method is used to dequeue it.  
  
 The <xref:System.Collections.Generic.Queue%601.ToArray%2A> method is used to create an array and copy the queue elements to it, then the array is passed to the <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructor that takes <xref:System.Collections.Generic.IEnumerable%601>, creating a copy of the queue. The elements of the copy are displayed.  
  
 An array twice the size of the queue is created, and the <xref:System.Collections.Generic.Queue%601.CopyTo%2A> method is used to copy the array elements beginning at the middle of the array. The <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructor is used again to create a second copy of the queue containing three null elements at the beginning.  
  
 The <xref:System.Collections.Generic.Queue%601.Contains%2A> method is used to show that the string "four" is in the first copy of the queue, after which the <xref:System.Collections.Generic.Queue%601.Clear%2A> method clears the copy and the <xref:System.Collections.Generic.Queue%601.Count%2A> property shows that the queue is empty.  
  
 [!code-csharp[Generic.Queue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.TrimExcess" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Contains(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.Queue`1" /> 内で検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>ある要素が <see cref="T:System.Collections.Generic.Queue`1" /> 内に存在するかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="item" /> に存在する場合は <see cref="T:System.Collections.Generic.Queue`1" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for **parameterReference tag is not supported!!!!**  
, the type of values in the queue.  
  
 This method performs a linear search; therefore, this method is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## 例  
 The following code example demonstrates several methods of the <xref:System.Collections.Generic.Queue%601> generic class, including the <xref:System.Collections.Generic.Queue%601.Contains%2A> method.  
  
 The code example creates a queue of strings with default capacity and uses the <xref:System.Collections.Generic.Queue%601.Enqueue%2A> method to queue five strings. The elements of the queue are enumerated, which does not change the state of the queue. The <xref:System.Collections.Generic.Queue%601.Dequeue%2A> method is used to dequeue the first string. The <xref:System.Collections.Generic.Queue%601.Peek%2A> method is used to look at the next item in the queue, and then the <xref:System.Collections.Generic.Queue%601.Dequeue%2A> method is used to dequeue it.  
  
 The <xref:System.Collections.Generic.Queue%601.ToArray%2A> method is used to create an array and copy the queue elements to it, then the array is passed to the <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructor that takes <xref:System.Collections.Generic.IEnumerable%601>, creating a copy of the queue. The elements of the copy are displayed.  
  
 An array twice the size of the queue is created, and the <xref:System.Collections.Generic.Queue%601.CopyTo%2A> method is used to copy the array elements beginning at the middle of the array. The <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructor is used again to create a second copy of the queue containing three null elements at the beginning.  
  
 The <xref:System.Collections.Generic.Queue%601.Contains%2A> method is used to show that the string "four" is in the first copy of the queue, after which the <xref:System.Collections.Generic.Queue%601.Clear%2A> method clears the copy and the <xref:System.Collections.Generic.Queue%601.Count%2A> property shows that the queue is empty.  
  
 [!code-csharp[Generic.Queue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.CopyTo(`0[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> から要素がコピーされる 1 次元の <see cref="T:System.Collections.Generic.Queue`1" />。<see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。</param>
        <param name="arrayIndex">コピーの開始位置とする <c>array</c> のインデックス \(0 から始まる\)。</param>
        <summary>
          <see cref="T:System.Collections.Generic.Queue`1" /> の要素を既存の 1 次元の <see cref="T:System.Array" /> にコピーします。コピー操作は、配列内の指定したインデックスから始まります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素がコピーされた、 [CopyTo メソッド \(T\<xref:System.Array> を列挙子が反復処理する順序と同じ順序で、 [CopyTo メソッド \(T\<xref:System.Collections.Generic.Queue%601>です。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は [CopyTo メソッド \(T\<xref:System.Collections.Generic.Queue%601.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">ソース内の要素の数 <see cref="T:System.Collections.Generic.Queue`1" /> から使用可能な領域よりも大きい <paramref name="arrayIndex" /> 変換先の末尾に <paramref name="array" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Queue`1" /> に格納されている要素の数を取得します。</summary>
        <value>
          <see cref="T:System.Collections.Generic.Queue`1" /> に格納されている要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The capacity of a <xref:System.Collections.Generic.Queue%601> is the number of elements that the <xref:System.Collections.Generic.Queue%601> can store. <xref:System.Collections.Generic.Queue%601.Count%2A> is the number of elements that are actually in the <xref:System.Collections.Generic.Queue%601>.  
  
 The capacity is always greater than or equal to <xref:System.Collections.Generic.Queue%601.Count%2A>. If <xref:System.Collections.Generic.Queue%601.Count%2A> exceeds the capacity while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements.  
  
 Retrieving the value of this property is an O\(1\) operation.  
  
   
  
## 例  
 The following code example demonstrates several properties and methods of the <xref:System.Collections.Generic.Queue%601> generic class, including the <xref:System.Collections.Generic.Queue%601.Count%2A> property.  
  
 The code example creates a queue of strings with default capacity and uses the <xref:System.Collections.Generic.Queue%601.Enqueue%2A> method to queue five strings. The elements of the queue are enumerated, which does not change the state of the queue. The <xref:System.Collections.Generic.Queue%601.Dequeue%2A> method is used to dequeue the first string. The <xref:System.Collections.Generic.Queue%601.Peek%2A> method is used to look at the next item in the queue, and then the <xref:System.Collections.Generic.Queue%601.Dequeue%2A> method is used to dequeue it.  
  
 The <xref:System.Collections.Generic.Queue%601.ToArray%2A> method is used to create an array and copy the queue elements to it, then the array is passed to the <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructor that takes <xref:System.Collections.Generic.IEnumerable%601>, creating a copy of the queue. The elements of the copy are displayed.  
  
 An array twice the size of the queue is created, and the <xref:System.Collections.Generic.Queue%601.CopyTo%2A> method is used to copy the array elements beginning at the middle of the array. The <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructor is used again to create a second copy of the queue containing three null elements at the beginning.  
  
 The <xref:System.Collections.Generic.Queue%601.Contains%2A> method is used to show that the string "four" is in the first copy of the queue, after which the <xref:System.Collections.Generic.Queue%601.Clear%2A> method clears the copy and the <xref:System.Collections.Generic.Queue%601.Count%2A> property shows that the queue is empty.  
  
 [!code-csharp[Generic.Queue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dequeue">
      <MemberSignature Language="C#" Value="public T Dequeue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Dequeue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Dequeue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Queue`1" /> の先頭にあるオブジェクトを削除し、返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Queue`1" /> の先頭から削除されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is similar to the <xref:System.Collections.Generic.Queue%601.Peek%2A> method, but <xref:System.Collections.Generic.Queue%601.Peek%2A> does not modify the <xref:System.Collections.Generic.Queue%601>.  
  
 If type **parameterReference tag is not supported!!!!**  
 is a reference type, **languageKeyword tag is not supported!!!!**  
 can be added to the <xref:System.Collections.Generic.Queue%601> as a value.  
  
 This method is an O\(1\) operation.  
  
   
  
## 例  
 The following code example demonstrates several methods of the <xref:System.Collections.Generic.Queue%601> generic class, including the <xref:System.Collections.Generic.Queue%601.Dequeue%2A> method.  
  
 The code example creates a queue of strings with default capacity and uses the <xref:System.Collections.Generic.Queue%601.Enqueue%2A> method to queue five strings. The elements of the queue are enumerated, which does not change the state of the queue. The <xref:System.Collections.Generic.Queue%601.Dequeue%2A> method is used to dequeue the first string. The <xref:System.Collections.Generic.Queue%601.Peek%2A> method is used to look at the next item in the queue, and then the <xref:System.Collections.Generic.Queue%601.Dequeue%2A> method is used to dequeue it.  
  
 The <xref:System.Collections.Generic.Queue%601.ToArray%2A> method is used to create an array and copy the queue elements to it, then the array is passed to the <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructor that takes <xref:System.Collections.Generic.IEnumerable%601>, creating a copy of the queue. The elements of the copy are displayed.  
  
 An array twice the size of the queue is created, and the <xref:System.Collections.Generic.Queue%601.CopyTo%2A> method is used to copy the array elements beginning at the middle of the array. The <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructor is used again to create a second copy of the queue containing three null elements at the beginning.  
  
 The <xref:System.Collections.Generic.Queue%601.Contains%2A> method is used to show that the string "four" is in the first copy of the queue, after which the <xref:System.Collections.Generic.Queue%601.Clear%2A> method clears the copy and the <xref:System.Collections.Generic.Queue%601.Count%2A> property shows that the queue is empty.  
  
 [!code-csharp[Generic.Queue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Generic.Queue`1" /> が空です。</exception>
        <altmember cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Peek" />
      </Docs>
    </Member>
    <Member MemberName="Enqueue">
      <MemberSignature Language="C#" Value="public void Enqueue (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Enqueue(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.Queue`1" /> に追加するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>
          <see cref="T:System.Collections.Generic.Queue`1" /> の末尾にオブジェクトを追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If <xref:System.Collections.Generic.Queue%601.Count%2A> already equals the capacity, the capacity of the <xref:System.Collections.Generic.Queue%601> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.  
  
 If <xref:System.Collections.Generic.Queue%601.Count%2A> is less than the capacity of the internal array, this method is an O\(1\) operation. If the internal array needs to be reallocated to accommodate the new element, this method becomes an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is <xref:System.Collections.Generic.Queue%601.Count%2A>.  
  
   
  
## 例  
 The following code example demonstrates several methods of the <xref:System.Collections.Generic.Queue%601> generic class, including the <xref:System.Collections.Generic.Queue%601.Enqueue%2A> method.  
  
 The code example creates a queue of strings with default capacity and uses the <xref:System.Collections.Generic.Queue%601.Enqueue%2A> method to queue five strings. The elements of the queue are enumerated, which does not change the state of the queue. The <xref:System.Collections.Generic.Queue%601.Dequeue%2A> method is used to dequeue the first string. The <xref:System.Collections.Generic.Queue%601.Peek%2A> method is used to look at the next item in the queue, and then the <xref:System.Collections.Generic.Queue%601.Dequeue%2A> method is used to dequeue it.  
  
 The <xref:System.Collections.Generic.Queue%601.ToArray%2A> method is used to create an array and copy the queue elements to it, then the array is passed to the <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructor that takes <xref:System.Collections.Generic.IEnumerable%601>, creating a copy of the queue. The elements of the copy are displayed.  
  
 An array twice the size of the queue is created, and the <xref:System.Collections.Generic.Queue%601.CopyTo%2A> method is used to copy the array elements beginning at the middle of the array. The <xref:System.Collections.Generic.Queue%601.%23ctor%2A> constructor is used again to create a second copy of the queue containing three null elements at the beginning.  
  
 The <xref:System.Collections.Generic.Queue%601.Contains%2A> method is used to show that the string "four" is in the first copy of the queue, after which the <xref:System.Collections.Generic.Queue%601.Clear%2A> method clears the copy and the <xref:System.Collections.Generic.Queue%601.Count%2A> property shows that the queue is empty.  
  
 [!code-csharp[Generic.Queue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.Dequeue" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Peek" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Queue&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Queue`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Queue&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Queue`1" /> を反復処理する列挙子を返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Queue`1.Enumerator" /> の <see cref="T:System.Collections.Generic.Queue`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 この位置では、<xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> が未定義です。 そのため、<xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> は、<xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> は、<xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> は定義されていません。<xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> を、再度、コレクションの最初の要素に設定することはできません。列挙子の新しいインスタンスを作成する必要があります。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例を示しますが、 <xref:System.Collections.Generic.Queue%601> ジェネリック クラスは列挙可能です。`foreach` ステートメント \(`For Each` Visual basic で `for each` C\+\+ で\)、キューを列挙するために使用します。  
  
 このコード例は、既定の容量を持つ文字列のキューを作成し、使用して、 <xref:System.Collections.Generic.Queue%601.Enqueue%2A> 5 つの文字列のキューにします。 キューの要素が表示され、キューの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Queue%601.Dequeue%2A> メソッドを使用して、最初の文字列をキューから削除します。<xref:System.Collections.Generic.Queue%601.Peek%2A> メソッドを使用して、キューでは、次の項目を確認し、 <xref:System.Collections.Generic.Queue%601.Dequeue%2A> がデキューするメソッドを使用します。  
  
 <xref:System.Collections.Generic.Queue%601.ToArray%2A> 配列を作成し、キューの要素をコピーするメソッドを使用しに渡した配列、 <xref:System.Collections.Generic.Queue%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、キューのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、キューのサイズが作成、および <xref:System.Collections.Generic.Queue%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Queue%601.%23ctor%2A> コンス トラクターは先頭に次の 3 つの null 要素を含むキューの 2 つ目のコピーを作成するにはもう一度使用されます。  
  
 <xref:System.Collections.Generic.Queue%601.Contains%2A> メソッドを使用して、表示するまで、キューの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Queue%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Queue%601.Count%2A> キューが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Queue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Queue`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Peek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Queue`1" /> の先頭にあるオブジェクトを削除せずに返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Queue`1" /> の先頭にあるオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは <xref:System.Collections.Generic.Queue%601.Dequeue%2A> メソッドに類似していますが、<xref:System.Collections.Generic.Queue%601.Peek%2A> は <xref:System.Collections.Generic.Queue%601> を変更しません。  
  
 場合型 `T` 、参照型では、 `null` に追加できる、 <xref:System.Collections.Generic.Queue%601> 値として。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例をいくつかの方法を示しています、 <xref:System.Collections.Generic.Queue%601> ジェネリック クラスを含む、 <xref:System.Collections.Generic.Queue%601.Peek%2A> メソッドです。  
  
 このコード例は、既定の容量を持つ文字列のキューを作成し、使用して、 <xref:System.Collections.Generic.Queue%601.Enqueue%2A> 5 つの文字列のキューにします。 キューの要素が表示され、キューの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Queue%601.Dequeue%2A> メソッドを使用して、最初の文字列をキューから削除します。<xref:System.Collections.Generic.Queue%601.Peek%2A> メソッドを使用して、キューでは、次の項目を確認し、 <xref:System.Collections.Generic.Queue%601.Dequeue%2A> がデキューするメソッドを使用します。  
  
 <xref:System.Collections.Generic.Queue%601.ToArray%2A> 配列を作成し、キューの要素をコピーするメソッドを使用しに渡した配列、 <xref:System.Collections.Generic.Queue%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、キューのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、キューのサイズが作成、および <xref:System.Collections.Generic.Queue%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Queue%601.%23ctor%2A> コンス トラクターは先頭に次の 3 つの null 要素を含むキューの 2 つ目のコピーを作成するにはもう一度使用されます。  
  
 <xref:System.Collections.Generic.Queue%601.Contains%2A> メソッドを使用して、表示するまで、キューの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Queue%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Queue%601.Count%2A> キューが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Queue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Generic.Queue`1" /> が空です。</exception>
        <altmember cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Dequeue" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションを反復処理する列挙子を返します。</summary>
        <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.Generic.IEnumerator`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 この位置では、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> は定義されていません。<xref:System.Collections.Generic.IEnumerator%601.Current%2A> を、再度、コレクションの最初の要素に設定することはできません。列挙子の新しいインスタンスを作成する必要があります。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.GetEnumerator" />
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Collections.ICollection" /> から要素がコピーされる 1 次元の <see cref="T:System.Array" />。<see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。</param>
        <param name="index">コピーの開始位置とする <c>array</c> のインデックス \(0 から始まる\)。</param>
        <summary>
          <see cref="T:System.Collections.ICollection" /> の要素を <see cref="T:System.Array" /> にコピーします。<see cref="T:System.Array" /> の特定のインデックスからコピーが開始されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  場合、ソースの種類 <xref:System.Collections.ICollection> 変換先の型に自動的にキャストすることはできません `array`, の非ジェネリックの実装 <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=fullName> スロー <xref:System.InvalidCastException>, 汎用実装がスローされ、 <xref:System.ArgumentException>です。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.Queue%601.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  
  
 または  
  
 <paramref name="array" /> には、0 から始まるインデックス番号がありません。  
  
 または  
  
 ソース内の要素の数 <see cref="T:System.Collections.ICollection" /> から使用可能な領域よりも大きい <paramref name="index" /> 変換先の末尾に <paramref name="array" />します。  
  
 または  
  
 ソースの種類 <see cref="T:System.Collections.ICollection" /> 先の型に自動的にキャストできない <paramref name="array" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> へのアクセスが同期されている \(スレッド セーフである\) かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> へのアクセスが同期されている \(スレッド セーフである\) 場合は <see cref="T:System.Collections.ICollection" />。それ以外の場合は <see langword="false" />。<see cref="T:System.Collections.Generic.Queue`1" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> は、<xref:System.Collections.ICollection> へのアクセスを同期するために使用できるオブジェクトを返します。 同期は、すべてのスレッドがコレクションにアクセスする前にこのオブジェクトをロックする場合のみ有効です。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> へのアクセスを同期するために使用できるオブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> へのアクセスを同期するために使用できるオブジェクト。<see cref="T:System.Collections.Generic.Queue`1" /> の既定の実装では、このプロパティは常に現在のインスタンスを返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装のコレクションの<xref:System.Collections.Generic?displayProperty=fullName>が同期されていません。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> は、<xref:System.Collections.ICollection> へのアクセスを同期するために使用できるオブジェクトを返します。 同期は、すべてのスレッドがコレクションにアクセスする前にこのオブジェクトをロックする場合のみ有効です。 次のコードの使用を示しています、 <xref:System.Collections.ICollection.SyncRoot%2A> c\#、C\+\+、および Visual Basic のプロパティです。  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As IColletion = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションを反復処理する列挙子を返します。</summary>
        <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。<xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、<xref:System.Collections.IEnumerator.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.IEnumerator.Current%2A> は定義されていません。<xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.ToArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Queue`1" /> の要素を新しい配列にコピーします。</summary>
        <returns>コピーした要素を格納する新しい配列、 <see cref="T:System.Collections.Generic.Queue`1" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.Queue%601> は変更されません。 新しい配列内の要素の順序の先頭から要素の順序と同じでは、 <xref:System.Collections.Generic.Queue%601> の終わりにします。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.Queue%601.Count%2A>です。  
  
   
  
## 例  
 次のコード例をいくつかの方法を示しています、 <xref:System.Collections.Generic.Queue%601> ジェネリック クラスを含む、 <xref:System.Collections.Generic.Queue%601.ToArray%2A> メソッドです。  
  
 このコード例は、既定の容量を持つ文字列のキューを作成し、使用して、 <xref:System.Collections.Generic.Queue%601.Enqueue%2A> 5 つの文字列のキューにします。 キューの要素が表示され、キューの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Queue%601.Dequeue%2A> メソッドを使用して、最初の文字列をキューから削除します。<xref:System.Collections.Generic.Queue%601.Peek%2A> メソッドを使用して、キューでは、次の項目を確認し、 <xref:System.Collections.Generic.Queue%601.Dequeue%2A> がデキューするメソッドを使用します。  
  
 <xref:System.Collections.Generic.Queue%601.ToArray%2A> 配列を作成し、キューの要素をコピーするメソッドを使用しに渡した配列、 <xref:System.Collections.Generic.Queue%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、キューのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、キューのサイズが作成、および <xref:System.Collections.Generic.Queue%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Queue%601.%23ctor%2A> コンス トラクターは先頭に次の 3 つの null 要素を含むキューの 2 つ目のコピーを作成するにはもう一度使用されます。  
  
 <xref:System.Collections.Generic.Queue%601.Contains%2A> メソッドを使用して、表示するまで、キューの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Queue%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Queue%601.Count%2A> キューが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Queue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TrimExcess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Queue`1" /> 内にある実際の要素数が現在の容量の 90% 未満の場合は、容量をその数に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コレクションのメモリ オーバーヘッドを最小コレクションに新しい要素が追加されない場合に使用できます。 再割り当てすることと、大規模なコピーのコスト <xref:System.Collections.Generic.Queue%601> 多く、ただしは、されるため、 <xref:System.Collections.Generic.Queue%601.TrimExcess%2A> メソッドは何も一覧にある容量の 90% を超える場合。 これにより、比較的小さな向上のための大規模な再割り当てコストを発生させることがなくなります。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.Queue%601.Count%2A>です。  
  
 リセットする、 <xref:System.Collections.Generic.Queue%601> の初期状態を呼び出し、 <xref:System.Collections.Generic.Queue%601.Clear%2A> メソッドを呼び出す前に <xref:System.Collections.Generic.Queue%601.TrimExcess%2A> メソッドです。 空のトリミング <xref:System.Collections.Generic.Queue%601> のキャパシティを設定、 <xref:System.Collections.Generic.Queue%601> を既定の容量。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Queue`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="public bool TryDequeue (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryDequeue(!T result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TryDequeue(`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek(!T result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TryPeek(`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Queue`1" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>