<Type Name="SortedList&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.SortedList&lt;TKey,TValue&gt;">
  <TypeSignature Language="C#" Value="public class SortedList&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.SortedList`2" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">コレクション内のキーの型。</typeparam>
    <typeparam name="TValue">コレクション内の値の型。</typeparam>
    <summary>関連付けられた <see cref="T:System.Collections.Generic.IComparer`1" /> 実装に基づいて、キーにより並べ替えられた、キーと値のペアのコレクションを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.SortedList%602> ジェネリック クラスは O\(log `n`\) の取得、キー\/値ペアの配列、ディクショナリの要素の数です。 似ていますが、この、 <xref:System.Collections.Generic.SortedDictionary%602> ジェネリック クラスです。 2 つのクラスには同様のオブジェクト モデルでは、あり両方 O\(log `n`\) 取得します。 メモリの使用し、挿入、削除の速度は 2 つのクラスが異なります。  
  
-   <xref:System.Collections.Generic.SortedList%602> 少ないメモリ <xref:System.Collections.Generic.SortedDictionary%602>します。  
  
-   <xref:System.Collections.Generic.SortedDictionary%602> O\(log `n`\) O ではなく、並べ替えられていないデータの高速な挿入と削除操作が \(`n`\) の <xref:System.Collections.Generic.SortedList%602>です。  
  
-   リストが並べ替えられたデータは、一度にすべて設定されている場合 <xref:System.Collections.Generic.SortedList%602> よりも高速 <xref:System.Collections.Generic.SortedDictionary%602>します。  
  
 別の相違点の間、 <xref:System.Collections.Generic.SortedDictionary%602> と <xref:System.Collections.Generic.SortedList%602> クラスは <xref:System.Collections.Generic.SortedList%602> キーと値によって返されるコレクションの間での効率的なインデックス付きの取得をサポートしている、 <xref:System.Collections.Generic.SortedList%602.Keys%2A> と <xref:System.Collections.Generic.SortedList%602.Values%2A> プロパティです。 リストはキーと値の内部配列の単なるラッパーであるため、プロパティにアクセスすると、時に、リストを再生成する必要はありません。 次のコードは、使用、 <xref:System.Collections.Generic.SortedList%602.Values%2A> 文字列の並べ替えられたリストから値のインデックス付きの取得のためのプロパティ。  
  
 [!code-cpp[Generic.SortedList\#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList\#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 <xref:System.Collections.Generic.SortedList%602> キーにより並べ替えのキー\/値ペアの配列として実装されます。  各要素を取得することができます、 <xref:System.Collections.Generic.KeyValuePair%602> オブジェクトです。  
  
 内のキーとして使用されている限りに主要なオブジェクトが変更可能にする必要があります、 <xref:System.Collections.Generic.SortedList%602>です。 内のすべてのキー、 <xref:System.Collections.Generic.SortedList%602> で一意である必要があります。 キーには `null`, 、値ことができますが場合、リスト内の値の型 `TValue`, 、参照型であります。  
  
 <xref:System.Collections.Generic.SortedList%602> 並べ替えと比較を実行する比較子の実装が必要です。  既定の比較子 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> キーを入力するかどうかを確認 `TKey` 実装 <xref:System.IComparable%601?displayProperty=fullName> は使用可能な場合に、その実装を使用するとします。  ない場合は、 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> キーを入力するかどうかを確認 `TKey` 実装 <xref:System.IComparable?displayProperty=fullName>します。  キーの入力と `TKey` インターフェイスを実装しないか、指定することができます、 <xref:System.Collections.Generic.IComparer%601?displayProperty=fullName> を受け入れるコンス トラクター オーバー ロードの実装、 `comparer` パラメーター。  
  
 容量、 <xref:System.Collections.Generic.SortedList%602> 要素の数が、 <xref:System.Collections.Generic.SortedList%602> を保持できます。 要素が追加されると、 <xref:System.Collections.Generic.SortedList%602>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> を設定したり、 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> プロパティに明示的にします。 メモリを再割り当ての容量を削減し、内のすべての要素をコピー、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 非常に大きな <xref:System.Collections.Generic.SortedList%602> オブジェクトを設定して、64 ビット システム上の 20億要素に最大の容量を増やすことができます、 `enabled` する構成要素の属性 `true` 、実行時の環境にします。  
  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual Basic で\)、コレクション内の要素の型のオブジェクトを返します。 要素から、 <xref:System.Collections.Generic.SortedList%602> キー\/値ペアを要素型は、キーの型または値の型ではありません。 代わりに、要素型は <xref:System.Collections.Generic.KeyValuePair%602>です。 例:  
  
 [!code-cpp[Generic.SortedList\#12](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#12)]
 [!code-csharp[Generic.SortedList\#12](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#12)]
 [!code-vb[Generic.SortedList\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#12)]  
  
 `foreach` ステートメントは、コレクションに書き込まないことから読み取り、列挙子のラッパーです。  
  
   
  
## 例  
 次のコード例は、空を作成 <xref:System.Collections.Generic.SortedList%602> 文字列キーと使用された文字列、 <xref:System.Collections.Generic.SortedList%602.Add%2A> をいくつかの要素を追加するメソッドです。 例を <xref:System.Collections.Generic.SortedList%602.Add%2A> メソッドがスローされます、 <xref:System.ArgumentException> に重複するキーを追加しようとしています。  
  
 例では、 <xref:System.Collections.Generic.SortedList%602.Item%2A> プロパティ \(c\# のインデクサー\) を示す値を取得する、 <xref:System.Collections.Generic.KeyNotFoundException> を示す値をキーに関連付けられていることを置き換えることが要求されたキーが存在しない場合にスローされます。  
  
 例では、使用する方法を示しています、 <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> メソッドが値を取得する場合は、プログラムは多くの場合、並べ替えられたリストに含まれていないキーの値を試行する必要があり、使用する方法を示しますより効率的な方法として、 <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> メソッドを呼び出す前にキーが存在するかどうかをテストする、 <xref:System.Collections.Generic.SortedList%602.Add%2A> メソッドです。  
  
 この例は、キーと並べ替えられたリスト内の値を列挙する方法と、キーを列挙する方法を示していて、単独で使用して値を <xref:System.Collections.Generic.SortedList%602.Keys%2A> プロパティおよび <xref:System.Collections.Generic.SortedList%602.Values%2A> プロパティです。  
  
 最後に、例、 <xref:System.Collections.Generic.SortedList%602.Remove%2A> メソッドです。  
  
 [!code-cpp[Generic.SortedList\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#1)]
 [!code-csharp[Generic.SortedList\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#1)]
 [!code-vb[Generic.SortedList\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 \(<see langword="Shared" /> Visual Basic では\) この型のメンバーは、スレッド セーフであります。 インスタンス メンバーの場合は、スレッド セーフであるとは限りません。  
  
 A <see cref="T:System.Collections.Generic.SortedList`2" /> コレクションが変更されない限り、複数のリーダーを同時にサポートできます。  それでも、コレクションの列挙は、本質的には、スレッド セーフなプロシージャでは。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。</threadsafe>
    <altmember cref="T:System.Collections.Generic.IDictionary`2" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
    <altmember cref="T:System.Collections.Generic.SortedDictionary`2" />
    <altmember cref="T:System.Collections.Generic.KeyValuePair`2" />
    <altmember cref="T:System.Collections.Generic.IComparer`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>空で、既定の初期量を備え、既定の <see cref="T:System.Collections.Generic.SortedList`2" /> を使用する、<see cref="T:System.Collections.Generic.IComparer`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内のすべてのキー、 <xref:System.Collections.Generic.SortedList%602> 既定の比較子に従って一意である必要があります。  
  
 このコンス トラクターに既定値の初期容量を使用、 <xref:System.Collections.Generic.SortedList%602>です。 初期の容量を設定するには、使用、 <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%29> コンス トラクターです。 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションの最終的なサイズを推定できる場合、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 このコンス トラクターの既定の比較子を使用して `TKey`します。 比較演算子を指定するには、使用、 <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IComparer%7B%600%7D%29> コンス トラクターです。 既定の比較子 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> キーを入力するかどうかを確認 `TKey` 実装 <xref:System.IComparable%601?displayProperty=fullName> は使用可能な場合に、その実装を使用するとします。  ない場合は、 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> キーを入力するかどうかを確認 `TKey` 実装 <xref:System.IComparable?displayProperty=fullName>します。  キーの入力と `TKey` インターフェイスを実装しないか、指定することができます、 <xref:System.Collections.Generic.IComparer%601?displayProperty=fullName> を受け入れるコンス トラクター オーバー ロードの実装、 `comparer` パラメーター。  
  
 このコンス トラクターは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例は、空を作成 <xref:System.Collections.Generic.SortedList%602> 文字列キーと使用された文字列、 <xref:System.Collections.Generic.SortedList%602.Add%2A> をいくつかの要素を追加するメソッドです。 例を <xref:System.Collections.Generic.SortedList%602.Add%2A> メソッドがスローされます、 <xref:System.ArgumentException> に重複するキーを追加しようとしています。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.SortedList%602> クラスです。  
  
 [!code-cpp[Generic.SortedList\#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#2)]
 [!code-csharp[Generic.SortedList\#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#2)]
 [!code-vb[Generic.SortedList\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  
  
 または  
  
 キーの型に既定の <see langword="null" /> を使用する場合は <see cref="T:System.Collections.Generic.Comparer`1" />。</param>
        <summary>空で、既定の初期量を備え、指定した <see cref="T:System.Collections.Generic.SortedList`2" /> を使用する、<see cref="T:System.Collections.Generic.IComparer`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内のすべてのキー、 <xref:System.Collections.Generic.SortedList%602> 指定した比較子に従って一意である必要があります。  
  
 このコンス トラクターに既定値の初期容量を使用、 <xref:System.Collections.Generic.SortedList%602>です。 初期の容量を設定するには、使用、 <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> コンス トラクターです。 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションの最終的なサイズを推定できる場合、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 このコンス トラクターは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、現在のカルチャの大文字と小文字の比較子を並べ替えられたリストを作成します。 例では、小文字のキーを使用して一部使用と、大文字のキーを使用して一部を使用する、4 つの要素を追加します。 次に、キーの場合も、唯一の既存のキーから相違点を持つ要素を追加する試行は、結果として得られる例外をキャッチし、エラー メッセージが表示されます。 最後に、この例では、小文字を区別しない並べ替え順序において、要素が表示されます。  
  
 [!code-csharp[Generic.SortedList.ctor\_IComp\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor\_IComp\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">新しい <see cref="T:System.Collections.Generic.IDictionary`2" /> に要素がコピーされた <see cref="T:System.Collections.Generic.SortedList`2" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.SortedList`2" /> からコピーした要素を格納し、コピーした要素の数を格納できるだけの容量を備え、既定の <see cref="T:System.Collections.Generic.IDictionary`2" /> を使用する、<see cref="T:System.Collections.Generic.IComparer`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内のすべてのキー、 <xref:System.Collections.Generic.SortedList%602> 既定に従って一意でなければなりません比較子。 同様に、ソース内のすべてのキー `dictionary` 既定の比較子に従って一意もする必要があります。  
  
 新しい容量 <xref:System.Collections.Generic.SortedList%602> 内の要素の数に設定されている `dictionary`, であるため、サイズ変更は行われませんリストが作成されている間、します。  
  
 このコンス トラクターの既定の比較子を使用して `TKey`します。 比較演算子を指定するには、使用、 <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> コンス トラクターです。 既定の比較子 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> キーを入力するかどうかを確認 `TKey` 実装 <xref:System.IComparable%601?displayProperty=fullName> は使用可能な場合に、その実装を使用するとします。  ない場合は、 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> キーを入力するかどうかを確認 `TKey` 実装 <xref:System.IComparable?displayProperty=fullName>します。  キーの入力と `TKey` インターフェイスを実装しないか、指定することができます、 <xref:System.Collections.Generic.IComparer%601?displayProperty=fullName> を受け入れるコンス トラクター オーバー ロードの実装、 `comparer` パラメーター。  
  
 場合内のデータ `dictionary` が並べ替えられて、このコンス トラクターでは、O \(`n`\) 操作、ここで `n` 内の要素の数は、 `dictionary`です。 それ以外の場合これは、O \(`n`\*`n`\) 操作です。  
  
   
  
## 例  
 次のコード例は、使用する方法を示しています。 <xref:System.Collections.Generic.SortedList%602> 内の情報の並べ替えられたコピーを作成する、 <xref:System.Collections.Generic.Dictionary%602>, 、を渡すことによって、 <xref:System.Collections.Generic.Dictionary%602> に、 <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%29> コンス トラクターです。  
  
 [!code-csharp[Generic.SortedList.ctor\_IDic\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IDic/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor\_IDic\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IDic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> 1 つまたは複数の重複するキーが含まれています。</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Generic.SortedList`2" /> が格納できる要素数の初期値。</param>
        <summary>空で、指定した初期量を備え、既定の <see cref="T:System.Collections.Generic.SortedList`2" /> を使用する、<see cref="T:System.Collections.Generic.IComparer`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内のすべてのキー、 <xref:System.Collections.Generic.SortedList%602> 既定の比較子に従って一意である必要があります。  
  
 容量、 <xref:System.Collections.Generic.SortedList%602> は要素の数を <xref:System.Collections.Generic.SortedList%602> のサイズを変更する前に保持できます。 要素が追加されると、 <xref:System.Collections.Generic.SortedList%602>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> を設定したり、 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> プロパティに明示的にします。 メモリを再割り当ての容量を削減し、内のすべての要素をコピー、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 このコンス トラクターの既定の比較子を使用して `TKey`します。 比較演算子を指定するには、使用、 <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> コンス トラクターです。 既定の比較子 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> キーを入力するかどうかを確認 `TKey` 実装 <xref:System.IComparable%601?displayProperty=fullName> は使用可能な場合に、その実装を使用するとします。  ない場合は、 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> キーを入力するかどうかを確認 `TKey` 実装 <xref:System.IComparable?displayProperty=fullName>します。  キーの入力と `TKey` インターフェイスを実装しないか、指定することができます、 <xref:System.Collections.Generic.IComparer%601?displayProperty=fullName> を受け入れるコンス トラクター オーバー ロードの実装、 `comparer` パラメーター。  
  
 このコンス トラクターは、O \(`n`\) 操作の場合、 `n` は `capacity`です。  
  
   
  
## 例  
 次のコード例では、4 の初期の容量を持つ、並べ替えられたリストを作成し、4 つのエントリを設定します。  
  
 [!code-csharp[Generic.SortedList.ctor\_Int32\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_Int32/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor\_Int32\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_Int32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">新しい <see cref="T:System.Collections.Generic.IDictionary`2" /> に要素がコピーされた <see cref="T:System.Collections.Generic.SortedList`2" />。</param>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  
  
 または  
  
 キーの型に既定の <see langword="null" /> を使用する場合は <see cref="T:System.Collections.Generic.Comparer`1" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.SortedList`2" /> からコピーした要素を格納し、コピーした要素の数を格納できるだけの容量を備え、指定した <see cref="T:System.Collections.Generic.IDictionary`2" /> を使用する、<see cref="T:System.Collections.Generic.IComparer`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内のすべてのキー、 <xref:System.Collections.Generic.SortedList%602> 、指定に従って一意である必要があります比較子。 同様に、ソース内のすべてのキー `dictionary` 指定した比較子に従って一意もする必要があります。  
  
 新しい容量 <xref:System.Collections.Generic.SortedList%602> 内の要素の数に設定されている `dictionary`, であるため、サイズ変更は行われませんリストが作成されている間、します。  
  
 場合内のデータ `dictionary` が並べ替えられて、このコンス トラクターでは、O \(`n`\) 操作、ここで `n` 内の要素の数は、 `dictionary`です。 それ以外の場合これは、O \(`n`\*`n`\) 操作です。  
  
   
  
## 例  
 次のコード例は、使用する方法を示しています。 <xref:System.Collections.Generic.SortedList%602> 大文字小文字の区別を作成する、大文字小文字の区別の情報のコピーを並べ替える <xref:System.Collections.Generic.Dictionary%602>, 、を渡すことによって、 <xref:System.Collections.Generic.Dictionary%602> に、 <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> コンス トラクターです。 この例では大文字と小文字の比較演算子は、現在のカルチャです。  
  
 [!code-csharp[Generic.SortedList.ctor\_IDicIComp\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IDicIComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor\_IDicIComp\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IDicIComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> 1 つまたは複数の重複するキーが含まれています。</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int capacity, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Generic.SortedList`2" /> が格納できる要素数の初期値。</param>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.Generic.IComparer`1" /> の実装。  
  
 または  
  
 キーの型に既定の <see langword="null" /> を使用する場合は <see cref="T:System.Collections.Generic.Comparer`1" />。</param>
        <summary>空で、指定した初期量を備え、指定した <see cref="T:System.Collections.Generic.SortedList`2" /> を使用する、<see cref="T:System.Collections.Generic.IComparer`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内のすべてのキー、 <xref:System.Collections.Generic.SortedList%602> 指定した比較子に従って一意である必要があります。  
  
 容量、 <xref:System.Collections.Generic.SortedList%602> は要素の数を <xref:System.Collections.Generic.SortedList%602> のサイズを変更する前に保持できます。 要素が追加されると、 <xref:System.Collections.Generic.SortedList%602>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> を設定したり、 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> プロパティに明示的にします。 メモリを再割り当ての容量を削減し、内のすべての要素をコピー、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 このコンス トラクターは、O \(`n`\) 操作の場合、 `n` は `capacity`です。  
  
   
  
## 例  
 次のコード例では、5 と小文字を区別しない比較子の現在のカルチャの初期の容量を持つ、並べ替えられたリストを作成します。 例では、小文字のキーを使用して一部使用と、大文字のキーを使用して一部を使用する、4 つの要素を追加します。 次に、キーの場合も、唯一の既存のキーから相違点を持つ要素を追加する試行は、結果として得られる例外をキャッチし、エラー メッセージが表示されます。 最後に、この例では、小文字を区別しない並べ替え順序において、要素が表示されます。  
  
 [!code-csharp[Generic.SortedList.ctor\_Int32IComp\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_Int32IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor\_Int32IComp\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_Int32IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">追加する要素のキー。</param>
        <param name="value">追加する要素の値。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>指定したキーおよび値を持つ要素を <see cref="T:System.Collections.Generic.SortedList`2" /> に追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーには `null`, 、ですが場合の値が並べ替えられたリスト内の値の型 `TValue`, 、参照型であります。  
  
 使用することも、 <xref:System.Collections.Generic.SortedList%602.Item%2A> にキーの値を設定して新しい要素を追加するプロパティが存在しない、 <xref:System.Collections.Generic.SortedList%602>。 たとえば、 `myCollection["myNonexistentKey"] = myValue`です。 ただしで指定したキーが既に存在する場合、 <xref:System.Collections.Generic.SortedList%602>, で、設定、 <xref:System.Collections.Generic.SortedList%602.Item%2A> プロパティには、古い値が上書きされます。 これに対し、 <xref:System.Collections.Generic.SortedList%602.Add%2A> メソッドでは、既存の要素は変更しません。  
  
 場合 <xref:System.Collections.Generic.SortedList%602.Count%2A> と既に同じ <xref:System.Collections.Generic.SortedList%602.Capacity%2A>, の容量、 <xref:System.Collections.Generic.SortedList%602> が増加すると、内部の配列を自動的に再割り当てによって、新しい要素が追加される前に、新しい配列に既存の要素がコピーされたとします。  
  
 このメソッドは O \(`n`\) 並べ替えられていないデータの操作、 `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。 新しい要素がリストの末尾に追加された場合は、O\(log `n`\) 操作になります。 カーソルでは、サイズ変更が発生する場合、操作は O \(`n`\)。  
  
   
  
## 例  
 次のコード例は、空を作成 <xref:System.Collections.Generic.SortedList%602> 文字列キーと使用された文字列、 <xref:System.Collections.Generic.SortedList%602.Add%2A> をいくつかの要素を追加するメソッドです。 例を <xref:System.Collections.Generic.SortedList%602.Add%2A> メソッドがスローされます、 <xref:System.ArgumentException> に重複するキーを追加しようとしています。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.SortedList%602> クラスです。  
  
 [!code-cpp[Generic.SortedList\#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#2)]
 [!code-csharp[Generic.SortedList\#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#2)]
 [!code-vb[Generic.SortedList\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">同じキーを持つ要素が、<see cref="T:System.Collections.Generic.SortedList`2" /> に既に存在します。</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.SortedList`2" /> に格納できる要素の数を取得または設定します。</summary>
        <value>
          <see cref="T:System.Collections.Generic.SortedList`2" /> に格納できる要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> 要素の数を <xref:System.Collections.Generic.SortedList%602> を格納できます。<xref:System.Collections.Generic.SortedList%602.Count%2A> 実際に含まれる要素の数が、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> 以上の値には、常に <xref:System.Collections.Generic.SortedList%602.Count%2A>します。 場合 <xref:System.Collections.Generic.SortedList%602.Count%2A> を超える <xref:System.Collections.Generic.SortedList%602.Capacity%2A> 変更前の要素をコピーし、新しい要素を追加する前に、内部配列を自動的に再割り当てして要素を追加するときに容量が増加します。  
  
 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> を設定したり、 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> プロパティに明示的にします。 ときに、値の <xref:System.Collections.Generic.SortedList%602.Capacity%2A> を設定すると、明示的に指定した容量に合わせて、内部配列が再割り当てもします。  
  
 このプロパティの値を取得する場合は、o \(1\) 操作です。O は、プロパティを設定 \(`n`\) 操作、 `n` 新しい容量します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Collections.Generic.SortedList`2.Capacity" /> ある値に設定されているより小さい <see cref="P:System.Collections.Generic.SortedList`2.Count" />します。</exception>
        <exception cref="T:System.OutOfMemoryException">システムで使用可能なメモリが不足しています。</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Count" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.TrimExcess" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.SortedList`2" /> からすべての要素を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.SortedList%602.Count%2A> is set to zero, and references to other objects from elements of the collection are also released.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> remains unchanged. To reset the capacity of the <xref:System.Collections.Generic.SortedList%602>, call <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> or set the <xref:System.Collections.Generic.SortedList%602.Capacity%2A> property directly. Trimming an empty <xref:System.Collections.Generic.SortedList%602> sets the capacity of the <xref:System.Collections.Generic.SortedList%602> to the default capacity.  
  
 This method is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.TrimExcess" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>並べ替えられたリストの <see cref="T:System.Collections.Generic.IComparer`1" /> を取得します。</summary>
        <value>現在の <see cref="T:System.IComparable`1" /> の <see cref="T:System.Collections.Generic.SortedList`2" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Collections.Generic.SortedList`2" /> 内で検索されるキー。</param>
        <summary>
          <see cref="T:System.Collections.Generic.SortedList`2" /> に特定のキーが格納されているかどうかを判断します。</summary>
        <returns>指定したキーを持つ要素が <see langword="true" /> に格納されている場合は <see cref="T:System.Collections.Generic.SortedList`2" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは O\(log `n`\) 操作では、ここで `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> メソッドを呼び出す前にキーが存在するかどうかをテストする、 <xref:System.Collections.Generic.SortedList%602.Add%2A> メソッドです。 使用する方法も示します、 <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> プログラムは、並べ替えられたリストに含まれていないキーを頻繁に試行時に値を取得する効率的であるメソッドを取得する値にします。 さらに、その説明をテストする最も非効率的な方法では、 <xref:System.Collections.Generic.SortedList%602.Item%2A> プロパティ \(c\# のインデクサー\)。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.SortedList%602> クラスです。  
  
 [!code-cpp[Generic.SortedList#6](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#6)]
 [!code-csharp[Generic.SortedList#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#6)]
 [!code-vb[Generic.SortedList#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#6)]  
[!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
[!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
[!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Collections.Generic.SortedList`2" /> 内で検索される値。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>
          <see cref="T:System.Collections.Generic.SortedList`2" /> に特定の値が格納されているかどうかを判断します。</summary>
        <returns>指定した値を持つ要素が <see langword="true" /> に格納されている場合は <see cref="T:System.Collections.Generic.SortedList`2" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method determines equality using the default comparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> for the value type **parameterReference tag is not supported!!!!**  
.  <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether the value type **parameterReference tag is not supported!!!!**  
 implements <xref:System.IComparable%601?displayProperty=fullName> and uses that implementation, if available.  If not, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether the value type **parameterReference tag is not supported!!!!**  
 implements <xref:System.IComparable?displayProperty=fullName>.  If the value type **parameterReference tag is not supported!!!!**  
 does not implement either interface, this method uses <xref:System.Object.Equals%2A?displayProperty=fullName>.  
  
 This method performs a linear search; therefore, the average execution time is proportional to <xref:System.Collections.Generic.SortedList%602.Count%2A>. That is, this method is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.SortedList`2" /> に格納されているキー\/値ペアの数を取得します。</summary>
        <value>
          <see cref="T:System.Collections.Generic.SortedList`2" /> に格納されているキー\/値ペアの数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> is the number of elements that the <xref:System.Collections.Generic.SortedList%602> can store. <xref:System.Collections.Generic.SortedList%602.Count%2A> is the number of elements that are actually in the <xref:System.Collections.Generic.SortedList%602>.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> is always greater than or equal to <xref:System.Collections.Generic.SortedList%602.Count%2A>. If <xref:System.Collections.Generic.SortedList%602.Count%2A> exceeds <xref:System.Collections.Generic.SortedList%602.Capacity%2A> while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements.  
  
 Retrieving the value of this property is an O\(1\) operation.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.SortedList`2" /> を反復処理する列挙子を返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> の <see cref="T:System.Collections.Generic.KeyValuePair`2" /> 型の <see cref="T:System.Collections.Generic.SortedList`2" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。  したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 ディクショナリは、内部のツリーを使用した並べ替え順序で維持されます。 並べ替えの正しい位置にあるすべての新しい要素が配置されているし、要素が削除されるたびに、並べ替え順序を維持するために、ツリーを調整します。 を列挙しているときに、並べ替え順序が維持されます。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 この位置では、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> 返す `false`します。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> は定義されていません。<xref:System.Collections.Generic.IEnumerator%601.Current%2A> を、再度、コレクションの最初の要素に設定することはできません。列挙子の新しいインスタンスを作成する必要があります。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public int IndexOfKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Collections.Generic.SortedList`2" /> 内で検索されるキー。</param>
        <summary>指定したキーを検索し、<see cref="T:System.Collections.Generic.SortedList`2" /> 全体内でそのキーが見つかった位置の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="key" /> 全体内で <see cref="T:System.Collections.Generic.SortedList`2" /> が見つかった場合は、見つかった位置の 0 から始まるインデックス番号。それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、バイナリ サーチを実行します。そのため、このメソッドは、O\(log `n`\) 操作では、ここで `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public int IndexOfValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Collections.Generic.SortedList`2" /> 内で検索される値。  参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>指定した値を検索し、<see cref="T:System.Collections.Generic.SortedList`2" /> 全体内で最初に見つかった位置の 0 から始まるインデックスを返します。</summary>
        <returns>
          <paramref name="value" /> 全体を対象に <see cref="T:System.Collections.Generic.SortedList`2" /> を検索し、見つかった場合は、インデックス番号の最も小さい要素の 0 から始まるインデックス番号、それ以外の場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、既定の比較子を使用して等しいかどうかを判断 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> 値型の `TValue`です。<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> 値を入力するかどうかを確認 `TValue` 実装 <xref:System.IComparable%601?displayProperty=fullName> は使用可能な場合に、その実装を使用するとします。  ない場合は、 <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> 値を入力するかどうかを確認 `TValue` 実装 <xref:System.IComparable?displayProperty=fullName>します。  値の入力と `TValue` いずれのインターフェイスでは、このメソッドを使用して実装するわけでは <xref:System.Object.Equals%2A?displayProperty=fullName>です。  
  
 このメソッドは、一方向の検索を実行します。したがって、平均実行時間に比例 <xref:System.Collections.Generic.SortedList%602.Count%2A>します。 たとえば、このメソッドは、O \(`n`\) 操作、ここで `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Item(`0)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">値を取得または設定する対象のキー。</param>
        <summary>指定されたキーに関連付けられている値を取得または設定します。</summary>
        <value>指定されたキーに関連付けられている値。 指定したキーが見つからなかった場合、get 操作は <see cref="T:System.Collections.Generic.KeyNotFoundException" /> をスローし、set 操作は指定したキーを使用して新しい要素を作成します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティでは、`myCollection[key]` という構文を使用して、コレクション内の特定の要素にアクセスできます。  
  
 キーには `null`, 、値ことができますが場合、リスト内の値の型 `TValue`, 、参照型であります。  
  
 キーが値の取得するときに見つからない場合 <xref:System.Collections.Generic.KeyNotFoundException> がスローされます。 キーが見つからない場合、値が設定されている場合は、キーと値が追加されます。  
  
 使用することも、 <xref:System.Collections.Generic.SortedList%602.Item%2A> にキーの値を設定して新しい要素を追加するプロパティが存在しない、 <xref:System.Collections.Generic.SortedList%602>。 たとえば、 `myCollection["myNonexistentKey"] = myValue`です。 ただしで指定したキーが既に存在する場合、 <xref:System.Collections.Generic.SortedList%602>, で、設定、 <xref:System.Collections.Generic.SortedList%602.Item%2A> プロパティには、古い値が上書きされます。 これに対し、 <xref:System.Collections.Generic.SortedList%602.Add%2A> メソッドでは、既存の要素は変更しません。  
  
 C\# 言語キーワードを使用して実装する代わりに、インデクサーの定義、 <xref:System.Collections.Generic.SortedList%602.Item%2A> プロパティです。 Visual Basic は、<xref:System.Collections.Generic.SortedList%602.Item%2A> を既定のプロパティとして実装しており、同様のインデックス機能を提供します。  
  
 ここで n は O\(log `n`\) 操作は、このプロパティの値を取得する <xref:System.Collections.Generic.SortedList%602.Count%2A>です。 キーになっている場合は O\(log `n`\) 操作にプロパティを設定、 <xref:System.Collections.Generic.SortedList%602>です。 キーが一覧にない場合、プロパティは設定は O \(`n`\) 並べ替えられていないデータまたは O\(log `n`\) 一覧の最後に、新しい要素が追加された場合の操作です。 カーソルでは、サイズ変更が発生する場合、操作は O \(`n`\)。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Collections.Generic.SortedList%602.Item%2A> プロパティ \(c\# のインデクサー\) を示す値を取得する、 <xref:System.Collections.Generic.KeyNotFoundException> を示す値をキーに関連付けられていることを置き換えることが要求されたキーが存在しない場合にスローされます。  
  
 使用する方法も示します、 <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> メソッドとしてより効率的値を取得する場合は、プログラムは多くの場合、並べ替えられたリストに含まれていないキーの値を試行する必要があります。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.SortedList%602> クラスです。  
  
 [!code-cpp[Generic.SortedList#3](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#3)]
 [!code-csharp[Generic.SortedList#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#3)]
 [!code-vb[Generic.SortedList#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#3)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
[!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
[!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
[!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">プロパティが取得され、<paramref name="key" /> がコレクションに存在しません。</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>並べ替えられた順序で、<see cref="T:System.Collections.Generic.SortedList`2" /> 内のキーを含むコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Collections.Generic.IList`1" /> 内のキーを格納している <see cref="T:System.Collections.Generic.SortedList`2" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内のキーの順序、 <xref:System.Collections.Generic.IList%601> 内での順序と同じ、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 返された <xref:System.Collections.Generic.IList%601> 静的コピーではありません。 代わりに、 <xref:System.Collections.Generic.IList%601> は元のキーを逆参照 <xref:System.Collections.Generic.SortedList%602>します。 そのため、変更、 <xref:System.Collections.Generic.SortedList%602> に反映されるまでに続行、 <xref:System.Collections.Generic.IList%601>です。  
  
 によって返されるコレクション、 <xref:System.Collections.Generic.SortedList%602.Keys%2A> プロパティは、効率的にインデックスを使ってキーを取得します。 場合によっては、リストがキーの内部配列のラッパーだけであるため、プロパティにアクセスするときにリストを再生成する必要はありません。 次のコードは、使用、 <xref:System.Collections.Generic.SortedList%602.Keys%2A> のインデックスの検索文字列のキーを持つ要素の並べ替えられたリストからのキーのプロパティ。  
  
 [!code-cpp[Generic.SortedList\#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList\#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
   
  
## 例  
 次のコード例を使用して、並べ替えられたリスト内のキーを列挙する方法を示しています、 <xref:System.Collections.Generic.SortedList%602.Keys%2A> プロパティ、およびキーと並べ替えられたリスト内の値を列挙する方法です。  
  
 使用する方法も示します、 <xref:System.Collections.Generic.SortedList%602.Keys%2A> プロパティのキーの効率的なインデックス付き検索をします。  
  
 このコードは、コンパイルして実行できるサンプルが大きくの一部です。 「<xref:System.Collections.Generic.SortedList%602>」を参照してください。  
  
 [!code-cpp[Generic.SortedList#9](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#9)]
 [!code-csharp[Generic.SortedList#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#9)]
 [!code-vb[Generic.SortedList#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#9)]  
[!code-cpp[Generic.SortedList#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#7)]
[!code-csharp[Generic.SortedList#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#7)]
[!code-vb[Generic.SortedList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">削除する要素のキー。</param>
        <summary>指定したキーを持つ要素を <see cref="T:System.Collections.Generic.SortedList`2" /> から削除します。</summary>
        <returns>要素が正常に削除された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。  このメソッドは、<see langword="false" /> が元の <paramref name="key" /> に見つからなかった場合にも <see cref="T:System.Collections.Generic.SortedList`2" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、バイナリ サーチを実行します。ただし、エレメントは、移動ため、このメソッドは O 開く位置を埋めるために \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。  
  
   
  
## 例  
 次のコード例を使用して、並べ替えられたリストから、キー\/値ペアを削除する方法を示しています、 <xref:System.Collections.Generic.SortedList%602.Remove%2A> メソッドです。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.SortedList%602> クラスです。  
  
 [!code-cpp[Generic.SortedList\#10](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#10)]
 [!code-csharp[Generic.SortedList\#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#10)]
 [!code-vb[Generic.SortedList\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">削除する要素の 0 から始まるインデックス。</param>
        <summary>
          <see cref="T:System.Collections.Generic.SortedList`2" /> の指定したインデックスにある要素を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、バイナリ サーチを実行します。ただし、エレメントは、移動ため、このメソッドは O 開く位置を埋めるために \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が 0 未満です。  
  
 または  
  
 <paramref name="index" /> が <see cref="P:System.Collections.Generic.SortedList`2.Count" /> 以上になっています。</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="arrayIndex">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Collections.ICollection" /> から要素がコピーされる 1 次元の <see cref="T:System.Array" />。<see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。</param>
        <param name="arrayIndex">コピーの開始位置とする <c>array</c> のインデックス \(0 から始まる\)。</param>
        <summary>
          <see cref="T:System.Collections.ICollection" /> の要素を <see cref="T:System.Array" /> にコピーします。<see cref="T:System.Array" /> の特定のインデックスからコピーが開始されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  場合、ソースの種類 <xref:System.Collections.ICollection> 変換先の型に自動的にキャストすることはできません `array`, の非ジェネリックの実装 <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=fullName> スロー <xref:System.InvalidCastException>, 汎用実装がスローされ、 <xref:System.ArgumentException>です。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  
  
 または  
  
 <paramref name="array" /> には、0 から始まるインデックス番号がありません。  
  
 または  
  
 ソース内の要素の数 <see cref="T:System.Collections.ICollection" /> から使用可能な領域よりも大きい <paramref name="arrayIndex" /> 変換先の末尾に <paramref name="array" />します。  
  
 または  
  
 ソースの種類 <see cref="T:System.Collections.ICollection" /> 先の型に自動的にキャストできない <paramref name="array" />します。</exception>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> へのアクセスが同期されている \(スレッド セーフである\) かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> へのアクセスが同期されている \(スレッド セーフである\) 場合は <see cref="T:System.Collections.ICollection" />。それ以外の場合は <see langword="false" />。<see cref="T:System.Collections.Generic.SortedList`2" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> プロパティへのアクセスを同期に使用できるオブジェクトを返す、 <xref:System.Collections.ICollection>です。 同期は、すべてのスレッドがコレクションにアクセスする前にこのオブジェクトをロックする場合のみ有効です。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> へのアクセスを同期するために使用できるオブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> へのアクセスを同期するために使用できるオブジェクト。<see cref="T:System.Collections.Generic.SortedList`2" /> の既定の実装では、このプロパティは常に現在のインスタンスを返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装のコレクションの<xref:System.Collections.Generic?displayProperty=fullName>が同期されていません。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。 コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>プロパティへのアクセスを同期するために使用できるオブジェクトを返します、<xref:System.Collections.ICollection>です。 同期は、すべてのスレッドがコレクションにアクセスする前にこのオブジェクトをロックする場合のみ有効です。 次のコードの使用を示しています、 <xref:System.Collections.ICollection.SyncRoot%2A> c\#、C\+\+、および Visual Basic のプロパティです。  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">追加する要素のキーとして使用する <see cref="T:System.Object" />。</param>
        <param name="value">追加する要素の値として使用する <see cref="T:System.Object" />。</param>
        <summary>指定したキーおよび値を持つ要素を <see cref="T:System.Collections.IDictionary" /> オブジェクトに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することも、 <xref:System.Collections.IDictionary.Item%2A> ディクショナリに存在しないキーの値を設定して新しい要素を追加するプロパティなど `myCollection["myNonexistentKey"] = myValue`します。 ただし、ディクショナリで指定したキーが既に存在する場合は、設定、 <xref:System.Collections.IDictionary.Item%2A> プロパティには、古い値が上書きされます。 これに対し、 <xref:System.Collections.IDictionary.Add%2A> メソッドでは、既存の要素は変更しません。  
  
 このメソッドは O \(`n`\) 並べ替えられていないデータの操作、 `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。 新しい要素がリストの末尾に追加された場合は、O\(log `n`\) 操作になります。 カーソルでは、サイズ変更が発生する場合、操作は O \(`n`\)。  
  
   
  
## 例  
 次のコード例へのアクセス方法を示しています、 <xref:System.Collections.Generic.SortedList%602> クラスを通じて、 <xref:System.Collections.IDictionary?displayProperty=fullName> インターフェイスです。 このコード例は、空を作成 <xref:System.Collections.Generic.SortedList%602> 文字列を使用して文字列のキーの <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> をいくつかの要素を追加するメソッドです。 例を <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> メソッドでのスロー、 <xref:System.ArgumentException> キーまたは無効なデータ型の値が指定されている場合または重複するキーを追加しようとしています。  
  
 コード例では他のメンバーは、いくつかの使用、 <xref:System.Collections.IDictionary?displayProperty=fullName> インターフェイスです。  
  
 [!code-csharp[Generic.SortedList.IDictionary\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.IDictionary\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> キーの型に割り当てることがない場合、型の <paramref name="TKey" /> の <see cref="T:System.Collections.IDictionary" />です。  
  
 または  
  
 <paramref name="value" /> 値の型に割り当てることができません型 <paramref name="TValue" /> の <see cref="T:System.Collections.IDictionary" />です。  
  
 または  
  
 同じキーを持つ要素が、<see cref="T:System.Collections.IDictionary" /> に既に存在します。</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Collections.IDictionary" /> 内で検索されるキー。</param>
        <summary>指定したキーの要素が <see cref="T:System.Collections.IDictionary" /> に格納されているかどうかを確認します。</summary>
        <returns>指定したキーを持つ要素を <see langword="true" /> が保持している場合は <see cref="T:System.Collections.IDictionary" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る `false` 場合 `key` がキーの種類に割り当てることがない型の `TKey` の <xref:System.Collections.Generic.SortedList%602>です。  
  
 このメソッドは O\(log `n`\) 操作では、ここで `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Contains%2A> のメソッド、 <xref:System.Collections.IDictionary?displayProperty=fullName> とのインターフェイス、 <xref:System.Collections.Generic.SortedList%602>です。 例が、メソッドを返す `false` 場合は無効なデータ型のキーを指定します。  
  
 指定された出力を含むサンプルが大きくのコード例は、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> メソッドです。  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#6)]
[!code-vb[Generic.SortedList.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> の <see cref="T:System.Collections.IDictionary" /> を返します。</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> の <see cref="T:System.Collections.IDictionary" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。  したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。<xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、<xref:System.Collections.IDictionaryEnumerator.Entry%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IDictionaryEnumerator.Entry%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IDictionaryEnumerator.Entry%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IDictionaryEnumerator.Entry%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.IDictionaryEnumerator.Entry%2A> は定義されていません。<xref:System.Collections.IDictionaryEnumerator.Entry%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例を使用して並べ替えられたリスト内のキー\/値ペアを列挙する方法を示しています、 `foreach` ステートメント \(`For Each` Visual basic で `for each` C\+\+ で\)、列挙子の使用が隠ぺいされます。 具体的には、注意してくださいの列挙子、 <xref:System.Collections.IDictionary?displayProperty=fullName> インターフェイスを返します。 <xref:System.Collections.DictionaryEntry> オブジェクトではなく <xref:System.Collections.Generic.KeyValuePair%602> オブジェクトです。  
  
 指定された出力を含むサンプルが大きくのコード例は、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> メソッドです。  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.IDictionary" /> が固定サイズかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が固定サイズの場合は <see cref="T:System.Collections.IDictionary" />。それ以外の場合は <see langword="false" />。<see cref="T:System.Collections.Generic.SortedList`2" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 固定サイズのコレクションでは、コレクションの作成後に要素の追加または削除はできませんが、既存の要素の変更はできます。  
  
 固定サイズのコレクションは、コレクションの追加と要素の削除を防止するラッパーです。そのため、追加または削除、要素を含む、基になるコレクションに変更が加えられた場合、固定サイズ コレクションにはそれらの変更が反映されます。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.IDictionary.IsFixedSize" />
        <altmember cref="P:System.Collections.IDictionary.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.IDictionary" /> が読み取り専用かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が読み取り専用である場合は <see cref="T:System.Collections.IDictionary" />。それ以外の場合は <see langword="false" />。<see cref="T:System.Collections.Generic.SortedList`2" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 読み取り専用のコレクションでは、コレクション作成後に要素の追加、削除、または変更はできません。  
  
 読み取り専用であるコレクションは、コレクションのコレクションの変更を防止するラッパーです。そのため、基になるコレクションの変更が加えられた、読み取り専用コレクションはそれらの変更を反映します。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.IDictionary.IsReadOnly" />
        <altmember cref="P:System.Collections.IDictionary.IsFixedSize" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">取得または設定する要素のキー。</param>
        <summary>指定したキーを持つ要素を取得または設定します。</summary>
        <value>指定したキーを持つ要素。<see langword="null" /> がディクショナリに存在しない場合、または <paramref name="key" /> が <paramref name="key" /> のキーの型 <paramref name="TKey" /> に代入できない型である場合は <see cref="T:System.Collections.Generic.SortedList`2" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを返します `null` 場合 `key` がキーの種類に割り当てることがない型の `TKey` の <xref:System.Collections.Generic.SortedList%602>です。  
  
 このプロパティでは、`myCollection[key]` という構文を使用して、コレクション内の特定の要素にアクセスできます。  
  
 使用することも、 <xref:System.Collections.IDictionary.Item%2A> ディクショナリに存在しないキーの値を設定して新しい要素を追加するプロパティなど `myCollection["myNonexistentKey"] = myValue`します。 ただし、ディクショナリで指定したキーが既に存在する場合は、設定、 <xref:System.Collections.IDictionary.Item%2A> プロパティには、古い値が上書きされます。 これに対し、 <xref:System.Collections.IDictionary.Add%2A> メソッドでは、既存の要素は変更しません。  
  
 C\# 言語を使用して、 [この](http://msdn.microsoft.com/ja-jp/d4f827fe-4710-410b-89b8-867dad44b8a3) キーワードを実装する代わりに、インデクサーの定義、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> プロパティです。 Visual Basic は、<xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> を既定のプロパティとして実装しており、同様のインデックス機能を提供します。  
  
 ここで n は O\(log `n`\) 操作は、このプロパティの値を取得する <xref:System.Collections.Generic.SortedList%602.Count%2A>です。 キーになっている場合は O\(log `n`\) 操作にプロパティを設定、 <xref:System.Collections.Generic.SortedList%602>です。 キーが一覧にない場合、プロパティは設定は O \(`n`\) 並べ替えられていないデータまたは O\(log `n`\) 一覧の最後に、新しい要素が追加された場合の操作です。 カーソルでは、サイズ変更が発生する場合、操作は O \(`n`\)。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> のプロパティ \(c\# のインデクサー\)、 <xref:System.Collections.IDictionary?displayProperty=fullName> とのインターフェイス、 <xref:System.Collections.Generic.SortedList%602>, 、およびプロパティが異なる方法、 <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=fullName> プロパティです。  
  
 同様に、例、 <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=fullName> プロパティには、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=fullName> プロパティが既存のキーに関連付けられている値を変更でき、指定したキーが並べ替えられたリスト内にない場合は、新しいキー\/値ペアを追加することができます。 またこの例とは異なり、 <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=fullName> プロパティには、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=fullName> プロパティが例外をスローしていない場合は `key` が並べ替えられたリストに戻らない場合は null 参照代わりにします。 最後に、この例を取得する、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=fullName> 場合、プロパティが null 参照を返します `key` 正しいデータ型ではないと、プロパティの設定は例外をスロー `key` 正しいデータ型ではありません。  
  
 指定された出力を含むサンプルが大きくのコード例は、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> メソッドです。  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#3)]
[!code-vb[Generic.SortedList.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.SortedList.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedList.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">値が割り当てられていると <paramref name="key" /> がキーの種類に割り当てることがない型の <paramref name="TKey" /> の <see cref="T:System.Collections.Generic.SortedList`2" />です。  
  
 または  
  
 値が割り当てられていると <paramref name="value" /> の型値の型に割り当てることができませんが <paramref name="TValue" /> の <see cref="T:System.Collections.Generic.SortedList`2" />です。</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> のキーを保持している <see cref="T:System.Collections.IDictionary" /> を取得します。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> のキーを保持している <see cref="T:System.Collections.IDictionary" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内のキーの順序、 <xref:System.Collections.ICollection> 内での順序と同じ、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23Generic%23IDictionary%7BTKey%40TValue%7D%23Keys%2A> のプロパティ、 <xref:System.Collections.IDictionary?displayProperty=fullName> とのインターフェイス、 <xref:System.Collections.Generic.SortedList%602>, 、並べ替えられたリスト内のキーの一覧表示します。 例では、並べ替えられたリスト内のキー\/値ペアを列挙する方法も示していますなおの列挙子、 <xref:System.Collections.IDictionary?displayProperty=fullName> インターフェイスを返します。 <xref:System.Collections.DictionaryEntry> オブジェクトではなく <xref:System.Collections.Generic.KeyValuePair%602> オブジェクトです。  
  
 指定された出力を含むサンプルが大きくのコード例は、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> メソッドです。  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#9)]
[!code-vb[Generic.SortedList.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">削除する要素のキー。</param>
        <summary>指定したキーを持つ要素を <see cref="T:System.Collections.IDictionary" /> から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、バイナリ サーチを実行します。ただし、エレメントは、移動ため、このメソッドは O 開く位置を埋めるために \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Remove%2A> の <xref:System.Collections.IDictionary?displayProperty=fullName> とのインターフェイス、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 指定された出力を含むサンプルが大きくのコード例は、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> メソッドです。  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#10)]
[!code-vb[Generic.SortedList.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#10)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> 内の値を格納している <see cref="T:System.Collections.IDictionary" /> を取得します。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> 内の値を格納している <see cref="T:System.Collections.IDictionary" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値の順序、 <xref:System.Collections.ICollection> 内での順序と同じ、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Values%2A> のプロパティ、 <xref:System.Collections.IDictionary?displayProperty=fullName> とのインターフェイス、 <xref:System.Collections.Generic.SortedList%602>, 、並べ替えられたリスト内の値を表示します。 例では、並べ替えられたリスト内のキー\/値ペアを列挙する方法も示していますなおの列挙子、 <xref:System.Collections.IDictionary?displayProperty=fullName> インターフェイスを返します。 <xref:System.Collections.DictionaryEntry> オブジェクトではなく <xref:System.Collections.Generic.KeyValuePair%602> オブジェクトです。  
  
 指定された出力を含むサンプルが大きくのコード例は、 <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> メソッドです。  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#8)]
[!code-vb[Generic.SortedList.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションを反復処理する列挙子を返します。</summary>
        <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。  したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。<xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、<xref:System.Collections.IEnumerator.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.IEnumerator.Current%2A> は定義されていません。<xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.TrimExcess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.SortedList`2" /> 内にある実際の要素数が現在の容量の 90% 未満の場合は、容量をその数に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コレクションのメモリ オーバーヘッドを最小コレクションに新しい要素が追加されない場合に使用できます。 再割り当てすることと、大規模なコピーのコスト <xref:System.Collections.Generic.SortedList%602> 多く、ただしは、されるため、 <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> メソッドは何も一覧にある容量の 90% を超える場合。 これにより、比較的小さな向上のための大規模な再割り当てコストを発生させることがなくなります。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。  
  
 リセットする、 <xref:System.Collections.Generic.SortedList%602> の初期状態を呼び出し、 <xref:System.Collections.Generic.SortedList%602.Clear%2A> メソッドを呼び出す前に <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> メソッドです。 空のトリミング <xref:System.Collections.Generic.SortedList%602> のキャパシティを設定、 <xref:System.Collections.Generic.SortedList%602> を既定の容量。  
  
 使用して、容量を設定することも、 <xref:System.Collections.Generic.SortedList%602.Capacity%2A> プロパティです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.TryGetValue(`0,`1@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">値を取得する対象のキー。</param>
        <param name="value">このメソッドが返されるときに、キーが見つかった場合は、指定したキーに関連付けられている値。それ以外の場合は <c>value</c> パラメーターの型に対する既定の値。 このパラメーターは初期化せずに渡されます。</param>
        <summary>指定したキーに関連付けられている値を取得します。</summary>
        <returns>指定したキーを持つ要素が <see langword="true" /> に格納されている場合は <see cref="T:System.Collections.Generic.SortedList`2" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、機能が組み合わされて、 <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> メソッドおよび <xref:System.Collections.Generic.SortedList%602.Item%2A> プロパティです。  
  
 キーが見つからない場合、 `value` パラメーター値の型の適切な既定値を取得する `TValue`; たとえば、整数型のゼロ \(0\) `false` Boolean 型用と `null` 参照型の場合。  
  
 このメソッドは、バイナリ サーチを実行します。そのため、このメソッドは、O\(log `n`\) 操作では、ここで `n` は <xref:System.Collections.Generic.SortedList%602.Count%2A>です。  
  
   
  
## 例  
 例では、使用する方法を示しています、 <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> メソッドとしてより効率的に頻繁に並べ替えられたリストに含まれていないキーを試行するプログラムで値を取得します。 これに対しても示していますが、どのように <xref:System.Collections.Generic.SortedList%602.Item%2A> プロパティ \(c\# のインデクサー\) が存在しないキーを取得中に、例外をスローします。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.SortedList%602> クラスです。  
  
 [!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
 [!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
 [!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.SortedList`2" /> 内の値を格納しているコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Collections.Generic.IList`1" /> 内の値を格納している <see cref="T:System.Collections.Generic.SortedList`2" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値の順序、 <xref:System.Collections.Generic.IList%601> 内での順序と同じ、 <xref:System.Collections.Generic.SortedList%602>です。  
  
 返された <xref:System.Collections.Generic.IList%601> 静的コピーではありません。 代わりに、 <xref:System.Collections.Generic.IList%601> は元の値を逆参照 <xref:System.Collections.Generic.SortedList%602>します。 そのため、変更、 <xref:System.Collections.Generic.SortedList%602> に反映されるまでに続行、 <xref:System.Collections.Generic.IList%601>です。  
  
 によって返されるコレクション、 <xref:System.Collections.Generic.SortedList%602.Values%2A> プロパティは値を取得するインデックスでの効率的な方法を提供します。 場合によっては、リストは単なる値の内部配列のラッパーであるため、プロパティにアクセスするときにリストを再生成する必要はありません。 次のコードは、使用、 <xref:System.Collections.Generic.SortedList%602.Values%2A> 文字列の並べ替えられたリストから値のインデックス付きの取得のためのプロパティ。  
  
 [!code-cpp[Generic.SortedList\#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList\#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
   
  
## 例  
 このコード例を使用して、並べ替えられたリスト内の値を列挙する方法を示しています、 <xref:System.Collections.Generic.SortedList%602.Values%2A> プロパティ、およびキーと並べ替えられたリスト内の値を列挙する方法です。  
  
 使用する方法も示します、 <xref:System.Collections.Generic.SortedList%602.Values%2A> プロパティ値の効率的なインデックス付き検索をします。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.SortedList%602> クラスです。  
  
 [!code-cpp[Generic.SortedList#8](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#8)]
 [!code-csharp[Generic.SortedList#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#8)]
 [!code-vb[Generic.SortedList#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#8)]  
[!code-cpp[Generic.SortedList#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#7)]
[!code-csharp[Generic.SortedList#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#7)]
[!code-vb[Generic.SortedList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.SortedList`2" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>