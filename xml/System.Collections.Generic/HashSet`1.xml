<Type Name="HashSet&lt;T&gt;" FullName="System.Collections.Generic.HashSet&lt;T&gt;">
  <TypeSignature Language="C#" Value="public class HashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.HashSet`1" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">ハッシュ セット内の要素の型。</typeparam>
    <summary>値のセットを表します。  
  
 この型の .NET Framework ソース コードを参照するには、[参照ソース](http://referencesource.microsoft.com/#System.Core/System/Collections/Generic/HashSet.cs#2d265edc718b158b)をご覧ください。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#System.Core/System/Collections/Generic/HashSet.cs#2d265edc718b158b). You can browse through the source code online, download the reference for offline viewing, and step through the sources \(including patches and updates\) during debugging; see [instructions](http://referencesource.microsoft.com/).  
  
 The <xref:System.Collections.Generic.HashSet%601> class provides high\-performance set operations. A set is a collection that contains no duplicate elements, and whose elements are in no particular order.  
  
> [!NOTE]
>  <xref:System.Collections.Generic.HashSet%601> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> interface starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Generic.HashSet%601> class did not implement this interface.  
  
 The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold. A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.  
  
 The <xref:System.Collections.Generic.HashSet%601> class is based on the model of mathematical sets and provides high\-performance set operations similar to accessing the keys of the <xref:System.Collections.Generic.Dictionary%602> or <xref:System.Collections.Hashtable> collections. In simple terms, the <xref:System.Collections.Generic.HashSet%601> class can be thought of as a <xref:System.Collections.Generic.Dictionary%602> collection without values.  
  
 A <xref:System.Collections.Generic.HashSet%601> collection is not sorted and cannot contain duplicate elements. If order or element duplication is more important than performance for your application, consider using the <xref:System.Collections.Generic.List%601> class together with the <xref:System.Collections.Generic.List%601.Sort%2A> method.  
  
 <xref:System.Collections.Generic.HashSet%601> provides many mathematical set operations, such as set addition \(unions\) and set subtraction. The following table lists the provided <xref:System.Collections.Generic.HashSet%601> operations and their mathematical equivalents.  
  
|HashSet\(Of T\) operation|Mathematical equivalent|  
|-------------------------------|-----------------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|Union or set addition|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|Intersection|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|Set subtraction|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|Symmetric difference|  
  
 In addition to the listed set operations, the <xref:System.Collections.Generic.HashSet%601> class also provides methods for determining set equality, overlap of sets, and whether a set is a subset or superset of another set.  
  
 For very large <xref:System.Collections.Generic.HashSet%601> objects, you can increase the maximum capacity to 2 billion elements on a 64\-bit system by setting the **languageKeyword tag is not supported!!!!**  
 attribute of the  configuration element to **languageKeyword tag is not supported!!!!**  
 in the run\-time environment.  
  
 Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Collections.Generic.HashSet%601> class implements the <xref:System.Collections.Generic.ISet%601> interface.  
  
## HashSet and LINQ Set Operations  
 LINQ provides access to the **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
, **languageKeyword tag is not supported!!!!**  
 and **languageKeyword tag is not supported!!!!**  
 set operations on any data source that implements the <xref:System.Collections.IEnumerable> or <xref:System.Linq.IQueryable> interfaces.  <xref:System.Collections.Generic.HashSet%601> provides a larger and more robust collection of set operations. For example, <xref:System.Collections.Generic.HashSet%601> provides comparisons such as <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> and <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.  
  
 The primary difference between LINQ set operations and <xref:System.Collections.Generic.HashSet%601> operations is that LINQ set operations always return a new <xref:System.Collections.Generic.IEnumerable%601> collection, whereas the <xref:System.Collections.Generic.HashSet%601> equivalent methods modify the current collection.  
  
 Typically, if you must create a new set or if your application needs access only to the provided set operations, using LINQ set operations on any <xref:System.Collections.Generic.IEnumerable%601> collection or array will be sufficient. However, if your application requires access to additional set operations, or if it is not desirable or necessary to create a new collection, use the <xref:System.Collections.Generic.HashSet%601> class.  
  
 The following table shows the <xref:System.Collections.Generic.HashSet%601> operations and their equivalent LINQ set operations.  
  
|HashSet\(Of T\) operation|LINQ equivalent|  
|-------------------------------|---------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<xref:System.Linq.Enumerable.Union%2A>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<xref:System.Linq.Enumerable.Intersect%2A>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<xref:System.Linq.Enumerable.Except%2A>|  
|Not provided.|<xref:System.Linq.Enumerable.Distinct%2A>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|Not provided.|  
|<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>|Not provided.|  
|<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>|Not provided.|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSubsetOf%2A>|Not provided.|  
|<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>|Not provided.|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSupersetOf%2A>|Not provided.|  
|<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>|Not provided.|  
  
   
  
## 例  
 The following example demonstrates how to merge two disparate sets. This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively. A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers. The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.  
  
 [!code-csharp[System.Collections.Generic.HashSet\_UnionWith\#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet\_UnionWith\#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Generic.SortedSet`1" />
    <altmember cref="T:System.Collections.Generic.ISet`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> クラスの新しいインスタンスを初期化します。初期化後のインスタンスの内容は空です。このセット型には既定の等値比較子が使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 容量、 <xref:System.Collections.Generic.HashSet%601> オブジェクトは、オブジェクトが保持できる要素の数。 A <xref:System.Collections.Generic.HashSet%601> オブジェクトに要素が追加されるオブジェクトの容量が自動的に増加します。  
  
 このコンス トラクターは、o \(1\) 操作です。  
  
   
  
## 例  
 2 つ作成し、次の例には <xref:System.Collections.Generic.HashSet%601> オブジェクトです。 この例に示されている例の一部である、 <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> メソッドです。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_UnionWith\#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">新しいセットの要素のコピー元となるコレクション。</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> クラスの新しいインスタンスを初期化します。このセット型には既定の等値比較子が使用されます。指定されたコレクションからコピーされた要素が格納され、コピー対象の要素数を格納できるだけの十分な容量が確保されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 容量、 <xref:System.Collections.Generic.HashSet%601> オブジェクトは、オブジェクトが保持できる要素の数。 A <xref:System.Collections.Generic.HashSet%601> オブジェクトに要素が追加されるオブジェクトの容量が自動的に増加します。  
  
 場合 `collection` 、重複を含む、セットで、一意の各要素のいずれかが含まれます。 例外はスローされません。 そのため、結果セットのサイズがのサイズと同じ `collection`します。  
  
 このコンス トラクターは、O \(`n`\) 操作の場合、 `n` 内の要素の数は、 `collection` パラメーター。  
  
   
  
## 例  
 次の例では、作成する方法、 <xref:System.Collections.Generic.HashSet%601> 既存のセットのコレクション。 この例では 2 つのセットは偶数と奇数の整数値でそれぞれ作成されます。 第 3 <xref:System.Collections.Generic.HashSet%601> 偶数整数のセットからオブジェクトが作成されます。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_UnionWith\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_UnionWith\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">セット内の値を比較する際に使用する <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> の実装。このセット型に、既定の <see cref="T:System.Collections.Generic.EqualityComparer`1" /> の実装を使用する場合は <see langword="null" />。</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> クラスの新しいインスタンスを初期化します。初期化後のインスタンスの内容は空です。このセット型には指定した等値比較子が使用されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold. A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.  
  
 This constructor is an O\(1\) operation.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">新しいセットの要素のコピー元となるコレクション。</param>
        <param name="comparer">セット内の値を比較する際に使用する <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> の実装。このセット型に、既定の <see cref="T:System.Collections.Generic.EqualityComparer`1" /> の実装を使用する場合は <see langword="null" />。</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> クラスの新しいインスタンスを初期化します。このセット型には指定した等値比較子が使用されます。指定されたコレクションからコピーされた要素が格納され、コピー対象の要素数を格納できるだけの十分な容量が確保されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 容量、<xref:System.Collections.Generic.HashSet%601>オブジェクトは、オブジェクトが保持できる要素の数。 A<xref:System.Collections.Generic.HashSet%601>要素がオブジェクトに追加されたオブジェクトの容量が自動的に増加します。  
  
 場合`collection`重複を含む一意の各要素の 1 つのセットが含まれます。 例外はスローされません。 したがって、結果セットのサイズのサイズと同じではありません`collection`です。  
  
 このコンス トラクターは、O \(`n`\) 操作、場所`n`内の要素の数が、`collection`パラメーター。  
  
   
  
## 例  
 次の例は、指定された<xref:System.Collections.Generic.IEqualityComparer%601>の要素を区別しない比較を許可する、 <xref:System.Collections.Generic.HashSet%601> vehicle 型のコレクション。  
  
 [!code-cpp[System.Collections.Generic.HashSet\_ExceptWith\#03](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/source2.cpp#03)]
 [!code-csharp[System.Collections.Generic.HashSet\_ExceptWith\#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/source2.cs#03)]
 [!code-vb[System.Collections.Generic.HashSet\_ExceptWith\#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/source2.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトをシリアル化するために必要な情報を格納している <see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクト。</param>
        <param name="context">
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトに関連付けられているシリアル化ストリームの転送元および転送先を格納する <see cref="T:System.Runtime.Serialization.StreamingContext" /> 構造体。</param>
        <summary>シリアル化したデータを使用して、<see cref="T:System.Collections.Generic.HashSet`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは、ストリームを介して送信されるオブジェクトを再構成する逆シリアル化中に呼び出されます。 詳細については、「[XML and SOAP Serialization](http://msdn.microsoft.com/ja-jp/832ac524-21bc-419a-a27b-ca8bfc45840f)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Add(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">セットに追加する要素。</param>
        <summary>指定された要素をセットに追加します。</summary>
        <returns>要素が <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトに追加された場合は <see langword="true" />。要素が既に存在していた場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If <xref:System.Collections.Generic.HashSet%601.Count%2A> already equals the capacity of the <xref:System.Collections.Generic.HashSet%601> object, the capacity is automatically adjusted to accommodate the new item.  
  
 If <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the capacity of the internal array, this method is an O\(1\) operation. If the <xref:System.Collections.Generic.HashSet%601> object must be resized, this method becomes an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is <xref:System.Collections.Generic.HashSet%601.Count%2A>.  
  
   
  
## 例  
 The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects. This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.  
  
 [!code-csharp[System.Collections.Generic.HashSet\_UnionWith\#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトからすべての要素を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.HashSet%601.Count%2A> is set to zero and references to other objects from elements of the collection are also released. The capacity remains unchanged until a call to <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> is made.  
  
 This method is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is <xref:System.Collections.Generic.HashSet%601.Count%2A>.  
  
   
  
## 例  
 The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, then clears it and releases the memory referenced by the collection.  
  
 [!code-csharp[System.Collections.Generic.HashSet\_Clear\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_Clear\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>セット内の値が等しいかどうかを確認するために使用する <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> オブジェクトを取得します。</summary>
        <value>セット内の値が等しいかどうかを確認するために使用する <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Contains(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクト内で検索する要素。</param>
        <summary>指定した要素が <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトに含まれているかどうかを判断します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトに指定された要素が格納されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is an O\(1\) operation.  
  
   
  
## 例  
 The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method. In this example, the <xref:System.Collections.Generic.HashSet%601.Contains%2A> method verifies that the set contains a value before removing it.  
  
 [!code-csharp[System.Collections.Generic.HashSet\_RemoveWhere\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_RemoveWhere\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトからコピーされる要素のコピー先となる 1 次元配列。 配列には、0 から始まるインデックスが設定されている必要があります。</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトの要素を配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is <xref:System.Collections.Generic.HashSet%601.Count%2A>.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトからコピーされる要素のコピー先となる 1 次元配列。 配列には、0 から始まるインデックスが設定されている必要があります。</param>
        <param name="arrayIndex">コピーの開始位置とする <c>array</c> のインデックス \(0 から始まる\)。</param>
        <summary>指定された配列インデックスを開始位置として、<see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトの要素を配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは O \(`n`\) 操作の場合、 `n` は [CopyTo メソッド \(T\<xref:System.Collections.Generic.HashSet%601.Count%2A>です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayIndex" /> 変換先の長さよりも大きい <paramref name="array" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトからコピーされる要素のコピー先となる 1 次元配列。 配列には、0 から始まるインデックスが設定されている必要があります。</param>
        <param name="arrayIndex">コピーの開始位置とする <c>array</c> のインデックス \(0 から始まる\)。</param>
        <param name="count">
          <c>array</c> にコピーする要素の数。</param>
        <summary>指定された配列インデックスを開始位置として、<see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトから、指定された数の要素を配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは O \(`n`\) 操作の場合、 `n` は `count`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> が 0 未満です。  
  
 \-または\-  
  
 <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayIndex" /> 変換先の長さよりも大きい <paramref name="array" />します。  
  
 または  
  
 <paramref name="count" /> 使用可能な領域よりも大きい、 <paramref name="index" /> 変換先の末尾に <paramref name="array" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>セットに格納されている要素の数を取得します。</summary>
        <value>セットに格納されている要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold. A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.  
  
 The capacity is always greater than or equal to <xref:System.Collections.Generic.HashSet%601.Count%2A>. If <xref:System.Collections.Generic.HashSet%601.Count%2A> exceeds the capacity while adding elements, the capacity is set to the first prime number that is greater than double the previous capacity.  
  
 Retrieving the value of this property is an O\(1\) operation.  
  
   
  
## 例  
 The following example demonstrates how to create, populate, and manipulate two <xref:System.Collections.Generic.HashSet%601> objects. In this example, both the contents of the set and <xref:System.Collections.Generic.HashSet%601.Count%2A> display to the console.  
  
 [!code-csharp[System.Collections.Generic.HashSet\_UnionWith\#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet\_UnionWith\#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.HashSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CreateSetComparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトの等価テストに使用できる <see cref="T:System.Collections.IEqualityComparer" /> オブジェクトを返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトの深いレベルの等価テストに使用できる <see cref="T:System.Collections.IEqualityComparer" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Collections.IEqualityComparer> object checks for equality at only one level; however, you can chain together comparers at additional levels to perform deeper equality testing.  
  
 Calling this method is an O\(1\) operation.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトから削除する項目のコレクション。</param>
        <summary>現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトから、指定されたコレクションに含まれる要素をすべて削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method is the equivalent of mathematical set subtraction.  
  
 This method is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is the number of elements in the **parameterReference tag is not supported!!!!**  
 parameter.  
  
   
  
## 例  
 The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data. The lower range of values is then removed from the larger set using the <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method.  
  
 [!code-cpp[System.Collections.Generic.HashSet\_ExceptWith\#02](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/program.cpp#02)]
 [!code-csharp[System.Collections.Generic.HashSet\_ExceptWith\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_ExceptWith\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.HashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.HashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトを反復処理する列挙子を返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトの <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがってを使用して `foreach` 、列挙子を直接操作するのではなくをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 この位置では、 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> プロパティが定義されています。 そのため、呼び出す必要があります、 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> メソッドの値を読み取る前にコレクションの最初の要素を列挙子を進める <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>します。  
  
 <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> プロパティまで同じオブジェクトを返す <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> が呼び出されます。<xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> は、<xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> は定義されていません。 設定することはできません <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> 再度、コレクションの最初の要素を作成する必要が新しい列挙子オブジェクトにします。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.Generic?displayProperty=fullName> 名前空間のコレクションの既定の実装は同期されません。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトをシリアル化するために必要な情報を格納している <see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクト。</param>
        <param name="context">
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトに関連付けられているシリアル化ストリームの転送元および転送先を格納する <see cref="T:System.Runtime.Serialization.StreamingContext" /> 構造体。</param>
        <summary>
          <see cref="T:System.Runtime.Serialization.ISerializable" /> インターフェイスを実装し、<see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトをシリアル化するために必要なデータを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 O は、このメソッドを呼び出す \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.HashSet%601.Count%2A>です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for providing serialization services. Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと比較するコレクション。</param>
        <summary>現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトを、そのオブジェクトと指定されたコレクションの両方に存在する要素だけが格納されるように変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 によって表されるコレクションの場合、 `other` パラメーターは、 <xref:System.Collections.Generic.HashSet%601> 現在として同じ等値比較子を使用して、コレクション <xref:System.Collections.Generic.HashSet%601> オブジェクトに、このメソッドは O \(`n`\) 操作です。 それ以外の場合、このメソッドは、O \(`n` \+ `m`\) 操作、 `n` は <xref:System.Collections.Generic.HashSet%601.Count%2A> と `m` 内の要素の数は、 `other`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと比較するコレクション。</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトが、指定されたコレクションの真のサブセット \(真部分集合\) であるかどうかを判断します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトが <paramref name="other" /> の真のサブセットである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 空のセットは、他のコレクションの真のサブセットです。 したがって、このメソッドが返されます `true` 現在のコレクションを表す場合 <xref:System.Collections.Generic.HashSet%601> オブジェクトが空しない限り、 `other` パラメーターが空のセットです。  
  
 このメソッドは常に返します `false` 場合 <xref:System.Collections.Generic.HashSet%601.Count%2A> 内の要素の数以上 `other`します。  
  
 によって表されるコレクション場合 `other` は、 <xref:System.Collections.Generic.HashSet%601> 現在として同じ等値比較子を使用して、コレクション <xref:System.Collections.Generic.HashSet%601> オブジェクトをこのメソッドは、O \(`n`\) 操作です。 それ以外の場合、このメソッドは、O \(`n` \+ `m`\) 操作、 `n` は <xref:System.Collections.Generic.HashSet%601.Count%2A> と `m` 内の要素の数は、 `other`です。  
  
   
  
## 例  
 次の例を作成する 2 つの異なる <xref:System.Collections.Generic.HashSet%601> オブジェクトし、相互に比較します。 この例では `lowNumbers` は真のサブセットおよびサブセット `allNumbers` まで `allNumbers` を使用して、変更、 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> メソッドは両方のセットに存在する値のみが含まれています。 1 回 `allNumbers` と `lowNumbers` 同じですが、 `lowNumbers` のサブセットではまだ `allNumbers` が真のサブセットがなくなりました。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと比較するコレクション。</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトが、指定されたコレクションの真のスーパーセット \(真上位集合\) であるかどうかを判断します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトが <paramref name="other" /> の真のスーパーセットである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 空のセットは、他のコレクションの真のスーパー セットです。 したがって、このメソッドが返されます `true` によって表されるコレクションの場合、 `other` パラメーターが空しない限り、現在 <xref:System.Collections.Generic.HashSet%601> コレクションも空です。  
  
 このメソッドは常に返します `false` 場合 <xref:System.Collections.Generic.HashSet%601.Count%2A> 内の要素の数以下 `other`します。  
  
 によって表されるコレクション場合 `other` は、 <xref:System.Collections.Generic.HashSet%601> 現在として同じ等値比較子を使用して、コレクション <xref:System.Collections.Generic.HashSet%601> オブジェクトに、このメソッドは O \(`n`\) 操作です。 それ以外の場合、このメソッドは、O \(`n` \+ `m`\) 操作、 `n` 内の要素の数は、 `other` と `m` は <xref:System.Collections.Generic.HashSet%601.Count%2A>です。  
  
   
  
## 例  
 次の例を作成する 2 つの異なる <xref:System.Collections.Generic.HashSet%601> オブジェクトし、相互に比較します。 この例では `allNumbers` スーパー セットと真のスーパー セットの両方が `lowNumbers` まで `allNumbers` を使用して、変更、 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> メソッドは両方のセットに存在する値のみが含まれています。 1 回 `allNumbers` と `lowNumbers` 同じですが、 `allNumbers` のスーパー セットではまだ `lowNumbers` が真のスーパー セットではなくなりました。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと比較するコレクション。</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトが、指定されたコレクションのサブセットであるかどうかを判断します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトが <paramref name="other" /> のサブセットである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 空のセットは空のセットを含むその他のコレクションのサブセットしたがって、このメソッドが返されます `true` 現在のコレクションを表す場合 <xref:System.Collections.Generic.HashSet%601> オブジェクトが空でも、 `other` パラメーターは、空のセットです。  
  
 このメソッドは常に返します `false` 場合 <xref:System.Collections.Generic.HashSet%601.Count%2A> 内の要素の数よりも大きい `other`します。  
  
 によって表されるコレクション場合 `other` は、 <xref:System.Collections.Generic.HashSet%601> 現在として同じ等値比較子を使用して、コレクション <xref:System.Collections.Generic.HashSet%601> オブジェクトに、このメソッドは O \(`n`\) 操作です。 それ以外の場合、このメソッドは、O \(`n` \+ `m`\) 操作、 `n` は <xref:System.Collections.Generic.HashSet%601.Count%2A> と `m` 内の要素の数は、 `other`です。  
  
   
  
## 例  
 次の例を作成する 2 つの異なる <xref:System.Collections.Generic.HashSet%601> オブジェクトし、相互に比較します。 この例では `lowNumbers` は真のサブセットおよびサブセット `allNumbers` まで `allNumbers` を使用して、変更、 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> メソッドは両方のセットに存在する値のみが含まれています。 1 回 `allNumbers` と `lowNumbers` 同じですが、 `lowNumbers` のサブセットではまだ `allNumbers` が真のサブセットがなくなりました。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと比較するコレクション。</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトが、指定されたコレクションのスーパーセットであるかどうかを判断します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトが <paramref name="other" /> のスーパーセットである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 空のセットを含む、すべてのコレクションは、空のセットのスーパー セットです。 したがって、このメソッドが返されます `true` によって表されるコレクションの場合、 `other` パラメーターが空で場合でも、現在 <xref:System.Collections.Generic.HashSet%601> オブジェクトは空です。  
  
 このメソッドは常に返します `false` 場合 <xref:System.Collections.Generic.HashSet%601.Count%2A> が内の要素の数より少ない `other`します。  
  
 によって表されるコレクション場合 `other` は、 <xref:System.Collections.Generic.HashSet%601> 現在として同じ等値比較子を使用して、コレクション <xref:System.Collections.Generic.HashSet%601> オブジェクトに、このメソッドは O \(`n`\) 操作です。 それ以外の場合、このメソッドは、O \(`n` \+ `m`\) 操作、 `n` 内の要素の数は、 `other` と `m` は <xref:System.Collections.Generic.HashSet%601.Count%2A>です。  
  
   
  
## 例  
 次の例を作成する 2 つの異なる <xref:System.Collections.Generic.HashSet%601> オブジェクトし、相互に比較します。 この例では `allNumbers` スーパー セットと真のスーパー セットの両方が `lowNumbers` まで `allNumbers` を使用して、変更、 <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> メソッドは両方のセットに存在する値のみが含まれています。 1 回 `allNumbers` と `lowNumbers` 同じですが、 `allNumbers` のスーパー セットではまだ `lowNumbers` が真のスーパー セットではなくなりました。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">逆シリアル化イベントのソース。</param>
        <summary>
          <see cref="T:System.Runtime.Serialization.ISerializable" /> インターフェイスを実装し、逆シリアル化が完了したときに逆シリアル化イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 O は、このメソッドを呼び出す \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.HashSet%601.Count%2A>です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクトに現在関連付けられている <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトが無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと比較するコレクション。</param>
        <summary>現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと指定されたコレクションとが共通の要素を共有しているかどうかを判断します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと <paramref name="other" /> との間に共通する要素が 1 つでも存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは O \(`n`\) 操作の場合、 `n` 内の要素の数は、 `other`です。  
  
   
  
## 例  
 次の例を作成する 2 つの異なる <xref:System.Collections.Generic.HashSet%601> オブジェクトし、相互に比較します。 この例では `allNumbers` と `lowNumbers` を使用して共通の要素を示す、 <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> メソッドです。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Remove(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">削除する要素。</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトから指定された要素を削除します。</summary>
        <returns>要素が見つかり、正常に削除された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。  このメソッドは、<paramref name="item" /> が <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトに見つからない場合、<see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Collections.Generic.HashSet%601> オブジェクトに指定された要素が含まれていないオブジェクトは変更されません場合、。 例外をスローすることはありません。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次の例から値を削除する方法、 <xref:System.Collections.Generic.HashSet%601> コレクションを使用して、 <xref:System.Collections.Generic.HashSet%601.Remove%2A> メソッドです。 この例では 0 が任意にから削除、 <xref:System.Collections.Generic.HashSet%601> コレクションです。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_RemoveWhere\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_RemoveWhere\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">削除する要素の条件を定義する <see cref="T:System.Predicate`1" /> デリゲート。</param>
        <summary>指定の述語によって定義された条件に一致するすべての要素を <see cref="T:System.Collections.Generic.HashSet`1" /> コレクションから削除します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> コレクションから削除された要素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 O は、このメソッドを呼び出す \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.HashSet%601.Count%2A>です。  
  
   
  
## 例  
 次の例から値を削除する方法、 <xref:System.Collections.Generic.HashSet%601> コレクションを使用して、 <xref:System.Collections.Generic.HashSet%601.Remove%2A> メソッドです。 この例ではすべての奇数の整数値の削除、 <xref:System.Collections.Generic.HashSet%601> で指定されたコレクション、 `match` を委任します。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_RemoveWhere\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_RemoveWhere\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと比較するコレクション。</param>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと指定されたコレクションに同じ要素が存在するかどうかを判断します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトが <paramref name="other" /> と等しい場合は <see langword="true" />。それ以外の場合は false。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> メソッドは、重複したエントリおよび要素の順序は無視されます。、 `other` パラメーター。  
  
 によって表されるコレクション場合 `other` は、 <xref:System.Collections.Generic.HashSet%601> 現在として同じ等値比較子を使用して、コレクション <xref:System.Collections.Generic.HashSet%601> オブジェクトに、このメソッドは O \(`n`\) 操作です。 それ以外の場合、このメソッドは、O \(`n` \+ `m`\) 操作、 `n` 内の要素の数は、 `other` と `m` は <xref:System.Collections.Generic.HashSet%601.Count%2A>です。  
  
   
  
## 例  
 次の例を作成する 2 つの異なる <xref:System.Collections.Generic.HashSet%601> オブジェクトし、相互に比較します。 最初に、2 つのセットが等しくないを使用して説明する、 <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> メソッドです。`allNumbers`<xref:System.Collections.Generic.HashSet%601> オブジェクトは、後で変更、その後のセットが等しい。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_boolMethods\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと比較するコレクション。</param>
        <summary>現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトを、そのオブジェクトと指定されたコレクションの \(両方に存在するのではなく\) どちらか一方に存在する要素だけが格納されるように変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 `other` パラメーターは、 <xref:System.Collections.Generic.HashSet%601> 現在として同じ等値比較子を使用して、コレクション <xref:System.Collections.Generic.HashSet%601> オブジェクトに、このメソッドは O \(`n`\) 操作です。 それ以外の場合、このメソッドは、O \(`n` \+ `m`\) 操作、 `n` 内の要素の数は、 `other` と `m` は <xref:System.Collections.Generic.HashSet%601.Count%2A>です。  
  
   
  
## 例  
 次の例では、2 つ作成されます <xref:System.Collections.Generic.HashSet%601> データの重複があるコレクション。 低い値を含むセットですが、後で変更を使用して、 <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> メソッドが、両方のセットに存在しない値のみが含まれています。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_SymmetricExceptWith\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_SymmetricExceptWith\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.ICollection`1" /> オブジェクトに追加するオブジェクト。</param>
        <summary>
          <see cref="T:System.Collections.Generic.ICollection`1" /> オブジェクトに項目を追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 <xref:System.Collections.Generic.List%601.Count%2A> がより小さい <xref:System.Collections.Generic.List%601.Capacity%2A>, 、このメソッドは、o \(1\) 操作になります。 新しい要素に対応するには、容量を増やす必要があります、このメソッドが O \(`n`\) 操作、 `n` は <xref:System.Collections.Generic.List%601.Count%2A>です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.Generic.ICollection`1" /> は読み取り専用です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コレクションが読み取り専用かどうかを示す値を取得します。</summary>
        <value>コレクションが読み取り専用の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションを反復処理する列挙子を返します。</summary>
        <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.Generic.IEnumerator`1" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 この位置では、 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> プロパティが定義されています。 そのため、呼び出す必要があります、 <xref:System.Collections.IEnumerator.MoveNext%2A> メソッドの値を読み取る前にコレクションの最初の要素を列挙子を進める <xref:System.Collections.Generic.IEnumerator%601.Current%2A>します。  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> プロパティまで同じオブジェクトを返す <xref:System.Collections.IEnumerator.MoveNext%2A> が呼び出されます。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> は定義されていません。 設定することはできません <xref:System.Collections.Generic.IEnumerator%601.Current%2A> 再度、コレクションの最初の要素を作成する必要が新しい列挙子オブジェクトにします。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.Generic?displayProperty=fullName> 名前空間のコレクションの既定の実装は同期されません。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションを反復処理する列挙子を返します。</summary>
        <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。<xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、 <xref:System.Collections.IEnumerator.Current%2A> プロパティが定義されています。 そのため、呼び出す必要があります、 <xref:System.Collections.IEnumerator.MoveNext%2A> メソッドの値を読み取る前にコレクションの最初の要素を列挙子を進める <xref:System.Collections.IEnumerator.Current%2A>します。  
  
 <xref:System.Collections.IEnumerator.Current%2A> プロパティでは、同じオブジェクトを取得するまで <xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されます。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.IEnumerator.Current%2A> は定義されていません。<xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.Generic?displayProperty=fullName> 名前空間のコレクションの既定の実装は同期されません。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TrimExcess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトの容量を、そこに格納されている実際の要素数を最も近い実装に固有の値に切り上げて設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することができます、 <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> を最小限に抑える方法、 <xref:System.Collections.Generic.HashSet%601> 要素が追加されないことが判明することは、オブジェクトのメモリ オーバーヘッドが発生します。 完全に消去する、 <xref:System.Collections.Generic.HashSet%601> オブジェクト、これによって参照されるすべてのメモリを解放し、呼び出した後にこのメソッドを呼び出す、 <xref:System.Collections.Generic.HashSet%601.Clear%2A> メソッドです。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.HashSet%601.Count%2A>です。  
  
   
  
## 例  
 次の例を作成し、入力、 <xref:System.Collections.Generic.HashSet%601> 、コレクションのコレクションを消去して、これによって参照されるメモリを解放します。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_Clear\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet\_Clear\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, !T actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue">To be added.</param>
        <param name="actualValue">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトと比較するコレクション。</param>
        <summary>現在の <see cref="T:System.Collections.Generic.HashSet`1" /> オブジェクトに変更を加えて、そのオブジェクト自体、指定されたコレクション、またはそれら両方に存在するすべての要素を格納するようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは O \(`n`\) 操作の場合、 `n` 内の要素の数は、 `other` パラメーター。  
  
   
  
## 例  
 次の例では、2 つの異なるセットをマージする方法を示します。 この例では、2 つ作成されます <xref:System.Collections.Generic.HashSet%601> オブジェクト、およびそれぞれ偶数と奇数の番号に設定しています。 第 3 <xref:System.Collections.Generic.HashSet%601> 偶数番号が含まれるセットからオブジェクトを作成します。 次の <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> 奇数の数値のセットを 3 番目のセットに追加するメソッドです。  
  
 [!code-csharp[System.Collections.Generic.HashSet\_UnionWith\#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet\_UnionWith\#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="other" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> コレクションの要素を配列にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.HashSet`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>