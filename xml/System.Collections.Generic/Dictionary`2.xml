<Type Name="Dictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;">
  <TypeSignature Language="C#" Value="public class Dictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Dictionary`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Dictionary`2" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">ディクショナリ内のキーの型。</typeparam>
    <typeparam name="TValue">ディクショナリ内の値の型。</typeparam>
    <summary>キーと値のコレクションを表します。  
  
 この型の .NET Framework ソース コードを参照するには、[参照ソース](http://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs#d3599058f8d79be0)をご覧ください。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs#d3599058f8d79be0). You can browse through the source code online, download the reference for offline viewing, and step through the sources \(including patches and updates\) during debugging; see [instructions](http://referencesource.microsoft.com/).  
  
 The <xref:System.Collections.Generic.Dictionary%602> generic class provides a mapping from a set of keys to a set of values. Each addition to the dictionary consists of a value and its associated key. Retrieving a value by using its key is very fast, close to O\(1\), because the <xref:System.Collections.Generic.Dictionary%602> class is implemented as a hash table.  
  
> [!NOTE]
>  The speed of retrieval depends on the quality of the hashing algorithm of the type specified for **parameterReference tag is not supported!!!!**  
> .  
  
 As long as an object is used as a key in the <xref:System.Collections.Generic.Dictionary%602>, it must not change in any way that affects its hash value. Every key in a <xref:System.Collections.Generic.Dictionary%602> must be unique according to the dictionary's equality comparer. A key cannot be **languageKeyword tag is not supported!!!!**  
, but a value can be, if the value type **parameterReference tag is not supported!!!!**  
 is a reference type.  
  
 <xref:System.Collections.Generic.Dictionary%602> requires an equality implementation to determine whether keys are equal. You can specify an implementation of the <xref:System.Collections.Generic.IEqualityComparer%601> generic interface by using a constructor that accepts a `comparer` parameter; if you do not specify an implementation, the default generic equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> is used. If type `TKey` implements the <xref:System.IEquatable%601?displayProperty=fullName> generic interface, the default equality comparer uses that implementation.  
  
> [!NOTE]
>  For example, you can use the case\-insensitive string comparers provided by the <xref:System.StringComparer> class to create dictionaries with case\-insensitive string keys.  
  
 The capacity of a <xref:System.Collections.Generic.Dictionary%602> is the number of elements the <xref:System.Collections.Generic.Dictionary%602> can hold. As elements are added to a <xref:System.Collections.Generic.Dictionary%602>, the capacity is automatically increased as required by reallocating the internal array.  
  
 For very large <xref:System.Collections.Generic.Dictionary%602> objects, you can increase the maximum capacity to 2 billion elements on a 64\-bit system by setting the **languageKeyword tag is not supported!!!!**  
 attribute of the  configuration element to **languageKeyword tag is not supported!!!!**  
 in the run\-time environment.  
  
 For purposes of enumeration, each item in the dictionary is treated as a <xref:System.Collections.Generic.KeyValuePair%602> structure representing a value and its key. The order in which the items are returned is undefined.  
  
 The **languageKeyword tag is not supported!!!!**  
 statement of the C\# language \(**languageKeyword tag is not supported!!!!**  
 in C\+\+, **languageKeyword tag is not supported!!!!**  
 in Visual Basic\) returns an object of the type of the elements in the collection. Since the <xref:System.Collections.Generic.Dictionary%602> is a collection of keys and values, the element type is not the type of the key or the type of the value. Instead, the element type is a <xref:System.Collections.Generic.KeyValuePair%602> of the key type and the value type. For example:  
  
 [!code-cpp[Generic.Dictionary\#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source2.cpp#11)]
 [!code-csharp[Generic.Dictionary\#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source2.cs#11)]
 [!code-vb[Generic.Dictionary\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source2.vb#11)]  
  
 The **languageKeyword tag is not supported!!!!**  
 statement is a wrapper around the enumerator, which allows only reading from the collection, not writing to it.  
  
> [!NOTE]
>  Because keys can be inherited and their behavior changed, their absolute uniqueness cannot be guaranteed by comparisons using the <xref:System.Type.Equals%2A> method.  
  
   
  
## 例  
 The following code example creates an empty <xref:System.Collections.Generic.Dictionary%602> of strings with string keys and uses the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to add some elements. The example demonstrates that the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method throws an <xref:System.ArgumentException> when attempting to add a duplicate key.  
  
 The example uses the <xref:System.Collections.Generic.Dictionary%602.Item%2A> property \(the indexer in C\#\) to retrieve values, demonstrating that a <xref:System.Collections.Generic.KeyNotFoundException> is thrown when a requested key is not present, and showing that the value associated with a key can be replaced.  
  
 The example shows how to use the <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> method as a more efficient way to retrieve values if a program often must try key values that are not in the dictionary, and it shows how to use the <xref:System.Collections.Generic.Dictionary%602.ContainsKey%2A> method to test whether a key exists before calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method.  
  
 The example shows how to enumerate the keys and values in the dictionary and how to enumerate the keys and values alone using the <xref:System.Collections.Generic.Dictionary%602.Keys%2A> property and the <xref:System.Collections.Generic.Dictionary%602.Values%2A> property.  
  
 Finally, the example demonstrates the <xref:System.Collections.Generic.Dictionary%602.Remove%2A> method.  
  
 [!code-cpp[Generic.Dictionary\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#1)]
 [!code-csharp[Generic.Dictionary\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>A <see cref="T:System.Collections.Generic.Dictionary`2" /> can support multiple readers concurrently, as long as the collection is not modified. Even so, enumerating through a collection is intrinsically not a thread\-safe procedure. In the rare case where an enumeration contends with write accesses, the collection must be locked during the entire enumeration. To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.  
  
 For thread\-safe alternatives, see the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class or <see cref="T:System.Collections.Immutable.ImmutableDictionary`2" /> class.  
  
 Public static \(**languageKeyword tag is not supported!!!!**  
 in Visual Basic\) members of this type are thread safe.</threadsafe>
    <altmember cref="T:System.Collections.Generic.IDictionary`2" />
    <altmember cref="T:System.Collections.Generic.SortedList`2" />
    <altmember cref="T:System.Collections.Generic.KeyValuePair`2" />
    <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>空で、既定の初期量を備え、キーの型の既定の等値比較子を使用する、<see cref="T:System.Collections.Generic.Dictionary`2" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Every key in a <xref:System.Collections.Generic.Dictionary%602> must be unique according to the default equality comparer.  
  
 <xref:System.Collections.Generic.Dictionary%602> requires an equality implementation to determine whether keys are equal. This constructor uses the default generic equality comparer, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName>. If type `TKey` implements the <xref:System.IEquatable%601?displayProperty=fullName> generic interface, the default equality comparer uses that implementation. Alternatively, you can specify an implementation of the <xref:System.Collections.Generic.IEqualityComparer%601> generic interface by using a constructor that accepts a `comparer` parameter.  
  
> [!NOTE]
>  If you can estimate the size of the collection, using a constructor that specifies the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Generic.Dictionary%602>.  
  
 This constructor is an O\(1\) operation.  
  
   
  
## 例  
 The following code example creates an empty <xref:System.Collections.Generic.Dictionary%602> of strings with string keys and uses the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method to add some elements. The example demonstrates that the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method throws an <xref:System.ArgumentException> when attempting to add a duplicate key.  
  
 This code example is part of a larger example provided for the <xref:System.Collections.Generic.Dictionary%602> class.  
  
 [!code-cpp[Generic.Dictionary\#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#2)]
 [!code-csharp[Generic.Dictionary\#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#2)]
 [!code-vb[Generic.Dictionary\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Immutable.IImmutableDictionary`2" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">新しい <see cref="T:System.Collections.Generic.IDictionary`2" /> に要素がコピーされた <see cref="T:System.Collections.Generic.Dictionary`2" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.IDictionary`2" /> から要素をコピーして格納し、キーの型の既定の等値比較子を使用する、<see cref="T:System.Collections.Generic.Dictionary`2" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Every key in a <xref:System.Collections.Generic.Dictionary%602> must be unique according to the default equality comparer; likewise, every key in the source **parameterReference tag is not supported!!!!**  
 must also be unique according to the default equality comparer.  
  
 The initial capacity of the new <xref:System.Collections.Generic.Dictionary%602> is large enough to contain all the elements in **parameterReference tag is not supported!!!!**  
.  
  
 <xref:System.Collections.Generic.Dictionary%602> requires an equality implementation to determine whether keys are equal. This constructor uses the default generic equality comparer, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName>. If type `TKey` implements the <xref:System.IEquatable%601?displayProperty=fullName> generic interface, the default equality comparer uses that implementation. Alternatively, you can specify an implementation of the <xref:System.Collections.Generic.IEqualityComparer%601> generic interface by using a constructor that accepts a `comparer` parameter.  
  
 This constructor is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is the number of elements in **parameterReference tag is not supported!!!!**  
.  
  
   
  
## 例  
 The following code example shows how to use the <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> constructor to initialize a <xref:System.Collections.Generic.Dictionary%602> with sorted content from another dictionary. The code example creates a <xref:System.Collections.Generic.SortedDictionary%602> and populates it with data in random order, then passes the <xref:System.Collections.Generic.SortedDictionary%602> to the <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> constructor, creating a <xref:System.Collections.Generic.Dictionary%602> that is sorted. This is useful if you need to build a sorted dictionary that at some point becomes static; copying the data from a <xref:System.Collections.Generic.SortedDictionary%602> to a <xref:System.Collections.Generic.Dictionary%602> improves retrieval speed.  
  
 [!code-csharp[Generic.Dictionary.ctor\_IDic\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_IDic/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor\_IDic\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_IDic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> には 1 つまたは複数の重複するキーが含まれます。</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 実装。キーの型の既定の <see langword="null" /> を使用する場合は <see cref="T:System.Collections.Generic.EqualityComparer`1" />。</param>
        <summary>空で、既定の初期量を備え、指定した <see cref="T:System.Collections.Generic.Dictionary`2" /> を使用する、<see cref="T:System.Collections.Generic.IEqualityComparer`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use this constructor with the case\-insensitive string comparers provided by the <xref:System.StringComparer> class to create dictionaries with case\-insensitive string keys.  
  
 Every key in a <xref:System.Collections.Generic.Dictionary%602> must be unique according to the specified comparer.  
  
 <xref:System.Collections.Generic.Dictionary%602> requires an equality implementation to determine whether keys are equal. If `comparer` is `null`, this constructor uses the default generic equality comparer, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName>. If type `TKey` implements the <xref:System.IEquatable%601?displayProperty=fullName> generic interface, the default equality comparer uses that implementation.  
  
> [!NOTE]
>  If you can estimate the size of the collection, using a constructor that specifies the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Generic.Dictionary%602>.  
  
 This constructor is an O\(1\) operation.  
  
   
  
## 例  
 The following code example creates a <xref:System.Collections.Generic.Dictionary%602> with a case\-insensitive equality comparer for the current culture. The example adds four elements, some with lower\-case keys and some with upper\-case keys. The example then attempts to add an element with a key that differs from an existing key only by case, catches the resulting exception, and displays an error message. Finally, the example displays the elements in the dictionary.  
  
 [!code-csharp[Generic.Dictionary.ctor\_IEqC\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_IEqC/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor\_IEqC\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_IEqC/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Generic.Dictionary`2" /> が格納できる要素数の初期値。</param>
        <summary>空で、指定した初期量を備え、キーの型の既定の等値比較子を使用する、<see cref="T:System.Collections.Generic.Dictionary`2" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Every key in a <xref:System.Collections.Generic.Dictionary%602> must be unique according to the default equality comparer.  
  
 The capacity of a <xref:System.Collections.Generic.Dictionary%602> is the number of elements that can be added to the <xref:System.Collections.Generic.Dictionary%602> before resizing is necessary. As elements are added to a <xref:System.Collections.Generic.Dictionary%602>, the capacity is automatically increased as required by reallocating the internal array.  
  
 If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Generic.Dictionary%602>.  
  
 <xref:System.Collections.Generic.Dictionary%602> requires an equality implementation to determine whether keys are equal. This constructor uses the default generic equality comparer, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName>. If type `TKey` implements the <xref:System.IEquatable%601?displayProperty=fullName> generic interface, the default equality comparer uses that implementation. Alternatively, you can specify an implementation of the <xref:System.Collections.Generic.IEqualityComparer%601> generic interface by using a constructor that accepts a `comparer` parameter.  
  
 This constructor is an O\(1\) operation.  
  
   
  
## 例  
 The following code example creates a dictionary with an initial capacity of 4 and populates it with 4 entries.  
  
 [!code-csharp[Generic.Dictionary.ctor\_Int32\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor\_Int32\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">新しい <see cref="T:System.Collections.Generic.IDictionary`2" /> に要素がコピーされた <see cref="T:System.Collections.Generic.Dictionary`2" />。</param>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 実装。キーの型の既定の <see langword="null" /> を使用する場合は <see cref="T:System.Collections.Generic.EqualityComparer`1" />。</param>
        <summary>指定した <see cref="T:System.Collections.Generic.IDictionary`2" /> から要素をコピーして格納し、指定した <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> を使用する、<see cref="T:System.Collections.Generic.Dictionary`2" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use this constructor with the case\-insensitive string comparers provided by the <xref:System.StringComparer> class to create dictionaries with case\-insensitive string keys.  
  
 Every key in a <xref:System.Collections.Generic.Dictionary%602> must be unique according to the specified comparer; likewise, every key in the source **parameterReference tag is not supported!!!!**  
 must also be unique according to the specified comparer.  
  
> [!NOTE]
>  For example, duplicate keys can occur if **parameterReference tag is not supported!!!!**  
>  is one of the case\-insensitive string comparers provided by the <xref:System.StringComparer> class and **parameterReference tag is not supported!!!!**  
>  does not use a case\-insensitive comparer key.  
  
 The initial capacity of the new <xref:System.Collections.Generic.Dictionary%602> is large enough to contain all the elements in **parameterReference tag is not supported!!!!**  
.  
  
 <xref:System.Collections.Generic.Dictionary%602> requires an equality implementation to determine whether keys are equal. If `comparer` is `null`, this constructor uses the default generic equality comparer, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName>. If type `TKey` implements the <xref:System.IEquatable%601?displayProperty=fullName> generic interface, the default equality comparer uses that implementation.  
  
 This constructor is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is the number of elements in **parameterReference tag is not supported!!!!**  
.  
  
   
  
## 例  
 The following code example shows how to use the <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%600%7D%29> constructor to initialize a <xref:System.Collections.Generic.Dictionary%602> with case\-insensitive sorted content from another dictionary. The code example creates a <xref:System.Collections.Generic.SortedDictionary%602> with a case\-insensitive comparer and populates it with data in random order, then passes the <xref:System.Collections.Generic.SortedDictionary%602> to the <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%600%7D%29> constructor, along with a case\-insensitive equality comparer, creating a <xref:System.Collections.Generic.Dictionary%602> that is sorted. This is useful if you need to build a sorted dictionary that at some point becomes static; copying the data from a <xref:System.Collections.Generic.SortedDictionary%602> to a <xref:System.Collections.Generic.Dictionary%602> improves retrieval speed.  
  
> [!NOTE]
>  When you create a new dictionary with a case\-insensitive comparer and populate it with entries from a dictionary that uses a case\-sensitive comparer, as in this example, an exception occurs if the input dictionary has keys that differ only by case.  
  
 [!code-csharp[Generic.Dictionary.ctor\_IDicIEqC\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_IDicIEqC/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor\_IDicIEqC\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_IDicIEqC/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dictionary" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="dictionary" /> には 1 つまたは複数の重複するキーが含まれます。</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (int capacity, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Generic.Dictionary`2" /> が格納できる要素数の初期値。</param>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 実装。キーの型の既定の <see langword="null" /> を使用する場合は <see cref="T:System.Collections.Generic.EqualityComparer`1" />。</param>
        <summary>空で、指定した初期量を備え、指定した <see cref="T:System.Collections.Generic.Dictionary`2" /> を使用する、<see cref="T:System.Collections.Generic.IEqualityComparer`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use this constructor with the case\-insensitive string comparers provided by the <xref:System.StringComparer> class to create dictionaries with case\-insensitive string keys.  
  
 Every key in a <xref:System.Collections.Generic.Dictionary%602> must be unique according to the specified comparer.  
  
 The capacity of a <xref:System.Collections.Generic.Dictionary%602> is the number of elements that can be added to the <xref:System.Collections.Generic.Dictionary%602> before resizing is necessary. As elements are added to a <xref:System.Collections.Generic.Dictionary%602>, the capacity is automatically increased as required by reallocating the internal array.  
  
 If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Generic.Dictionary%602>.  
  
 <xref:System.Collections.Generic.Dictionary%602> requires an equality implementation to determine whether keys are equal. If `comparer` is `null`, this constructor uses the default generic equality comparer, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName>. If type `TKey` implements the <xref:System.IEquatable%601?displayProperty=fullName> generic interface, the default equality comparer uses that implementation.  
  
 This constructor is an O\(1\) operation.  
  
   
  
## 例  
 The following code example creates a <xref:System.Collections.Generic.Dictionary%602> with an initial capacity of 5 and a case\-insensitive equality comparer for the current culture. The example adds four elements, some with lower\-case keys and some with upper\-case keys. The example then attempts to add an element with a key that differs from an existing key only by case, catches the resulting exception, and displays an error message. Finally, the example displays the elements in the dictionary.  
  
 [!code-csharp[Generic.Dictionary.ctor\_Int32IEqC\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32IEqC/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor\_Int32IEqC\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32IEqC/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Dictionary (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> をシリアル化するために必要な情報を格納している <see cref="T:System.Collections.Generic.Dictionary`2" /> オブジェクト。</param>
        <param name="context">
          <see cref="T:System.Collections.Generic.Dictionary`2" /> に関連付けられているシリアル化ストリームの送信元および送信先を格納している <see cref="T:System.Runtime.Serialization.StreamingContext" /> 構造体。</param>
        <summary>シリアル化したデータを使用して、<see cref="T:System.Collections.Generic.Dictionary`2" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This constructor is called during deserialization to reconstitute an object transmitted over a stream. For more information, see [XML and Soap Serialization](http://msdn.microsoft.com/ja-jp/832ac524-21bc-419a-a27b-ca8bfc45840f).  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Runtime.Serialization" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">追加する要素のキー。</param>
        <param name="value">追加する要素の値。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>指定したキーと値をディクショナリに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することも、 <xref:System.Collections.Generic.Dictionary%602.Item%2A> にキーの値を設定して新しい要素を追加するプロパティが存在しない、 <xref:System.Collections.Generic.Dictionary%602>。 たとえば、 `myCollection[myKey] = myValue` \(Visual basic で `myCollection(myKey) = myValue`\)。 ただしで指定したキーが既に存在する場合、 <xref:System.Collections.Generic.Dictionary%602>, で、設定、 <xref:System.Collections.Generic.Dictionary%602.Item%2A> プロパティには、古い値が上書きされます。 これに対し、 <xref:System.Collections.Generic.Dictionary%602.Add%2A>メソッドは、指定したキーに値が既に存在する場合に例外をスローします。  
  
 場合、 <xref:System.Collections.Generic.Dictionary%602.Count%2A> プロパティの値と、容量の容量を既に同じ、 <xref:System.Collections.Generic.Dictionary%602> が増加すると、内部の配列を自動的に再割り当てによって、新しい要素が追加される前に、新しい配列に既存の要素がコピーされたとします。  
  
 キーには `null`, 、値ことができますが場合、 `TValue` は参照型です。  
  
 場合 <xref:System.Collections.Generic.Dictionary%602.Count%2A> が小さい、容量よりもこのメソッドのアプローチ、o \(1\) 操作になります。 新しい要素に対応するには、容量を増やす必要があります、このメソッドが O \(`n`\) 操作、 `n` は <xref:System.Collections.Generic.Dictionary%602.Count%2A>です。  
  
   
  
## 例  
 次のコード例は、空を作成 <xref:System.Collections.Generic.Dictionary%602> 文字列キーと使用された文字列、 <xref:System.Collections.Generic.Dictionary%602.Add%2A> をいくつかの要素を追加するメソッドです。 例を <xref:System.Collections.Generic.Dictionary%602.Add%2A> メソッドがスローされます、 <xref:System.ArgumentException> に重複するキーを追加しようとしています。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.Dictionary%602> クラスです。  
  
 [!code-cpp[Generic.Dictionary\#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#2)]
 [!code-csharp[Generic.Dictionary\#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#2)]
 [!code-vb[Generic.Dictionary\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">同じキーを持つ要素が、<see cref="T:System.Collections.Generic.Dictionary`2" /> に既に存在します。</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> からすべてのキーと値を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.Dictionary%602.Count%2A> プロパティは 0 に設定され、コレクションの要素からその他のオブジェクトへの参照も解放します。 容量は変更されません。  
  
 このメソッドは O \(`n`\) 操作、場所 `n` ディクショナリの容量です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ディクショナリのキーが等しいかどうかを確認するために使用する <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> を取得します。</summary>
        <value>現在の <see cref="T:System.Collections.Generic.Dictionary`2" /> のキーが等しいかどうかを確認し、キーのハッシュ値を提供するために使用する <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> ジェネリック インターフェイスの実装。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.Dictionary%602> キーが等しいかどうかを判断するための等値実装が必要です。 実装を指定する、 <xref:System.Collections.Generic.IEqualityComparer%601> ジェネリック インターフェイスを受け取るコンス トラクターを使用して、 `comparer` パラメーター; かどうかを指定しない、既定のジェネリック等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> を使用します。  
  
 このプロパティの値の取得は、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Collections.Generic.Dictionary`2" /> 内で検索されるキー。</param>
        <summary>指定したキーが <see cref="T:System.Collections.Generic.Dictionary`2" /> に格納されているかどうかを判断します。</summary>
        <returns>指定したキーを持つ要素が <see langword="true" /> に格納されている場合は <see cref="T:System.Collections.Generic.Dictionary`2" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method approaches an O\(1\) operation.  
  
   
  
## 例  
 The following code example shows how to use the <xref:System.Collections.Generic.Dictionary%602.ContainsKey%2A> method to test whether a key exists prior to calling the <xref:System.Collections.Generic.Dictionary%602.Add%2A> method. It also shows how to use the <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> method to retrieve values, which is an efficient way to retrieve values when a program frequently tries keys that are not in the dictionary. Finally, it shows the least efficient way to test whether keys exist, by using the <xref:System.Collections.Generic.Dictionary%602.Item%2A> property \(the indexer in C\#\).  
  
 This code example is part of a larger example provided for the <xref:System.Collections.Generic.Dictionary%602> class \(`openWith` is the name of the Dictionary used in this example\).  
  
 [!code-cpp[Generic.Dictionary#6](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#6)]
 [!code-csharp[Generic.Dictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#6)]
 [!code-vb[Generic.Dictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#6)]  
[!code-cpp[Generic.Dictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.Dictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#5)]
[!code-vb[Generic.Dictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#5)]  
[!code-cpp[Generic.Dictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.Dictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.ContainsValue(`1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Collections.Generic.Dictionary`2" /> 内で検索される値。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> に特定の値が格納されているかどうかを判断します。</summary>
        <returns>指定した値を持つ要素が <see langword="true" /> に格納されている場合は <see cref="T:System.Collections.Generic.Dictionary`2" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for **parameterReference tag is not supported!!!!**  
, the type of values in the dictionary.  
  
 This method performs a linear search; therefore, the average execution time is proportional to <xref:System.Collections.Generic.Dictionary%602.Count%2A>. That is, this method is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> に格納されているキー\/値ペアの数を取得します。</summary>
        <value>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> に格納されているキー\/値ペアの数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The capacity of a <xref:System.Collections.Generic.Dictionary%602> is the number of elements that the <xref:System.Collections.Generic.Dictionary%602> can store. The <xref:System.Collections.Generic.Dictionary%602.Count%2A> property is the number of elements that are actually in the <xref:System.Collections.Generic.Dictionary%602>.  
  
 The capacity is always greater than or equal to <xref:System.Collections.Generic.Dictionary%602.Count%2A>. If <xref:System.Collections.Generic.Dictionary%602.Count%2A> exceeds the capacity while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements.  
  
 Getting the value of this property is an O\(1\) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Dictionary`2/Enumerator&lt;!TKey, !TValue&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> を反復処理する列挙子を返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> の <see cref="T:System.Collections.Generic.Dictionary`2.Enumerator" /> 構造体。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 列挙のために、各項目は、 <xref:System.Collections.Generic.KeyValuePair%602> 値とそのキーを表す構造体。  
  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 この位置では、 <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> プロパティが定義されています。 そのため、呼び出す必要があります、 <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> メソッドの値を読み取る前にコレクションの最初の要素を列挙子を進める <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A>します。  
  
> [!NOTE]
>  パフォーマンスを向上させるには、このプロパティによって返された列挙子は例外をスローしません最初の要素の前に、または最後の要素の後に配置されている場合、 <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> ; プロパティへのアクセスの値、 <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> プロパティが定義されていません。  
  
 <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> まで同じ要素を返します、 <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> メソッドが呼び出されます。<xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> は、<xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> は定義されていません。<xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> を、再度、コレクションの最初の要素に設定することはできません。列挙子の新しいインスタンスを作成する必要があります。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.Generic?displayProperty=fullName> 名前空間のコレクションの既定の実装は同期されません。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Dictionary`2.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> インスタンスをシリアル化するために必要な情報を格納する <see cref="T:System.Collections.Generic.Dictionary`2" /> オブジェクト。</param>
        <param name="context">
          <see cref="T:System.Collections.Generic.Dictionary`2" /> インスタンスに関連付けられているシリアル化ストリームの転送元および転送先を格納する <see cref="T:System.Runtime.Serialization.StreamingContext" /> 構造体。</param>
        <summary>
          <see cref="T:System.Runtime.Serialization.ISerializable" /> インターフェイスを実装し、<see cref="T:System.Collections.Generic.Dictionary`2" /> インスタンスをシリアル化するために必要なデータを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.Dictionary%602.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for providing serialization services. Associated enumeration:   <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /> Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Generic.Dictionary`2.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Item(`0)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">取得または設定する値のキー。</param>
        <summary>指定されたキーに関連付けられている値を取得または設定します。</summary>
        <value>指定されたキーに関連付けられている値。 指定したキーが見つからなかった場合、get 操作は <see cref="T:System.Collections.Generic.KeyNotFoundException" /> をスローし、set 操作は指定したキーを持つ新しい要素を作成します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、次の c\# の構文を使用して、コレクション内の特定の要素にアクセスする機能を提供します。 `myCollection[key]` \(`myCollection(key)` Visual Basic で\)。  
  
 使用することも、 <xref:System.Collections.Generic.Dictionary%602.Item%2A> にキーの値を設定して新しい要素を追加するプロパティが存在しない、 <xref:System.Collections.Generic.Dictionary%602>です。 キーがである場合に、プロパティの値を設定すると、 <xref:System.Collections.Generic.Dictionary%602>, 、そのキーに関連付けられている値は、割り当てられた値で置き換えられます。 キーに含まれていない場合、 <xref:System.Collections.Generic.Dictionary%602>, 、キーと値をディクショナリに追加します。 これに対し、 <xref:System.Collections.Generic.Dictionary%602.Add%2A> メソッドでは、既存の要素は変更しません。  
  
 キーには `null`, 、ですが、値を入力する場合の値が `TValue` は参照型です。  
  
 C\# 言語キーワードを使用して実装する代わりに、インデクサーの定義、 <xref:System.Collections.Generic.Dictionary%602.Item%2A> プロパティです。 Visual Basic は、<xref:System.Collections.Generic.Dictionary%602.Item%2A> を既定のプロパティとして実装しており、同様のインデックス機能を提供します。  
  
 このプロパティの値の設定を取得または o \(1\) 操作に近くなります。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Collections.Generic.Dictionary%602.Item%2A> プロパティ \(c\# のインデクサー\) を示す値を取得する、 <xref:System.Collections.Generic.KeyNotFoundException> を示す値をキーに関連付けられていることを置き換えることが要求されたキーが存在しない場合にスローされます。  
  
 使用する方法も示します、 <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> メソッドとしてより効率的値を取得する場合は、プログラムは多くの場合、ディクショナリに含まれていないキーの値を試行する必要があります。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.Dictionary%602> クラスです。`openWith` この例で使用されるディクショナリの名前です。  
  
 [!code-cpp[Generic.Dictionary#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#2)]
 [!code-csharp[Generic.Dictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#2)]
 [!code-vb[Generic.Dictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#2)]  
[!code-cpp[Generic.Dictionary#3](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#3)]
[!code-csharp[Generic.Dictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#3)]
[!code-vb[Generic.Dictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#3)]  
[!code-cpp[Generic.Dictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.Dictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#4)]  
[!code-cpp[Generic.Dictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.Dictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#5)]
[!code-vb[Generic.Dictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">プロパティが取得され、<paramref name="key" /> がコレクションに存在しません。</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;.KeyCollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.Dictionary`2/KeyCollection&lt;!TKey, !TValue&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;+KeyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> 内のキーを格納しているコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection" /> 内のキーを格納している <see cref="T:System.Collections.Generic.Dictionary`2" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内のキーの順序、 <xref:System.Collections.Generic.Dictionary%602.KeyCollection> は指定しませんが、関連付けられている値と同じ順序、 <xref:System.Collections.Generic.Dictionary%602.ValueCollection> によって返される、 <xref:System.Collections.Generic.Dictionary%602.Values%2A> プロパティです。  
  
 返された <xref:System.Collections.Generic.Dictionary%602.KeyCollection> 静的コピーではありません。 代わりに、 <xref:System.Collections.Generic.Dictionary%602.KeyCollection> は元のキーを逆参照 <xref:System.Collections.Generic.Dictionary%602>します。 そのため、変更、 <xref:System.Collections.Generic.Dictionary%602> に反映されるまでに続行、 <xref:System.Collections.Generic.Dictionary%602.KeyCollection>です。  
  
 このプロパティの値の取得は、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例を使用して、ディクショナリ内のキーを列挙する方法を示しています、 <xref:System.Collections.Generic.Dictionary%602.Keys%2A> プロパティ、およびキーとディクショナリ内の値を列挙する方法です。  
  
 このコード例をコンパイルして実行できるは \(`openWith` この例で使用されるディクショナリの名前を指定します\)。 「<xref:System.Collections.Generic.Dictionary%602>」を参照してください。  
  
 [!code-cpp[Generic.Dictionary#9](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#9)]
 [!code-csharp[Generic.Dictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#9)]
 [!code-vb[Generic.Dictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#9)]  
[!code-cpp[Generic.Dictionary#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#7)]
[!code-csharp[Generic.Dictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Dictionary`2.KeyCollection" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.OnDeserialization(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">逆シリアル化イベントのソース。</param>
        <summary>
          <see cref="T:System.Runtime.Serialization.ISerializable" /> インターフェイスを実装し、逆シリアル化が完了したときに逆シリアル化イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.Dictionary%602.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクトに現在関連付けられている <see cref="T:System.Collections.Generic.Dictionary`2" /> インスタンスが無効です。</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Generic.Dictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Remove(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">削除する要素のキー。</param>
        <summary>指定したキーを持つ値を <see cref="T:System.Collections.Generic.Dictionary`2" /> から削除します。</summary>
        <returns>要素が見つかり、正常に削除された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。  このメソッドは、<paramref name="key" /> が <see cref="T:System.Collections.Generic.Dictionary`2" /> に見つからない場合、<see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Collections.Generic.Dictionary%602> 指定のキーを持つ要素が含まれていない、 <xref:System.Collections.Generic.Dictionary%602> は変更されません。 例外をスローすることはありません。  
  
 このメソッドは、o \(1\) 操作に近くなります。  
  
   
  
## 例  
 次のコード例を使用して、ディクショナリからキー\/値ペアを削除する方法を示しています、 <xref:System.Collections.Generic.Dictionary%602.Remove%2A> メソッドです。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.Dictionary%602> クラス \(`openWith` この例で使用されるディクショナリの名前を指定します\)。  
  
 [!code-cpp[Generic.Dictionary\#10](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#10)]
 [!code-csharp[Generic.Dictionary\#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#10)]
 [!code-vb[Generic.Dictionary\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Remove(`0,`1@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Collections.Generic.ICollection`1" /> から要素がコピーされる 1 次元の配列。 配列には、0 から始まるインデックスが設定されている必要があります。</param>
        <param name="index">コピーの開始位置とする <c>array</c> のインデックス \(0 から始まる\)。</param>
        <summary>指定した配列インデックスを開始位置として、配列に <see cref="T:System.Collections.Generic.ICollection`1" /> の要素をコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各要素からコピーした、 <xref:System.Collections.Generic.Dictionary%602> は、 <xref:System.Collections.Generic.KeyValuePair%602> 値とそのキーを表す構造体。  
  
> [!NOTE]
>  場合、ソースの種類 <xref:System.Collections.ICollection> 変換先の型に自動的にキャストすることはできません `array`, の非ジェネリックの実装 <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=fullName> スロー、 <xref:System.InvalidCastException>, 、汎用的な実装がスロー、 <xref:System.ArgumentException>です。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.Dictionary%602.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  
  
 または  
  
 <paramref name="array" /> には、0 から始まるインデックス番号がありません。  
  
 または  
  
 ソース内の要素の数 <see cref="T:System.Collections.Generic.ICollection`1" /> から使用可能な領域よりも大きい <paramref name="index" /> 変換先の末尾に <paramref name="array" />します。  
  
 または  
  
 ソースの種類 <see cref="T:System.Collections.Generic.ICollection`1" /> 先の型に自動的にキャストできない <paramref name="array" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> へのアクセスが同期されている \(スレッド セーフである\) かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> へのアクセスが同期されている \(スレッド セーフである\) 場合は <see cref="T:System.Collections.ICollection" />。それ以外の場合は <see langword="false" />。<see cref="T:System.Collections.Generic.Dictionary`2" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic?displayProperty=fullName> 名前空間のコレクションの既定の実装は同期されません。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションが同期されている場合でも、他のスレッドも変更できます、コレクションは、列挙子は例外をスローする可能性があります。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> プロパティへのアクセスを同期に使用できるオブジェクトを返す、 <xref:System.Collections.ICollection>です。 同期は、すべてのスレッドがコレクションにアクセスする前に、オブジェクトをロックする場合のみ有効です。  
  
 このプロパティの値の取得は、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> へのアクセスを同期するために使用できるオブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> へのアクセスを同期するために使用できるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic?displayProperty=fullName> 名前空間のコレクションの既定の実装は同期されません。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>プロパティへのアクセスを同期するために使用できるオブジェクトを返します、<xref:System.Collections.ICollection>です。 同期は、すべてのスレッドがコレクションにアクセスする前に、オブジェクトをロックする場合のみ有効です。 次のコードの使用を示しています、 <xref:System.Collections.ICollection.SyncRoot%2A> c\#、C\+\+、および Visual Basic のプロパティです。  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 このプロパティの値を取得するは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">キーとして使用するオブジェクト。</param>
        <param name="value">値として使用するオブジェクト。</param>
        <summary>指定したキーと値をディクショナリに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することも、 <xref:System.Collections.IDictionary.Item%2A> ディクショナリに存在しないキーの値を設定して新しい要素を追加するプロパティなど `myCollection["myNonexistentKey"] = myValue`します。 ただし、ディクショナリで指定したキーが既に存在する場合は、設定、 <xref:System.Collections.IDictionary.Item%2A> プロパティには、古い値が上書きされます。 これに対し、 <xref:System.Collections.IDictionary.Add%2A> メソッドは、指定したキーが既に存在する場合に例外をスローします。  
  
 場合 <xref:System.Collections.Generic.Dictionary%602.Count%2A> が小さい、容量よりもこのメソッドのアプローチ、o \(1\) 操作になります。 容量は、新しい要素を格納するためにする必要がある、このメソッドが O \(`n`\) 操作、 `n` は <xref:System.Collections.Generic.Dictionary%602.Count%2A>です。  
  
   
  
## 例  
 次のコード例へのアクセス方法を示しています、 <xref:System.Collections.Generic.Dictionary%602> クラスを通じて、 <xref:System.Collections.IDictionary?displayProperty=fullName> インターフェイスです。 このコード例は、空を作成 <xref:System.Collections.Generic.Dictionary%602> 文字列を使用して文字列のキーの <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> をいくつかの要素を追加するメソッドです。 例を <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> メソッドでのスロー、 <xref:System.ArgumentException> キーまたは無効なデータ型の値が指定されている場合または重複するキーを追加しようとしています。  
  
 コード例では他のメンバーは、いくつかの使用、 <xref:System.Collections.IDictionary?displayProperty=fullName> インターフェイスです。  
  
 [!code-csharp[Generic.Dictionary.IDictionary\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.IDictionary\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> キーの型に割り当てることがない場合、型の <paramref name="TKey" /> の <see cref="T:System.Collections.Generic.Dictionary`2" />です。  
  
 または  
  
 <paramref name="value" /> 型に割り当てることができませんが <paramref name="TValue" />, の値の型、 <see cref="T:System.Collections.Generic.Dictionary`2" />です。  
  
 または  
  
 既に存在すると同じキー値、 <see cref="T:System.Collections.Generic.Dictionary`2" />です。</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Collections.IDictionary" /> 内で検索されるキー。</param>
        <summary>指定したキーの要素が <see cref="T:System.Collections.IDictionary" /> に格納されているかどうかを確認します。</summary>
        <returns>指定したキーを持つ要素が <see langword="true" /> に格納されている場合は <see cref="T:System.Collections.IDictionary" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る `false` 場合 `key` がキーの種類に割り当てることがない型の `TKey` の <xref:System.Collections.Generic.Dictionary%602>です。  
  
 このメソッドは、o \(1\) 操作に近くなります。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Contains%2A> のメソッド、 <xref:System.Collections.IDictionary?displayProperty=fullName> とのインターフェイス、 <xref:System.Collections.Generic.Dictionary%602>です。 例が、メソッドを返す `false` 場合は無効なデータ型のキーを指定します。  
  
 指定された出力を含むサンプルが大きくのコード例は、 <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> メソッドです。  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#6)]
[!code-vb[Generic.Dictionary.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> の <see cref="T:System.Collections.IDictionary" /> を返します。</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> の <see cref="T:System.Collections.IDictionary" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 列挙のために、各項目は、 <xref:System.Collections.Generic.KeyValuePair%602> 値とそのキーを表す構造体。  
  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。<xref:System.Collections.IEnumerator.Reset%2A> メソッドがこの位置に戻さも、列挙子を表示します。  この位置では、 <xref:System.Collections.IDictionaryEnumerator.Entry%2A> プロパティが定義されています。 そのため、呼び出す必要があります、 <xref:System.Collections.IEnumerator.MoveNext%2A> メソッドの値を読み取る前にコレクションの最初の要素を列挙子を進める <xref:System.Collections.IDictionaryEnumerator.Entry%2A>します。  
  
 <xref:System.Collections.IDictionaryEnumerator.Entry%2A> プロパティでは、同じ要素を返しますまで、 <xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> メソッドが呼び出されます。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IDictionaryEnumerator.Entry%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.IDictionaryEnumerator.Entry%2A> は定義されていません。<xref:System.Collections.IDictionaryEnumerator.Entry%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.Generic?displayProperty=fullName> 名前空間のコレクションの既定の実装は同期されません。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例を使用して、ディクショナリのキー\/値ペアを列挙する方法を示しています、 `foreach` ステートメント \(`For Each` Visual basic で `for each` C\+\+ で\)、列挙子の使用が隠ぺいされます。 具体的には、注意してくださいの列挙子、 <xref:System.Collections.IDictionary?displayProperty=fullName> インターフェイスを返します。 <xref:System.Collections.DictionaryEntry> オブジェクトではなく <xref:System.Collections.Generic.KeyValuePair%602> オブジェクトです。  
  
 指定された出力を含むサンプルが大きくのコード例は、 <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> メソッドです。  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.IDictionary" /> が固定サイズかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が固定サイズの場合は <see cref="T:System.Collections.IDictionary" />。それ以外の場合は <see langword="false" />。<see cref="T:System.Collections.Generic.Dictionary`2" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 固定サイズのコレクションでは、コレクションの作成後に要素の追加または削除はできませんが、既存の要素の変更はできます。  
  
 固定サイズのコレクションは、コレクションの追加と要素の削除を防止するラッパーです。そのため、追加または削除、要素を含む、基になるコレクションに変更が加えられた場合、固定サイズ コレクションにはそれらの変更が反映されます。  
  
 このプロパティの値の取得は、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.IDictionary" /> が読み取り専用かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> が読み取り専用である場合は <see cref="T:System.Collections.IDictionary" />。それ以外の場合は <see langword="false" />。<see cref="T:System.Collections.Generic.Dictionary`2" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 読み取り専用のコレクションでは、コレクション作成後に要素の追加、削除、または変更はできません。  
  
 読み取り専用であるコレクションは、コレクションのコレクションの変更を防止するラッパーです。そのため、基になるコレクションの変更が加えられた、読み取り専用コレクションはそれらの変更を反映します。  
  
 このプロパティの値の取得は、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">取得する値のキー。</param>
        <summary>指定したキーの値を取得または設定します。</summary>
        <value>指定したキーに関連付けられた値。ただし、<paramref name="key" /> がディクショナリにない場合、または <paramref name="key" /> が <see cref="T:System.Collections.Generic.Dictionary`2" /> のキー型 <paramref name="TKey" /> に割り当てられない型である場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、次の c\# の構文を使用して、コレクション内の特定の値にアクセスする機能を提供します。 `myCollection[key]` \(`myCollection(key)` Visual Basic で\)。  
  
 使用することも、 <xref:System.Collections.IDictionary.Item%2A> ; ディクショナリに存在しないキーの値を設定して新しい要素を追加するプロパティなど、`myCollection["myNonexistentKey"] = myValue`です。 ただし、ディクショナリ内で指定したキーが既に存在する場合は、設定、<xref:System.Collections.IDictionary.Item%2A>プロパティに古い値が上書きされます。 これに対し、<xref:System.Collections.IDictionary.Add%2A>メソッドでは、既存の要素は変更しません。  
  
 C\# 言語を使用して、[この](http://msdn.microsoft.com/ja-jp/d4f827fe-4710-410b-89b8-867dad44b8a3)キーワードを実装する代わりに、インデクサーの定義、<xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A>プロパティです。 Visual Basic は、<xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A> を既定のプロパティとして実装しており、同様のインデックス機能を提供します。  
  
 このプロパティの値の設定を取得または o \(1\) 操作に近くなります。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、<xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A>のプロパティ \(c\# のインデクサー\)、<xref:System.Collections.IDictionary?displayProperty=fullName>とのインターフェイス、 <xref:System.Collections.Generic.Dictionary%602>、およびプロパティが異なる方法、<xref:System.Collections.Generic.Dictionary%602.Item%2A?displayProperty=fullName>プロパティです。  
  
 同様に、例、<xref:System.Collections.Generic.Dictionary%602.Item%2A?displayProperty=fullName>プロパティ、<xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=fullName>プロパティが既存のキーに関連付けられている値を変更でき、指定したキーがディクショナリにない場合は、新しいキー\/値ペアを追加するために使用できます。 示しますとは異なり、<xref:System.Collections.Generic.Dictionary%602.Item%2A?displayProperty=fullName>プロパティ、<xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=fullName>場合に、プロパティが例外をスローしません`key`がディクショナリで返されない、null 参照代わりにします。 最後に、この例は、取得、<xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=fullName>場合、プロパティが null 参照を返します`key`正しいデータ型ではないと、プロパティの設定は例外をスロー`key`正しいデータ型ではありません。  
  
 コード例は、指定された出力を含む例の一部、<xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A>メソッドです。  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#3)]
[!code-vb[Generic.Dictionary.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.Dictionary.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">値が割り当てられている、および<paramref name="key" />のキー型に割り当てることはできません型<paramref name="TKey" />の<see cref="T:System.Collections.Generic.Dictionary`2" />です。  
  
 または  
  
 値が割り当てられている、および<paramref name="value" />の値の型に割り当てることはできません型<paramref name="TValue" />の<see cref="T:System.Collections.Generic.Dictionary`2" />です。</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> のキーを保持している <see cref="T:System.Collections.IDictionary" /> を取得します。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> のキーを保持している <see cref="T:System.Collections.IDictionary" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された内のキーの順序<xref:System.Collections.ICollection>は指定しませんが、対応する値と同じ順序である保証は、<xref:System.Collections.ICollection>によって返される、<xref:System.Collections.IDictionary.Values%2A>プロパティです。  
  
 このプロパティの値を取得するは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、<xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Keys%2A>プロパティの<xref:System.Collections.IDictionary?displayProperty=fullName>とのインターフェイス、<xref:System.Collections.Generic.Dictionary%602>ディクショナリのキーを一覧表示します。 ディクショナリ内のキー\/値ペアを列挙する方法も示しますなおの列挙子、<xref:System.Collections.IDictionary?displayProperty=fullName>インターフェイスを返します<xref:System.Collections.DictionaryEntry>オブジェクトなく<xref:System.Collections.Generic.KeyValuePair%602>オブジェクト。  
  
 コード例は、指定された出力を含む例の一部、<xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A>メソッドです。  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#9)]
[!code-vb[Generic.Dictionary.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.Dictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">削除する要素のキー。</param>
        <summary>指定したキーを持つ要素を <see cref="T:System.Collections.IDictionary" /> から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、o \(1\) 操作に近くなります。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Remove%2A> の <xref:System.Collections.IDictionary?displayProperty=fullName> とのインターフェイス、 <xref:System.Collections.Generic.Dictionary%602>です。  
  
 指定された出力を含むサンプルが大きくのコード例は、 <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> メソッドです。  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#10)]
[!code-vb[Generic.Dictionary.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#10)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> 内の値を格納している <see cref="T:System.Collections.IDictionary" /> を取得します。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> 内の値を格納している <see cref="T:System.Collections.IDictionary" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返される値の順序<xref:System.Collections.ICollection>は指定しませんが、内の対応するキーと同じ順序である保証は、<xref:System.Collections.ICollection>によって返される、<xref:System.Collections.IDictionary.Keys%2A>プロパティです。  
  
 このプロパティの値を取得するは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、<xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Values%2A>プロパティの<xref:System.Collections.IDictionary?displayProperty=fullName>とのインターフェイス、<xref:System.Collections.Generic.Dictionary%602>ディクショナリ内の値を一覧表示します。 ディクショナリ内のキー\/値ペアを列挙する方法も示しますなおの列挙子、<xref:System.Collections.IDictionary?displayProperty=fullName>インターフェイスを返します<xref:System.Collections.DictionaryEntry>オブジェクトなく<xref:System.Collections.Generic.KeyValuePair%602>オブジェクト。  
  
 コード例は、指定された出力を含む例の一部、<xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A>メソッドです。  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#8)]
[!code-vb[Generic.Dictionary.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.Dictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションを反復処理する列挙子を返します。</summary>
        <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 列挙のために、各項目は、 <xref:System.Collections.Generic.KeyValuePair%602> 値とそのキーを表す構造体。  
  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。<xref:System.Collections.IEnumerator.Reset%2A> メソッドがこの位置に戻さも、列挙子を表示します。  この位置では、 <xref:System.Collections.IEnumerator.Current%2A> プロパティが定義されています。 そのため、呼び出す必要があります、 <xref:System.Collections.IEnumerator.MoveNext%2A> メソッドの値を読み取る前にコレクションの最初の要素を列挙子を進める <xref:System.Collections.IEnumerator.Current%2A>します。  
  
> [!NOTE]
>  パフォーマンスを向上させるには、このプロパティによって返された列挙子は例外をスローしません最初の要素の前に、または最後の要素の後に配置されている場合、 <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> ; プロパティへのアクセスの値、 <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> プロパティが定義されていません。  
  
 <xref:System.Collections.IEnumerator.Current%2A> プロパティでは、同じ要素を返しますまで、 <xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> メソッドが呼び出されます。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.IEnumerator.Current%2A> は定義されていません。<xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子には、コレクションへの排他アクセスがありません。したがって、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.Generic?displayProperty=fullName> 名前空間のコレクションの既定の実装は同期されません。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.TryAdd(`0,`1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">取得する値のキー。</param>
        <param name="value">このメソッドから制御が戻るときに、キーが見つかった場合は、指定したキーに関連付けられている値が格納されます。それ以外の場合は <c>value</c> パラメーターの型に対する既定の値です。 このパラメーターは初期化せずに渡されます。</param>
        <summary>指定したキーに関連付けられている値を取得します。</summary>
        <returns>指定したキーを持つ要素が <see langword="true" /> に格納されている場合は <see cref="T:System.Collections.Generic.Dictionary`2" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドには、機能が組み合わされて、 <xref:System.Collections.Generic.Dictionary%602.ContainsKey%2A> メソッドおよび <xref:System.Collections.Generic.Dictionary%602.Item%2A> プロパティです。  
  
 キーが見つからない場合、 `value` パラメーター型の適切な既定値を取得する `TValue`; たとえば、整数型の 0 \(ゼロ\) `false` Boolean 型用と `null` 参照型です。  
  
 使用して、 <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> メソッドの場合は、ディクショナリに含まれていないキーにアクセスするコードを頻繁に試行します。 キャッチするよりも効率的ではこのメソッドを使用して、 <xref:System.Collections.Generic.KeyNotFoundException> によってスローされた、 <xref:System.Collections.Generic.Dictionary%602.Item%2A> プロパティです。  
  
 このメソッドは、o \(1\) 操作に近くなります。  
  
   
  
## 例  
 例では、使用する方法を示しています、 <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> メソッドとしてより効率的に頻繁にディクショナリに含まれていないキーを試行するプログラムで値を取得します。 これに対しても示していますが、どのように <xref:System.Collections.Generic.Dictionary%602.Item%2A> プロパティ \(c\# のインデクサー\) が存在しないキーを取得中に、例外をスローします。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.Dictionary%602> クラス \(`openWith` この例で使用されるディクショナリの名前を指定します\)。  
  
 [!code-cpp[Generic.Dictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#5)]
 [!code-csharp[Generic.Dictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#5)]
 [!code-vb[Generic.Dictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#5)]  
[!code-cpp[Generic.Dictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.Dictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;.ValueCollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.Dictionary`2/ValueCollection&lt;!TKey, !TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;+ValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> 内の値を格納しているコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Collections.Generic.Dictionary`2.ValueCollection" /> 内の値を格納している <see cref="T:System.Collections.Generic.Dictionary`2" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.Dictionary%602.ValueCollection> 内の値の順序は指定されていませんが、<xref:System.Collections.Generic.Dictionary%602.KeyCollection> プロパティによって返される <xref:System.Collections.Generic.Dictionary%602.Keys%2A> 内の関連するキーと同じ順序です。  
  
 返された <xref:System.Collections.Generic.Dictionary%602.ValueCollection> 静的コピーではありません。 代わりに、 <xref:System.Collections.Generic.Dictionary%602.ValueCollection> は元の値を逆参照 <xref:System.Collections.Generic.Dictionary%602>します。 そのため、変更、 <xref:System.Collections.Generic.Dictionary%602> に反映されるまでに続行、 <xref:System.Collections.Generic.Dictionary%602.ValueCollection>です。  
  
 このプロパティの値の取得は、o \(1\) 操作です。  
  
   
  
## 例  
 このコード例を使用して、ディクショナリ内の値を列挙する方法を示しています、 <xref:System.Collections.Generic.Dictionary%602.Values%2A> プロパティ、およびキーとディクショナリ内の値を列挙する方法です。  
  
 このコード例が示されている例の一部は、 <xref:System.Collections.Generic.Dictionary%602> クラス \(`openWith` この例で使用されるディクショナリの名前を指定します\)。  
  
 [!code-cpp[Generic.Dictionary#8](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#8)]
 [!code-csharp[Generic.Dictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#8)]
 [!code-vb[Generic.Dictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#8)]  
[!code-cpp[Generic.Dictionary#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#7)]
[!code-csharp[Generic.Dictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Dictionary`2.ValueCollection" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Keys" />
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>