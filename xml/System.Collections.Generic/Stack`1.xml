<Type Name="Stack&lt;T&gt;" FullName="System.Collections.Generic.Stack&lt;T&gt;">
  <TypeSignature Language="C#" Value="public class Stack&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Stack`1" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_StackDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">スタック内の要素の型を指定します。</typeparam>
    <summary>指定した同じ型のインスタンスの、後入れ先出し \(LIFO\) の可変サイズのコレクションを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.Stack%601> 配列として実装されます。  
  
 スタックやキューは便利ですが必要な一時記憶域の情報つまり、可能性がありますをする場合、値を取得した後でその要素を破棄します。 使用 <xref:System.Collections.Generic.Queue%601> かどうかには、コレクションに格納される順序と同じ順序での情報にアクセスする必要があります。 使用 <xref:System.Collections.Generic.Stack%601?displayProperty=fullName> 逆の順序で、情報にアクセスする必要がある場合。  
  
 使用して、 <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=fullName> と <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=fullName> 型の場合、同時に複数のスレッドからコレクションにアクセスする必要があります。  
  
 一般的な用途 <xref:System.Collections.Generic.Stack%601?displayProperty=fullName> を他のプロシージャの呼び出し時に変数の状態を維持しています。  
  
 次の 3 つの主要な操作を実行できる、 <xref:System.Collections.Generic.Stack%601?displayProperty=fullName> とその要素。  
  
-   <xref:System.Collections.Generic.Stack%601.Push%2A> 上部にある要素を挿入、 <xref:System.Collections.Stack>です。  
  
-   <xref:System.Collections.Generic.Stack%601.Pop%2A> 先頭から要素を削除、 <xref:System.Collections.Generic.Stack%601>です。  
  
-   <xref:System.Collections.Generic.Stack%601.Peek%2A> 上部にある要素を返す、 <xref:System.Collections.Generic.Stack%601> からは削除されませんが、 <xref:System.Collections.Generic.Stack%601>です。  
  
 容量、 <xref:System.Collections.Generic.Stack%601> 要素の数が、 <xref:System.Collections.Generic.Stack%601> を保持できます。 要素が追加されると、 <xref:System.Collections.Generic.Stack%601>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>です。  
  
 場合 <xref:System.Collections.Generic.Stack%601.Count%2A> が、スタックの容量よりも小さい <xref:System.Collections.Generic.Stack%601.Push%2A> o \(1\) 操作です。 容量は、新しい要素を格納するために必要がある場合 <xref:System.Collections.Generic.Stack%601.Push%2A> O になります \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.Stack%601.Count%2A>です。<xref:System.Collections.Generic.Stack%601.Pop%2A> o \(1\) 操作です。  
  
 <xref:System.Collections.Generic.Stack%601> 受け入れる `null` 参照の有効な値型し、重複する要素を使用します。  
  
   
  
## 例  
 次のコード例をいくつかの方法を示しています、 <xref:System.Collections.Generic.Stack%601> ジェネリック クラスです。 このコード例は、既定の容量を持つ文字列のスタックを作成し、使用して、 <xref:System.Collections.Generic.Stack%601.Push%2A> 5 つの文字列をスタックにプッシュします。 スタックの要素が表示され、スタックの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Stack%601.Pop%2A> メソッドを使用して、最初の文字列をスタックからポップします。<xref:System.Collections.Generic.Stack%601.Peek%2A> メソッドを使用して、スタックの次の項目を確認し、 <xref:System.Collections.Generic.Stack%601.Pop%2A> ポップ オフ メソッドを使用します。  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> 配列を作成し、スタックの要素をコピーするメソッドを使用して、配列に渡されます、 <xref:System.Collections.Generic.Stack%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、逆に、要素の順序でスタックのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、スタックのサイズが作成、および <xref:System.Collections.Generic.Stack%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Stack%601.%23ctor%2A> コンス トラクターは要素を逆の順序でスタックのコピーを作成するにはもう一度使用されます。 したがって、次の 3 つの null 要素は末尾にあります。  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> メソッドを使用して、表示するまで、スタックの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Stack%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Stack%601.Count%2A> スタックが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 \(<see langword="Shared" /> Visual Basic では\) この型のメンバーは、スレッド セーフであります。 インスタンス メンバーの場合は、スレッド セーフであるとは限りません。  
  
 A <see cref="T:System.Collections.Generic.Stack`1" /> コレクションが変更されない限り、複数のリーダーを同時にサポートできます。  それでも、コレクションの列挙は、本質的には、スレッド セーフなプロシージャでは。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>空で、既定の初期量を備えた、<see cref="T:System.Collections.Generic.Stack`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 容量、 <xref:System.Collections.Generic.Stack%601> は要素の数を <xref:System.Collections.Generic.Stack%601> を保持できます。 要素が追加されると、 <xref:System.Collections.Generic.Stack%601>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.Generic.Stack%601>です。  
  
 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>です。  
  
 このコンス トラクターは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、このコンス トラクターのいくつかの方法、 <xref:System.Collections.Generic.Stack%601> ジェネリック クラスです。  
  
 このコード例は、既定の容量を持つ文字列のスタックを作成し、使用して、 <xref:System.Collections.Generic.Stack%601.Push%2A> 5 つの文字列をスタックにプッシュします。 スタックの要素が表示され、スタックの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Stack%601.Pop%2A> メソッドを使用して、最初の文字列をスタックからポップします。<xref:System.Collections.Generic.Stack%601.Peek%2A> メソッドを使用して、スタックの次の項目を確認し、 <xref:System.Collections.Generic.Stack%601.Pop%2A> ポップ オフ メソッドを使用します。  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> 配列を作成し、スタックの要素をコピーするメソッドを使用して、配列に渡されます、 <xref:System.Collections.Generic.Stack%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、逆に、要素の順序でスタックのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、スタックのサイズが作成、および <xref:System.Collections.Generic.Stack%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Stack%601.%23ctor%2A> コンス トラクターは要素を逆の順序でスタックのコピーを作成するにはもう一度使用されます。 したがって、次の 3 つの null 要素は末尾にあります。  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> メソッドを使用して、表示するまで、スタックの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Stack%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Stack%601.Count%2A> スタックが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">要素のコピー元のコレクション。</param>
        <summary>指定したコレクションからコピーした要素を格納し、コピーされる要素の数を格納できるだけの容量を備えた、<see cref="T:System.Collections.Generic.Stack`1" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 容量、 <xref:System.Collections.Generic.Stack%601> は要素の数を <xref:System.Collections.Generic.Stack%601> を保持できます。 要素が追加されると、 <xref:System.Collections.Generic.Stack%601>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.Generic.Stack%601>です。  
  
 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>です。  
  
 要素の上にコピー、 <xref:System.Collections.Generic.Stack%601> によって読み取られる順序と同じ順序で、 <xref:System.Collections.Generic.IEnumerator%601> のコレクション。  
  
 このコンス トラクターは、O \(`n`\) 操作の場合、 `n` 内の要素の数は、 `collection`です。  
  
   
  
## 例  
 次のコード例では、このコンス トラクターのいくつかの方法、 <xref:System.Collections.Generic.Stack%601> ジェネリック クラスです。  
  
 このコード例は、既定の容量を持つ文字列のスタックを作成し、使用して、 <xref:System.Collections.Generic.Stack%601.Push%2A> 5 つの文字列をスタックにプッシュします。 スタックの要素が表示され、スタックの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Stack%601.Pop%2A> メソッドを使用して、最初の文字列をスタックからポップします。<xref:System.Collections.Generic.Stack%601.Peek%2A> メソッドを使用して、スタックの次の項目を確認し、 <xref:System.Collections.Generic.Stack%601.Pop%2A> ポップ オフ メソッドを使用します。  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> 配列を作成し、スタックの要素をコピーするメソッドを使用して、配列に渡されます、 <xref:System.Collections.Generic.Stack%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、逆に、要素の順序でスタックのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、スタックのサイズが作成、および <xref:System.Collections.Generic.Stack%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Stack%601.%23ctor%2A> コンス トラクターは要素を逆の順序でスタックのコピーを作成するにはもう一度使用されます。 したがって、次の 3 つの null 要素は末尾にあります。  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> メソッドを使用して、表示するまで、スタックの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Stack%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Stack%601.Count%2A> スタックが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <see cref="T:System.Collections.Generic.Stack`1" /> が格納できる要素数の初期値。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Collections.Generic.Stack`1" /> はクラスを空に指定した初期量または既定の初期量、大きい方します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 容量、 <xref:System.Collections.Generic.Stack%601> は要素の数を <xref:System.Collections.Generic.Stack%601> を保持できます。 要素が追加されると、 <xref:System.Collections.Generic.Stack%601>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.Generic.Stack%601>です。  
  
 呼び出すことによって、容量を削減できる <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>です。  
  
 このコンス トラクターは、O \(`n`\) 操作の場合、 `n` は `capacity`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Stack`1" /> からすべてのオブジェクトを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.Stack%601.Count%2A> is set to zero, and references to other objects from elements of the collection are also released.  
  
 The capacity remains unchanged. To reset the capacity of the <xref:System.Collections.Generic.Stack%601>, call <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>. Trimming an empty <xref:System.Collections.Generic.Stack%601> sets the capacity of the <xref:System.Collections.Generic.Stack%601> to the default capacity.  
  
 This method is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## 例  
 The following code example demonstrates several methods of the <xref:System.Collections.Generic.Stack%601> generic class, including the <xref:System.Collections.Generic.Stack%601.Clear%2A> method.  
  
 The code example creates a stack of strings with default capacity and uses the <xref:System.Collections.Generic.Stack%601.Push%2A> method to push five strings onto the stack. The elements of the stack are enumerated, which does not change the state of the stack. The <xref:System.Collections.Generic.Stack%601.Pop%2A> method is used to pop the first string off the stack. The <xref:System.Collections.Generic.Stack%601.Peek%2A> method is used to look at the next item on the stack, and then the <xref:System.Collections.Generic.Stack%601.Pop%2A> method is used to pop it off.  
  
 The <xref:System.Collections.Generic.Stack%601.ToArray%2A> method is used to create an array and copy the stack elements to it, then the array is passed to the <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor that takes <xref:System.Collections.Generic.IEnumerable%601>, creating a copy of the stack with the order of the elements reversed. The elements of the copy are displayed.  
  
 An array twice the size of the stack is created, and the <xref:System.Collections.Generic.Stack%601.CopyTo%2A> method is used to copy the array elements beginning at the middle of the array. The <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor is used again to create a copy of the stack with the order of elements reversed; thus, the three null elements are at the end.  
  
 The <xref:System.Collections.Generic.Stack%601.Contains%2A> method is used to show that the string "four" is in the first copy of the stack, after which the <xref:System.Collections.Generic.Stack%601.Clear%2A> method clears the copy and the <xref:System.Collections.Generic.Stack%601.Count%2A> property shows that the stack is empty.  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Contains(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.Stack`1" /> 内で検索するオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>ある要素が <see cref="T:System.Collections.Generic.Stack`1" /> 内に存在するかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="item" /> に存在する場合は <see cref="T:System.Collections.Generic.Stack`1" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for **parameterReference tag is not supported!!!!**  
, the type of values in the list.  
  
 This method performs a linear search; therefore, this method is an O\(**parameterReference tag is not supported!!!!**  
\) operation, where **parameterReference tag is not supported!!!!**  
 is <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## 例  
 The following code example demonstrates several methods of the <xref:System.Collections.Generic.Stack%601> generic class, including the <xref:System.Collections.Generic.Stack%601.Contains%2A> method.  
  
 The code example creates a stack of strings with default capacity and uses the <xref:System.Collections.Generic.Stack%601.Push%2A> method to push five strings onto the stack. The elements of the stack are enumerated, which does not change the state of the stack. The <xref:System.Collections.Generic.Stack%601.Pop%2A> method is used to pop the first string off the stack. The <xref:System.Collections.Generic.Stack%601.Peek%2A> method is used to look at the next item on the stack, and then the <xref:System.Collections.Generic.Stack%601.Pop%2A> method is used to pop it off.  
  
 The <xref:System.Collections.Generic.Stack%601.ToArray%2A> method is used to create an array and copy the stack elements to it, then the array is passed to the <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor that takes <xref:System.Collections.Generic.IEnumerable%601>, creating a copy of the stack with the order of the elements reversed. The elements of the copy are displayed.  
  
 An array twice the size of the stack is created, and the <xref:System.Collections.Generic.Stack%601.CopyTo%2A> method is used to copy the array elements beginning at the middle of the array. The <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor is used again to create a copy of the stack with the order of elements reversed; thus, the three null elements are at the end.  
  
 The <xref:System.Collections.Generic.Stack%601.Contains%2A> method is used to show that the string "four" is in the first copy of the stack, after which the <xref:System.Collections.Generic.Stack%601.Clear%2A> method clears the copy and the <xref:System.Collections.Generic.Stack%601.Count%2A> property shows that the stack is empty.  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> から要素がコピーされる 1 次元の <see cref="T:System.Collections.Generic.Stack`1" />。<see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。</param>
        <param name="arrayIndex">コピーの開始位置とする <c>array</c> のインデックス \(0 から始まる\)。</param>
        <summary>コピー、 <see cref="T:System.Collections.Generic.Stack`1" /> に既存の 1 次元 <see cref="T:System.Array" />, 、指定した配列インデックスから始まります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素の最後で先出し \(LIFO\) の順序への呼び出しの連続してによって返される要素の順序と似ての配列にコピー [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.Pop%2A>します。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.Count%2A>です。  
  
   
  
## 例  
 次のコード例をいくつかの方法を示しています、 [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601> ジェネリック クラスを含む、 [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.CopyTo%2A> メソッドです。  
  
 このコード例は、既定の容量を持つ文字列のスタックを作成し、使用して、 [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.Push%2A> 5 つの文字列をスタックにプッシュします。 スタックの要素が表示され、スタックの状態は変化しませんが列挙されます。[CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.Pop%2A> メソッドを使用して、最初の文字列をスタックからポップします。[CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.Peek%2A> メソッドを使用して、スタックの次の項目を確認し、 [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.Pop%2A> ポップ オフ メソッドを使用します。  
  
 [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.ToArray%2A> 配列を作成し、スタックの要素をコピーするメソッドを使用して、配列に渡されます、 [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.%23ctor%2A> を受け取るコンス トラクター [CopyTo メソッド \(T\<xref:System.Collections.Generic.IEnumerable%601>, 、逆に、要素の順序でスタックのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、スタックのサイズが作成、および [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。[CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.%23ctor%2A> コンス トラクターは要素を逆の順序でスタックのコピーを作成するにはもう一度使用されます。 したがって、次の 3 つの null 要素は末尾にあります。  
  
 [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.Contains%2A> メソッドを使用して、表示するまで、スタックの最初のコピーで文字列「4」が、 [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.Clear%2A> メソッドは、コピーをクリアし、 [CopyTo メソッド \(T\<xref:System.Collections.Generic.Stack%601.Count%2A> スタックが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">ソース内の要素の数 <see cref="T:System.Collections.Generic.Stack`1" /> から使用可能な領域よりも大きい <paramref name="arrayIndex" /> 変換先の末尾に <paramref name="array" />します。</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.ToArray" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Stack`1" /> に格納されている要素の数を取得します。</summary>
        <value>
          <see cref="T:System.Collections.Generic.Stack`1" /> に格納されている要素の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The capacity of the <xref:System.Collections.Generic.Stack%601> is the number of elements that the <xref:System.Collections.Generic.Stack%601> can store. <xref:System.Collections.Generic.Stack%601.Count%2A> is the number of elements that are actually in the <xref:System.Collections.Generic.Stack%601>.  
  
 The capacity is always greater than or equal to <xref:System.Collections.Generic.Stack%601.Count%2A>. If <xref:System.Collections.Generic.Stack%601.Count%2A> exceeds the capacity while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements.  
  
 Retrieving the value of this property is an O\(1\) operation.  
  
   
  
## 例  
 The following code example demonstrates several properties and methods of the <xref:System.Collections.Generic.Stack%601> generic class, including the <xref:System.Collections.Generic.Stack%601.Count%2A> property.  
  
 The code example creates a stack of strings with default capacity and uses the <xref:System.Collections.Generic.Stack%601.Push%2A> method to push five strings onto the stack. The elements of the stack are enumerated, which does not change the state of the stack. The <xref:System.Collections.Generic.Stack%601.Pop%2A> method is used to pop the first string off the stack. The <xref:System.Collections.Generic.Stack%601.Peek%2A> method is used to look at the next item on the stack, and then the <xref:System.Collections.Generic.Stack%601.Pop%2A> method is used to pop it off.  
  
 The <xref:System.Collections.Generic.Stack%601.ToArray%2A> method is used to create an array and copy the stack elements to it, then the array is passed to the <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor that takes <xref:System.Collections.Generic.IEnumerable%601>, creating a copy of the stack with the order of the elements reversed. The elements of the copy are displayed.  
  
 An array twice the size of the stack is created, and the <xref:System.Collections.Generic.Stack%601.CopyTo%2A> method is used to copy the array elements beginning at the middle of the array. The <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor is used again to create a copy of the stack with the order of elements reversed; thus, the three null elements are at the end.  
  
 The <xref:System.Collections.Generic.Stack%601.Contains%2A> method is used to show that the string "four" is in the first copy of the stack, after which the <xref:System.Collections.Generic.Stack%601.Clear%2A> method clears the copy and the <xref:System.Collections.Generic.Stack%601.Count%2A> property shows that the stack is empty.  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Stack&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Stack`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Stack&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>列挙子を返す、 <see cref="T:System.Collections.Generic.Stack`1" />です。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Stack`1.Enumerator" /> の <see cref="T:System.Collections.Generic.Stack`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 この位置では、<xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> が未定義です。 そのため、<xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> は、<xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> は、<xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> は定義されていません。<xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> を、再度、コレクションの最初の要素に設定することはできません。列挙子の新しいインスタンスを作成する必要があります。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例を示しますが、 <xref:System.Collections.Generic.Stack%601> ジェネリック クラスは列挙可能です。`foreach` ステートメント \(`For Each` Visual basic で `for each` C\+\+ で\)、キューを列挙するために使用します。  
  
 このコード例は、既定の容量を持つ文字列のスタックを作成し、使用して、 <xref:System.Collections.Generic.Stack%601.Push%2A> 5 つの文字列をスタックにプッシュします。 スタックの要素が表示され、スタックの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Stack%601.Pop%2A> メソッドを使用して、最初の文字列をスタックからポップします。<xref:System.Collections.Generic.Stack%601.Peek%2A> メソッドを使用して、スタックの次の項目を確認し、 <xref:System.Collections.Generic.Stack%601.Pop%2A> ポップ オフ メソッドを使用します。  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> 配列を作成し、スタックの要素をコピーするメソッドを使用して、配列に渡されます、 <xref:System.Collections.Generic.Stack%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、逆に、要素の順序でスタックのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、スタックのサイズが作成、および <xref:System.Collections.Generic.Stack%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Stack%601.%23ctor%2A> コンス トラクターは要素を逆の順序でスタックのコピーを作成するにはもう一度使用されます。 したがって、次の 3 つの null 要素は末尾にあります。  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> メソッドを使用して、表示するまで、スタックの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Stack%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Stack%601.Count%2A> スタックが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Stack`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Peek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>上部にあるオブジェクトを返す、 <see cref="T:System.Collections.Generic.Stack`1" /> 削除することがなく。</summary>
        <returns>オブジェクトの上部にある、 <see cref="T:System.Collections.Generic.Stack`1" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは <xref:System.Collections.Generic.Stack%601.Pop%2A> メソッドに類似していますが、<xref:System.Collections.Generic.Stack%601.Peek%2A> は <xref:System.Collections.Generic.Stack%601> を変更しません。  
  
 場合型 `T` 、参照型では、 `null` にプッシュできる、 <xref:System.Collections.Generic.Stack%601> のプレース ホルダーとして、必要な場合です。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例をいくつかの方法を示しています、 <xref:System.Collections.Generic.Stack%601> ジェネリック クラスを含む、 <xref:System.Collections.Generic.Stack%601.Peek%2A> メソッドです。  
  
 このコード例は、既定の容量を持つ文字列のスタックを作成し、使用して、 <xref:System.Collections.Generic.Stack%601.Push%2A> 5 つの文字列をスタックにプッシュします。 スタックの要素が表示され、スタックの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Stack%601.Pop%2A> メソッドを使用して、最初の文字列をスタックからポップします。<xref:System.Collections.Generic.Stack%601.Peek%2A> メソッドを使用して、スタックの次の項目を確認し、 <xref:System.Collections.Generic.Stack%601.Pop%2A> ポップ オフ メソッドを使用します。  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> 配列を作成し、スタックの要素をコピーするメソッドを使用して、配列に渡されます、 <xref:System.Collections.Generic.Stack%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、逆に、要素の順序でスタックのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、スタックのサイズが作成、および <xref:System.Collections.Generic.Stack%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Stack%601.%23ctor%2A> コンス トラクターは要素を逆の順序でスタックのコピーを作成するにはもう一度使用されます。 したがって、次の 3 つの null 要素は末尾にあります。  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> メソッドを使用して、表示するまで、スタックの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Stack%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Stack%601.Count%2A> スタックが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Generic.Stack`1" /> が空です。</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public T Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Pop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>削除し、上部にあるオブジェクトを返す、 <see cref="T:System.Collections.Generic.Stack`1" />です。</summary>
        <returns>先頭から削除するオブジェクト、 <see cref="T:System.Collections.Generic.Stack`1" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは <xref:System.Collections.Generic.Stack%601.Peek%2A> メソッドに類似していますが、<xref:System.Collections.Generic.Stack%601.Peek%2A> は <xref:System.Collections.Generic.Stack%601> を変更しません。  
  
 場合型 `T` 、参照型では、 `null` にプッシュできる、 <xref:System.Collections.Generic.Stack%601> のプレース ホルダーとして、必要な場合です。  
  
 <xref:System.Collections.Generic.Stack%601> 配列として実装されます。 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例をいくつかの方法を示しています、 <xref:System.Collections.Generic.Stack%601> ジェネリック クラスを含む、 <xref:System.Collections.Generic.Stack%601.Pop%2A> メソッドです。  
  
 このコード例は、既定の容量を持つ文字列のスタックを作成し、使用して、 <xref:System.Collections.Generic.Stack%601.Push%2A> 5 つの文字列をスタックにプッシュします。 スタックの要素が表示され、スタックの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Stack%601.Pop%2A> メソッドを使用して、最初の文字列をスタックからポップします。<xref:System.Collections.Generic.Stack%601.Peek%2A> メソッドを使用して、スタックの次の項目を確認し、 <xref:System.Collections.Generic.Stack%601.Pop%2A> ポップ オフ メソッドを使用します。  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> 配列を作成し、スタックの要素をコピーするメソッドを使用して、配列に渡されます、 <xref:System.Collections.Generic.Stack%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、逆に、要素の順序でスタックのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、スタックのサイズが作成、および <xref:System.Collections.Generic.Stack%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Stack%601.%23ctor%2A> コンス トラクターは要素を逆の順序でスタックのコピーを作成するにはもう一度使用されます。 したがって、次の 3 つの null 要素は末尾にあります。  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> メソッドを使用して、表示するまで、スタックの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Stack%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Stack%601.Count%2A> スタックが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Generic.Stack`1" /> が空です。</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Push(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.Stack`1" /> にプッシュするオブジェクト。 参照型の場合は <see langword="null" /> の値を使用できます。</param>
        <summary>
          <see cref="T:System.Collections.Generic.Stack`1" /> の先頭にオブジェクトを挿入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.Generic.Stack%601> 配列として実装されます。  
  
 場合 <xref:System.Collections.Generic.Stack%601.Count%2A> 容量の容量と既に同じ、 <xref:System.Collections.Generic.Stack%601> が増加すると、内部の配列を自動的に再割り当てによって、新しい要素が追加される前に、新しい配列に既存の要素がコピーされるとします。  
  
 場合型 `T` 、参照型では、 `null` にプッシュできる、 <xref:System.Collections.Generic.Stack%601> のプレース ホルダーとして、必要な場合です。 スタック内のスロットを占有し、任意のオブジェクトと同様に扱われます。  
  
 場合 <xref:System.Collections.Generic.Stack%601.Count%2A> が、スタックの容量よりも小さい <xref:System.Collections.Generic.Stack%601.Push%2A> o \(1\) 操作です。 容量は、新しい要素を格納するために必要がある場合 <xref:System.Collections.Generic.Stack%601.Push%2A> O になります \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.Stack%601.Count%2A>です。  
  
   
  
## 例  
 次のコード例をいくつかの方法を示しています、 <xref:System.Collections.Generic.Stack%601> ジェネリック クラスを含む、 <xref:System.Collections.Generic.Stack%601.Push%2A> メソッドです。  
  
 このコード例は、既定の容量を持つ文字列のスタックを作成し、使用して、 <xref:System.Collections.Generic.Stack%601.Push%2A> 5 つの文字列をスタックにプッシュします。 スタックの要素が表示され、スタックの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Stack%601.Pop%2A> メソッドを使用して、最初の文字列をスタックからポップします。<xref:System.Collections.Generic.Stack%601.Peek%2A> メソッドを使用して、スタックの次の項目を確認し、 <xref:System.Collections.Generic.Stack%601.Pop%2A> ポップ オフ メソッドを使用します。  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> 配列を作成し、スタックの要素をコピーするメソッドを使用して、配列に渡されます、 <xref:System.Collections.Generic.Stack%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、逆に、要素の順序でスタックのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、スタックのサイズが作成、および <xref:System.Collections.Generic.Stack%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Stack%601.%23ctor%2A> コンス トラクターは要素を逆の順序でスタックのコピーを作成するにはもう一度使用されます。 したがって、次の 3 つの null 要素は末尾にあります。  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> メソッドを使用して、表示するまで、スタックの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Stack%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Stack%601.Count%2A> スタックが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションを反復処理する列挙子を返します。</summary>
        <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.Generic.IEnumerator`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。 この位置では、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.Generic.IEnumerator%601.Current%2A> は定義されていません。<xref:System.Collections.Generic.IEnumerator%601.Current%2A> を、再度、コレクションの最初の要素に設定することはできません。列挙子の新しいインスタンスを作成する必要があります。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Collections.ICollection" /> から要素がコピーされる 1 次元の <see cref="T:System.Array" />。<see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。</param>
        <param name="arrayIndex">コピーの開始位置とする <c>array</c> のインデックス \(0 から始まる\)。</param>
        <summary>
          <see cref="T:System.Collections.ICollection" /> の要素を <see cref="T:System.Array" /> にコピーします。<see cref="T:System.Array" /> の特定のインデックスからコピーが開始されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  場合、ソースの種類 <xref:System.Collections.ICollection> 変換先の型に自動的にキャストすることはできません `array`, の非ジェネリックの実装 <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=fullName> スロー <xref:System.InvalidCastException>, 汎用実装がスローされ、 <xref:System.ArgumentException>です。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.Stack%601.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  
  
 または  
  
 <paramref name="array" /> には、0 から始まるインデックス番号がありません。  
  
 または  
  
 ソース内の要素の数 <see cref="T:System.Collections.ICollection" /> から使用可能な領域よりも大きい <paramref name="arrayIndex" /> 変換先の末尾に <paramref name="array" />します。  
  
 または  
  
 ソースの種類 <see cref="T:System.Collections.ICollection" /> 先の型に自動的にキャストできない <paramref name="array" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> へのアクセスが同期されている \(スレッド セーフである\) かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> へのアクセスが同期されている \(スレッド セーフである\) 場合は <see cref="T:System.Collections.ICollection" />。それ以外の場合は <see langword="false" />。<see cref="T:System.Collections.Generic.Stack`1" /> の既定の実装では、このプロパティは常に <see langword="false" /> を返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。  列挙体が書き込みアクセスに対処する、まれなケースでは、列挙中にコレクションをロックする必要があります。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> アクセスを同期するために使用できるオブジェクトを返す、 <xref:System.Collections.ICollection>です。 同期は、すべてのスレッドがコレクションにアクセスする前にこのオブジェクトをロックする場合のみ有効です。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Collections.ICollection" /> へのアクセスを同期するために使用できるオブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> へのアクセスを同期するために使用できるオブジェクト。<see cref="T:System.Collections.Generic.Stack`1" /> の既定の実装では、このプロパティは常に現在のインスタンスを返します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> アクセスを同期するために使用できるオブジェクトを返す、 <xref:System.Collections.ICollection>です。 同期は、すべてのスレッドがコレクションにアクセスする前にこのオブジェクトをロックする場合のみ有効です。 次のコードは、使用、 <xref:System.Collections.ICollection.SyncRoot%2A> c\#、C\+\+、および Visual Basic のプロパティです。  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コレクションを反復処理する列挙子を返します。</summary>
        <returns>コレクションを反復処理するために使用できる <see cref="T:System.Collections.IEnumerator" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `foreach` C\# 言語のステートメント \(`for each` C\+\+ では、 `For Each` Visual basic\) 列挙子の複雑さを隠蔽します。 したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。<xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、<xref:System.Collections.IEnumerator.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.IEnumerator.Current%2A> は定義されていません。<xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 既定の実装のコレクションの <xref:System.Collections.Generic?displayProperty=fullName> が同期されていません。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.ToArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コピー、 <see cref="T:System.Collections.Generic.Stack`1" /> を新しい配列にします。</summary>
        <returns>要素のコピーを格納する新しい配列、 <see cref="T:System.Collections.Generic.Stack`1" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素の最後で先出し \(LIFO\) の順序への呼び出しの連続してによって返される要素の順序と似ての配列にコピー <xref:System.Collections.Generic.Stack%601.Pop%2A>します。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.Stack%601.Count%2A>です。  
  
   
  
## 例  
 次のコード例をいくつかの方法を示しています、 <xref:System.Collections.Generic.Stack%601> ジェネリック クラスを含む、 <xref:System.Collections.Generic.Stack%601.ToArray%2A> メソッドです。  
  
 このコード例は、既定の容量を持つ文字列のスタックを作成し、使用して、 <xref:System.Collections.Generic.Stack%601.Push%2A> 5 つの文字列をスタックにプッシュします。 スタックの要素が表示され、スタックの状態は変化しませんが列挙されます。<xref:System.Collections.Generic.Stack%601.Pop%2A> メソッドを使用して、最初の文字列をスタックからポップします。<xref:System.Collections.Generic.Stack%601.Peek%2A> メソッドを使用して、スタックの次の項目を確認し、 <xref:System.Collections.Generic.Stack%601.Pop%2A> ポップ オフ メソッドを使用します。  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> 配列を作成し、スタックの要素をコピーするメソッドを使用して、配列に渡されます、 <xref:System.Collections.Generic.Stack%601.%23ctor%2A> を受け取るコンス トラクター <xref:System.Collections.Generic.IEnumerable%601>, 、逆に、要素の順序でスタックのコピーを作成します。 コピーの要素が表示されます。  
  
 配列 2 回、スタックのサイズが作成、および <xref:System.Collections.Generic.Stack%601.CopyTo%2A> メソッドを使用して、配列の途中で始まる配列の要素をコピーします。<xref:System.Collections.Generic.Stack%601.%23ctor%2A> コンス トラクターは要素を逆の順序でスタックのコピーを作成するにはもう一度使用されます。 したがって、次の 3 つの null 要素は末尾にあります。  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> メソッドを使用して、表示するまで、スタックの最初のコピーで文字列「4」が、 <xref:System.Collections.Generic.Stack%601.Clear%2A> メソッドは、コピーをクリアし、 <xref:System.Collections.Generic.Stack%601.Count%2A> スタックが空であるプロパティを示しています。  
  
 [!code-csharp[Generic.Stack\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TrimExcess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Stack`1" /> 内にある実際の要素数が現在の容量の 90% 未満の場合は、容量をその数に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コレクションのメモリ オーバーヘッドを最小コレクションに新しい要素が追加されない場合に使用できます。 再割り当てすることと、大規模なコピーのコスト <xref:System.Collections.Generic.Stack%601> 多く、ただしは、されるため、 <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> メソッドは何も一覧にある容量の 90% を超える場合。 これにより、比較的小さな向上のための大規模な再割り当てコストを発生させることがなくなります。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.Generic.Stack%601.Count%2A>です。  
  
 リセットする、 <xref:System.Collections.Generic.Stack%601> の初期状態を呼び出し、 <xref:System.Collections.Generic.Stack%601.Clear%2A> メソッドを呼び出す前に <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> メソッドです。 空のトリミング <xref:System.Collections.Generic.Stack%601> のキャパシティを設定、 <xref:System.Collections.Generic.Stack%601> を既定の容量。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Stack`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek(!T result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPeek(`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop">
      <MemberSignature Language="C#" Value="public bool TryPop (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPop(!T result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPop(`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.Generic.Stack`1" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>