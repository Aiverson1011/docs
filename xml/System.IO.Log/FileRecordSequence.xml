<Type Name="FileRecordSequence" FullName="System.IO.Log.FileRecordSequence">
  <TypeSignature Language="C#" Value="public sealed class FileRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.FileRecordSequence" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>ファイル上に <see cref="T:System.IO.Log.IRecordSequence" /> を実装します。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.IO.Log.FileRecordSequence> は、ファイル システム内の単一のログ ファイルに基づくレコード シーケンスです。 これは、単純なファイルに基づくログ上の <xref:System.IO.Log.IRecordSequence> インターフェイスの簡単な実装です。  
  
 ファイル ベースのログを操作するには、アプリケーションを実行しているアカウントに十分な特権が必要です。特権は、<xref:System.IO.Log.FileRecordSequence> の構築時にファイル システムのセキュリティで指定されます。 さらに、構築時に FullTrust への要求が行われます。 アクセス許可の検査の結果は、事後に Windows セキュリティ モデルに合わせてキャッシュされます。 レコード シーケンスのコンテンツを権限のないユーザーに誤って開示しないことを確認することをお勧めします。  
  
   
  
## 例  
 次の例では、レコード シーケンスを作成し、レコードを追加し、最後にレコードを読み取ります。  
  
 [!code-csharp[IRecordSequence\#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence\#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.IO.Log.FileRecordSequence" /> インスタンスがカプセル化するファイルの相対パスまたは絶対パス。</param>
        <summary>指定したファイルを使用して、<see cref="T:System.IO.Log.FileRecordSequence" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンストラクターは、ファイルへの読み取り\/書き込みアクセスを作成し、共有読み取りアクセス モードでファイルを開きます。 そのため、ファイルを書き込みアクセスで開く操作をこのプロセスまたは他のプロセスで要求すると、この <xref:System.IO.Log.FileRecordSequence> インスタンスを破棄していない限り、要求は失敗しますが、読み取りは成功します。`path` が見つからない場合、サイズが 0 バイトの新しいファイルが作成されます。  
  
   
  
## 例  
 次の例では、レコード シーケンスの作成、レコードの追加、およびレコードの読み取りを行い、最後にシーケンスを破棄します。  
  
 [!code-csharp[IRecordSequence\#1](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#1)]
 [!code-vb[IRecordSequence\#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> によって指定されたファイルが有効ではありません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> で指定したファイルが見つかりません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定のログ ストアへのアクセスは、オペレーティング システムにより拒否されました。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.IO.Log.FileRecordSequence" /> インスタンスがカプセル化するファイルの相対パスまたは絶対パス。</param>
        <param name="access">ユーザーがログ ファイルに対して持つアクセスの種類を制御する有効な <see cref="T:System.IO.FileAccess" /> 値。</param>
        <summary>ファイルおよびアクセス モードを指定して、<see cref="T:System.IO.Log.FileRecordSequence" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> によって指定されたファイルが有効ではありません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> で指定したファイルが見つかりません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定のログ ストアへのアクセスは、オペレーティング システムにより拒否されました。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileRecordSequence (string path, System.IO.FileAccess access, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileAccess access, int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">この <see cref="T:System.IO.Log.FileRecordSequence" /> インスタンスがカプセル化するファイルの相対パスまたは絶対パス。</param>
        <param name="access">ユーザーがログ ファイルに対して持つアクセスの種類を制御する有効な <see cref="T:System.IO.FileAccess" /> 値。</param>
        <param name="size">開くログ ファイルのサイズ。</param>
        <summary>ファイル、アクセス モード、およびファイル サイズを指定して、<see cref="T:System.IO.Log.FileRecordSequence" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上のパラメーターが有効範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> によって指定されたファイルが有効ではありません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> で指定したファイルが見つかりません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定のログ ストアへのアクセスは、オペレーティング システムにより拒否されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">レコード シーケンスの新しい基本シーケンス番号。</param>
        <summary>ログの基本シーケンス番号を前方移動します。 このメソッドは継承できません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newBaseSequenceNumber" /> が無効です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSequenceNumber" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。</exception>
        <exception cref="T:System.IO.IOException">シーケンスの変更中に I\/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ログ レコードを <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following example creates a record sequence, appends record to it, and finally reads the records.  
  
 [!code-csharp[IRecordSequence\#0](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#0)]
 [!code-vb[IRecordSequence\#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#0)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <summary>ログ レコードを <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
   
  
## 例  
 次の例では、レコード シーケンスを作成し、レコードを追加し、最後にレコードを読み取ります。  
  
 [!code-csharp[FileRecordSequence\#0](~/samples/snippets/csharp/VS_Snippets_CFX/filerecordsequence/cs/filerecordsequence.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <summary>ログ レコードを <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Data contained in the **parameterReference tag is not supported!!!!**  
 parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  
  
 Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the **parameterReference tag is not supported!!!!**  
 parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.  
  
   
  
## 例  
 The following example shows how you can create a record sequence with this method.  
  
 [!code-csharp[IRecordSequence\#3](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#3)]
 [!code-vb[IRecordSequence\#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservations">このレコードで使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <summary>以前にシーケンスに予約された領域を使用して、<see cref="T:System.IO.Log.FileRecordSequence" /> にログ レコードを書き込みます。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 追加されたレコードは、`reservations` パラメーターにより指定された予約を使用して以前に予約された領域を消費します。 この追加処理が成功すると、データを格納できる最も小さな予約領域が消費され、その予約領域がコレクションから削除されます。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> がこのレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservations">このレコードで使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <summary>以前にシーケンスに予約された領域を使用して、<see cref="T:System.IO.Log.FileRecordSequence" /> にログ レコードを書き込みます。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Data contained in the **parameterReference tag is not supported!!!!**  
 parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  
  
 The appended record will consume space that has been previously reserved, using a reservation specified by the **parameterReference tag is not supported!!!!**  
 parameter. If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.  
  
 Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the **parameterReference tag is not supported!!!!**  
 parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> がこのレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.IO.Log.FileRecordSequence" /> 内の最初の有効なレコードのシーケンス番号を取得します。</summary>
        <value>
          <see cref="T:System.IO.Log.FileRecordSequence" /> 内の有効なレコードに対応する下限のシーケンス番号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 有効なシーケンス番号は、<xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> 以上、<xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A> 未満です。 その他のシーケンス番号はすべて無効です。  
  
 このプロパティの値は、<xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> メソッドまたは <xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A> メソッドを呼び出すことにより変更できます。  
  
   
  
## 例  
 ループ内で <xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> を使用する方法を次の例に示します。  
  
 [!code-csharp[IRecordSequence\#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence\#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の追加を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method, to ensure that the append operation has completed and resources can be freed appropriately. If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.  
  
 Data contained in the **parameterReference tag is not supported!!!!**  
 parameter will be concatenated into a single byte array for appending as the record. However, no provision is made for splitting data back into array segments when the record is read.  
  
 Normally, this method completes before the record has been written. To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the **parameterReference tag is not supported!!!!**  
 parameter, or call the <xref:System.IO.Log.FileRecordSequence.Flush%2A> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の追加を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 追加処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> メソッドに渡すことをお勧めします。 非同期追加中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservations">このレコードで使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>以前にシーケンス内で予約された領域を使用して、非同期の追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の追加を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 追加処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> メソッドに渡すことをお勧めします。 非同期追加中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 追加されたレコードは、`reservations` パラメーターにより指定された予約を使用して以前に予約された領域を消費します。 この追加処理が成功すると、データを格納できる最も小さな予約領域が消費され、その予約領域がコレクションから削除されます。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservations">このレコードで使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>以前にシーケンス内で予約された領域を使用して、非同期の追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の追加を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 追加処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> メソッドに渡すことをお勧めします。 非同期追加中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 追加されたレコードは、`reservations` パラメーターにより指定された予約を使用して以前に予約された領域を消費します。 この追加処理が成功すると、データを格納できる最も小さな予約領域が消費され、その予約領域がコレクションから削除されます。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了します。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">書き込む必要のある最新レコードのシーケンス番号。<see cref="T:System.IO.Log.SequenceNumber" /> が無効な場合、すべてのレコードを書き込む必要があります。</param>
        <param name="callback">フラッシュの完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期フラッシュ要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>以前にシーケンス内で予約された領域を使用して、非同期のフラッシュ操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期のフラッシュ操作を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在のメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> メソッドに渡すことにより、フラッシュが完了し、リソースが適切に解放されたことを確認する必要があります。 非同期フラッシュ中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 このメソッドを呼び出すことにより、<xref:System.IO.Log.FileRecordSequence> に追加されたすべてのレコードが永続的に書き込まれたことを確認します。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I\/O 要求時にディスク障害が発生した場合など、非同期フラッシュ要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndFlush%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">1 つ以上の引数が無効です。  
  
 このシーケンスの <paramref name="sequenceNumber" /> が有効ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。</exception>
        <exception cref="T:System.IO.IOException">データのフラッシュ中に I\/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservationCollection">予約を作成する予約コレクション。</param>
        <param name="reservations">作成する予約のバイト数。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の予約および追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の操作を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 追加処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された [BeginReserveAndAppend メソッド \(ArraySegment\(Byte\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IAsyncResult> を [BeginReserveAndAppend メソッド \(ArraySegment\(Byte\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドに渡すことをお勧めします。 非同期追加中にエラーが発生した場合、このメソッドから返される [BeginReserveAndAppend メソッド \(ArraySegment\(Byte\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> を使用して [BeginReserveAndAppend メソッド \(ArraySegment\(Byte\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 指定の予約情報は、レコード追加操作を含む分割不可能な操作内で、提供された予約コレクションに追加されます。 追加が失敗した場合、領域は予約されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了できます。 レコードが書き込まれたことを確認するために、[BeginReserveAndAppend メソッド \(ArraySegment\(Byte\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、[BeginReserveAndAppend メソッド \(ArraySegment\(Byte\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I\/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、[BeginReserveAndAppend メソッド \(ArraySegment\(Byte\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservationCollection">予約を作成する予約コレクション。</param>
        <param name="reservations">作成する予約のバイト数。</param>
        <param name="callback">追加の完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の非同期追加要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の予約および追加操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の操作を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 追加処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された [BeginReserveAndAppend メソッド \(IList\(ArraySegment\(Byte\)\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IAsyncResult> を [BeginReserveAndAppend メソッド \(IList\(ArraySegment\(Byte\)\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドに渡すことをお勧めします。 非同期追加中にエラーが発生した場合、このメソッドから返される [BeginReserveAndAppend メソッド \(IList\(ArraySegment\(Byte\)\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> を使用して [BeginReserveAndAppend メソッド \(IList\(ArraySegment\(Byte\)\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 指定の予約情報は、レコード追加操作を含む分割不可能な操作内で、提供された予約コレクションに追加されます。 追加が失敗した場合、領域は予約されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了できます。 レコードが書き込まれたことを確認するために、[BeginReserveAndAppend メソッド \(IList\(ArraySegment\(Byte\)\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、[BeginReserveAndAppend メソッド \(IList\(ArraySegment\(Byte\)\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I\/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、[BeginReserveAndAppend メソッド \(IList\(ArraySegment\(Byte\)\), SequenceNumber, SequenceNumber, RecordAppendOptions, ReservationCollection, Int64\<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <param name="reservation">この再開領域で使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <param name="callback">再開領域の書き込みの完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の再開領域非同期書き込み要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>以前にシーケンス内で予約された領域を使用して、非同期の再開領域の書き込み操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の再開領域の書き込み処理を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 再開領域の書き込み処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> メソッドに渡す必要があります。 非同期の再開領域の書き込み処理中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 この操作が正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 <xref:System.IO.Log.ReservationCollection> を指定すると、コレクションに格納されていた予約情報で以前に予約された領域が、書き込まれた再開領域により消費されます。 このメソッドが成功すると、データを格納できる最も小さな予約が消費され、その予約がコレクションから削除されます。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I\/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
 または  
  
 新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。  
  
 または  
  
 このシーケンスの <paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <param name="reservation">この再開領域で使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <param name="callback">再開領域の書き込みの完了時に呼び出されるオプションの非同期コールバック。</param>
        <param name="state">この特定の再開領域非同期書き込み要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>以前にシーケンス内で予約された領域を使用して、非同期の再開領域の書き込み操作を開始します。 このメソッドは継承できません。</summary>
        <returns>非同期の再開領域の書き込み処理を表す <see cref="T:System.IAsyncResult" />。まだ保留状態の場合もあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 再開領域の書き込み処理が完了しておりリソースを適切に解放できることを確認するために、このメソッドから返された <xref:System.IAsyncResult> を <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> メソッドに渡す必要があります。 非同期の再開領域の書き込み処理中にエラーが発生した場合、このメソッドから返される <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> を使用して <xref:System.IAsyncResult> メソッドを呼び出すまで、例外はスローされません。  
  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 この操作が正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 <xref:System.IO.Log.ReservationCollection> を指定すると、コレクションに格納されていた予約情報で以前に予約された領域が、書き込まれた再開領域により消費されます。 このメソッドが成功すると、データを格納できる最も小さな予約が消費され、その予約がコレクションから削除されます。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I\/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
 または  
  
 新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。  
  
 または  
  
 このシーケンスの <paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.CreateReservationCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新しい <see cref="T:System.IO.Log.ReservationCollection" /> を作成します。 このメソッドは継承できません。</summary>
        <returns>新しく作成された <see cref="T:System.IO.Log.ReservationCollection" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オブジェクトで使用されているアンマネージ リソースを直ちに解放します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">データのフラッシュ中に I\/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">保留状態の非同期 I\/O リクエストへの参照。</param>
        <summary>非同期の追加操作を終了します。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method blocks until the I\/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I\/O request, become visible when <xref:System.IO.Log.FileRecordSequence.EndAppend%2A> is called.  
  
 This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginAppend%2A> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> が正しくありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> は、この非同期操作のために既に呼び出されています。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">保留状態の非同期 I\/O リクエストへの参照。</param>
        <summary>非同期フラッシュ操作を終了します。 このメソッドは継承できません。</summary>
        <returns>最後に書き込まれたレコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method blocks until the I\/O operation has completed. Errors that occur during an asynchronous flush request, such as a disk failure during the I\/O request, become visible when <xref:System.IO.Log.FileRecordSequence.EndFlush%2A> is called.  
  
 This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginFlush%2A> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> が正しくありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> は、この非同期操作のために既に呼び出されています。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">保留状態の非同期 I\/O リクエストへの参照。</param>
        <summary>非同期の予約および追加操作を終了します。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method blocks until the I\/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I\/O request, become visible when <xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> is called.  
  
 This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> が正しくありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> は、この非同期操作のために既に呼び出されています。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">保留状態の非同期 I\/O リクエストへの参照。</param>
        <summary>非同期の再開領域の書き込み操作を終了します。 このメソッドは継承できません。</summary>
        <returns>書き込まれたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method blocks until the I\/O operation has completed. Errors that occur during an asynchronous write request, such as a disk failure during the I\/O request, become visible when <xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> is called.  
  
 This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> が正しくありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see langword="End" /> は、この非同期操作のために既に呼び出されています。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>追加したすべてのレコードが書き込まれたことを確認します。 このメソッドは継承できません。</summary>
        <returns>最後に書き込まれたレコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出すことにより、<xref:System.IO.Log.FileRecordSequence> に追加されたすべてのレコードが永続的に書き込まれたことを確認します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">データのフラッシュ中に I\/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">書き込む必要のある最新レコードのシーケンス番号。 この <see cref="T:System.IO.Log.SequenceNumber" /> が無効な場合、すべてのレコードを書き込む必要があります。</param>
        <summary>追加したすべてのレコードが書き込まれたことを確認します。 このメソッドは継承できません。</summary>
        <returns>最後に書き込まれたレコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを呼び出すと、指定のシーケンス番号以下のシーケンス番号を持つすべてのレコードが永続的に書き込まれたことが確認されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。</exception>
        <exception cref="T:System.ArgumentException">このシーケンスの <paramref name="sequenceNumber" /> が有効ではありません。</exception>
        <exception cref="T:System.IO.IOException">データのフラッシュ中に I\/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>追加された最後のレコードのシーケンス番号より大きいシーケンス番号を取得します。</summary>
        <value>追加された最後のレコードのシーケンス番号より大きいシーケンス番号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティには、最後に追加されたレコードのシーケンス番号を超えることが保証されるシーケンス番号が格納されています。 有効なシーケンス番号は、<xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> 以上、<xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A> 未満です。 その他のシーケンス番号はすべて無効です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このシーケンスに対して追加または読み取りが可能な最大レコード サイズのバイト数を取得します。</summary>
        <value>このシーケンスに対して追加または読み取りが可能な最大レコード サイズのバイト数。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">読み取りを開始する先頭レコードのシーケンス番号。</param>
        <param name="logRecordEnum">
          <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> からレコードを読み取る方法 \(つまり、順方向または逆方向\) を指定する有効な <see cref="T:System.IO.Log.LogRecordSequence" /> 値。</param>
        <summary>シーケンス内のレコードの列挙可能なコレクションを返します。 このメソッドは継承できません。</summary>
        <returns>シーケンス内のレコードの列挙可能なコレクション。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、シーケンス内のレコードの列挙可能なコレクション。 列挙されたレコードの順序は、`logRecordEnum` パラメーター値に依存します。  
  
   
  
## 例  
 このメソッドを使用してログ シーケンスのレコードを読み取る方法を次の例に示します。  
  
 [!code-csharp[IRecordSequence\#2](~/samples/snippets/csharp/VS_Snippets_CFX/irecordsequence/cs/readrecord.cs#2)]
 [!code-vb[IRecordSequence\#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/irecordsequence/vb/readrecord.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが書き込み専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">レコード シーケンスが破損しています。  
  
 または  
  
 レコードは、レコード シーケンスと互換性がないバージョンで書き込まれました。</exception>
        <exception cref="T:System.InvalidOperationException">列挙体が終了しています。  
  
 または  
  
 列挙体が開始されていません。<see cref="M:System.Collections.IEnumerator.MoveNext" /> を呼び出す必要があります。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReadRestartAreas" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シーケンス内の再開領域の列挙可能なコレクションを返します。 このメソッドは継承できません。</summary>
        <returns>シーケンス内の再開領域の列挙可能なコレクション。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 再開領域では、シーケンス番号の逆順で \(大きなシーケンス番号から小さなシーケンス番号に向かって\) 列挙されます。 最後のシーケンス番号と基本シーケンス番号の間のシーケンス番号を持つ再開領域のみが列挙されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが書き込み専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">レコード シーケンスが破損しています。  
  
 または  
  
 レコードは、レコード シーケンスと互換性がないバージョンで書き込まれました。</exception>
        <exception cref="T:System.InvalidOperationException">列挙体が終了しています。  
  
 または  
  
 列挙体が開始されていません。<see cref="M:System.Collections.IEnumerator.MoveNext" /> を呼び出す必要があります。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservationCollection">予約を作成するコレクションを格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <param name="reservations">作成する予約のバイト数。</param>
        <summary>単一の予約を自動的に行って、シーケンスにレコードを追加します。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 指定の予約情報は、レコード追加操作を含む分割不可能な操作内で、提供された予約コレクションに追加されます。 追加が失敗した場合、領域は予約されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了できます。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> がこのレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="nextUndoRecord">ユーザー指定の順序で次のレコードのシーケンス番号。</param>
        <param name="previousRecord">以前の順序で次のレコードのシーケンス番号。</param>
        <param name="recordAppendOptions">データの書き込み方法を指定する <see cref="T:System.IO.Log.RecordAppendOptions" /> の有効な値。</param>
        <param name="reservationCollection">予約を作成する予約コレクション。</param>
        <param name="reservations">作成する予約のバイト数。</param>
        <summary>単一の予約を自動的に行って、シーケンスにレコードを追加します。 このメソッドは継承できません。</summary>
        <returns>追加されたログ レコードのシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `data` パラメーターに格納されたデータは、レコードとして追加するために単一バイトの配列に連結されます。 ただし、レコードの読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 指定の予約情報は、レコード追加操作を含む分割不可能な操作内で、提供された予約コレクションに追加されます。 追加が失敗した場合、領域は予約されません。  
  
 このメソッドは通常、レコードの書き込みが終わる前に完了できます。 レコードが書き込まれたことを確認するために、<xref:System.IO.Log.RecordAppendOptions.ForceFlush> パラメーターを使用して `recordAppendOptions` フラグを指定するか、<xref:System.IO.Log.FileRecordSequence.Flush%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">1 つ以上の引数が範囲外です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> がこのレコード シーケンスによって作成されていません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求は実行されませんでした。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>予約された合計バイト数を取得します。</summary>
        <value>このレコード シーケンス内でなされたすべての予約の合計サイズ。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>直前に書き込まれた再開領域のシーケンス番号を取得します。</summary>
        <value>直前に書き込まれた再開領域のシーケンス番号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用されます。 Common Log File System \(CLFS\) は、少なくとも 1 つの有効な領域が常に使用可能であることを保証するために 2 つの再開領域を維持します。 回復処理が必要な場合、CLFS は最後のチェックポイント操作から再開領域とすべてのデータを読み取ります。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.FileRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ログがいっぱいの場合に、追加を自動的に再試行するかどうかを示す値を取得または設定します。</summary>
        <value>ログがいっぱいの場合に追加の再試行を自動的に行う場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティ値が `true` である場合で、シーケンス内に十分な領域がないために <xref:System.IO.Log.FileRecordSequence.Append%2A> の呼び出しが失敗したときは、レコード シーケンスが領域の解放を試みた後、追加の再試行を行います。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にプロパティがアクセスされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.FileRecordSequence.TailPinned" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レコード シーケンスで末尾を前方に移動する必要があると判断された場合に発生します。 このメソッドは継承できません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、レコード シーケンスが領域を使い果たしたときに発行できます。 このイベントが発行されると、シーケンスの末尾 \(つまり、基本シーケンス番号\) が領域の解放のために前方に移動します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 バイト配列セグメント内のデータは、レコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 バイト配列セグメント内のデータは、レコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 再開領域が書き込まれた場合、バイト配列セグメント内のデータはレコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 このメソッドが正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
 または  
  
 新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException">このシーケンスの <paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 再開領域が書き込まれた場合、バイト配列セグメント内のデータはレコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 このメソッドが正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
 または  
  
 新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException">このシーケンスの <paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <param name="reservations">この再開領域で使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 再開領域が書き込まれた場合、バイト配列セグメント内のデータはレコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 予約を指定すると、コレクションに格納されていた予約情報で以前に予約された領域が書き込まれた再開領域により消費されます。 このメソッドが成功すると、データを格納できる最も小さな予約が消費され、その予約がコレクションから削除されます。  
  
 このメソッドが正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I\/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
 または  
  
 新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。  
  
 または  
  
 このシーケンスの <paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">レコードとして連結および追加されるバイト配列セグメントのリスト。</param>
        <param name="newBaseSeqNum">新しい基本シーケンス番号。 指定するシーケンス番号は、現在の基本シーケンス番号以上であることが必要です。</param>
        <param name="reservations">この再開領域で使用する予約情報を格納する <see cref="T:System.IO.Log.ReservationCollection" />。</param>
        <summary>再開領域を <see cref="T:System.IO.Log.FileRecordSequence" /> に書き込みます。 このメソッドは継承できません。</summary>
        <returns>書き込まれた再開領域のシーケンス番号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 再開領域は、クライアントの最後のチェックポイント操作に関する情報を一時的に保存するために使用できます。 回復処理が必要な場合、最後のチェックポイント操作から再開領域を読み取り、すべてのデータを取得できます。 このデータは、回復プロセスで使用できるようにトランザクション テーブルおよびダーティ ページ テーブルを初期化し、ファイル テーブルを開きます。  
  
 再開領域は、<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A> メソッドを使用して読み取ることができます。  
  
 再開領域が書き込まれた場合、バイト配列セグメント内のデータはレコードとして追加するために単一のバイト配列に連結されます。 レコード領域の読み取り時にデータを分割して配列セグメントに戻す準備は実施されません。  
  
 予約を指定すると、コレクションに格納されていた予約情報で以前に予約された領域が書き込まれた再開領域により消費されます。 このメソッドが成功すると、データを格納できる最も小さな予約が消費され、その予約がコレクションから削除されます。  
  
 このメソッドが正しく完了すると、基本シーケンス番号が更新されます。 新しい基本シーケンス番号未満の番号を持つすべてのログ レコードは、アクセスできません。  
  
 レコード シーケンスが破棄されている場合、または無効な引数を渡した場合、この操作内で例外が直ちにスローされます。 I\/O 要求時にディスク障害が発生した場合など、非同期追加要求中にエラーが発生した場合、<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> メソッドが呼び出されたときに例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">1 つ以上の引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newBaseSeqNum" /> が、このシーケンスの基本シーケンス番号と最後のシーケンス番号との間にありません。  
  
 または  
  
 新しいアーカイブ末尾または既存のアーカイブ末尾、あるいはアーカイブ ログの基本が無効です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reservations" /> が、このレコード シーケンスによって作成されていません。  
  
 または  
  
 このシーケンスの <paramref name="newBaseSeqNum" /> が有効ではありません。</exception>
        <exception cref="T:System.NotSupportedException">レコード シーケンスが読み取り専用アクセスで開かれているため、操作を実行できません。</exception>
        <exception cref="T:System.IO.IOException">予期しない I\/O 例外のため、要求を実行できません。</exception>
        <exception cref="T:System.ObjectDisposedException">シーケンスが破棄された後にメソッドが呼び出されました。</exception>
        <exception cref="T:System.OutOfMemoryException">プログラムの実行を継続する十分なメモリがありません。</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">レコード シーケンスがいっぱいです。</exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <paramref name="data" /> に対応する十分なサイズの予約が <paramref name="reservations" /> に見つかりません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同期の追加操作を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>追加したレコードは永続的に書き込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>単一の予約を自動的に行って、シーケンスにレコードを追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同期の予約および追加操作を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.IO.Log.FileRecordSequence" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同期の再開領域の書き込み操作を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>