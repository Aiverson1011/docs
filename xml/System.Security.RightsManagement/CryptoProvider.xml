<Type Name="CryptoProvider" FullName="System.Security.RightsManagement.CryptoProvider">
  <TypeSignature Language="C#" Value="public class CryptoProvider : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CryptoProvider extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Security.RightsManagement.CryptoProvider" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical(System.Security.SecurityCriticalScope.Everything)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>保護されたコンテンツを暗号化および復号化するデジタル著作権管理サービスを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Security.RightsManagement.CryptoProvider> is created as a result of the <xref:System.Security.RightsManagement.UseLicense.Bind%2A> method when binding a rights managed <xref:System.Security.RightsManagement.UseLicense> to a <xref:System.Security.RightsManagement.SecureEnvironment>.  
  
 As with other <xref:System.Security.RightsManagement> types, <xref:System.Security.RightsManagement.CryptoProvider> is only usable in full trust applications.  
  
   
  
## 例  
 The following example shows how to use the <xref:System.Security.RightsManagement.CryptoProvider> class to create an <xref:System.IO.Packaging.EncryptedPackageEnvelope>.  
  
 [!code-csharp[RightsManagedPackagePublish\#RmPkgPubEncrypt](~/samples/snippets/csharp/VS_Snippets_Wpf/RightsManagedPackagePublish/CSharp/Window1.xaml.cs#rmpkgpubencrypt)]
 [!code-vb[RightsManagedPackagePublish\#RmPkgPubEncrypt](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RightsManagedPackagePublish/visualbasic/window1.xaml.vb#rmpkgpubencrypt)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.RightsManagement.UseLicense" />
    <altmember cref="T:System.Security.RightsManagement.SecureEnvironment" />
  </Docs>
  <Members>
    <Member MemberName="BlockSize">
      <MemberSignature Language="C#" Value="public int BlockSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BlockSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.RightsManagement.CryptoProvider.BlockSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>暗号のブロック サイズをバイト単位で取得します。</summary>
        <value>暗号ブロック サイズ \(バイト単位\)。  既定のブロック サイズ 高度暗号化標準 \(AES\) は 8 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `clearText` と `cipherText` に渡されたバッファー <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> と <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A> n \* する必要があります<xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A> バイトの長さ、場所 'n' は整数値を 1 以上です。  
  
 場合 <xref:System.Security.RightsManagement.CryptoProvider.CanMergeBlocks%2A> は `false`, に渡されたバッファー <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> に渡されたバッファーと同じ長さにする必要があります <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A>します。  
  
 場合 <xref:System.Security.RightsManagement.CryptoProvider.CanMergeBlocks%2A> は `true`, に渡されたバッファー <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> に渡されるバッファーから別の長さを指定できます <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A> \(すべてのバッファー サイズの倍数である必要がありますも常に <xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A> バイトの長さ\) です。  
  
 A <xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A> 1 には、暗号文がストリーム暗号をあることを示します。 つまり、 <xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A> 2 以上のブロック暗号を示します。  
  
   
  
## 例  
 次の例では、使用する方法、 <xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A> 暗号化テキスト データをクリア テキスト データを変換する場合のプロパティです。  
  
 [!code-csharp[RightsManagedContentPublish\#RmContPubEncrypt](~/samples/snippets/csharp/VS_Snippets_Wpf/RightsManagedContentPublish/CSharp/Window1.xaml.cs#rmcontpubencrypt)]
 [!code-vb[RightsManagedContentPublish\#RmContPubEncrypt](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RightsManagedContentPublish/visualbasic/window1.xaml.vb#rmcontpubencrypt)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BoundGrants">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.RightsManagement.ContentGrant&gt; BoundGrants { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.RightsManagement.ContentGrant&gt; BoundGrants" />
      <MemberSignature Language="DocId" Value="P:System.Security.RightsManagement.CryptoProvider.BoundGrants" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.RightsManagement.ContentGrant&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>検証に合格し、ユーザーに付与される権限の一覧を表示するコレクションを取得します。</summary>
        <value>検証に合格し、する権限を列挙するコレクションは、ユーザーに付与されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例では、使用する方法、 <xref:System.Security.RightsManagement.CryptoProvider.BoundGrants%2A> を通じて付与された権限の一覧を取得するプロパティ、 <xref:System.Security.RightsManagement.UseLicense>です。  
  
 [!code-csharp[RightsManagedContentViewer\#RmContViewUseLicense](~/samples/snippets/csharp/VS_Snippets_Wpf/RightsManagedContentViewer/CSharp/Window1.xaml.cs#rmcontviewuselicense)]
 [!code-vb[RightsManagedContentViewer\#RmContViewUseLicense](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RightsManagedContentViewer/visualbasic/window1.xaml.vb#rmcontviewuselicense)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanDecrypt">
      <MemberSignature Language="C#" Value="public bool CanDecrypt { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanDecrypt" />
      <MemberSignature Language="DocId" Value="P:System.Security.RightsManagement.CryptoProvider.CanDecrypt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが暗号化を解除する権限を持っているかどうかを示す値を取得します。</summary>
        <value>**true** 場合、 <see cref="T:System.Security.RightsManagement.UseLicense" /> ; の暗号化を解除するユーザーの権利を許諾それ以外の場合、 **false**します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Security.RightsManagement.CryptoProvider.CanDecrypt%2A> 返します **true** 場合、 <xref:System.Security.RightsManagement.UseLicense> これにバインドされている <xref:System.Security.RightsManagement.CryptoProvider> 表示、編集、印刷、または所有者などの読み取りアクセス権をユーザーに付与します。  
  
   
  
## 例  
 次の例では、使用する方法、 <xref:System.Security.RightsManagement.CryptoProvider.CanDecrypt%2A> 復号化が許可されたかどうかを判断するプロパティです。  
  
 [!code-csharp[RightsManagedContentViewer\#RmContViewUseLicense](~/samples/snippets/csharp/VS_Snippets_Wpf/RightsManagedContentViewer/CSharp/Window1.xaml.cs#rmcontviewuselicense)]
 [!code-vb[RightsManagedContentViewer\#RmContViewUseLicense](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RightsManagedContentViewer/visualbasic/window1.xaml.vb#rmcontviewuselicense)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.RightsManagement.CryptoProvider.CanEncrypt" />
        <altmember cref="M:System.Security.RightsManagement.UseLicense.Bind(System.Security.RightsManagement.SecureEnvironment)" />
      </Docs>
    </Member>
    <Member MemberName="CanEncrypt">
      <MemberSignature Language="C#" Value="public bool CanEncrypt { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEncrypt" />
      <MemberSignature Language="DocId" Value="P:System.Security.RightsManagement.CryptoProvider.CanEncrypt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが暗号化の権限を持っているかどうかを示す値を取得します。</summary>
        <value>**true** 場合、 <see cref="T:System.Security.RightsManagement.UseLicense" /> ; の暗号化にユーザーの権利を許諾それ以外の場合、 **false**します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Security.RightsManagement.CryptoProvider.CanDecrypt%2A> 返します **true** 場合、 <xref:System.Security.RightsManagement.UseLicense> これにバインドされている <xref:System.Security.RightsManagement.CryptoProvider> 編集や所有者などの書き込みアクセス権をユーザーに付与します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.RightsManagement.CryptoProvider.CanDecrypt" />
        <altmember cref="M:System.Security.RightsManagement.UseLicense.Bind(System.Security.RightsManagement.SecureEnvironment)" />
      </Docs>
    </Member>
    <Member MemberName="CanMergeBlocks">
      <MemberSignature Language="C#" Value="public bool CanMergeBlocks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanMergeBlocks" />
      <MemberSignature Language="DocId" Value="P:System.Security.RightsManagement.CryptoProvider.CanMergeBlocks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか <see cref="M:System.Security.RightsManagement.CryptoProvider.Encrypt(System.Byte[])" /> と <see cref="M:System.Security.RightsManagement.CryptoProvider.Decrypt(System.Byte[])" /> 別のバッファー ブロック サイズの長さを受け取ることができます。</summary>
        <value>**true** にバッファーが渡された場合 <see cref="M:System.Security.RightsManagement.CryptoProvider.Encrypt(System.Byte[])" /> に渡されたバッファーから別の長さを指定できます <see cref="M:System.Security.RightsManagement.CryptoProvider.Decrypt(System.Byte[])" />。 そうしないと、 **false** に渡されたバッファー場合 <see cref="M:System.Security.RightsManagement.CryptoProvider.Encrypt(System.Byte[])" /> と <see cref="M:System.Security.RightsManagement.CryptoProvider.Decrypt(System.Byte[])" /> 完全に同じ長さにする必要があります。高度暗号化標準 \(AES\) 既定値は **true**します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `clearText` と `cipherText` に渡されたバッファー <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> と <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A> n \* する必要があります<xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A> バイトの長さ、場所 'n' は整数値を 1 以上です。  
  
 場合 <xref:System.Security.RightsManagement.CryptoProvider.CanMergeBlocks%2A> は **false**, に渡されたバッファー <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> に渡されたバッファーと同じ長さにする必要があります <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A>します。  
  
 場合 <xref:System.Security.RightsManagement.CryptoProvider.CanMergeBlocks%2A> は **true**, に渡されたバッファー <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> に渡されるバッファーから別の長さを指定できます <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A> \(すべてのバッファー サイズの倍数である必要がありますも常に <xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A> バイトの長さ\) です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public byte[] Decrypt (byte[] cryptoText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Decrypt(unsigned int8[] cryptoText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.RightsManagement.CryptoProvider.Decrypt(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cryptoText" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="cryptoText">復号化する暗号テキスト。</param>
        <summary>暗号テキストをクリア テキストを復号化します。</summary>
        <returns>テキストをオフに、復号化された <paramref name="cryptoText" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例では、使用する方法、 <xref:System.Security.RightsManagement.CryptoProvider.Decrypt%2A> 暗号化されたデータを暗号化されていないデータに変換します。  
  
 [!code-csharp[RightsManagedContentViewer\#RmContViewDecrypt](~/samples/snippets/csharp/VS_Snippets_Wpf/RightsManagedContentViewer/CSharp/Window1.xaml.cs#rmcontviewdecrypt)]
 [!code-vb[RightsManagedContentViewer\#RmContViewDecrypt](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RightsManagedContentViewer/visualbasic/window1.xaml.vb#rmcontviewdecrypt)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cipherText" /> が null です。</exception>
        <exception cref="T:System.Security.RightsManagement.RightsManagementException">権限は与えないでを復号化します。</exception>
        <altmember cref="P:System.Security.RightsManagement.CryptoProvider.CanDecrypt" />
        <altmember cref="M:System.Security.RightsManagement.CryptoProvider.Encrypt(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.RightsManagement.CryptoProvider.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Security.RightsManagement.CryptoProvider" /> によって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Security.RightsManagement.CryptoProvider.Dispose%2A> performs <xref:System.Security.RightsManagement.CryptoProvider.Dispose%2A>\(**true**\).  
  
 Call <xref:System.Security.RightsManagement.CryptoProvider.Dispose%2A> when you are finished using the <xref:System.Security.RightsManagement.CryptoProvider>. The <xref:System.Security.RightsManagement.CryptoProvider.Dispose%2A> method leaves the <xref:System.Security.RightsManagement.CryptoProvider> in an unusable state. After calling <xref:System.Security.RightsManagement.CryptoProvider.Dispose%2A>, you must release all references to the <xref:System.Security.RightsManagement.CryptoProvider> so the garbage collector can reclaim the memory that the <xref:System.Security.RightsManagement.CryptoProvider> was occupying. For more information, see [Cleaning Up Unmanaged Resources](http://msdn.microsoft.com/ja-jp/a17b0066-71c2-4ba4-9822-8e19332fc213) and [Implementing a Dispose Method](http://msdn.microsoft.com/ja-jp/eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9).  
  
> [!NOTE]
>  Always call <xref:System.Security.RightsManagement.CryptoProvider.Dispose%2A> before you release your last reference to the <xref:System.Security.RightsManagement.CryptoProvider>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Security.RightsManagement.CryptoProvider> object's **languageKeyword tag is not supported!!!!**  
>  method.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.RightsManagement.CryptoProvider.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Security.RightsManagement.CryptoProvider" /> によって使用されているアンマネージ リソースを解放し、オプションでマネージ リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is called by the public **languageKeyword tag is not supported!!!!**  
**legacyBold tag is not supported!!!!**  
method and the <xref:System.Object.Finalize%2A> method. **languageKeyword tag is not supported!!!!**  
 invokes the protected **languageKeyword tag is not supported!!!!**  
 method with the **parameterReference tag is not supported!!!!**  
 parameter set to **languageKeyword tag is not supported!!!!**  
. <xref:System.Object.Finalize%2A> invokes **languageKeyword tag is not supported!!!!**  
 with **parameterReference tag is not supported!!!!**  
 set to **languageKeyword tag is not supported!!!!**  
.  
  
 When the **parameterReference tag is not supported!!!!**  
 parameter is true, this method releases all resources held by any managed objects that this <xref:System.Security.RightsManagement.CryptoProvider> references. This method invokes the **languageKeyword tag is not supported!!!!**  
 method of each referenced object.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> can be called multiple times by other objects. When overriding <see langword="Dispose(Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />. For more information about how to implement <see langword="Dispose(Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public byte[] Encrypt (byte[] clearText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Encrypt(unsigned int8[] clearText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.RightsManagement.CryptoProvider.Encrypt(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clearText" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="clearText">暗号化するクリア テキスト コンテンツ。</param>
        <summary>クリア テキストを暗号化テキストに暗号化します。</summary>
        <returns>指定された <paramref name="clearText" /> の暗号化済みの暗号化テキスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The byte length of the **parameterReference tag is not supported!!!!**  
 buffer should be a multiple of the cipher <xref:System.Security.RightsManagement.CryptoProvider.BlockSize%2A> property.  
  
 The digital rights management system uses [!INCLUDE[TLA#tla_aes](~/includes/tlasharptla-aes-md.md)] block cipher.  With [!INCLUDE[TLA2#tla_aes](~/includes/tla2sharptla-aes-md.md)], blocks are encrypted independently such that two blocks of identical clear text produce identical cipher text results.  To minimize potential decryption threats from independent block encryption, applications should employ methods to modify content, such as compression, to avoid encrypting identical clear text blocks.  
  
   
  
## 例  
 The following example shows how to use the <xref:System.Security.RightsManagement.CryptoProvider.Encrypt%2A> method to convert clear\-text data to encrypted\-text data.  
  
 [!code-csharp[RightsManagedContentPublish\#RmContPubEncrypt](~/samples/snippets/csharp/VS_Snippets_Wpf/RightsManagedContentPublish/CSharp/Window1.xaml.cs#rmcontpubencrypt)]
 [!code-vb[RightsManagedContentPublish\#RmContPubEncrypt](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RightsManagedContentPublish/visualbasic/window1.xaml.vb#rmcontpubencrypt)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="clearText" /> が null です。</exception>
        <exception cref="T:System.Security.RightsManagement.RightsManagementException">暗号化は許可されていません。</exception>
        <altmember cref="P:System.Security.RightsManagement.CryptoProvider.CanEncrypt" />
        <altmember cref="M:System.Security.RightsManagement.CryptoProvider.Decrypt(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CryptoProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.RightsManagement.CryptoProvider.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リソースを解放し、インスタンスがガベージ コレクションによって回収される前に、内部的なクリーンアップを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Security.RightsManagement.CryptoProvider.Finalize%2A> 実行 <xref:System.Security.RightsManagement.CryptoProvider.Dispose%2A>\(**false**\)。  
  
 このメソッドは  <xref:System.Object.Finalize%2A>です。 アプリケーション コードは、このメソッドを呼び出さないようにオブジェクトの `Finalize` への呼び出しによって、ガベージ コレクターによって終了処理が無効になっていない限りガベージ コレクション中にメソッドが自動的に起動、 <xref:System.GC.SuppressFinalize%2A> メソッドです。  
  
 詳細については、次を参照してください。 [Finalize メソッドおよびデストラクター](http://msdn.microsoft.com/ja-jp/fd376774-1643-499b-869e-9546a3aeea70), 、[Cleaning Up Unmanaged Resources](http://msdn.microsoft.com/ja-jp/a17b0066-71c2-4ba4-9822-8e19332fc213), 、および [Finalize メソッドをオーバーライドする](http://msdn.microsoft.com/ja-jp/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Security.RightsManagement.CryptoProvider" /> で使用したリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>