<Type Name="TextBox" FullName="System.Windows.Forms.TextBox">
  <TypeSignature Language="C#" Value="public class TextBox : System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextBox extends System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.TextBox" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.TextBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows のテキスト ボックス コントロールを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Forms.TextBox> コントロール、ユーザーは、アプリケーションにテキストを入力することができます。 このコントロールには、複数行の編集やパスワードの文字のマスクを含む、標準の Windows テキスト ボックス コントロールに含まれていない追加の機能があります。  
  
 通常、 <xref:System.Windows.Forms.TextBox> を表示するか、1 行のテキストの入力としてそのまま使用するコントロールを使用します。 使用することができます、 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> と <xref:System.Windows.Forms.TextBox.ScrollBars%2A> プロパティを複数行の表示または入力するテキストを有効にします。 設定、 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A> と <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A> プロパティ `true` 複数行のテキスト操作の向上を有効にする <xref:System.Windows.Forms.TextBox> コントロールです。  
  
> [!NOTE]
>  設定する必要があります、 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> プロパティを `true` の高さを調整する、 <xref:System.Windows.Forms.TextBox> コントロールです。 高さを調整するには設定して、 <xref:System.Windows.Forms.Control.Size%2A> プロパティです。  
  
 入力したテキストに量を制限することができます、 <xref:System.Windows.Forms.TextBox> コントロールを設定して、 <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> プロパティを特定の文字数。<xref:System.Windows.Forms.TextBox> コントロールは、パスワードや他の機密情報をそのまま使用することもできます。 使用することができます、 <xref:System.Windows.Forms.TextBox.PasswordChar%2A> プロパティを単一行のバージョンのコントロールに入力された文字をマスクします。 使用して、 <xref:System.Windows.Forms.TextBox.CharacterCasing%2A> プロパティにより、ユーザーは、大文字、小文字のみ、型だけをまたはに大文字と小文字の文字を組み合わせた、 <xref:System.Windows.Forms.TextBox> コントロールです。  
  
 内容をスクロールする、 <xref:System.Windows.Forms.TextBox> 使用することができます \(キャレット\) のカーソルは、コントロールの可視領域内に入るまで、 <xref:System.Windows.Forms.TextBoxBase.ScrollToCaret%2A> メソッドです。 使用できるテキスト ボックス内のテキストの範囲を選択する、 <xref:System.Windows.Forms.TextBoxBase.Select%2A> メソッドです。  
  
 入力されているからテキストを制限する、 <xref:System.Windows.Forms.TextBox> 、コントロールのイベント ハンドラーを作成することができます、 <xref:System.Windows.Forms.Control.KeyDown> コントロールで入力した各文字を検証するためにイベントです。 内のデータのすべてのエントリを制限することも、 <xref:System.Windows.Forms.TextBox> コントロールを設定して、 <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> プロパティを `true`します。  
  
> [!NOTE]
>  ほとんどの機能の <xref:System.Windows.Forms.TextBox> から制御が継承された、 <xref:System.Windows.Forms.TextBoxBase> クラスです。  
>   
>  使用して、 <xref:System.Windows.Forms.TextBox> 有効になった visual スタイルを持つコントロールと、サロゲートのフォントが不適切に処理します。  
  
   
  
## 例  
 次のコード例は、複数行の文字列を作成 <xref:System.Windows.Forms.TextBox> 垂直スクロール バーをコントロールします。 この例では、 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, 、<xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, 、および <xref:System.Windows.Forms.Control.Dock%2A> のプロパティを複数行テキスト ボックス コントロールのテキスト ドキュメントを作成するのに便利です。  
  
 [!code-csharp[Classic TextBox Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.TextBoxBase" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.TextBox" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 親コンテナー コントロールの色とフォントの設定を定義する、 <xref:System.Windows.Forms.TextBox>です。  
  
   
  
## 例  
 次のコード例は、の新しいインスタンスを作成、 <xref:System.Windows.Forms.TextBox> を制御し、コントロールの文字列を割り当てます <xref:System.Windows.Forms.TextBoxBase.Text%2A> プロパティです。  
  
 [!code-cpp[Classic TextBox.TextBox Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.TextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.TextBox Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.TextBox Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.TextBox Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.TextBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptsReturn">
      <MemberSignature Language="C#" Value="public bool AcceptsReturn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcceptsReturn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.AcceptsReturn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>複数行で ENTER キーを押すかどうかを示す値を設定を取得または <see cref="T:System.Windows.Forms.TextBox" /> コントロールがコントロールで、新しい行のテキストを作成またはフォームの既定のボタンをアクティブにします。</summary>
        <value>
          <see langword="true" /> ENTER キーがコントロールの複数行のバージョンで、新しい行のテキストを作成する場合 <see langword="false" /> 場合は、ENTER キーがフォームの既定のボタンをアクティブにします。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの値の場合 `false`, 、複数行に新しい行を作成するには、CTRL \+ ENTER を押す必要がある <xref:System.Windows.Forms.TextBox> コントロールです。 フォームの既定のボタンがない場合は、ENTER キーは常に作成されているコントロールでは、このプロパティの値に関係なく、新しい行のテキストを使用します。  
  
   
  
## 例  
 次のコード例は、複数行の文字列を作成 <xref:System.Windows.Forms.TextBox> 垂直スクロール バーをコントロールします。 この例では、 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, 、<xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, 、および <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> のプロパティを複数行テキスト ボックス コントロールのテキスト ドキュメントを作成するのに便利です。  
  
 [!code-cpp[Classic TextBox.AcceptsReturn Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.AcceptsReturn Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.AcceptsReturn Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoCompleteCustomSource">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoCompleteStringCollection AutoCompleteCustomSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AutoCompleteStringCollection AutoCompleteCustomSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.AutoCompleteCustomSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ListControlStringCollectionEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoCompleteStringCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.TextBox.AutoCompleteSource" /> プロパティが <see langword="CustomSource" /> に設定されている場合に使用するカスタム <see cref="T:System.Collections.Specialized.StringCollection" /> を取得または設定します。</summary>
        <value>
          <see cref="P:System.Windows.Forms.TextBox.AutoCompleteSource" /> に使用する <see cref="T:System.Collections.Specialized.StringCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>, 、<xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>, 、および <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> を作成するプロパティ、 <xref:System.Windows.Forms.TextBox> 保持しているソース内のすべての文字列のプレフィックスに入力されているプレフィックスを比較することによって自動的に入力文字列は完成です。 これは <xref:System.Windows.Forms.TextBox> コントロールで Url、アドレス、ファイル名またはコマンド頻繁に入力されます。  
  
 使用、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A> プロパティは省略可能で、設定する必要がありますが、 <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> プロパティを `CustomSource` を使用するために <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>します。  
  
 使用する必要があります、 <xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A> と <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> プロパティをまとめています。  
  
> [!NOTE]
>  オペレーティング システムでは、一度に表示できるカスタムの文字列の数を制限可能性があります。  
  
   
  
## 例  
 オート コンプリートのカスタム ソースとしてコレクションを使用する次のコード例には、 <xref:System.Windows.Forms.TextBox> コントロールです。 この例の内容は次のとおりです。  
  
-   使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> プロパティを有効にする、 <xref:System.Windows.Forms.TextBox> 、オート コンプリートの動作のカスタム ソースをそのまま使用するコントロール。  
  
-   使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A> 値のカスタム リストを設定するプロパティです。  
  
-   使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A> オートコンプリートの候補の表示方法を設定するプロパティです。  
  
 [!code-csharp[System.Windows.Forms.TextBox.AutoCompleteCustomSource\#10](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/cs/form1.cs#10)]
 [!code-vb[System.Windows.Forms.TextBox.AutoCompleteCustomSource\#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/vb/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBox.AutoCompleteSource" />
        <altmember cref="P:System.Windows.Forms.TextBox.AutoCompleteMode" />
      </Docs>
    </Member>
    <Member MemberName="AutoCompleteMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoCompleteMode AutoCompleteMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoCompleteMode AutoCompleteMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.AutoCompleteMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoCompleteMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.Forms.TextBox" /> のオート コンプリートの動作を制御するオプションを取得または設定します。</summary>
        <value>
          <see cref="T:System.Windows.Forms.AutoCompleteMode" /> の値の 1 つ。 値を次に示します。  
  
 <see cref="F:System.Windows.Forms.AutoCompleteMode.Append" />  
 既存の文字を追加した文字を強調表示するには、最も可能性の高い候補文字列の残りの部分を追加します。  
  
 <see cref="F:System.Windows.Forms.AutoCompleteMode.Suggest" />  
 エディット コントロールに関連付けられている補助ボックスの一覧を表示します。 このドロップダウン リストには、1 つまたは複数補完文字列の候補が表示されます。  
  
 <see cref="F:System.Windows.Forms.AutoCompleteMode.SuggestAppend" />  
 両方を追加 <see langword="Suggest" /> と <see langword="Append" /> オプション。  
  
 <see cref="F:System.Windows.Forms.AutoCompleteMode.None" />  
 オート コンプリートを無効にします。 既定値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>, 、<xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>, 、および <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> を作成するプロパティ、 <xref:System.Windows.Forms.TextBox> 保持しているソース内のすべての文字列のプレフィックスに入力されているプレフィックスを比較することによって自動的に入力文字列は完成です。 これは <xref:System.Windows.Forms.TextBox> コントロールで Url、アドレス、ファイル名またはコマンド頻繁に入力されます。  
  
 使用、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A> プロパティは省略可能で、設定する必要がありますが、 <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> プロパティを `CustomSource` を使用するために <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>します。  
  
 使用する必要があります、 <xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A> と <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> プロパティをまとめています。  
  
> [!NOTE]
>  オペレーティング システムでは、一度に表示できるカスタムの文字列の数を制限可能性があります。  
  
   
  
## 例  
 オート コンプリートのカスタム ソースとしてコレクションを使用する次のコード例には、 <xref:System.Windows.Forms.TextBox> コントロールです。 この例の内容は次のとおりです。  
  
-   使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> プロパティを有効にする、 <xref:System.Windows.Forms.TextBox> 、オート コンプリートの動作のカスタム ソースをそのまま使用するコントロール。  
  
-   使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A> 値のカスタム リストを設定するプロパティです。  
  
-   使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A> オートコンプリートの候補の表示方法を設定するプロパティです。  
  
 [!code-csharp[System.Windows.Forms.TextBox.AutoCompleteCustomSource\#10](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/cs/form1.cs#10)]
 [!code-vb[System.Windows.Forms.TextBox.AutoCompleteCustomSource\#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/vb/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定した値がないの値の 1 つ <see cref="T:System.Windows.Forms.AutoCompleteMode" />します。</exception>
        <altmember cref="P:System.Windows.Forms.TextBox.AutoCompleteCustomSource" />
        <altmember cref="P:System.Windows.Forms.TextBox.AutoCompleteSource" />
      </Docs>
    </Member>
    <Member MemberName="AutoCompleteSource">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoCompleteSource AutoCompleteSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoCompleteSource AutoCompleteSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.AutoCompleteSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.TextBoxAutoCompleteSourceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoCompleteSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オート コンプリートで使用する完全な文字列のソースを指定する値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Windows.Forms.AutoCompleteSource" /> の値の 1 つ。 オプションは、<see langword="AllSystemSources" />、<see langword="AllUrl" />、<see langword="FileSystem" />、<see langword="HistoryList" />、<see langword="RecentlyUsedList" />、<see langword="CustomSource" />、および <see langword="None" /> です。 既定値は、<see langword="None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>, 、<xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A>, 、および <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> を作成するプロパティ、 <xref:System.Windows.Forms.TextBox> 保持しているソース内のすべての文字列のプレフィックスに入力されているプレフィックスを比較することによって自動的に入力文字列は完成です。 これは <xref:System.Windows.Forms.TextBox> コントロールで Url、アドレス、ファイル名またはコマンド頻繁に入力されます。  
  
 使用、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A> プロパティは省略可能で、設定する必要がありますが、 <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> プロパティを `CustomSource` を使用するために <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A>します。  
  
 使用する必要があります、 <xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A> と <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> プロパティをまとめています。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> 複数行では動作しません <xref:System.Windows.Forms.TextBox> コントロールです。  
  
> [!NOTE]
>  オペレーティング システムでは、一度に表示できるカスタムの文字列の数を制限可能性があります。  
  
   
  
## 例  
 オート コンプリートのカスタム ソースとしてコレクションを使用する次のコード例には、 <xref:System.Windows.Forms.TextBox> コントロールです。 この例の内容は次のとおりです。  
  
-   使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> プロパティを有効にする、 <xref:System.Windows.Forms.TextBox> 、オート コンプリートの動作のカスタム ソースをそのまま使用するコントロール。  
  
-   使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteCustomSource%2A> 値のカスタム リストを設定するプロパティです。  
  
-   使用して、 <xref:System.Windows.Forms.TextBox.AutoCompleteMode%2A> オートコンプリートの候補の表示方法を設定するプロパティです。  
  
 [!code-csharp[System.Windows.Forms.TextBox.AutoCompleteCustomSource\#10](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/cs/form1.cs#10)]
 [!code-vb[System.Windows.Forms.TextBox.AutoCompleteCustomSource\#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.textbox.autocompletecustomsource/vb/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定した値がないの値の 1 つ <see cref="T:System.Windows.Forms.AutoCompleteSource" />します。</exception>
        <altmember cref="P:System.Windows.Forms.TextBox.AutoCompleteCustomSource" />
        <altmember cref="P:System.Windows.Forms.TextBox.AutoCompleteMode" />
      </Docs>
    </Member>
    <Member MemberName="CharacterCasing">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.CharacterCasing CharacterCasing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.CharacterCasing CharacterCasing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.CharacterCasing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CharacterCasing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定するかどうか、 <see cref="T:System.Windows.Forms.TextBox" /> コントロールは、入力された文字の大文字と小文字を変更します。</summary>
        <value>いずれか、 <see cref="T:System.Windows.Forms.CharacterCasing" /> 列挙値を指定するかどうか、 <see cref="T:System.Windows.Forms.TextBox" /> コントロールは、文字の大文字と小文字を変更します。 既定値は、<see langword="CharacterCasing.Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することができます、 <xref:System.Windows.Forms.TextBox.CharacterCasing%2A> 、アプリケーションで必要な文字の大文字と小文字を変更するプロパティです。 入力されたすべての文字の大文字と小文字を変更するなど、 <xref:System.Windows.Forms.TextBox> コントロールのパスワード入力の大文字または小文字のパスワードのポリシーを適用するために使用します。  
  
   
  
## 例  
 次のコード例を作成、 <xref:System.Windows.Forms.TextBox> コントロール、パスワードをそのまま使用するために使用します。 この例では、 <xref:System.Windows.Forms.TextBox.CharacterCasing%2A> に型指定されたすべての文字を変更するプロパティを小文字の区別、および <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> パスワードの長さが 8 文字に制限するプロパティです。 またこの例では、 <xref:System.Windows.Forms.TextBox.TextAlign%2A> プロパティでパスワードを中央に配置する、 <xref:System.Windows.Forms.TextBox> コントロールです。  
  
 [!code-cpp[Classic TextBox.CharacterCasing Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.CharacterCasing Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.CharacterCasing Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">列挙体の有効な値の範囲外の値は、このプロパティに割り当てられました。</exception>
        <altmember cref="T:System.Windows.Forms.CharacterCasing" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール ハンドルが作成されるときに必要な作成パラメーターを取得します。</summary>
        <value>コントロールを識別するハンドルを作成するときに必要な作成パラメーターを格納している <see cref="T:System.Windows.Forms.CreateParams" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Windows.Forms.TextBox" /> によって使用されているアンマネージ リソースを解放し、オプションでマネージ リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is called by the public **languageKeyword tag is not supported!!!!**  
 method and the <xref:System.Object.Finalize%2A> method. **languageKeyword tag is not supported!!!!**  
 invokes the protected **languageKeyword tag is not supported!!!!**  
 method with the **parameterReference tag is not supported!!!!**  
 parameter set to **languageKeyword tag is not supported!!!!**  
. <xref:System.Object.Finalize%2A> invokes **languageKeyword tag is not supported!!!!**  
 with **parameterReference tag is not supported!!!!**  
 set to **languageKeyword tag is not supported!!!!**  
.  
  
 When the **parameterReference tag is not supported!!!!**  
 parameter is **languageKeyword tag is not supported!!!!**  
, this method releases all resources held by any managed objects that this <xref:System.Windows.Forms.TextBox> references. This method invokes the **languageKeyword tag is not supported!!!!**  
 method of each referenced object.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> can be called multiple times by other objects. When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" />. For more information about how to implement <see langword="Dispose(Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected override bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">キーの値のいずれかです。</param>
        <summary>指定されているキーが、入力キーであるか、またはプリプロセスを必要とする特殊なキーであるかを確認します。</summary>
        <returns>
          <see langword="true" /> 指定したキーが入力キーである場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Forms.TextBox.IsInputKey%2A> メソッドを返します。 `true` と `keyData` が含まれています、 <xref:System.Windows.Forms.Keys.Return> 値、および <xref:System.Windows.Forms.TextBox.AcceptsReturn%2A> プロパティは `true`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public override bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.Multiline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールが複数行 <see cref="T:System.Windows.Forms.TextBox" /> コントロールかどうかを示す値を取得または設定します。</summary>
        <value>コントロールが複数行 <see cref="T:System.Windows.Forms.TextBox" /> コントロールである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Forms.TextBox.AutoCompleteSource%2A> 複数行では動作しません <xref:System.Windows.Forms.TextBox> コントロールです。  
  
 フォントが変更されたときに定義されている任意のインデントは表示されません。 インデントを取得するには、次のように設定します。 <xref:System.Windows.Forms.TextBox.Multiline%2A> に `true` を基本クラスを呼び出すことはできるようにします。  
  
   
  
## 例  
 次のコード例は、複数行の文字列を作成 <xref:System.Windows.Forms.TextBox> 垂直スクロール バーをコントロールします。 この例では、 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, 、<xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, 、および <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> のプロパティを複数行テキスト ボックス コントロールのテキスト ドキュメントを作成するのに便利です。  
  
 [!code-cpp[Classic TextBox.AcceptsReturn Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.AcceptsReturn Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.AcceptsReturn Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.AcceptsReturn Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnBackColorChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/ja-jp/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)します。  
  
 <xref:System.Windows.Forms.TextBox.OnBackColorChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Windows.Forms.TextBox.OnBackColorChanged(System.EventArgs)" /> in a derived class, be sure to call the base class’s <see cref="M:System.Windows.Forms.TextBox.OnBackColorChanged(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnFontChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.FontChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/ja-jp/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)します。  
  
 <xref:System.Windows.Forms.TextBox.OnFontChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Windows.Forms.TextBox.OnFontChanged(System.EventArgs)" /> in a derived class, be sure to call the base class’s <see cref="M:System.Windows.Forms.TextBox.OnFontChanged(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnGotFocus(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.GotFocus" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ユーザーがテキストを選択すると、 <xref:System.Windows.Forms.TextBox> コントロール、コントロールが選択を保存します。 ときに、 <xref:System.Windows.Forms.TextBox> コントロールがフォーカスを選択する場合と同じ、 <xref:System.Windows.Forms.TextBox> がフォーカスを失った。 ときに、 <xref:System.Windows.Forms.TextBox> 取得が最初に集中、全体のテキストが選択されています。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/ja-jp/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)します。  
  
 <xref:System.Windows.Forms.TextBox.OnGotFocus%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Windows.Forms.TextBox.OnGotFocus(System.EventArgs)" /> in a derived class, be sure to call the base class’s <see cref="M:System.Windows.Forms.TextBox.OnGotFocus(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnHandleCreated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary>
          <see cref="E:System.Windows.Forms.Control.HandleCreated" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/ja-jp/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)します。  
  
 <xref:System.Windows.Forms.TextBox.OnHandleDestroyed%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Windows.Forms.TextBox.OnHandleDestroyed(System.EventArgs)" /> in a derived class, be sure to call the base class’s <see cref="M:System.Windows.Forms.TextBox.OnHandleDestroyed(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTextAlignChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextAlignChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextAlignChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.OnTextAlignChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Windows.Forms.TextBox.TextAlignChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。 [NIB: イベントを発生させる](http://msdn.microsoft.com/ja-jp/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)します。  
  
 <xref:System.Windows.Forms.TextBox.OnTextAlignChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>When overriding <see cref="M:System.Windows.Forms.TextBox.OnTextAlignChanged(System.EventArgs)" /> in a derived class, be sure to call the base class's <see cref="M:System.Windows.Forms.TextBox.OnTextAlignChanged(System.EventArgs)" /> method so that registered delegates receive the event.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.TextBox.TextAlignChanged" />
        <altmember cref="P:System.Windows.Forms.TextBox.TextAlign" />
      </Docs>
    </Member>
    <Member MemberName="PasswordChar">
      <MemberSignature Language="C#" Value="public char PasswordChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.PasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue('\0')</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>単一行でのパスワードのマスク文字に使用する文字を取得または <see cref="T:System.Windows.Forms.TextBox" /> コントロールです。</summary>
        <value>単一行に入力されたマスク文字に使用する文字 <see cref="T:System.Windows.Forms.TextBox" /> コントロールです。 これらは入力としては、マスク文字にコントロールをしない場合は、0 \(文字値\) にこのプロパティの値を設定します。 既定では 0 \(文字値\) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A> プロパティに優先、 <xref:System.Windows.Forms.TextBox.PasswordChar%2A> プロパティです。 ときに、 <xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A> に設定されている `true`, 、既定のシステム パスワード文字が使用され、任意の文字を設定 <xref:System.Windows.Forms.TextBox.PasswordChar%2A> は無視されます。  
  
 ときに、 <xref:System.Windows.Forms.TextBox.PasswordChar%2A> プロパティが設定されて、キーボードを使用してコントロールでの切り取りとコピーの操作を行うことはできません。  
  
> [!IMPORTANT]
>  ときに、 <xref:System.Windows.Forms.TextBox> のでパスワード モードでは <xref:System.Windows.Forms.TextBox.PasswordChar%2A>, 、<xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A>, 、または <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> は `true`, 、 <xref:System.Windows.Forms.TextBox> 制限モードでは、です。 このモードでは、 <xref:System.Windows.Forms.ImeMode> は無効な場合、現在 <xref:System.Windows.Forms.ImeMode> 場合、復元できるようにキャッシュ、 <xref:System.Windows.Forms.TextBox> 無制限になるとします。 切り替え、 <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> 一般的なシナリオです。<xref:System.Windows.Forms.ImeMode> コントロールは、制限モードでは。 デザイナーの観点から、 <xref:System.Windows.Forms.ImeMode> に表示される値は、実際の値。  
  
   
  
## 例  
 次のコード例を作成、 <xref:System.Windows.Forms.TextBox> コントロール、パスワードをそのまま使用するために使用します。 この例では、 <xref:System.Windows.Forms.TextBox.CharacterCasing%2A> を小文字に型指定されたすべての文字を変更するプロパティと <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> パスワードの長さが 8 文字に制限するプロパティです。 またこの例では、 <xref:System.Windows.Forms.TextBox.TextAlign%2A> プロパティでパスワードを中央に配置する、 <xref:System.Windows.Forms.TextBox> コントロールです。  
  
 [!code-cpp[Classic TextBox.CharacterCasing Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.CharacterCasing Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.CharacterCasing Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.Paste(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">置換するテキスト。</param>
        <summary>元に戻すバッファーをクリアせず、選択したテキストを指定したテキストに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定とは異なり <xref:System.Windows.Forms.TextBoxBase.SelectedText%2A>, 、<xref:System.Windows.Forms.TextBox.Paste%2A> 、クリップボードには影響しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message m, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message m, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="m">処理するウィンドウ メッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。</param>
        <param name="keyData">処理するショートカット キーを表す <see cref="T:System.Windows.Forms.Keys" /> 値の 1 つ。</param>
        <summary>コマンド キーを処理します。</summary>
        <returns>コマンド キーがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 4.6.1 の新機能です。 以前のバージョンで ctrl キーを押し、ショートカット キーで、 <xref:System.Windows.Forms.TextBox> のすべてのテキストの選択に失敗したときに、 <xref:System.Windows.Forms.TextBoxBase.ShortcutsEnabled%2A> と <xref:System.Windows.Forms.TextBox.Multiline%2A> プロパティがどちらに設定 `true.`します。 このメソッドのすべてのテキストを選択する ctrl キーを押し、ショートカット キーを使用するときに、 <xref:System.Windows.Forms.TextBoxBase.ShortcutsEnabled%2A> と <xref:System.Windows.Forms.TextBox.Multiline%2A> プロパティはどちらに設定 `true.`  
  
 .NET Framework のバージョン 4.6 での 4.0 を対象とするアプリケーションでは、次のコードを追加することでこの方法の利点がかかる、 `<runtime>` app.config ファイルのセクション。  
  
```xml  
<AppContextSwitchOverrides value = "Switch.System.Windows.Forms.DoNotSupportSelectAllShortcutInMultilineTextBox=false" />  
```  
  
 次のコードを追加することで、.NET Framework のバージョン 4.6.1 または新しいが対象とするアプリケーションがこの動作しないこと、 `<runtime>` app.config ファイルのセクション。  
  
```xml  
<AppContextSwitchOverrides value = "Switch.System.Windows.Forms.DoNotSupportSelectAllShortcutInMultilineTextBox=true" />  
```  
  
> [!NOTE]
>  App.config ファイルが既に含まれている場合、 `AppContextSwitchOverrides` キー、既存のキーに、新しいキー値をマージします。 たとえば、`<AppContextSwitchOverrides value = "oldKey=oldValue;Switch.System.Windows.Forms.DoNotSupportSelectAllShortcutInMultilineTextBox=false" />` のようにします。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for operating with unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ScrollBars">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ScrollBars ScrollBars { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ScrollBars ScrollBars" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.ScrollBars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ScrollBars</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>複数行を取得または設定するスクロール バーが表示されます <see cref="T:System.Windows.Forms.TextBox" /> コントロールです。</summary>
        <value>いずれか、 <see cref="T:System.Windows.Forms.ScrollBars" /> を示す列挙値かどうか、複数行 <see cref="T:System.Windows.Forms.TextBox" /> コントロールはスクロール縦棒のない、水平スクロール バー、垂直スクロール バー、またはその両方が表示されます。 既定値は、<see langword="ScrollBars.None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 水平スクロール バーは表示されない場合、 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> にプロパティが設定されている `true`, の値に関係なく、 <xref:System.Windows.Forms.TextBox.ScrollBars%2A> プロパティです。  
  
   
  
## 例  
 次のコード例は、複数行の文字列を作成 <xref:System.Windows.Forms.TextBox> 垂直スクロール バーをコントロールします。 またこの例では、 <xref:System.Windows.Forms.TextBoxBase.AcceptsTab%2A>, 、<xref:System.Windows.Forms.TextBox.AcceptsReturn%2A>, 、および <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> のプロパティを複数行 <xref:System.Windows.Forms.TextBox> コントロール テキスト ドキュメントを作成するのに便利です。  
  
 [!code-cpp[Classic TextBox.ScrollBars Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.ScrollBars Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.ScrollBars Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.ScrollBars Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.ScrollBars Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.ScrollBars Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">列挙体の有効な値の範囲外の値は、このプロパティに割り当てられました。</exception>
        <altmember cref="T:System.Windows.Forms.ScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールに関連付けられているテキストを取得または設定します。</summary>
        <value>このコントロールに関連付けられたテキスト。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="TextAlign">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment TextAlign { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment TextAlign" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.TextAlign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定内のテキストの配置、 <see cref="T:System.Windows.Forms.TextBox" /> コントロールです。</summary>
        <value>いずれか、 <see cref="T:System.Windows.Forms.HorizontalAlignment" /> コントロールでテキストを配置する方法を指定する列挙値。 既定値は、<see langword="HorizontalAlignment.Left" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 内のテキストを配置するこのプロパティを使用する、 <xref:System.Windows.Forms.TextBox> 、フォーム上のテキストのレイアウトと一致します。 たとえば、ある場合は、コントロールはすべて、フォームの右側にある、設定できます、 <xref:System.Windows.Forms.Label.TextAlign%2A> プロパティを `HorizontalAlignment.Right`, 、テキストは既定の左揃えの代わりに、コントロールの右側に配置するとします。  
  
   
  
## 例  
 次のコード例を作成、 <xref:System.Windows.Forms.TextBox> コントロール、パスワードをそのまま使用するために使用します。 この例では、 <xref:System.Windows.Forms.TextBox.CharacterCasing%2A> に型指定されたすべての文字を変更するプロパティを小文字の区別、および <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> パスワードの長さが 8 文字に制限するプロパティです。 またこの例では、 <xref:System.Windows.Forms.TextBox.TextAlign%2A> プロパティでパスワードを中央に配置する、 <xref:System.Windows.Forms.TextBox> コントロールです。  
  
 [!code-cpp[Classic TextBox.CharacterCasing Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CPP/source.cpp#1)]
 [!code-csharp[Classic TextBox.CharacterCasing Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/CS/source.cs#1)]
 [!code-vb[Classic TextBox.CharacterCasing Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic TextBox.CharacterCasing Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">列挙体の有効な値の範囲外の値は、このプロパティに割り当てられました。</exception>
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
      </Docs>
    </Member>
    <Member MemberName="TextAlignChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextAlignChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextAlignChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TextBox.TextAlignChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Forms.TextBox.TextAlign" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/ja-jp/01e4f1bc-e55e-413f-98c7-6588493e5f67)します。  
  
   
  
## 例  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは、発生するときに報告、 <xref:System.Windows.Forms.TextBox.TextAlignChanged> イベントです。 このレポートによって、イベントが発生し、デバッグに役立ちます。 複数のイベントまたは頻繁に発生するイベントを報告するためには、交換を検討 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=fullName> と <xref:System.Console.WriteLine%2A?displayProperty=fullName> またはメッセージを複数行に追加する <xref:System.Windows.Forms.TextBox>です。  
  
 このコード例を実行する型のインスタンスを含むプロジェクトに貼り付けること <xref:System.Windows.Forms.TextBox> という `TextBox1`します。 イベント ハンドラーが関連付けられていることを確認して、 <xref:System.Windows.Forms.TextBox.TextAlignChanged> イベントです。  
  
 [!code-csharp[System.Windows.Forms.EventExamples\#249](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#249)]
 [!code-vb[System.Windows.Forms.EventExamples\#249](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#249)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBox.OnTextAlignChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.TextBox.TextAlign" />
      </Docs>
    </Member>
    <Member MemberName="UseSystemPasswordChar">
      <MemberSignature Language="C#" Value="public bool UseSystemPasswordChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSystemPasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TextBox.UseSystemPasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうかのテキスト、 <see cref="T:System.Windows.Forms.TextBox" /> コントロールが既定のパスワードの文字として表示する必要があります。</summary>
        <value>
          <see langword="true" /> 場合にテキスト、 <see cref="T:System.Windows.Forms.TextBox" /> コントロールが既定のパスワードとして表示される文字以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A> プロパティに優先、 <xref:System.Windows.Forms.TextBox.PasswordChar%2A> プロパティです。 ときに、 <xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A> に設定されている `true`, 、既定のシステム パスワード文字が使用され、任意の文字を設定 <xref:System.Windows.Forms.TextBox.PasswordChar%2A> は無視されます。  
  
> [!IMPORTANT]
>  ときに、 <xref:System.Windows.Forms.TextBox> のでパスワード モードでは <xref:System.Windows.Forms.TextBox.PasswordChar%2A>, 、<xref:System.Windows.Forms.TextBox.UseSystemPasswordChar%2A>, 、または <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> は `true`, 、 <xref:System.Windows.Forms.TextBox> 制限モードでは、です。 このモードでは、 <xref:System.Windows.Forms.ImeMode> は無効な場合、現在 <xref:System.Windows.Forms.ImeMode> 場合、復元できるようにキャッシュ、 <xref:System.Windows.Forms.TextBox> 無制限になるとします。 切り替え、 <xref:System.Windows.Forms.TextBoxBase.ReadOnly%2A> 一般的なシナリオです。<xref:System.Windows.Forms.ImeMode> コントロールは、制限モードでは。 デザイナーの観点から、 <xref:System.Windows.Forms.ImeMode> に表示される値は、実際の値。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBox.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TextBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Windows メッセージ オブジェクト。</param>
        <summary>Windows メッセージを処理します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>