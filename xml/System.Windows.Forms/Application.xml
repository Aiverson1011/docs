<Type Name="Application" FullName="System.Windows.Forms.Application">
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Windows メッセージを処理するために、アプリケーションを開始および停止するメソッドや、アプリケーションについての情報を取得するためのプロパティなど、アプリケーションを管理するための <see langword="static" /> メソッドおよびプロパティを提供します。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Forms.Application> クラスを起動し、アプリケーションとのスレッドを停止し、次のように Windows メッセージを処理するメソッドには。  
  
-   <xref:System.Windows.Forms.Application.Run%2A> 現在のスレッドでのアプリケーション メッセージ ループを開始し、必要に応じて、フォームを表示します。  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> または <xref:System.Windows.Forms.Application.ExitThread%2A> メッセージ ループを停止します。  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> プログラムが、ループの中には、メッセージを処理します。  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Windows メッセージを監視するアプリケーションのメッセージ ポンプにメッセージ フィルターを追加します。  
  
-   <xref:System.Windows.Forms.IMessageFilter> イベント ハンドラーを呼び出す前に特別な操作を行ったり、イベントの発生を停止することができます。  
  
 このクラスは <xref:System.Windows.Forms.Application.CurrentCulture%2A> と <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> カルチャの現在のスレッドの情報をプロパティを取得または設定します。  
  
 このクラスのインスタンスを作成することはできません。  
  
   
  
## 例  
 次のコード例は、フォームにリスト ボックス内の番号を一覧表示します。 クリックするたびに `button1`, 、アプリケーションが一覧に別の番号を追加します。  
  
 `Main` メソッドの呼び出し <xref:System.Windows.Forms.Application.Run%2A> フォームを作成すると、アプリケーションを起動する `listBox1` と `button1`です。 ユーザーがクリックしたとき `button1`, 、 `button1_Click` メソッドを表示、 <xref:System.Windows.Forms.MessageBox>です。 ユーザーがクリックすると `No` 上、 <xref:System.Windows.Forms.MessageBox>, 、 `button1_Click` メソッドは、リストに数値を追加します。 ユーザーがクリックした場合 `Yes`, 、アプリケーション呼び出し <xref:System.Windows.Forms.Application.Exit%2A> をキューに残りのすべてのメッセージを処理し、終了します。  
  
> [!NOTE]
>  呼び出し <xref:System.Windows.Forms.Application.Exit%2A> 部分信頼では失敗します。  
  
 [!code-cpp[Classic Application Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">インストールする <see cref="T:System.Windows.Forms.IMessageFilter" /> インターフェイスの実装。</param>
        <summary>メッセージ フィルターを追加して、ルーティング先にルーティングされる Windows メッセージを監視します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use a message filter to prevent specific events from being raised or to perform special operations for an event before it is passed to an event handler. Message filters are unique to a specific thread.  
  
 To prevent a message from being dispatched, the **parameterReference tag is not supported!!!!**  
 parameter instance that you pass to this method must override the <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> method with the code to handle the message. The method must return **languageKeyword tag is not supported!!!!**  
.  
  
> [!CAUTION]
>  Adding message filters to the message pump for an application can degrade performance.  
  
   
  
## 例  
 The following code example creates a message filter called `TestMessageFilter`. This filter blocks all messages relating to the left mouse button. Before you can use a message filter, you must provide an implementation for the <xref:System.Windows.Forms.IMessageFilter> interface.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the immediate caller to call unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し元がこのアプリケーションを終了できるかどうかを示す値を取得します。</summary>
        <value>呼び出し元がこのアプリケーションを終了できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This property returns **languageKeyword tag is not supported!!!!**  
 if it is called from a <xref:System.Windows.Forms.Control> being hosted within a Web browser. Thus, the <xref:System.Windows.Forms.Control> cannot quit the <xref:System.Windows.Forms.Application>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションをシャットダウンしようとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベント ハンドラーをアタッチする必要があります、 <xref:System.Windows.Forms.Application.Exit%2A> ハンドルされていないを実行するにはタスクが必要なアプリケーションの実行が停止する前にします。 このアプリケーション、またはガベージ コレクションは再生されませんでしたオブジェクトの dispose が開かれたファイルを閉じることができます。  
  
 これは、静的イベントであるためで、このイベントにアタッチされたイベント ハンドラーを切断する必要があります、 <xref:System.Windows.Forms.Application.ApplicationExit> イベント ハンドラー自体です。 これらのハンドラーを接続解除しないでイベントに接続したまま、され、メモリの使用を継続します。  
  
   
  
## 例  
 次のコード例では、2 つのフォームを表示し、両方のフォームを閉じたときに、アプリケーションを終了します。 アプリケーションを起動し、終了、各フォームの位置が記憶されます。 この例では、 <xref:System.Windows.Forms.Application.ApplicationExit> おく、フォームの位置は、ファイルに永続化するとき、およびイベント、 `FileStream` 閉じる必要があります。  
  
 クラス `MyApplicationContext` から継承 <xref:System.Windows.Forms.ApplicationContext> し、各フォームは閉じられ、どちらも、するときに、現在のスレッドを終了するときの追跡します。 クラスは、閉じられているときに、各フォームの位置を記憶します。 ときに、 <xref:System.Windows.Forms.Application.ApplicationExit> イベントが発生する、クラスでは、ユーザーのそれぞれの位置をファイルに書き込みます。 フォームの位置データはという名前のファイルに格納 `appdata.txt` によって決定される場所に作成される <xref:System.Windows.Forms.Application.UserAppDataPath%2A>します。`Main` メソッドの呼び出し `Application.Run(context)` が与えられたアプリケーションを開始する、 <xref:System.Windows.Forms.ApplicationContext>です。  
  
 このコードは、例からの抜粋、 <xref:System.Windows.Forms.ApplicationContext> クラスの概要です。 参照してください <xref:System.Windows.Forms.ApplicationContext> コード全体の一覧です。  
  
 [!code-cpp[Application\#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application\#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application\#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのユーザーが共有するアプリケーション データのパスを取得します。</summary>
        <value>すべてのユーザーが共有するアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If a path does not exist, one is created in the following format:  
  
 *Base Path*\\[CommonAppDataPath](assetId:///P:System.Windows.Forms.Application.CompanyName?qualifyHint=False&autoUpgrade=True)\\[CommonAppDataPath](assetId:///P:System.Windows.Forms.Application.ProductName?qualifyHint=False&autoUpgrade=True)\\[CommonAppDataPath](assetId:///P:System.Windows.Forms.Application.ProductVersion?qualifyHint=False&autoUpgrade=True)  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> first looks to see if the assembly containing the main executable has the `AssemblyInformationalVersion` attribute on it. If this attribute exists, it is used for both <xref:System.Windows.Forms.Application.ProductVersion%2A> and <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. If this attribute does not exist, both properties use the version of the executable file instead.  
  
 The path will be different depending on whether the Windows Forms application is deployed using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] applications are stored in a per\-user application cache in the C:\\Documents and Settings\\**placeholder tag is not supported!!!!**  
 directory. For more information, see [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/ja-jp/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのユーザーが共有するアプリケーション データのレジストリ キーを取得します。</summary>
        <value>すべてのユーザーが共有するアプリケーション データのレジストリ キーを表す <see cref="T:Microsoft.Win32.RegistryKey" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the key does not exist, it is created in the following format:  
  
 LocalMachine\\Software\\[CommonAppDataRegistry](assetId:///P:System.Windows.Forms.Application.CompanyName?qualifyHint=False&autoUpgrade=True)\\[CommonAppDataRegistry](assetId:///P:System.Windows.Forms.Application.ProductName?qualifyHint=False&autoUpgrade=True)\\[CommonAppDataRegistry](assetId:///P:System.Windows.Forms.Application.ProductVersion?qualifyHint=False&autoUpgrade=True)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションに関連付けられている会社名を取得します。</summary>
        <value>会社名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following code example gets this property and displays its value in a text box. The example requires that `textBox1` has been placed on a form.  
  
 [!code-cpp[Classic Application.CompanyName Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのカルチャ情報を取得または設定します。</summary>
        <value>現在のスレッドのカルチャ情報を表す <see cref="T:System.Globalization.CultureInfo" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 The following code example gets this property and displays its value in a text box. The example requires that `textBox1` has been placed on a form.  
  
 [!code-cpp[Classic Application.CurrentCulture Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">for all windows to set this property. Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの現在の入力言語を取得または設定します。</summary>
        <value>現在のスレッドの現在の入力言語を表す <see cref="T:System.Windows.Forms.InputLanguage" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、このプロパティを取得し、テキスト ボックスにその値を表示します。 この例では、する必要があります `textBox1` がフォームに配置されています。  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the immediate caller to call unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メッセージ キューに現在ある Windows メッセージをすべて処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 When you run a Windows Form, it creates the new form, which then waits for events to handle. Each time the form handles an event, it processes all the code associated with that event. All other events wait in the queue. While your code handles the event, your application does not respond. For example, the window does not repaint if another window is dragged on top.  
  
 If you call <xref:System.Windows.Forms.Application.DoEvents%2A> in your code, your application can handle the other events. For example, if you have a form that adds data to a <xref:System.Windows.Forms.ListBox> and add <xref:System.Windows.Forms.Application.DoEvents%2A> to your code, your form repaints when another window is dragged over it. If you remove <xref:System.Windows.Forms.Application.DoEvents%2A> from your code, your form will not repaint until the click event handler of the button is finished executing. For more information on messaging, see [User Input in Windows Forms](http://msdn.microsoft.com/ja-jp/1486075f-1e06-4c9e-82c6-f948331db6d6).  
  
 Unlike Visual Basic 6.0, the <xref:System.Windows.Forms.Application.DoEvents%2A> method does not call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method.  
  
 Typically, you use this method in a loop to process messages.  
  
> [!CAUTION]
>  Calling this method causes the current thread to be suspended while all waiting window messages are processed. If a message causes an event to be triggered, then other areas of your application code may execute. This can cause your application to exhibit unexpected behaviors that are difficult to debug. If you perform operations or computations that take a long time, it is often preferable to perform those operations on a new thread. For more information about asynchronous programming, see [Asynchronous Programming Model \(APM\)](http://msdn.microsoft.com/ja-jp/c9b3501e-6bc6-40f9-8efd-4b6d9e39ccf0).  
  
   
  
## 例  
 The following code example demonstrates using the <xref:System.Windows.Forms.Application.DoEvents%2A> method. When the example runs, a user can select graphics files from an <xref:System.Windows.Forms.OpenFileDialog>. The selected files are displayed in the form. The <xref:System.Windows.Forms.Application.DoEvents%2A> method forces a repaint of the form for each graphics file opened. To run this example, paste the following code in a form containing a <xref:System.Windows.Forms.PictureBox> named `PictureBox1`, an <xref:System.Windows.Forms.OpenFileDialog> named `OpenFileDialog1`, and a button named `fileButton`. Call the `InitializePictureBox` and `InitializeOpenFileDialog` methods from the form's constructor or `Load` method.  
  
> [!NOTE]
>  In [!INCLUDE[vsprvs](~/includes/vsprvs-md.md)], if you add an <xref:System.Windows.Forms.OpenFileDialog> to your form by using a drag operation, you will have to modify the following `InitializeOpenFileDialog` method by removing the line that creates a new instance of <xref:System.Windows.Forms.OpenFileDialog>.  
  
 The example also requires that the <xref:System.Windows.Forms.Control.Click?displayProperty=fullName> event of the <xref:System.Windows.Forms.Button> control and the <xref:System.Windows.Forms.FileDialog.FileOk> event of the <xref:System.Windows.Forms.OpenFileDialog> are connected to the event handlers defined in the example. When the example is running, display the dialog box by clicking the button.  
  
 [!code-cpp[System.Windows.Forms.FileDialog\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションで visual スタイルを有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method enables visual styles for the application. Visual styles are the colors, fonts, and other visual elements that form an operating system theme. Controls will draw with visual styles if the control and the operating system support it. To have an effect, <xref:System.Windows.Forms.Application.EnableVisualStyles> must be called before creating any controls in the application; typically, <xref:System.Windows.Forms.Application.EnableVisualStyles> is the first line in the **languageKeyword tag is not supported!!!!**  
 function. A separate manifest is not required to enable visual styles when calling <xref:System.Windows.Forms.Application.EnableVisualStyles>.  
  
> [!NOTE]
>  Prior to the .NET Framework 2.0, the **languageKeyword tag is not supported!!!!**  
>  property of some controls, such as controls that derive from <xref:System.Windows.Forms.ButtonBase>, had to be set to <xref:System.Windows.Forms.FlatStyle.System?displayProperty=fullName> in order for the controls to be drawn with visual styles. In applications written with the .NET Framework 2.0, this is no longer necessary.  
  
> [!NOTE]
>  This method will have no effect for controls hosted in Internet Explorer.  
  
   
  
## 例  
 The following code example demonstrates calling <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> in the **languageKeyword tag is not supported!!!!**  
 function to enable visual styles for the application.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがモーダル状態に入ろうとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!CAUTION]
>  Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.  
  
   
  
## 例  
 The following code example demonstrates the use of this member. In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.EnterThreadModal> event. This report helps you to learn when the event occurs and can assist you in debugging. To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=fullName> with <xref:System.Console.WriteLine%2A?displayProperty=fullName> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.  
  
 To run the example code, paste it into a Windows Forms and ensure that the event handler is associated with the <xref:System.Windows.Forms.Application.EnterThreadModal> event.  
  
 [!code-csharp[System.Windows.Forms.EventExamples\#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples\#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Requires <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> permission to listen to the event.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションを開始した実行可能ファイルのパスを、ファイル名を含めて取得します。</summary>
        <value>アプリケーションを開始した実行可能ファイルのパスおよびファイル名。  
  
 このパスに Windows フォーム アプリケーションの配置を使用しているかどうかに応じて異なるなります ClickOnceします。ClickOnce アプリケーションが C:\\Documents and settings \\ ユーザーごとのアプリケーション キャッシュに格納されている*username* ディレクトリ。 詳細については、次を参照してください。 [にアクセスするローカルおよびリモート データ ClickOnce アプリケーションにおける](http://msdn.microsoft.com/ja-jp/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)します。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for getting the path. Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Windows.Forms.Application.Exit%2A> method stops all running message loops on all threads and closes all windows of the application. This method does not necessarily force the application to exit. The <xref:System.Windows.Forms.Application.Exit%2A> method is typically called from within a message loop, and forces <xref:System.Windows.Forms.Application.Run%2A> to return. To exit a message loop for the current thread only, call <xref:System.Windows.Forms.Application.ExitThread%2A>.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> raises the following events and performs the associated conditional actions:  
  
-   A <xref:System.Windows.Forms.Form.FormClosing> event is raised for every form represented by the <xref:System.Windows.Forms.Application.OpenForms%2A> property. This event can be canceled by setting the <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> property of their <xref:System.Windows.Forms.FormClosingEventArgs> parameter to **languageKeyword tag is not supported!!!!**  
    .  
  
-   If one of more of the handlers cancels the event, then <xref:System.Windows.Forms.Application.Exit%2A> returns without further action. Otherwise, a <xref:System.Windows.Forms.Form.FormClosed> event is raised for every open form, then all running message loops and forms are closed.  
  
> [!NOTE]
>  The <xref:System.Windows.Forms.Application.Exit%2A> method does not raise the <xref:System.Windows.Forms.Form.Closed> and <xref:System.Windows.Forms.Form.Closing> events, which are obsolete as of [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
   
  
## 例  
 The following code example lists numbers in a list box on a form. Each time you click `button1`, the application adds another number to the list.  
  
 The `Main` method calls <xref:System.Windows.Forms.Application.Run%2A> to start the application, which creates the form, `listBox1`, and `button1`. When the user clicks `button1`, the `button1_Click` method adds numbers one to three to the list box, and displays a <xref:System.Windows.Forms.MessageBox>. If the user clicks **ui tag is not supported!!!!**  
 on the <xref:System.Windows.Forms.MessageBox>, the `button1_Click` method adds another number to the list. If the user clicks **ui tag is not supported!!!!**  
, the application calls <xref:System.Windows.Forms.Application.Exit%2A>, to process all remaining messages in the queue and then to quit.  
  
 The example requires that `listBox1` and `button1` have been instantiated and placed on a form.  
  
 [!code-cpp[Classic Application.Exit Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the immediate caller to call unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">アプリケーション内の <see cref="T:System.Windows.Forms.Form" /> が終了をキャンセルしたかどうかを示す値を返します。</param>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">For permission to terminate a running application thread. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのメッセージ ループを終了し、スレッドのウィンドウをすべて閉じます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use this method to exit the message loop of the current thread. This method causes the call to <xref:System.Windows.Forms.Application.Run%2A> for the current thread to return. To exit the entire application, call <xref:System.Windows.Forms.Application.Exit%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the immediate caller to call unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">フィルター処理の対象となる Windows イベント メッセージ。</param>
        <summary>ウィンドウ メッセージに対してフィルターを実行し、変更したメッセージのコピーを返します。</summary>
        <returns>フィルターが処理された場合は <see langword="True" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが処理を完了し、アイドル状態に入ろうとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ために必要なタスクがある場合、スレッドがアイドル状態になると、前にこのイベントに添付します。  
  
> [!CAUTION]
>  これは、静的イベントであるため、アプリケーションが破棄されると、またはメモリ リークは発生時にイベント ハンドラーを切り離す必要があります。  
  
   
  
## 例  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは、発生するときに報告、 <xref:System.Windows.Forms.Application.Idle> イベントです。 このレポートは、イベントが発生してデバッグに役立つ説明を使用します。 複数のイベントまたは頻繁に発生するイベントを報告するためには、交換を検討 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=fullName> と <xref:System.Console.WriteLine%2A?displayProperty=fullName> またはメッセージを複数行に追加する <xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する Windows フォームに貼り付け、イベント ハンドラーが関連付けられているかどうかを確認、 <xref:System.Windows.Forms.Application.Idle> イベントです。  
  
 [!code-csharp[System.Windows.Forms.EventExamples\#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples\#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがモーダル状態を終了するときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!CAUTION]
>  これは、静的イベントであるため、アプリケーションが破棄されると、またはメモリ リークは発生時にイベント ハンドラーを切り離す必要があります。  
  
   
  
## 例  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは、発生するときに報告、 <xref:System.Windows.Forms.Application.LeaveThreadModal> イベントです。 このレポートは、イベントが発生してデバッグに役立つ説明を使用します。 複数のイベントまたは頻繁に発生するイベントを報告するためには、交換を検討 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=fullName> と <xref:System.Console.WriteLine%2A?displayProperty=fullName> またはメッセージを複数行に追加する <xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する Windows フォームに貼り付けるし、イベント ハンドラーが関連付けられていることを確認、 <xref:System.Windows.Forms.Application.LeaveThreadModal> イベントです。  
  
 [!code-csharp[System.Windows.Forms.EventExamples\#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples\#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカルで非ローミング ユーザーのアプリケーション データのパスを取得します。</summary>
        <value>ローカルで非ローミング ユーザーのアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ローカル ユーザーは、いずれかのプロファイルを持つユーザーは、ユーザーがログオンするシステムに格納します。 パスが存在しない場合は、次の形式で 1 つ作成されます。  
  
 *Base Path*\\[LocalUserAppDataPath](assetId:///P:System.Windows.Forms.Application.CompanyName?qualifyHint=False&autoUpgrade=True)\\[LocalUserAppDataPath](assetId:///P:System.Windows.Forms.Application.ProductName?qualifyHint=False&autoUpgrade=True)\\[LocalUserAppDataPath](assetId:///P:System.Windows.Forms.Application.ProductVersion?qualifyHint=False&autoUpgrade=True)  
  
 通常の基本パスは C:\\Documents and settings \\*username*\\Local Settings\\Application データ。 このパスは異なっていなければ、ただしを使用して Windows フォーム アプリケーションが展開されている場合 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]します。[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] その他のすべてのアプリケーションから分離された独自のアプリケーション データ ディレクトリを作成します。 詳細については、次を参照してください。 [にアクセスするローカルおよびリモート データ ClickOnce アプリケーションにおける](http://msdn.microsoft.com/ja-jp/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)します。  
  
   
  
## 例  
 次のコード例では、2 つのフォームを表示し、両方のフォームを閉じたときに、アプリケーションを終了します。 アプリケーションを起動し、終了、各フォームの位置が記憶されます。 この例を使用して、 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 、ユーザーのアプリケーション データを格納するプロパティ、 <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> 代わりに使用されることができます。  
  
 `MyApplicationContext` クラスから継承 <xref:System.Windows.Forms.ApplicationContext> し、各フォームは閉じられ、どちらも、するときに、現在のスレッドを終了するときは常に追跡します。 クラスは、ユーザーの各フォームの位置を格納します。 フォームの位置データはという名前のファイルに格納 `Appdata.txt` によって決定される場所に作成される <xref:System.Windows.Forms.Application.UserAppDataPath%2A>します。`Main` メソッドの呼び出し `Application.Run(context)` が与えられたアプリケーションを開始する、 <xref:System.Windows.Forms.ApplicationContext>です。  
  
 このコードは、例からの抜粋、 <xref:System.Windows.Forms.ApplicationContext> クラスの概要です。 いくつかのコードは簡潔さを優先するためには表示されません。 参照してください <xref:System.Windows.Forms.ApplicationContext> コード全体の一覧です。  
  
 [!code-cpp[Application\#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application\#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application\#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このスレッドにメッセージ ループが存在するかどうかを示す値を取得します。</summary>
        <value>メッセージ ループが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Windows フォームをアンマネージ アプリケーションなど他の環境でホストするときにこのプロパティは常に返す `false`します。 使用 <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> にホスティング環境はまだアクティブなメッセージ ループかどうかに Windows フォームを指示します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドで OLE を初期化します。</summary>
        <returns>
          <see cref="T:System.Threading.ApartmentState" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す前にこのメソッドを呼び出す `Microsoft.Win32` OLE を必要とするメソッドです。<xref:System.Windows.Forms.Application.OleRequired%2A> まず、現在のスレッドで OLE が初期化されているかどうかを確認します。 それ以外の場合は、OLE のスレッドを初期化します。  
  
> [!NOTE]
>  スレッドが直接 OLE メソッドを呼び出す場合を除き、このメソッドを呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">スローされた例外を表す <see cref="T:System.Exception" />。</param>
        <summary>
          <see cref="E:System.Windows.Forms.Application.ThreadException" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す <xref:System.Windows.Forms.Application.OnThreadException%2A> アプリケーションの処理は停止しますから例外が発生します。  
  
 <xref:System.Windows.Forms.Application> クラスには、 <xref:System.Windows.Forms.Application.ThreadException> イベントです。 未処理の例外の必要なカスタム処理を実行するには、このイベントにイベント ハンドラーをアタッチできます。 イベント ハンドラーをアタッチしない場合 <xref:System.Windows.Forms.Application.OnThreadException%2A> があったこと、エラーをユーザーに通知するダイアログ ボックスの表示は、既定の動作を実行します。  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> Windows フォームによって所有されているスレッドで発生する未処理の例外に対する例外の既定の動作をだけを実装します。 他のスレッドで未処理の例外は、 <xref:System.AppDomain.UnhandledException> イベントです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが所有している、開かれたフォームのコレクションを取得します。</summary>
        <value>アプリケーションによって所有されている、現在開いているすべてのフォームが格納された <see cref="T:System.Windows.Forms.FormCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Forms.Application.OpenForms%2A> プロパティは、アプリケーションによって所有されているフォームの読み取り専用コレクションを表します。 インデックスの位置または、このコレクションを検索できる、 <xref:System.Windows.Forms.Control.Name%2A> の <xref:System.Windows.Forms.Form>です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Caller must have permission to access all windows, as defined by the <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> value of the <see cref="T:System.Security.Permissions.UIPermissionWindow" /> enumeration.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアプリケーションに関連付けられている製品名を取得します。</summary>
        <value>製品名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `ProductName` 現在のアプリケーションのメイン フォームを含むアセンブリのメタデータから取得されます。 設定できます <xref:System.Reflection.AssemblyProductAttribute> 、アセンブリ マニフェスト内です。 詳細については、次を参照してください。 [アセンブリ マニフェスト](http://msdn.microsoft.com/ja-jp/8e40fab9-549d-4731-aec2-ffa47a382de0)します。  
  
   
  
## 例  
 次のコード例では、このプロパティを取得し、テキスト ボックスにその値を表示します。 この例では、する必要があります `textBox1` がフォームに配置されています。  
  
 [!code-cpp[Classic Application.ProductName Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアプリケーションに関連付けられている製品のバージョンを取得します。</summary>
        <value>製品のバージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 通常、バージョン番号として表示されます *メジャー番号*。*。番号のマイナー*します。*ビルド番号*.*プライベート パート番号*します。 アセンブリ マニフェスト内でアセンブリのバージョンを設定して明示的に設定できます。 詳細については、次を参照してください。 [アセンブリ マニフェスト](http://msdn.microsoft.com/ja-jp/8e40fab9-549d-4731-aec2-ffa47a382de0)します。  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> メインの実行可能ファイルを含むアセンブリが含まれているが最初に検索、 `AssemblyInformationalVersion` の属性です。 この属性が存在する場合が、両方の使用 <xref:System.Windows.Forms.Application.ProductVersion%2A> と <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>です。 両方のプロパティをこの属性が存在しない場合、実行可能ファイルのバージョンが代わりに使用します。  
  
   
  
## 例  
 次のコード例では、このプロパティを取得し、テキスト ボックスにその値を表示します。 この例では、する必要があります `textBox1` がフォームに配置されています。  
  
 [!code-cpp[Classic Application.ProductVersion Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> イベントに渡す <see cref="E:System.Windows.Forms.Application.Idle" /> オブジェクト。</param>
        <summary>ホストされているシナリオで <see cref="E:System.Windows.Forms.Application.Idle" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ アプリケーションなどの別の環境で Windows フォームをホストするときに使用します。 呼び出す必要があります <xref:System.Windows.Forms.Application.RaiseIdle%2A> 、ホスト アプリケーションがアイドル状態に入ったとき。 これにより、一部の Windows フォーム コントロールおよびコンポーネントをユーザーがアプリケーションと対話していない重要なバック グラウンド処理を行います。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">ホスト環境が依然としてメッセージを送信しているかどうかを Windows フォームでチェックする必要がある場合に呼び出すメソッド。</param>
        <summary>メッセージ ループがホストされている環境で実行されているかどうかをチェックするためのコールバックを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ アプリケーションなどの別の環境で Windows フォームをホストするときに使用します。 ホストされた環境で、 <xref:System.Windows.Forms.Application.MessageLoop%2A> プロパティが false の場合、Windows フォームでは、メッセージは処理されていない常に返します。 ホスティング環境がまだメッセージを処理してかどうかに Windows フォームを確認するのにには、このコールバックを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">アプリケーションから削除する <see cref="T:System.Windows.Forms.IMessageFilter" /> の実装。</param>
        <summary>アプリケーションのメッセージ ポンプからメッセージ フィルターを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ディスパッチされる前に、Windows メッセージをキャプチャする必要がなくなったときにメッセージ フィルターを削除することができます。  
  
   
  
## 例  
 メッセージ フィルターを使用するには、実装を提供する必要があります、 <xref:System.Windows.Forms.IMessageFilter> インターフェイスです。 次のクラスと呼ばれるメッセージ フィルターを作成 `TestMessageFilter`します。 このフィルターは、マウスの左ボタンに関連するすべてのメッセージをブロックします。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーションが visual スタイルを使用してコントロールを描画しているかどうかを示す値を取得します。</summary>
        <value>アプリケーション ウィンドウのクライアント領域のコントロールで visual スタイルが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 カスタム コントロールを描画する場合は、このプロパティを使用して、外観は、アプリケーションでは、他のコントロールと一貫性のあるように、visual スタイルの有無にコントロールを描画するかどうかを決定します。  
  
 次の表に、4 つの条件に残す必要のある <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> を返す `true`します。  
  
|条件|説明|  
|--------|--------|  
|オペレーティング システムは、visual スタイルをサポートしています。|この状態を個別に確認するため、 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> のプロパティ、 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> クラスです。|  
|ユーザーがオペレーティング システムで visual スタイルを有効に|この状態を個別に確認するため、 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> のプロパティ、 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> クラスです。|  
|アプリケーションで visual スタイルが有効になっています。|Visual スタイルは、アプリケーションで呼び出すことによって有効にすることができます、 <xref:System.Windows.Forms.Application.EnableVisualStyles> メソッドまたはコントロールを描画するアプリケーションを使用してその ComCtl32.dll バージョン 6 以降を指定するマニフェストが使用されます。|  
|Visual スタイルは、アプリケーション ウィンドウのクライアント領域の描画に使用されています|この状態を個別に確認するため、 <xref:System.Windows.Forms.Application.VisualStyleState%2A> のプロパティ、 <xref:System.Windows.Forms.Application> クラスし、値を使用していることを確認 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=fullName> または <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=fullName>です。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションをシャットダウンし、直後に新しいインスタンスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す最も一般的な理由 `Restart` は新しいバージョンをダウンロードしたアプリケーションの起動を [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] を使用して、 `Update` または `UpdateAsync` メソッドです。  
  
 アプリケーションは、最初に実行されたコンテキストで再起動されます。 アプリケーションのメイン実行可能ファイルを直接指し示す URL を使用して、アプリケーションが開始された場合は再開されます同じ URL を使用します。 アプリケーションの場合、 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] アプリケーションを使用して再開されます [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]します。  
  
 最初に実行されたときに、アプリケーションによって指定された最初のコマンド ライン オプションがあった場合 <xref:System.Windows.Forms.Application.Restart%2A> 同じオプションを使用してアプリケーションを起動します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">コードは、Windows フォーム アプリケーションではありません。 このコンテキストでは、このメソッドを呼び出すことはできません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Requires <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> permission.</permission>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を、フォームなしで開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Win32 ベースまたは Windows フォームで、アプリケーション メッセージ ループは、マウス クリックやキーボード入力などのユーザー イベントを処理するコード内のルーチンです。 各実行中の Windows ベースのアプリケーションでは、メイン メッセージ ループと呼ばれる、アクティブなメッセージ ループが必要です。 メイン メッセージ ループを終了すると、アプリケーションが終了します。 Windows フォームでこのようなループが閉じられるときに、 <xref:System.Windows.Forms.Application.Exit%2A> メソッドが呼び出されるとき、または、 <xref:System.Windows.Forms.Application.ExitThread%2A> メイン メッセージ ループを実行しているスレッドで呼び出されます。  
  
 Windows フォームでほとんどの開発者は、このバージョンのメソッドを使用する必要はありません。 使用する必要があります、 <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> 、メイン フォームが閉じられると、アプリケーションが終了するように、メイン フォームがアプリケーションを起動するオーバー ロードします。 その他のすべての状況を使用して、 <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> オーバー ロードの指定をサポートする、 <xref:System.Windows.Forms.ApplicationContext> アプリケーションの有効期間の制御を強化するためのオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループは、このスレッドで実行されています。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">アプリケーションが実行される <see cref="T:System.Windows.Forms.ApplicationContext" />。</param>
        <summary>
          <see cref="T:System.Windows.Forms.ApplicationContext" /> を使用して、現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メッセージ ループを実行するまで <xref:System.Windows.Forms.Application.Exit%2A> または <xref:System.Windows.Forms.Application.ExitThread%2A> と呼びますまたは <xref:System.Windows.Forms.Application.ThreadExit> コンテキスト オブジェクトでイベントが発生します。  
  
   
  
## 例  
 この例では、2 つのフォームを表示し、両方のフォームを閉じたときに、アプリケーションを終了します。 アプリケーションを起動し、終了、各フォームの位置が記憶されます。 この例では、使用して、 <xref:System.Windows.Forms.ApplicationContext>, 、と共に、 `Application.Run(context)` メソッドは、アプリケーションの起動時に、複数のフォームを表示します。  
  
 クラス `MyApplicationContext` から継承 <xref:System.Windows.Forms.ApplicationContext> し、各フォームは閉じられ、どちらも、するときに、現在のスレッドを終了するときは常に追跡します。 クラスは、ユーザーの各フォームの位置を格納します。 フォームの位置データはという名前のファイルに格納 `Appdata.txt` によって決定される場所に作成される <xref:System.Windows.Forms.Application.UserAppDataPath%2A>します。`Main` メソッドの呼び出し `Application.Run(context)` が与えられたアプリケーションを開始する、 <xref:System.Windows.Forms.ApplicationContext>です。  
  
 コードを `AppForm1` と `AppForm2` フォームは簡潔さを優先するためには表示されません。 参照してください、 <xref:System.Windows.Forms.ApplicationContext> クラスのコード全体の概要です。  
  
 [!code-cpp[Application\#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application\#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application\#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループは、このスレッドで実行されています。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">表示するフォームを表す <see cref="T:System.Windows.Forms.Form" />。</param>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始し、指定したフォームを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 通常、アプリケーションの main 関数では、このメソッドを呼び出して、アプリケーションのメイン ウィンドウを渡します。  
  
 このメソッドは、イベント ハンドラーを追加、 `mainForm` のパラメーター、 <xref:System.Windows.Forms.Form.Closed> イベントです。 イベント ハンドラー呼び出し <xref:System.Windows.Forms.Application.ExitThread%2A> アプリケーションをクリーンアップします。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Dispose%2A> のメソッド、 <xref:System.Windows.Forms.Form> クラスがこのメソッドの戻り値の前に呼び出されます。  
  
   
  
## 例  
 次のコード例は、フォームにリスト ボックス内の番号を一覧表示します。 クリックするたびに `button1`, 、アプリケーションが一覧に別の番号を追加します。  
  
 `Main` メソッドの呼び出し <xref:System.Windows.Forms.Application.Run%2A> フォームを作成すると、アプリケーションを起動する `listBox1`, 、および `button1`です。 ユーザーがクリックしたとき `button1`, 、 `button1_Click` メソッドは、リスト ボックスには、1 ~ 3 の数値を加算し、表示、 <xref:System.Windows.Forms.MessageBox>です。 ユーザーがクリックした場合 **いいえ** 上、 <xref:System.Windows.Forms.MessageBox>, 、 `button1_Click` メソッドは、一覧に別の番号を追加します。 ユーザーがクリックした場合 **\[はい\]**, 、アプリケーション呼び出し <xref:System.Windows.Forms.Application.Exit%2A> をキューに残りのすべてのメッセージを処理し、終了します。  
  
 この例では、する必要があります `listBox1` と `button1` が作成され、フォーム上に配置します。  
  
 [!code-cpp[Classic Application.Exit Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループは、現在のスレッドで既に行われています。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>警告見出しと共に表示された場合にトップレベル ウィンドウのキャプションに適用する書式指定文字列を取得または設定します。</summary>
        <value>トップレベル ウィンドウのキャプションに適用する書式指定文字列。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">for all windows to set this property. Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">新しいコントロールに適用する既定値。<see langword="true" /> の場合、<c>UseCompatibleTextRendering</c> をサポートする新しいコントロールは、テキスト レンダリングに GDI+ ベースの <see cref="T:System.Drawing.Graphics" /> クラスを使用します。<see langword="false" /> の場合、新しいコントロールは GDI ベースの <see cref="T:System.Windows.Forms.TextRenderer" /> クラスを使用します。</param>
        <summary>特定のコントロールで定義された <c>UseCompatibleTextRendering</c> プロパティにアプリケーション全体で有効な既定値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 特定の Windows フォーム コントロールは、いずれかを使用して、テキストを描画できます、 <xref:System.Windows.Forms.TextRenderer> クラスに基づく、 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] グラフィックス ライブラリまたは <xref:System.Drawing.Graphics> クラスに基づく、 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] グラフィックス ライブラリです。 この変更された、 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] でパフォーマンスおよびローカリゼーションの問題があるため [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]です。 使用する <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> の既定値を設定する、 `UseCompatibleTextRendering` サポートしているコントロールのプロパティです。  
  
 `UseCompatibleTextRendering` プロパティは、その表示テキストを使用して Windows フォーム コントロールの間での visual の互換性を維持するためのもの、 <xref:System.Windows.Forms.TextRenderer> クラスと [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] と [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] を使用してカスタム テキスト レンダリングを実行するアプリケーション、 <xref:System.Drawing.Graphics> クラスです。 ほとんどの場合から、アプリケーションがアップグレードされていない場合に [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] または [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], 、しておくことをお勧め `UseCompatibleTextRendering` の既定値に設定 `false`します。  
  
 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] ベース <xref:System.Windows.Forms.TextRenderer> クラスがで導入された、 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] パフォーマンスを向上させるには、テキストの見栄えをよく、および国際対応フォントのサポートの改善を作成します。 以前のバージョンの [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], 、 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] ベース <xref:System.Drawing.Graphics> クラスを使用してすべてのテキスト レンダリングを実行します。[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 文字間隔とでの折り返しが異なるから計算 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]します。 使用する Windows フォーム アプリケーションで、 <xref:System.Drawing.Graphics> テキストをレンダリングするクラスで、これが原因で使用される、コントロールのテキストを <xref:System.Windows.Forms.TextRenderer> を異なるアプリケーションで他のテキストで表示します。 この非互換性を解決するには、設定することができます、 `UseCompatibleTextRendering` プロパティを `true`します。 設定する `UseCompatibleTextRendering` に `true` アプリケーションでサポートされているすべてのコントロールを呼び出して、 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> メソッドのパラメーターを持つ `true`です。  
  
 Windows フォームのコードが Internet Explorer などの別のアプリケーションでホストされている場合にことはありません、このメソッドを呼び出す必要があります。 スタンドアロンの Windows フォーム アプリケーションでこのメソッドを呼び出すだけです。  
  
   
  
## 例  
  
> [!IMPORTANT]
>  既定値を設定する `UseCompatibleTextRendering` で [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] か、後で、「 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=fullName>します。  
  
 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] またはそれ以降への呼び出し <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> Program.cs ファイルでは自動的に生成します。 既定のテキスト レンダリングを変更するには、生成されたコードを変更します。  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Windows フォーム アプリケーションで最初のウィンドウが作成される前にのみ、このメソッドを呼び出すことができます。</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">移行後の電源の動作モードを示す <see cref="T:System.Windows.Forms.PowerState" />。</param>
        <param name="force">すぐに、強制的に中断モードにする場合は <see langword="true" />。Windows からすべてのアプリケーションに中断の要求が送られるようにする場合は <see langword="false" />。</param>
        <param name="disableWakeEvent">システムの電源ステータスの復元が wake イベントでアクティブにならないようにするには <see langword="true" />。システムの電源ステータスの復元が wake イベントでアクティブになるようにするには <see langword="false" />。</param>
        <summary>システムを中断または休止状態にするか、システムが中断または休止状態になるよう要求します。</summary>
        <returns>システムが中断中の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 20 秒以内で、アプリケーションが中断の要求に応答しない場合、Windows は、応答しない状態であるとするアプリケーションするスリープ状態にするか、終了を決定します。 アプリケーションは、中断の要求に応答すると、かかることがリソースをクリーンアップし、アクティブなプロセスをシャット ダウンに必要な時間です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>未処理の例外への対応方法をアプリケーションに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、Windows フォーム スレッドと他のスレッドで発生する例外の例外が発生するイベント ハンドラーを設定します。 設定 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> すべての例外は、アプリケーションのユーザー構成ファイルの設定に関係なく、アプリケーションで処理されるようにします。 使用して、 <xref:System.Windows.Forms.Application.ThreadException> UI スレッドの例外を処理するイベントと <xref:System.AppDomain.UnhandledException> 非 UI スレッドの例外を処理するイベントです。<xref:System.AppDomain.UnhandledException> アプリケーションを防ぐことはできませんが終了するには、例では、単にエラーがログ記録、終了する前にアプリケーション イベント ログにします。  
  
 この例では、2 つを定義した <xref:System.Windows.Forms.Button> コントロール、 `button1` と `button2`, の <xref:System.Windows.Forms.Form> クラスです。  
  
 [!code-cpp[Classic Application.ThreadException Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">キャッチされない例外がスローされた場合に必要なアプリケーションの動作方法を説明する <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 値。</param>
        <summary>未処理の例外への対応方法をアプリケーションに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 すべての Windows フォームによってスローされる例外をキャッチするは多くの場合です。 このメソッドを使用して Windows フォームのコンポーネントによってスローされたすべての未処理の例外をキャッチして操作を続行する必要があるかどうか、またはそれらをユーザーに公開し、実行を停止かどうか、アプリケーションに指示できます。  
  
 呼び出す <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> を使用して、アプリケーションのメイン フォームのインスタンスを作成する前に、 <xref:System.Windows.Forms.Application.Run%2A> メソッドです。  
  
 作成していないスレッドで発生する例外をキャッチし、使用して Windows フォームによって所有されている、 <xref:System.AppDomain.UnhandledException> イベント ハンドラーです。  
  
   
  
## 例  
 次のコード例では、Windows フォーム スレッドと他のスレッドで発生する例外の例外が発生するイベント ハンドラーを設定します。 設定 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> すべての例外は、アプリケーションのユーザー構成ファイルの設定に関係なく、アプリケーションで処理されるようにします。 使用して、 <xref:System.Windows.Forms.Application.ThreadException> UI スレッドの例外を処理するイベントと <xref:System.AppDomain.UnhandledException> 非 UI スレッドの例外を処理するイベントです。<xref:System.AppDomain.UnhandledException> アプリケーションを防ぐことはできませんが終了するには、例では、単にエラーがログ記録、終了する前にアプリケーション イベント ログにします。  
  
 この例では、2 つを定義した <xref:System.Windows.Forms.Button> コントロール、 `button1` と `button2`, の <xref:System.Windows.Forms.Form> クラスです。  
  
 [!code-cpp[Classic Application.ThreadException Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">アプリケーションが最初のウィンドウを作成した後は、例外モードを設定できません。</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">キャッチされない例外がスローされた場合に必要なアプリケーションの動作方法を説明する <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 値。</param>
        <param name="threadScope">スレッド例外モードを設定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>未処理の例外に応答する方法をアプリケーションに指示し、オプションでスレッド固有の動作を適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 すべての Windows フォームによってスローされる例外をキャッチするは多くの場合です。 このメソッドを使用して Windows フォームのコンポーネントによってスローされたすべての未処理の例外をキャッチして操作を続行する必要があるかどうか、またはそれらをユーザーに公開し、実行を停止かどうか、アプリケーションに指示できます。  
  
 呼び出す <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> を使用して、アプリケーションのメイン フォームのインスタンスを作成する前に、 <xref:System.Windows.Forms.Application.Run%2A> メソッドです。  
  
 `threadScope` は `true`, 、スレッド例外モードを設定します。 スレッド例外モードと、アプリケーション例外モードを上書きする `mode` に設定されていない <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>します。  
  
 `threadScope` は `false`, 、アプリケーション例外モードを設定します。 含まれるすべてのスレッドのアプリケーション例外モードが使用される、 <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> モードです。 アプリケーション例外モードを設定しても、現在のスレッドの設定には影響しません。  
  
 作成していないスレッドで発生する例外をキャッチし、使用して Windows フォームによって所有されている、 <xref:System.AppDomain.UnhandledException> イベント ハンドラーです。  
  
   
  
## 例  
 次のコード例では、Windows フォーム スレッドと他のスレッドで発生する例外の例外が発生するイベント ハンドラーを設定します。 設定 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> すべての例外は、アプリケーションのユーザー構成ファイルの設定に関係なく、アプリケーションで処理されるようにします。 使用して、 <xref:System.Windows.Forms.Application.ThreadException> UI スレッドの例外を処理するイベントと <xref:System.AppDomain.UnhandledException> 非 UI スレッドの例外を処理するイベントです。<xref:System.AppDomain.UnhandledException> アプリケーションを防ぐことはできませんが終了するには、例では、単にエラーがログ記録、終了する前にアプリケーション イベント ログにします。  
  
 この例では、2 つを定義した <xref:System.Windows.Forms.Button> コントロール、 `button1` と `button2`, の <xref:System.Windows.Forms.Form> クラスです。  
  
 [!code-cpp[Classic Application.ThreadException Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">アプリケーションが最初のウィンドウを作成した後は、例外モードを設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションを開始した実行可能ファイルの、ファイル名を含まないパスを取得します。</summary>
        <value>アプリケーションを開始した実行可能ファイルのパス。  
  
 このパスに Windows フォーム アプリケーションの配置を使用しているかどうかに応じて異なるなります ClickOnceします。ClickOnce アプリケーションが C:\\Documents and settings \\ ユーザーごとのアプリケーション キャッシュに格納されている*username* ディレクトリ。 詳細については、次を参照してください。 [にアクセスするローカルおよびリモート データ ClickOnce アプリケーションにおける](http://msdn.microsoft.com/ja-jp/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次のコード例では、このプロパティを取得し、テキスト ボックスにその値を表示します。 この例では、する必要があります `textBox1` がフォームに配置されています。  
  
 [!code-cpp[Classic Application.StartupPath Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for getting the path. Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>トラップされないスレッドの例外がスローされると、発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、Windows フォーム スレッドで発生する例外を未処理のハンドルのそれ以外の場合に、Windows フォーム アプリケーションを使用します。 イベント ハンドラーをアタッチ、 <xref:System.Windows.Forms.Application.ThreadException> アプリケーションそのままの状態は不明にこれらの例外を処理するイベントです。 可能であれば、構造化例外処理ブロックで例外を処理する必要があります。  
  
 このコールバックは Windows フォーム スレッドの未処理の例外を設定して使用するかどうかを変更する <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>です。 作成していないスレッドで発生する例外をキャッチし、使用して Windows フォームによって所有されている、 <xref:System.AppDomain.UnhandledException> イベント ハンドラーです。  
  
> [!NOTE]
>  このイベントのアクティブ化が実行されなかったしないことを保証するために呼び出す前に、ハンドラーをアタッチする必要があります <xref:System.Windows.Application.Run%2A?displayProperty=fullName>します。  
  
> [!CAUTION]
>  これは、静的イベントであるため、アプリケーションが破棄されると、またはメモリ リークは発生時にイベント ハンドラーを切り離す必要があります。  
  
   
  
## 例  
 次のコード例では、Windows フォーム スレッドと他のスレッドで発生する例外の例外が発生するイベント ハンドラーを設定します。 設定 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> すべての例外は、アプリケーションのユーザー構成ファイルの設定に関係なく、アプリケーションで処理されるようにします。 使用して、 <xref:System.Windows.Forms.Application.ThreadException> UI スレッドの例外を処理するイベントと <xref:System.AppDomain.UnhandledException> 非 UI スレッドの例外を処理するイベントです。<xref:System.AppDomain.UnhandledException> アプリケーションを防ぐことはできませんが終了するには、例では、単にエラーがログ記録、終了する前にアプリケーション イベント ログにします。  
  
 この例では、2 つを定義した <xref:System.Windows.Forms.Button> コントロール、 `button1` と `button2`, の <xref:System.Windows.Forms.Form> クラスです。  
  
 [!code-cpp[Classic Application.ThreadException Example\#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example\#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the immediate caller to call unmanaged code when adding a handler to this event. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドをシャットダウンしようとすると発生します。 アプリケーションのメイン スレッドをシャットダウンしようとすると、まずこのイベントが発生し、続いて <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> イベントが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 イベント ハンドラーをアタッチする必要があります、 <xref:System.Windows.Forms.Application.ThreadExit> を実行するイベントがハンドルされていないとき、スレッドの実行が停止する前にタスクが必要です。 このスレッド、またはガベージ コレクターがクリアされなかったオブジェクトの破棄によって開かれたファイルを閉じます。  
  
> [!CAUTION]
>  これは、静的イベントであるため、アプリケーションが破棄されると、またはメモリ リークは発生時にイベント ハンドラーを切り離す必要があります。  
  
   
  
## 例  
 次のコード例では、このメンバーの使用方法を示します。 例では、イベント ハンドラーは、発生するときに報告、 <xref:System.Windows.Forms.Application.ThreadExit> イベントです。 このレポートは、イベントが発生してデバッグに役立つ説明を使用します。 複数のイベントまたは頻繁に発生するイベントを報告するためには、交換を検討 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=fullName> と <xref:System.Console.WriteLine%2A?displayProperty=fullName> またはメッセージを複数行に追加する <xref:System.Windows.Forms.TextBox>です。  
  
 コード例を実行する Windows フォームに貼り付けるし、イベント ハンドラーが関連付けられていることを確認、 <xref:System.Windows.Forms.Application.ThreadExit> イベントです。  
  
 [!code-csharp[System.Windows.Forms.EventExamples\#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples\#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> によってなされたメッセージ ループ コールバックを登録解除します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーのアプリケーション データのパスを取得します。</summary>
        <value>ユーザーのアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 パスが存在しない場合は、次の形式で 1 つ作成されます。  
  
 *Base Path*\\[UserAppDataPath](assetId:///P:System.Windows.Forms.Application.CompanyName?qualifyHint=False&autoUpgrade=True)\\[UserAppDataPath](assetId:///P:System.Windows.Forms.Application.ProductName?qualifyHint=False&autoUpgrade=True)\\[UserAppDataPath](assetId:///P:System.Windows.Forms.Application.ProductVersion?qualifyHint=False&autoUpgrade=True)  
  
 このパスに格納されたデータは、ローミングが有効になっているユーザー プロファイルの一部です。 ローミング ユーザーは、ネットワーク内の 1 つ以上のコンピューターで動作します。 ローミング ユーザーのユーザー プロファイルは、ネットワーク上のサーバー上に保持され、ユーザーがログオンしたときに、システムに読み込まれます。 対象となる、ローミング ユーザー プロファイルのオペレーティング システムは移動プロファイルをサポートする必要があり、有効にする必要があります。  
  
 通常の基本パスは C:\\Documents and settings \\*username*\\Application Data です。 このパスは異なっていなければ、ただしを使用して Windows フォーム アプリケーションが展開されている場合 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]します。[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] その他のすべてのアプリケーションから分離された独自のアプリケーション データ ディレクトリを作成します。 詳細については、次を参照してください。 [にアクセスするローカルおよびリモート データ ClickOnce アプリケーションにおける](http://msdn.microsoft.com/ja-jp/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)します。  
  
   
  
## 例  
 次のコード例では、2 つのフォームを表示し、両方のフォームを閉じたときに、アプリケーションを終了します。 アプリケーションを起動し、終了、各フォームの位置が記憶されます。 この例では、 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> プロパティをユーザーのアプリケーション データを格納します。  
  
 クラス `MyApplicationContext` から継承 <xref:System.Windows.Forms.ApplicationContext> し、各フォームは閉じられ、どちらも、するときに、現在のスレッドを終了するときは常に追跡します。 クラスは、ユーザーの各フォームの位置を格納します。 フォームの位置データはという名前のファイルに格納 `Appdata.txt` によって決定される場所に作成される <xref:System.Windows.Forms.Application.UserAppDataPath%2A>します。`Main` メソッドの呼び出し `Application.Run(context)` が与えられたアプリケーションを開始する、 <xref:System.Windows.Forms.ApplicationContext>です。  
  
 このコードは、例からの抜粋、 <xref:System.Windows.Forms.ApplicationContext> クラスの概要です。 いくつかのコードは簡潔さを優先するためには表示されません。 参照してください <xref:System.Windows.Forms.ApplicationContext> コード全体の一覧です。  
  
 [!code-cpp[Application\#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application\#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application\#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーのアプリケーション データのレジストリ キーを取得します。</summary>
        <value>ユーザー固有のアプリケーション データのレジストリ キーを表す <see cref="T:Microsoft.Win32.RegistryKey" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キーが存在しない場合は、次の形式で作成されます。  
  
 CurrentUser\\Software\\[UserAppDataRegistry](assetId:///P:System.Windows.Forms.Application.CompanyName?qualifyHint=False&autoUpgrade=True)\\[UserAppDataRegistry](assetId:///P:System.Windows.Forms.Application.ProductName?qualifyHint=False&autoUpgrade=True)\\[UserAppDataRegistry](assetId:///P:System.Windows.Forms.Application.ProductVersion?qualifyHint=False&autoUpgrade=True)  
  
 このキーに格納されたデータは、ローミングが有効になっているユーザー プロファイルの一部です。 ローミング ユーザーは、ネットワーク内の 1 つ以上のコンピューターで動作します。 ローミング ユーザーのユーザー プロファイルは、ネットワーク上のサーバー上に保持され、ユーザーがログオンしたときに、システムに読み込まれます。 対象となる、ローミング ユーザー プロファイルのオペレーティング システムは移動プロファイルをサポートする必要があり、有効にする必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの開いているフォームすべてに待機カーソルを使用するかどうかについて、取得または設定します。</summary>
        <value>すべての開いているフォームで待機カーソルが使用される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティに設定すると `true`, 、 <xref:System.Windows.Forms.Control.UseWaitCursor%2A> 、アプリケーションで開いているすべてのフォームのプロパティが設定されます `true`します。 この呼び出しは、すべてのフォームにこのプロパティが設定されるまでは返されません。 実行時間の長い操作し、すべてのアプリケーションのフォームで、操作がまだ処理されていることを示すために必要な場合は、このプロパティを使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ウィンドウに visual スタイルをどのように適用するかを指定する値を取得します。</summary>
        <value>
          <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 値のビットごとの組み合わせ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、 <xref:System.Windows.Forms.Application.VisualStyleState%2A> プロパティは、クライアント領域またはアプリケーション ウィンドウの非クライアント領域の視覚スタイルが有効にするかどうかを決定します。 一般に、メイン フォームのコンス トラクター内でこのプロパティを設定する必要がありますか <xref:System.Windows.Forms.Form.Load> イベント ハンドラーです。  
  
   
  
## 例  
 次のコード例、 <xref:System.Windows.Forms.Application.VisualStyleState%2A> プロパティのいずれかを <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=fullName> 内で値を <xref:System.Windows.Forms.Control.Click> のイベント ハンドラー、 <xref:System.Windows.Forms.Button> コントロールです。 このコード例が示されている例の一部は、 <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=fullName> 列挙します。  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState\#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState\#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState\#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>