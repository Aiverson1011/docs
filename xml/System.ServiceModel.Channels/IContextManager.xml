<Type Name="IContextManager" FullName="System.ServiceModel.Channels.IContextManager">
  <TypeSignature Language="C#" Value="public interface IContextManager" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IContextManager" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.IContextManager" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>チャネルのコンテキストを取得および設定できるインターフェイスを定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.ServiceModel.WSHttpContextBinding> 値を設定して <xref:System.ServiceModel.SessionMode.NotAllowed> を使用するチャネルの場合、<xref:System.ServiceModel.Channels.IContextManager> を使用してクライアント上でコンテキストを取得することはできません。それは、<xref:System.ServiceModel.Channels.IChannelFactory.GetProperty%2A> を呼び出してチャネル上で <xref:System.ServiceModel.SessionMode.NotAllowed> セマンティクスを実行するたびに、セッションを確立する新しいチャネルが作成されるためです。 これは、このようなケースでコンテキストがクライアントに正しく反映されても、<xref:System.ServiceModel.Channels.IContextManager> を使用してコンテキストを取得できないことを意味します。 次のコードのように <xref:System.ServiceModel.Channels.ContextMessageProperty> を使用すると、コンテキストを取得できます。  
  
```csharp  
using (new OperationContextScope((IContextChannel)channel))  
{  
    channel.MyChannel("Test");  
    ContextMessageProperty context;  
    if (ContextMessageProperty.TryGet(OperationContext.Current.IncomingMessageProperties, out context))  
    {  
        Console.WriteLine(context.Count);  
    }  
}  
  
```  
  
   
  
## 例  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.IContextManager.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンテキスト管理が有効にされたかどうかを示す値を取得または設定します。</summary>
        <value>コンテキストが有効な場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 When context management is enabled the context channel caches the context in its lifetime. Context can be retrieved from the channel through the **languageKeyword tag is not supported!!!!**  
 channel property by calling <xref:System.ServiceModel.Channels.IContextManager.GetContext%2A> method on it. The channel can also be pre\-initialized with context before being opened by calling the <xref:System.ServiceModel.Channels.IContextManager.SetContext%2A> method on the channel property. Once the channel is initialized with context it cannot be reset.  
  
 The following are invariants in this mode:  
  
-   Any call to <xref:System.ServiceModel.Channels.IContextManager.SetContext%2A> after the channel is open throws an **languageKeyword tag is not supported!!!!**  
    .  
  
-   Any attempt to send context through the **languageKeyword tag is not supported!!!!**  
     in an outgoing message throws **languageKeyword tag is not supported!!!!**  
    .  
  
-   If a message is received from the server with context, when the channel is already initialized with a context a **languageKeyword tag is not supported!!!!**  
     is thrown. Note that you can receive initial context from a server if the channel is opened without explicitly setting the context.  
  
-   The **languageKeyword tag is not supported!!!!**  
     on an incoming message is always **languageKeyword tag is not supported!!!!**  
    .  
  
 When context management is not enabled, the context channel does not manage context. It is the application's responsibility to retrieve, manage and apply context through the **languageKeyword tag is not supported!!!!**  
. Any attempt to call <xref:System.ServiceModel.Channels.IContextManager.GetContext%2A> or <xref:System.ServiceModel.Channels.IContextManager.SetContext%2A> using through the **languageKeyword tag is not supported!!!!**  
 channel property results in **languageKeyword tag is not supported!!!!**  
.  
  
 All HTTP cookies, except for context HTTP cookies, are handled at the channel level. Context HTTP cookies are managed at the application level. This can have unexpected consequences when channels are shared to talk to different instances targeted by <xref:System.ServiceModel.Channels.ContextMessageProperty>. The following table shows how HTTP cookies are affected when <xref:System.ServiceModel.Channels.IContextManager.Enabled%2A> is set to either **languageKeyword tag is not supported!!!!**  
 or **languageKeyword tag is not supported!!!!**  
.  
  
|Binding|IContextManager.Enabled Value|Context HTTP Cookie Scope|Other HTTP Cookies Scope|  
|-------------|-----------------------------------|-------------------------------|------------------------------|  
|BasicHttpBinding|n\/a|ChannelFactory|ChannelFactory|  
|BasicHttpContextBinding|true|Channel|Channel|  
|BasicHttpContextBinding|false|For each message \(explicitly managed by application\)|Channel|  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContext">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GetContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GetContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IContextManager.GetContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コンテキストを取得します。</summary>
        <returns>名前空間およびコンテキスト名が含まれたキーと値のペアの <see cref="T:System.Collections.Generic.IDictionary`2" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次のコードは、クライアント上の型指定のあるプロキシ インスタンスからコンテキストを取得する方法を示しています。  
  
```  
IDictionary<string, string> context;  
CalculatorProxy proxy;  
IContextManager cm = proxy.InnerChannel.GetProperty<IContextManager>();  
if (cm != null)  
    context = cm.GetContext();  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetContext">
      <MemberSignature Language="C#" Value="public void SetContext (System.Collections.Generic.IDictionary&lt;string,string&gt; context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContext(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.IContextManager.SetContext(System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="context">名前空間と設定済みのコンテキスト名が含まれたキーと値のペアの <see cref="T:System.Collections.Generic.IDictionary`2" />。</param>
        <summary>コンテキストを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次のコードは、クライアントでコンテキストを設定する方法を示しています。  
  
```  
IDictionary<string, string> context;  
CalculatorProxy proxy;  
IContextManager cm = proxy.InnerChannel.GetProperty<IContextManager>();  
if (cm != null)  
    cm.SetContext(context);  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>