<Type Name="BindingElement" FullName="System.ServiceModel.Channels.BindingElement">
  <TypeSignature Language="C#" Value="public abstract class BindingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit BindingElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.BindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>送信および受信メッセージの処理に使用されるさまざまな種類のチャネルのチャネル ファクトリとチャネル リスナーを作成するバインドの要素。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 A binding consists of an ordered set of binding elements that inherit from this abstract base class.  The <xref:System.ServiceModel.Channels.TransportBindingElement> class inherits from the <xref:System.ServiceModel.Channels.BindingElement> class.  
  
 Creating a binding and binding element for your transport is optional if you are just using the channel model. It is possible to do everything you need through the channel factory and listener as long as they are made public.  
  
 The [!INCLUDE[indigo1](~/includes/indigo1-md.md)] service model uses a factory pattern where the binding is used to create the channel stack. If you want to use the [!INCLUDE[indigo2](~/includes/indigo2-md.md)] service model, then using a transport binding element is required. Placing this binding element into a binding is a good practice because it removes the requirement for users to create their own custom binding for your transport. It is best to create both a binding and binding element, and hide the channel factory and listener inside the assembly.  
  
 On the sending side, a binding is used to build a <xref:System.ServiceModel.Channels.IChannelFactory>, which in turn builds a channel stack and returns a reference to the top channel in the stack. The application can then use this channel to send messages.  
  
 Similarly, on the receiving side a binding is used to build a <xref:System.ServiceModel.Channels.IChannelListener>, which listens for incoming messages. The <xref:System.ServiceModel.Channels.IChannelListener> provides messages to the listening application by creating channel stacks and handing the application a reference to the top channel. The application then uses this channel to receive incoming messages.  
  
> [!NOTE]
>  If you are adding message headers that must be encrypted you must return a <xref:System.ServiceModel.Security.ChannelProtectionRequirements> instance with your requirements from the <xref:System.ServiceModel.Channels.BindingElement.GetProperty%60%601%28System.ServiceModel.Channels.BindingContext%29> method when asked for <xref:System.ServiceModel.Security.ChannelProtectionRequirements>.  
  
   
  
## 例  
 The following example shows how to add a transport binding element to a custom binding and then build a channel listener that can accept incoming messages.  
  
 [!code-csharp[S\_UEChannels\#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uechannels/cs/servicesnippets.cs#1)]
 [!code-vb[S\_UEChannels\#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uechannels/vb/servicesnippets.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected BindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BindingElement.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.ServiceModel.Channels.BindingElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected BindingElement (System.ServiceModel.Channels.BindingElement elementToBeCloned);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Channels.BindingElement elementToBeCloned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BindingElement.#ctor(System.ServiceModel.Channels.BindingElement)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="elementToBeCloned" Type="System.ServiceModel.Channels.BindingElement" />
      </Parameters>
      <Docs>
        <param name="elementToBeCloned">複製する <see cref="T:System.ServiceModel.Channels.BindingElement" />。</param>
        <summary>指定したバインド要素を使用して、<see cref="T:System.ServiceModel.Channels.BindingElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">ファクトリが作成するチャネルの種類。</typeparam>
        <param name="context">バインディング要素のコンテキストを提供する <see cref="T:System.ServiceModel.Channels.BindingContext" />。</param>
        <summary>指定した種類のチャネルを生成するよう、バインド コンテキストからチャネル ファクトリを初期化します。</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> から初期化される <paramref name="TChannel" /> 型の <paramref name="context" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 [!code-csharp[S\_UEChannels\#16](~/samples/snippets/csharp/VS_Snippets_CFX/s_uechannels/cs/clientsnippets.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">リスナーが受け入れるように作成されているチャネルの種類。</typeparam>
        <param name="context">バインディング要素のコンテキストを提供する <see cref="T:System.ServiceModel.Channels.BindingContext" />。</param>
        <summary>指定した種類のチャネルを受け入れるよう、バインディング コンテキストからチャネル リスナーを初期化します。</summary>
        <returns>
          <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> から初期化される <see cref="T:System.ServiceModel.Channels.IChannel" /> 型の <paramref name="context" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 [!code-csharp[S\_UEChannels\#17](~/samples/snippets/csharp/VS_Snippets_CFX/s_uechannels/cs/servicesnippets.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">チャネル ファクトリが作成するチャネルの種類。</typeparam>
        <param name="context">バインディング要素のコンテキストを提供する <see cref="T:System.ServiceModel.Channels.BindingContext" />。</param>
        <summary>指定した種類のチャネルに対するチャネル ファクトリをバインド要素が作成できるかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> 型の <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> をバインディング要素によって作成できる場合は <paramref name="TChannel" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ファクトリを作成する前に、指定した `TChannel` に対して `context` 型のチャネルのチャネル ファクトリを作成できることを確認するには、このメソッドを使用します。 または、<xref:System.ServiceModel.Channels.BindingElement.BuildChannelFactory%2A> を呼び出してチャネル ファクトリを作成し、作成できない場合は生成される例外をキャッチします。  
  
   
  
## 例  
 [!code-csharp[S\_UEChannels\#18](~/samples/snippets/csharp/VS_Snippets_CFX/s_uechannels/cs/clientsnippets.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">リスナーが受け入れるチャネルの種類。</typeparam>
        <param name="context">バインディング要素のコンテキストを提供する <see cref="T:System.ServiceModel.Channels.BindingContext" />。</param>
        <summary>指定した種類のチャネルに対するリスナーをバインド要素が作成できるかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> 型の <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> をバインディング要素によって作成できる場合は <see cref="T:System.ServiceModel.Channels.IChannel" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use this method if you want to check that the channel listener for channels of type **parameterReference tag is not supported!!!!**  
 can be build for the **parameterReference tag is not supported!!!!**  
 provided before attempting to build the listener. Alternatively, build the channel listener by calling <xref:System.ServiceModel.Channels.BindingElement.BuildChannelListener%2A> and catch the exception generated if it cannot be built.  
  
   
  
## 例  
 [!code-csharp[S\_UEChannels\#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_uechannels/cs/servicesnippets.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public abstract System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BindingElement.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、バインド要素オブジェクトのコピーを返します。</summary>
        <returns>オリジナルのディープ クローンである <see cref="T:System.ServiceModel.Channels.BindingElement" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Implement the <xref:System.ServiceModel.Channels.BindingElement.Clone%2A> method to return a deep clone of your binding element. Returning a clone enables the runtime to support the case in which multiple custom bindings share a custom binding element. If a clone is not returned, the run\-time behavior is undefined.  
  
 A deep clone of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object. \(This is also called copying the entire object graph.\) A shallow clone of an object, by contrast, is a copy of the object only. If the object contains references to other objects, the shallow copy does not create copies of the referred objects; instead, it copies only the references to the original objects.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public abstract T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">メソッドが照会している、型指定されたオブジェクト。</typeparam>
        <param name="context">バインディング要素の <see cref="T:System.ServiceModel.Channels.BindingContext" />。</param>
        <summary>派生クラスでオーバーライドされると、バインド スタックの適切な層から、要求のあった型指定されたオブジェクト \(ある場合\) を返します。</summary>
        <returns>要求される型指定されたオブジェクト <paramref name="T" /> がある場合は、そのオブジェクト。ない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 バインディング要素スタックから機能、要件、およびパラメーターを取得するには、このメソッドを使用します。 バインド要素が、要求されたオブジェクトを返せる場合は、オブジェクトを返します。 それ以外の場合は、スタック内の次のバインド要素に呼び出しを代行させます。 スタックの最下位に達しても要求されたオブジェクトをサポートするバインディング要素がない場合、メソッドは、`null` を返します。  
  
> [!NOTE]
>  暗号化する必要のあるメッセージ ヘッダーを追加している場合、<xref:System.ServiceModel.Security.ChannelProtectionRequirements> を求められたときに、このメソッドから、要件と共に <xref:System.ServiceModel.Security.ChannelProtectionRequirements> インスタンスを返す必要があります。  
  
   
  
## 例  
 [!code-csharp[S\_UEChannels\#20](~/samples/snippets/csharp/VS_Snippets_CFX/s_uechannels/cs/servicesnippets.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.ServiceModel.Channels.BindingElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>