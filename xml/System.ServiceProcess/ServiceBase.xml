<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>サービス アプリケーションの一部として存在するサービスの基本クラスを提供します。<see cref="T:System.ServiceProcess.ServiceBase" /> 新しいサービス クラスを作成するときからを派生させる必要があります。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生 <xref:System.ServiceProcess.ServiceBase> サービス アプリケーションで、サービス クラスを定義する場合。 有効なサービスの上書き、 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> と <xref:System.ServiceProcess.ServiceBase.OnStop%2A> メソッドです。 他の機能をオーバーライドできます <xref:System.ServiceProcess.ServiceBase.OnPause%2A> と <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> の特定の動作をサービスの状態の変更に応答します。  
  
 サービスは、ユーザー インターフェイスをサポートしていない実行時間の長い実行可能ファイルでは、ログオン ユーザー アカウントで実行するとします。 サービスは、すべてのユーザーがコンピューターにログオンすることがなく実行できます。  
  
 既定では、サービスは、管理者アカウントと同じではないシステム アカウントで実行します。 システム アカウントの権限を変更することはできません。 また、使用することができます、 <xref:System.ServiceProcess.ServiceProcessInstaller> サービスを実行するユーザー アカウントを指定します。  
  
 実行可能ファイルは、複数のサービスを含めることができますが、個別に含める必要があります <xref:System.ServiceProcess.ServiceInstaller> サービスごとにします。<xref:System.ServiceProcess.ServiceInstaller> インスタンスをシステム サービスに登録します。 また、インストーラーは、サービスのコマンドを記録する使用できるイベント ログを含む各サービスを関連付けます。`main()` 実行可能ファイル内の関数を定義するサービスを実行する必要があります。 サービスの現在の作業ディレクトリは、実行可能ファイルが配置されているディレクトリではなく、システム ディレクトリです。  
  
 システムが実行可能ファイルを検索し、実行されるサービスを開始するときに、 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 実行可能ファイル内に含まれる、そのサービスのメソッドです。 ただし、サービスを実行するは、実行可能ファイルを実行すると同じです。 実行可能ファイルは、サービスを読み込むだけです。 アクセスされるサービス \(たとえば、開始および停止\) サービス コントロール マネージャーを使用します。  
  
 実行可能ファイルが、 <xref:System.ServiceProcess.ServiceBase> 派生したサービスの開始を呼び出すクラスの 1 つ目のコンス トラクターにします。<xref:System.ServiceProcess.ServiceBase.OnStart%2A> コンス トラクターの実行直後に、コマンド処理メソッドが呼び出されます。 によって実行されるコンス トラクターで実行される処理を分離する必要があるために、サービスが読み込まれると、最初に実行し直してのコンス トラクターが実行されない <xref:System.ServiceProcess.ServiceBase.OnStart%2A>します。 すべてのリソースを解放することができますを <xref:System.ServiceProcess.ServiceBase.OnStop%2A> で作成する必要があります <xref:System.ServiceProcess.ServiceBase.OnStart%2A>します。 コンス トラクターでリソースを作成するようにした後、サービスが開始された場合に正常に作成される <xref:System.ServiceProcess.ServiceBase.OnStop%2A> がリソースを解放します。  
  
 サービス コントロール マネージャー \(SCM\) は、サービスと対話する手段を提供します。 SCM を使用すると、サービスを開始、停止、一時停止、続行、またはカスタムのコマンドを渡します。 SCM の値を使用する <xref:System.ServiceProcess.ServiceBase.CanStop%2A> と <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 、サービスが停止を受け入れるかどうかを確認するのには、一時停止、またはコマンドを続行します。 停止、一時停止、および継続は SCM のコンテキスト メニュー場合にのみに有効になっている、対応するプロパティ <xref:System.ServiceProcess.ServiceBase.CanStop%2A> または <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> は `true` サービス クラスにします。 コマンドが、サービスに渡される有効な場合、および <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, 、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>, 、または <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> が呼び出されます。 場合 <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, 、<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, 、または <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> は `false`, 、対応するコマンドの処理メソッド \(よう <xref:System.ServiceProcess.ServiceBase.OnStop%2A>\) は処理されず、メソッドを実装している場合でもです。  
  
 使用することができます、 <xref:System.ServiceProcess.ServiceController> クラスは、SCM はどのようなプログラムを使用してユーザー インターフェイスを使用します。 コンソールで利用可能なタスクを自動化することができます。 場合 <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, 、<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, 、または <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> は `true` が対応するコマンドの処理メソッドが実装されていません \(よう <xref:System.ServiceProcess.ServiceBase.OnStop%2A>\)、システムが例外をスローし、コマンドは無視されます。  
  
 実装する必要はありません <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, 、<xref:System.ServiceProcess.ServiceBase.OnStop%2A>, 、またはその他の方法で <xref:System.ServiceProcess.ServiceBase>します。 ただし、サービスの動作は、「 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, ので少なくとも、このメンバーをオーバーライドする必要があります。`main()` 実行可能ファイルの関数は、呼び出すことによって、実行可能ファイルをサービス コントロール マネージャで、サービスを登録、 <xref:System.ServiceProcess.ServiceBase.Run%2A> メソッドです。<xref:System.ServiceProcess.ServiceBase.ServiceName%2A> のプロパティ、 <xref:System.ServiceProcess.ServiceBase> オブジェクトに渡される、 <xref:System.ServiceProcess.ServiceBase.Run%2A> メソッドに一致する必要があります、 <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> そのサービスのサービスのインストーラーのプロパティです。  
  
 使用する `InstallUtil.exe` 、システムにサービスをインストールします。  
  
> [!NOTE]
>  サービスの呼び出しが、どちらの通知を受け取るアプリケーション イベント ログ以外のログを指定する、 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> も <xref:System.ServiceProcess.ServiceBase.EventLog%2A> プロパティは、カスタムのログに書き込むことができます。 設定 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> に `false` 自動ログを使用したくない場合。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.ServiceProcess.ServiceBase" /> クラスの新しいインスタンスを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスを作成しないでください、 <xref:System.ServiceProcess.ServiceBase> クラスです。 派生させる代わりに、 <xref:System.ServiceProcess.ServiceBase> し、派生クラスをインスタンス化します。 最小値から継承したクラスのコンス トラクターで実装する必要があります <xref:System.ServiceProcess.ServiceBase> 設定するのには、 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 、コンポーネントにします。 他の処理は、コンス トラクターで具体的には必要ありません。 ほとんどの初期化を処理する必要があります <xref:System.ServiceProcess.ServiceBase.OnStart%2A> コンス トラクターではなく。 それ以外の場合、オブジェクトは再初期化が停止した後にサービスを再起動したときに保証することはありません。  
  
 派生クラスでは、コンス トラクターをオーバーライドする場合は、コード内の基本クラス コンス トラクターを呼び出します。  
  
 <xref:System.ServiceProcess.ServiceBase> コンス トラクターのセット <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> に `true`します。 サービス コントロール マネージャー \(SCM\) から、サービスに対する呼び出しを自動的にログオンしない場合は、設定 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> に `false`します。  
  
 実行可能ファイルに 1 つのサービスが含まれている場合、システムは、開始、SCM からを選択し、Stop が呼び出された場合、デストラクターを実行サービスのコンス トラクターを呼び出します。  
  
 実行可能ファイルに複数のサービスが含まれている場合は、1 つのサービスの開始を呼び出すと、実行可能ファイルのすべてのサービスに対して呼び出されるコンス トラクターが、指定したサービスのみが開始されます。 すべてのサービスが停止した、個別ではなく各サービスが停止したときに、サービスのデストラクターは一緒に実行されます。  
  
> [!NOTE]
>  基本クラス コンス トラクターをオーバーライドする場合は、派生クラスのコンス トラクターで明示的に呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログの開始、停止、一時停止、続行のコマンドを報告するかどうかを示します。</summary>
        <value>
          <see langword="true" /> イベント ログに情報のレポートそれ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> に `true` 、サービスの起動、停止、一時停止、状態変更情報だけでなく、コマンドの失敗を報告するアプリケーション イベント ログを使用して、サービスのイベントを続けるように指示します。 サービスの名前は、ログのとして使用 <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>します。  
  
 設定をアプリケーション ログではなく、カスタム イベント ログに情報をレポートする <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> に `false` コマンド処理メソッドは、内の指示を記述および <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, 、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>, 、または <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 、適切なログに投稿します。  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, 、イベント ログのソース文字列を提供する必要があります前に設定する、サービスがイベント ログに書き込みを試みます。 例外をスローするソース名を設定する前にイベント ログにアクセスしようとしています。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはサービスがコンピューターの電源ステータスの変更の通知を処理できるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> サービスに変更が示されているコンピューターの電源状態を処理するかどうか、 <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> クラス、それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コンピューターの電源ステータスの変更、サービス コントロール マネージャー \(SCM\) が検証されたとき、サービスでの値を使用して、電源イベント コマンドを受け入れるかどうか <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>します。  
  
 場合 <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> は `true`, 、コマンドが、サービスに渡されると、 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> 定義されている場合、メソッドが呼び出されます。 場合 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> は実装されておらず、SCM が空の基底クラスを通じた電源イベントを処理する派生クラスで <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスが開始された後、このプロパティが変更します。</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはサービスで、ターミナル サーバー セッションから受信したセッションの変更イベントを処理できるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> サービスは、ターミナル サーバー セッションの変更イベントを処理できる場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">サービスが開始された後、このプロパティが変更します。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはサービスの一時停止および再開するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> サービスを一時停止できる場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値を設定、 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 、サービスのコンス トラクターでプロパティです。  
  
 サービスが一時停止されるとは何を停止します。 \(またはいずれか、サービス コントロール マネージャでプログラムを使用して\)、サービスを続行する <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> を実行します。  
  
 一時停止要求をサービスに送信すると、システム リソースを節約できます。 一時停止は、すべてのシステム リソースを解放しないことがありますが、停止します。<xref:System.ServiceProcess.ServiceBase.OnPause%2A><xref:System.ServiceProcess.ServiceBase.OnContinue%2A> よりも少ない処理を実行する多くの場合、実装されている <xref:System.ServiceProcess.ServiceBase.OnStop%2A> と <xref:System.ServiceProcess.ServiceBase.OnStart%2A>です。  
  
 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> は `true`, 、オーバーライド <xref:System.ServiceProcess.ServiceBase.OnPause%2A> と <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> サービス コントロール マネージャー \(SCM\) は、サービスに、一時停止または続行要求を渡すときに発生する処理を指定します。<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 元に戻すで処理するために実装 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>します。  
  
 場合 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> は `false`, 、SCM は一時停止を合格しない、または、サービスに要求をため続行、 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> と <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 実装されている場合でも、メソッドは呼び出されません。 SCM で、 `Pause` と `Continue` コントロールが無効になっているときに <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> は `false`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスが既に開始されています。<see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> 、サービスが開始されると、プロパティを変更できません。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはシステムがシャット ダウンするときに、サービスを通知するかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> 場合は、システムがシャット ダウン時にサービスに通知する必要があります。それ以外の場合、 <see langword="false" />です。  既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> は `true`, 、サービスは、システムがシャット ダウンするときに通知します。 シャット ダウン時に、 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> 、派生クラスで実装されている場合、メソッドが呼び出されます。  
  
> [!NOTE]
>  システムのみが発生する必要があります、 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> ; を実行するメソッド、サービスを呼び出すことができますが、これは推奨されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスが既に開始されています。<see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> 、サービスが開始されると、プロパティを変更できません。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはが起動した後に、サービスを停止できるかどうかを示す値を設定します。</summary>
        <value>
          <see langword="true" /> サービスを停止する場合、 <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> メソッドが呼び出されます。 それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サービスの停止が呼び出されると、サービス コントロール マネージャー \(SCM\) は、サービスが停止コマンドの値を使用してを受け入れるかどうかを確認 <xref:System.ServiceProcess.ServiceBase.CanStop%2A>します。 ほとんどのサービスでの値の <xref:System.ServiceProcess.ServiceBase.CanStop%2A> は `true`, 、一部のオペレーティング システム サービスなどの見えないようにユーザーに通知を停止します。  
  
 場合 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> は `true`, 、停止コマンドが、サービスに渡されると、 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 定義されている場合、メソッドが呼び出されます。 場合 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> は空の基底クラスからの停止コマンド、SCM ハンドル、派生クラスで実装されていません <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスが既に開始されています。<see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> 、サービスが開始されると、プロパティを変更できません。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.ServiceProcess.ServiceBase" /> で使用されていたリソース \(メモリを除く\) を解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Call <xref:System.ServiceProcess.ServiceBase.Dispose%2A> in your derived class \(and through it, in the <xref:System.ServiceProcess.ServiceBase> class\) when you are finished using the derived class. The <xref:System.ServiceProcess.ServiceBase.Dispose%2A> method leaves the derived class in an unusable state. After calling <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, you must release all references to the derived class and <xref:System.ServiceProcess.ServiceBase> so the memory they were occupying can be reclaimed by garbage collection.  
  
> [!NOTE]
>  Always call <xref:System.ServiceProcess.ServiceBase.Dispose%2A> before you release your last reference to the class derived from <xref:System.ServiceProcess.ServiceBase>. Otherwise, the resources <xref:System.ServiceProcess.ServiceBase> and the derived class are using will not be freed until garbage collection calls the objects' destructors.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> is often implemented to process the code in <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, combined with a call to <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. If you choose to do this in your derived class, it is customary to implement <xref:System.ServiceProcess.ServiceBase.OnStart%2A> to allocate whatever <xref:System.ServiceProcess.ServiceBase.Dispose%2A> released.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>開始、停止などのサービス コマンドの呼び出しの通知をアプリケーション イベント ログに書き込みを行うこともできますイベント ログを取得します。</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLog" /> ソースがアプリケーション ログに登録されているインスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コンス トラクターは、 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> プロパティを使用してインスタンスを <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> と <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=fullName> プロパティを設定します。 ソースは、 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 、サービスのログで、コンピューターのアプリケーション ログに記録します。 これらの値が自動的に設定し、サービス コマンドの自動ログは変更できません。  
  
 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> は `true`, 、開始、停止、一時停止、続行、およびカスタムのコマンドは、アプリケーション イベント ログに自動的に記録します。 使用することができます、 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> もログに関連するメッセージを書き込むプロパティ。 コンポーネントの呼び出し <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=fullName> これを使用して <xref:System.ServiceProcess.ServiceBase.EventLog%2A> メンバーです。  
  
 設定をアプリケーション ログではなく、カスタム イベント ログに情報をレポートする <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> に `false` コマンド処理メソッドは、内の指示を記述および <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, 、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>, 、または <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 、適切なログに投稿します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはサービスの終了コードを設定します。</summary>
        <value>サービスの終了コード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定、 <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> プロパティをサービス コントロール マネージャーにエラーを示すためにサービスを停止する前に 0 以外の値にします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>サービス名の最大サイズを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ServiceName と DisplayName 両方サービス クラスのプロパティを設定するときに従う必要がありますサイズの制限があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスで実装された場合 <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> 続行コマンドがサービス コントロール マネージャー \(SCM\) によって、サービスに送信されるときに実行します。 サービスが一時停止された後に正常な機能を再開したときに実行されるアクションを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 実装 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> へのアプリケーションの応答をミラー化する <xref:System.ServiceProcess.ServiceBase.OnPause%2A>です。 \(または、サービス コンソール プログラムによって\)、サービスを続行する場合、 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 処理を実行して、サービスが再びアクティブです。  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> オーバーライドするときに期待どおり、 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> プロパティは `true`です。  
  
 場合 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> は `false`, 、SCM は一時停止を合格しない、または、サービスに要求をため続行、 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> と <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 実装されている場合でも、メソッドは呼び出されません。 SCM で、 `Pause` と `Continue` コントロールが無効になっているときに <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> は `false`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">コマンド メッセージをサービスに送信します。</param>
        <summary>派生クラスで実装された場合 <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> サービス コントロール マネージャー \(SCM\) は、サービスにカスタム コマンドを渡すときに実行されます。 指定したパラメーター値を使用したコマンドが発生したときに実行されるアクションを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> 起動、停止、一時停止と継続的なサービス以外の他の機能を指定します。  
  
 SCM がサービスをサポートするかどうかを確認するカスタム コマンドを調べない、 `command` でパラメーターが渡されます。 サービスに直接カスタム コマンドを渡します。 サービスが認識しない場合、 `command` パラメーターは何も行いません。  
  
 カスタム コマンドが発生した、 <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> 内のステートメントで、 <xref:System.ServiceProcess.ServiceController> コンポーネントです。 Switch ステートメントを使用する場合は.サービスで定義するカスタムのコマンドを処理し、条件です。  
  
 アプリケーションで定義したりで使用できるカスタム コマンドの値のみ <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> 128 ~ 255 の範囲とは。 128 未満の整数は、システム予約の値に対応します。  
  
 場合、 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> プロパティは、 `true`, 、他のすべてのコマンドと同様に、カスタムのコマンドは、メソッドの実行が成功または失敗したかどうかを報告するイベント ログにエントリを書き込みます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスとして実装された場合は、一時停止コマンドがサービス コントロール マネージャー \(SCM\) によって、サービスに送信されるときを実行します。 サービスが一時中断時に実行するアクションを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> サービスが一時停止コマンドを受信するときに発生する処理を指定します。<xref:System.ServiceProcess.ServiceBase.OnPause%2A> オーバーライドするときに期待どおり、 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> プロパティは `true`です。  
  
 \(または、サービス コンソール プログラムによって\)、一時停止したサービスを続行する場合、 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 処理が実行され、サービスが再度アクティブになります。  
  
 一時停止コマンドには、特定のイベントに対応するため、アプリケーションのみが許可されます。<xref:System.ServiceProcess.ServiceBase.OnPause%2A> これを行うには定義されていないサービスに何も行いません。  
  
 一時停止要求をサービスに送信すると、一時停止は、すべてのシステム リソースを解放しない必要があるためにシステム リソースを節約できます。 たとえば、スレッドを停止できるが開いている場合は、スレッドではなく、サービスを一時停止、プロセスによって開かれている場合、サービスを続行するときにそれらを再割り当てする必要があります。 すべてのシステム リソースを解放する一時停止を定義する場合は、停止コマンドと同様に動作します。  
  
 設定 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> に `true`, 、させ <xref:System.ServiceProcess.ServiceBase.OnPause%2A> と <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 、SCM がサービスに、一時停止または続行要求を渡すときに発生する処理を指定します。<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 元に戻すで処理するために実装 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>します。  
  
 場合 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> は `false`, 、SCM は一時停止を合格しない、または、サービスに要求をため続行、 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> と <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 実装されている場合でも、メソッドは呼び出されません。 SCM で、 `Pause` と `Continue` コントロールが無効になっているときに <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> は `false`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">A <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> を示す、電源状態のシステムから通知されます。</param>
        <summary>派生クラスとして実装された場合は、コンピューターの電源状態が変更されたときに実行します。 これにより、システムのシャット ダウンと同じではない中断モードに移動すると、ラップトップ コンピュータに適用されます。</summary>
        <returns>派生クラスとして実装された場合、アプリケーションのニーズは、返される値を決定します。 たとえば場合、 <see langword="QuerySuspend" /> ブロードキャストのステータスが渡されて、アプリケーションを返すことによって、クエリを拒否する可能性が <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> に、システム イベントに示されているときに発生する処理を指定する、 <xref:System.ServiceProcess.PowerBroadcastStatus> 列挙が行われる \- たとえば、コンピューターをサスペンド モードで配置またはバッテリ電源を示します。  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> オーバーライドするときに期待どおり、 <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> プロパティは `true`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">変更の種類を識別する構造体。</param>
        <summary>変更イベントは、ターミナル サーバー セッションから受信したときに実行されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定する必要があります、 <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> プロパティを `true` このメソッドの実行を有効にします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスとして実装された場合は、システムがシャット ダウンを実行します。 システムがシャット ダウンする前にすぐに何が起きるかを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用する <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> システム シャット ダウンするときに発生する処理を指定します。  
  
 このイベントは、コンピューターが電源オフ時ではなく、オペレーティング システムをシャット ダウン時にのみ発生します。  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> オーバーライドするときに期待どおり、 <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> プロパティは `true`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">開始コマンドによって渡されるデータ。</param>
        <summary>派生クラスとして実装された場合は、サービス コントロール マネージャー \(SCM\) によって、またはオペレーティング システムを起動すると \(自動的に起動するサービス\)、サービスに送信されると開始コマンドを実行します。 サービスの開始時に実行されるアクションを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> サービスが開始コマンドを受信するときに発生する処理を指定します。<xref:System.ServiceProcess.ServiceBase.OnStart%2A> サービスの動作を指定する方法です。<xref:System.ServiceProcess.ServiceBase.OnStart%2A> データを渡す方法として引数を受け取ることができますが、この使用方法はほとんどありません。  
  
> [!CAUTION]
>  登録する処理を実行するコンス トラクターを使用しないでください <xref:System.ServiceProcess.ServiceBase.OnStart%2A>します。 使用 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> サービスのすべての初期化を処理します。 コンス トラクターは、アプリケーションの実行可能ファイルときに呼び出されますが、サービスが実行時ではなく、実行します。 実行可能ファイルを実行する前に <xref:System.ServiceProcess.ServiceBase.OnStart%2A>します。 続行すると、たとえば、コンス トラクターは再度呼び出されません、SCM は、メモリ内のオブジェクトを既に保持しているためです。 場合 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> コンス トラクターではなく、割り当てられているリソースを解放 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, 、必要なリソースを作成できませんが 2 番目に、サービスが呼び出されるときに再びします。  
  
 コンピューターを設定して再起動するときに自動的に開始するサービスを設定することができます、 <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> するために、サービスのインストーラーに <xref:System.ServiceProcess.ServiceStartMode.Automatic>します。 このような場合、 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> はシステムの起動時に呼び出されます。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 派生クラスでオーバーライドされると想定されます。 有効に機能するサービスの <xref:System.ServiceProcess.ServiceBase.OnStart%2A> と <xref:System.ServiceProcess.ServiceBase.OnStop%2A> どちらも、サービス クラスで実装する必要があります。  
  
 サービスの初期化の引数を処理、 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Main メソッドではなく、メソッドです。 引数、 `args` パラメーター配列は、サービス コンソールで、サービスのプロパティ\] ウィンドウで手動で設定することができます。 コンソールで入力した引数は保存されません。渡すことが、サービスを一時的に、コントロール パネルから、サービスが開始されるとします。 サービスが自動的に起動すると現在のところにする必要がある引数は、サービスのレジストリ キーの ImagePath 文字列値に配置することができます \(HKEY\_LOCAL\_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\*\< サービス名 \>*\)。 使用して、レジストリから引数を取得することができます、 <xref:System.Environment.GetCommandLineArgs%2A> 例については、メソッド:  `string[] imagePathArgs = Environment.GetCommandLineArgs();`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスとして実装された場合は、停止コマンドがサービス コントロール マネージャー \(SCM\) によって、サービスに送信されるときを実行します。 実行しているサービスが停止したときに実行するアクションを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> サービスが停止コマンドを受信するときに発生する処理を指定します。  
  
 値を使用して、SCM では、停止コマンドを受信するときに <xref:System.ServiceProcess.ServiceBase.CanStop%2A> をサービスが停止コマンドを受け入れるかどうかを確認します。 場合 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> は `true`, 、停止コマンドが、サービスに渡されると、 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 定義されている場合、メソッドが呼び出されます。 場合 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> は実装されていません、SCM はサービスでは、停止コマンドを処理します。  
  
 場合 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> は `false`, 、SCM は、停止コマンドを無視します。 サービスには渡されません。 停止コマンドを返し、例外がスローされます。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 派生クラスでオーバーライドされると想定されます。 有効に機能するサービスの <xref:System.ServiceProcess.ServiceBase.OnStart%2A> と <xref:System.ServiceProcess.ServiceBase.OnStop%2A> どちらも、サービス クラスで実装する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">ミリ秒単位で要求された時刻。</param>
        <summary>保留中の操作について追加の時間を要求します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> メソッドが呼び出されるもので、オーバーライドされた <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, 、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>, 、<xref:System.ServiceProcess.ServiceBase.OnStart%2A>, 、または <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 要求をサービス コントロール マネージャー \(SCM\) が応答するいないとサービスへのマークすることを防ぐために、保留中の操作の時間を追加する方法です。  保留中の操作が続行、一時停止、開始または停止ではない場合、 <xref:System.InvalidOperationException> がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスは、保留中の状態ではありません。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">A <see cref="T:System.ServiceProcess.ServiceBase" /> サービスを開始することを示します。</param>
        <summary>サービス コントロール マネージャー \(SCM\) とサービスの実行可能ファイルを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを呼び出して、 `main()` 実行可能ファイルをサービス コントロール マネージャ サービスに登録をサービスの機能です。 呼び出した後 <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, 、サービス コントロール マネージャーへの呼び出しで開始コマンドの発行、 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 、サービスのメソッドです。 サービスは開始コマンドが実行されるまでは開始されません。  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=fullName> と同様にメソッドが呼び出された <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName> Windows フォーム アプリケーションです。  
  
 場合 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> は `true`, で、サービスが指定された場合に、イベント ログにエントリが書き込まれます、 `service` パラメーターの開始に失敗します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="service" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">サービスの開始を示す ServiceBase インスタンスの配列。</param>
        <summary>サービス コントロール マネージャー \(SCM\) に複数のサービス実行可能ファイルを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードを呼び出して、 `main()` 実行可能ファイルをサービス コントロール マネージャ サービスの登録をサービスの機能です。 呼び出した後 <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, 、サービス コントロール マネージャへの呼び出しと、\[開始\] コマンドの発行、 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> サービス内のメソッドです。 Start コマンドを実行するまで、サービスは開始されません。  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=fullName> メソッドが呼び出されると同様、 <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName> Windows フォーム アプリケーションのメソッドです。  
  
 場合 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> は `true`, 、配列内のサービスが開始しなかった場合、エントリがイベント ログに書き込まれます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">サービスを開始するが指定されていません。 配列である可能性があります <see langword="null" /> または空です。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サービスのサービス コントロール ハンドルを取得します。</summary>
        <value>
          <see cref="T:System.IntPtr" /> サービスのサービス コントロール ハンドルを格納する構造体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サービス コントロール ハンドルは、サービス コントロール マネージャー \(SCM\) との通信に使用されます。  ハンドルを使用してアンマネージを使用して呼び出し元のサービスのサービス コントロール マネージャーの状態情報を更新すること `SetServiceStatus` 関数です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for access to unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">引数の配列内の引数の数。</param>
        <param name="argPointer">
          <see cref="T:System.IntPtr" /> 引数の配列を指す構造体。</param>
        <summary>コマンド ハンドラーを登録し、サービスを開始します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはシステム サービスを識別するために使用する短い名前を設定します。</summary>
        <value>サービスの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> サービス コントロール マネージャーにサービスを識別します。 このプロパティの値は、サービスの記録された名前と同じである必要があります、 <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=fullName> 、対応するインストーラー クラスのプロパティです。 コードでは、 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> サービスの通常は設定、 `main()` 実行可能ファイルの関数です。  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 指定にも使用されて、 <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> に関連付けられている、 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> プロパティです。 これは、 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> サービス コマンドの情報をアプリケーション ログに記録されるインスタンスです。  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, 、イベント ログのソース文字列を提供する必要があります前に設定する、サービスがイベント ログに書き込みます。 スローする例外が発生したソース名を設定する前にイベント ログにアクセスしようとしています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスが既に開始されています。<see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> 、サービスが開始されると、プロパティを変更できません。</exception>
        <exception cref="T:System.ArgumentException">指定した名前が長さ 0 の文字列は、またはより長い <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />, 、または指定した名前には、前方のスラッシュまたは円記号の文字が含まれています。</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>実行中のサービスを停止します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.ServiceProcess.ServiceBase.Stop%2A> メソッドは、停止が保留中であることを示すサービスの状態と呼び出しを設定、 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> メソッドです。  アプリケーションが停止した後、サービスの状態が停止に設定します。 アプリケーションがホストされるサービスの場合は、アプリケーション ドメインがアンロードされます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>サービスの実行可能ファイルのメイン エントリ ポイントを提供します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>