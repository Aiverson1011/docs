<Type Name="XElement" FullName="System.Xml.Linq.XElement">
  <TypeSignature Language="C#" Value="public class XElement : System.Xml.Linq.XContainer, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XElement extends System.Xml.Linq.XContainer implements class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XElement" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.Xml.Linq.ComponentModel.XTypeDescriptionProvider`1&lt;System.Xml.Linq.XElement&gt;))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider(null, IsAny=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>XML 要素を表します。  参照してください [XElement Class Overview](http://msdn.microsoft.com/ja-jp/d35180fe-7016-4895-9bfc-ba1e3f7875ec) と使用状況の情報と例については、このページの「解説」セクション。  
  
 この型の .NET Framework ソース コードを参照するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#System.Xml.Linq/XLinq.cs#3367036406d1344a)します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを参照してください、 [Reference Source](http://referencesource.microsoft.com/#System.Xml.Linq/XLinq.cs#3367036406d1344a)します。 ソース コードをオンラインで参照、オフライン表示のリファレンスをダウンロードおよびデバッグ中にソース \(パッチや更新を含む\) をステップsee [instructions](http://referencesource.microsoft.com/).  
  
 このクラスは、基本的な XML 構造、XML 要素を表します。  参照してください [XElement Class Overview](http://msdn.microsoft.com/ja-jp/d35180fe-7016-4895-9bfc-ba1e3f7875ec) の他の使用法の情報です。  
  
 要素とは、 <xref:System.Xml.Linq.XName>, 、必要に応じて 1 つまたは複数属性、およびオプションで、コンテンツを含めることができます \(詳細については、次を参照してください。 <xref:System.Xml.Linq.XContainer.Nodes%2A>\)。  
  
 <xref:System.Xml.Linq.XElement> 次の種類のコンテンツを含めることができます。  
  
-   <xref:System.Xml.Linq.XElement>  
  
-   <xref:System.Xml.Linq.XComment>  
  
-   <xref:System.Xml.Linq.XProcessingInstruction>  
  
-   <xref:System.Xml.Linq.XText>  
  
 有効なコンテンツについては、 <xref:System.Xml.Linq.XElement>, を参照してください [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/ja-jp/aee2d319-5c5f-4b99-9bb4-2f58232577ae)します。  
  
 <xref:System.Xml.Linq.XElement> 派生した <xref:System.Xml.Linq.XContainer>, から派生した <xref:System.Xml.Linq.XNode>します。  
  
 いくつか <xref:System.Xml.Linq.XElement> XAML からメソッドを使用することができます。 詳細については、「[LINQ to XML Dynamic Properties](http://msdn.microsoft.com/ja-jp/0455f47c-4a68-4f2e-a3f8-dd1d85b99012)」を参照してください。  
  
   
  
## 例  
 次の例では、XML ツリーを作成します。 新しい要素の内容は、LINQ クエリから取得されます。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _  
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim xmlTree2 As XElement = _   
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 同じ例を次に示しますが、ここで XML 名前空間。 詳細については、「[Working With Namespaces](http://msdn.microsoft.com/ja-jp/e3003209-3234-45be-a832-47feb7927430)」を参照してください。  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree1 = new XElement(aw + "Root",  
    new XElement(aw + "Child1", 1),  
    new XElement(aw + "Child2", 2),  
    new XElement(aw + "Child3", 3),  
    new XElement(aw + "Child4", 4),  
    new XElement(aw + "Child5", 5),  
    new XElement(aw + "Child6", 6)  
);  
  
XElement xmlTree2 = new XElement(aw + "Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
  
                Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree1 As XElement = _  
            <Root>  
                <Child1>1</Child1>  
                <Child2>2</Child2>  
                <Child3>3</Child3>  
                <Child4>4</Child4>  
                <Child5>5</Child5>  
                <Child6>6</Child6>  
            </Root>  
  
        Dim xmlTree2 As XElement = _   
            <Root>  
                <%= From el In xmlTree1.Elements() _  
                    Where el.Value >= 3 And el.Value <= 5 _  
                    Select el %>  
            </Root>  
  
        Console.WriteLine(xmlTree2)  
    End SUb  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root xmlns="http://www.adventure-works.com">  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Xml.Linq.XElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターに渡すことができる有効なコンテンツに関する詳細については、「 [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/ja-jp/aee2d319-5c5f-4b99-9bb4-2f58232577ae)します。  
  
 文字列からへの暗黙の変換が <xref:System.Xml.Linq.XName>です。 このコンス トラクターの一般的な用途は、新しいを作成する代わりにパラメーターとして文字列を指定する、 <xref:System.Xml.Linq.XName>です。  
  
 加算演算子オーバー ロードを使用する一般的な使用方法は、要素を名前空間を作成する場合、 <xref:System.Xml.Linq.XNamespace> および作成するための文字列、 <xref:System.Xml.Linq.XName>です。 詳細については、「[Working With Namespaces](http://msdn.microsoft.com/ja-jp/e3003209-3234-45be-a832-47feb7927430)」を参照してください。  
  
   
  
## 例  
 次の例では、XML ツリーを作成します。 新しい要素の内容は、LINQ クエリから取得されます。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child", 1),  
    new XElement("Child", 2),  
    new XElement("Child", 3),  
    new XElement("Child", 4),  
    new XElement("Child", 5),  
    new XElement("Child", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
            <Child>6</Child>  
        </Root>  
  
Dim xmlTree2 As XElement = _  
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child>3</Child>  
  <Child>4</Child>  
  <Child>5</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XElement other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XElement other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XElement)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="other">
          <see cref="T:System.Xml.Linq.XElement" /> からコピー先のオブジェクト。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Xml.Linq.XElement" /> から別のクラス <see cref="T:System.Xml.Linq.XElement" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは、要素の詳細コピーを作成します。  
  
   
  
## 例  
 次の例は、XML ツリーを作成して、ツリーの複製を作成しを呼び出して <xref:System.Xml.Linq.XNode.DeepEquals%2A>, 、2 つの XML ツリーが等しいかどうかをテストします。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XElement("Child1", 1),  
    new XElement("Child2", 2)  
);  
  
// Create a clone of the tree.  
XElement treeClone = new XElement(xmlTree);  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone));  
  
// Do some work with xmlTree, perhaps pass it to other methods.  
xmlTree.Add(new XElement("Child3", 3));  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone));  
```  
  
```vb  
  
                Dim xmlTree As XElement = _  
        <Root Att1="1">  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
        </Root>  
  
' Create a clone of the tree.  
Dim treeClone As XElement = New XElement(xmlTree)  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone))  
  
' Do some work with xmlTree, perhaps pass it to other methods.  
xmlTree.Add(New XElement("Child3", 3))  
  
Console.WriteLine("xmlTree = treeClone: {0}", XNode.DeepEquals(xmlTree, treeClone))  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                xmlTree = treeClone: True  
xmlTree = treeClone: False  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> 要素の名前を格納しています。</param>
        <summary>指定した名前を使用して、<see cref="T:System.Xml.Linq.XElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは、内容と属性を持たない要素を作成します。  
  
 文字列からへの暗黙の変換が <xref:System.Xml.Linq.XName>です。 このコンス トラクターの一般的な用途は、新しいを作成する代わりにパラメーターとして文字列を指定する、 <xref:System.Xml.Linq.XName>です。 加算演算子オーバー ロードを使用する一般的な使用方法は、要素を名前空間を作成する場合、 <xref:System.Xml.Linq.XNamespace> および作成するための文字列、 <xref:System.Xml.Linq.XName>です。 詳細については、「[Working With Namespaces](http://msdn.microsoft.com/ja-jp/e3003209-3234-45be-a832-47feb7927430)」を参照してください。  
  
   
  
## 例  
 次の例では、内容を含まない要素を作成します。  
  
```csharp  
  
                XElement el = new XElement("Root");  
Console.WriteLine(el);  
```  
  
```vb  
  
                Dim el As XElement = <Root/>  
Console.WriteLine(el)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root />  
```  
  
 次の例では、内容のない名前空間に要素を作成します。 詳細については、「[Working With Namespaces](http://msdn.microsoft.com/ja-jp/e3003209-3234-45be-a832-47feb7927430)」を参照してください。  
  
```  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root");  
Console.WriteLine(root);  
```  
  
```vb  
  
                Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root = <Root/>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root xmlns="http://www.adventure-works.com" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XStreamingElement other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XStreamingElement other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XStreamingElement" />
      </Parameters>
      <Docs>
        <param name="other">
          <see cref="T:System.Xml.Linq.XStreamingElement" /> これの内容に対して反復処理されるが評価されていないクエリを含む <see cref="T:System.Xml.Linq.XElement" />します。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Xml.Linq.XElement" /> クラスからの <see cref="T:System.Xml.Linq.XStreamingElement" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは、指定した内容を反復処理 <xref:System.Xml.Linq.XStreamingElement>, 、およびその内容を持つ要素を作成します。  
  
   
  
## 例  
 次の例は、ソース XML ツリーを作成し、作成し、 <xref:System.Xml.Linq.XStreamingElement> ソース XML ツリーに対してクエリからです。 シリアル化し、 <xref:System.Xml.Linq.XStreamingElement> をコンソールには、ソースの XML ツリーに新しい要素を追加し、シリアル化し、 <xref:System.Xml.Linq.XStreamingElement> もう一度です。 ソース XML ツリーに新しく追加された要素は、最初のシリアル化に含まれていないが、もう 1 つに含まれることがわかります。  
  
```csharp  
  
                XElement src = new XElement("Root",  
                   new XElement("Child1", 1),  
                   new XElement("Child2", 2),  
                   new XElement("Child3", 3)  
               );  
XStreamingElement xse = new XStreamingElement("NewRoot",  
                            from el in src.Elements()  
                            where (int)el >= 2  
                            select el  
                        );  
Console.WriteLine(xse);  
src.Add(new XElement("Child4", 4));  
Console.WriteLine("----");  
Console.WriteLine(xse);  
```  
  
```vb  
  
                Dim src As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
        </Root>  
Dim xse As XStreamingElement = New XStreamingElement("NewRoot", _  
        From el In src.Elements() _  
        Where (CInt(el) >= 2) _  
        Select el _  
)  
Console.WriteLine(xse)  
src.Add(New XElement("Child4", 4))  
Console.WriteLine("----")  
Console.WriteLine(xse)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <NewRoot>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
</NewRoot>  
----  
<NewRoot>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XName name, object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> 要素名を含みます。</param>
        <param name="content">要素の内容。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Xml.Linq.XElement" /> 指定した名前と内容を持つクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは、指定されたコンテンツおよび属性を持つ要素を作成します。  
  
 文字列からへの暗黙の変換が <xref:System.Xml.Linq.XName>です。 このコンス トラクターの一般的な用途は、新しいを作成する代わりにパラメーターとして文字列を指定する、 <xref:System.Xml.Linq.XName>です。  
  
 加算演算子オーバー ロードを使用する一般的な使用方法は、要素を名前空間を作成する場合、 <xref:System.Xml.Linq.XNamespace> および作成するための文字列、 <xref:System.Xml.Linq.XName>です。 詳細については、「[Working With Namespaces](http://msdn.microsoft.com/ja-jp/e3003209-3234-45be-a832-47feb7927430)」を参照してください。  
  
 このコンス トラクターに渡すことができる有効なコンテンツに関する詳細については、「 [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/ja-jp/aee2d319-5c5f-4b99-9bb4-2f58232577ae)します。  
  
   
  
## 例  
 次の例では、XML ツリーを作成します。 新しい要素の内容は、LINQ クエリから取得されます。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim xmlTree2 As XElement = _  
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 次の例では、さまざまなコンテンツの種類の XML ツリーを作成します。  
  
```csharp  
  
                XElement root;  
  
// String content:  
root = new XElement("Root", "Some text");  
Console.WriteLine(root);  
  
// XElement object content:  
root = new XElement("Root",   
    new XElement("NewChild", "n")  
);  
Console.WriteLine(root);  
  
// XAttribute object content:  
root = new XElement("Root",   
    new XAttribute("NewAttribute", "n")  
);  
Console.WriteLine(root);  
  
// Double content:  
double dbl = 12.345;  
root = new XElement("Root", dbl);  
Console.WriteLine(root);  
  
// DateTime content:  
DateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);  
root = new XElement("Root", dt);  
Console.WriteLine(root);  
  
// String array content:  
// Any collection other than a collection of XElement or XAttribute objects  
// are converted to strings. The strings are concatenated and added.  
string[] stringArray = {  
    "abc",  
    "def",  
    "ghi"  
};  
root = new XElement("Root", stringArray);  
Console.WriteLine(root);  
  
// XElement object array content:  
XElement[] ellArray = {  
    new XElement("NewChild1", 1),  
    new XElement("NewChild2", 2),  
    new XElement("NewChild3", 3)  
};  
root = new XElement("Root", ellArray);  
Console.WriteLine(root);  
  
// XAttribute object array content:  
XAttribute[] attArray = {  
    new XAttribute("NewAtt1", 1),  
    new XAttribute("NewAtt2", 2),  
    new XAttribute("NewAtt3", 3)  
};  
root = new XElement("Root", attArray);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement  
  
' String content:  
root = <Root>Some text</Root>  
Console.WriteLine(root)  
  
' XElement object content:  
root = <Root>  
           <NewChild>n</NewChild>  
       </Root>  
Console.WriteLine(root)  
  
' XAttribute object content:  
root = <Root NewAttribute="n"/>  
Console.WriteLine(root)  
  
' Double content:  
Dim dbl As Double = 12.345  
root = <Root><%= dbl %></Root>  
Console.WriteLine(root)  
  
' DateTime content:  
Dim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)  
root = <Root><%= dt %></Root>  
Console.WriteLine(root)  
  
' String array content:  
' Any collection other than a collection of XElement or XAttribute objects  
' are converted to strings. The strings are concatenated and added.  
  
Dim stringArray As String() = { _  
    "abc", _  
    "def", _  
    "ghi" _  
}  
root = <Root><%= stringArray %></Root>  
Console.WriteLine(root)  
  
' XElement object array content:  
Dim ellArray As XElement() = { _  
    <NewChild1>1</NewChild1>, _  
    <NewChild2>2</NewChild2>, _  
    <NewChild3>3</NewChild3> _  
}  
  
root = <Root><%= ellArray %></Root>  
Console.WriteLine(root)  
  
' XAttribute object array content  
Dim attArray As XAttribute() = { _  
    New XAttribute("NewAtt1", 1), _  
    New XAttribute("NewAtt2", 2), _  
    New XAttribute("NewAtt3", 3) _  
}  
root = <Root><%= attArray %></Root>  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>Some text</Root>  
<Root>  
  <NewChild>n</NewChild>  
</Root>  
<Root NewAttribute="n" />  
<Root>12.345</Root>  
<Root>2006-10-06T12:30:00</Root>  
<Root>abcdefghi</Root>  
<Root>  
  <NewChild1>1</NewChild1>  
  <NewChild2>2</NewChild2>  
  <NewChild3>3</NewChild3>  
</Root>  
<Root NewAtt1="1" NewAtt2="2" NewAtt3="3" />  
```  
  
 次の例では、名前空間で XML ツリーを作成します。  
  
```csharp  
  
                // Create an XML tree in a namespace.  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XElement(aw + "Child", "child content")  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                ' Create an XML tree in a namespace.  
Dim root As XElement = _   
    <Root xmlns='http://www.adventure-works.com'>  
        <Child>child content</Child>  
    </Root>  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root xmlns="http://www.adventure-works.com">  
  <Child>child content</Child>  
</Root>  
```  
  
 次の例では、入れ子になった名前空間を持つ XML ツリーを作成します。  
  
```csharp  
  
                // Create an XML tree with nested namespaces.  
XNamespace aw = "http://www.adventure-works.com";  
XNamespace fc = "www.fourthcoffee.com";  
XDocument root = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XElement(aw + "Root",  
        new XElement(fc + "Child",  
            new XElement(aw + "DifferentChild", "other content")  
        )  
    )  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                ' Create an XML tree with nested namespaces.  
Dim root As XDocument = _   
    <?xml version='1.0'?>  
    <Root xmlns='http://www.adventure-works.com'>  
        <Child xmlns='www.fourthcoffee.com'>  
        <DifferentChild xmlns='http://www.adventure-works.com'>other content</DifferentChild>  
        </Child>  
    </Root>  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root xmlns="http://www.adventure-works.com">  
  <Child xmlns="www.fourthcoffee.com">  
    <DifferentChild xmlns="http://www.adventure-works.com">other content</DifferentChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XElement (System.Xml.Linq.XName name, object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> 要素名を含みます。</param>
        <param name="content">要素の初期コンテンツ。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Xml.Linq.XElement" /> 指定した名前と内容を持つクラス。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは、指定されたコンテンツおよび属性を持つ要素を作成します。  
  
 文字列からへの暗黙の変換が <xref:System.Xml.Linq.XName>です。 このコンス トラクターの一般的な用途は、新しいを作成する代わりにパラメーターとして文字列を指定する、 <xref:System.Xml.Linq.XName>です。  
  
 加算演算子オーバー ロードを使用する一般的な使用方法は、要素を名前空間を作成する場合、 <xref:System.Xml.Linq.XNamespace> および作成するための文字列、 <xref:System.Xml.Linq.XName>です。 詳細については、「[Working With Namespaces](http://msdn.microsoft.com/ja-jp/e3003209-3234-45be-a832-47feb7927430)」を参照してください。  
  
 このコンス トラクターに渡すことができる有効なコンテンツに関する詳細については、「 [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/ja-jp/aee2d319-5c5f-4b99-9bb4-2f58232577ae)します。  
  
   
  
## 例  
 次の例では、XML ツリーを作成します。 新しい要素の内容は、LINQ クエリから取得されます。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement xmlTree2 = new XElement("Root",  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(xmlTree2);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim xmlTree2 As XElement = _   
    <Root>  
        <%= From el In xmlTree1.Elements() _  
            Where el.Value >= 3 And el.Value <= 5 _  
            Select el %>  
    </Root>  
  
Console.WriteLine(xmlTree2)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 次の例では、さまざまなコンテンツの種類の XML ツリーを作成します。  
  
```csharp  
  
                XElement root;  
  
// String content:  
root = new XElement("Root", "Some text");  
Console.WriteLine(root);  
  
// XElement object content:  
root = new XElement("Root",   
    new XElement("NewChild", "n")  
);  
Console.WriteLine(root);  
  
// XAttribute object content:  
root = new XElement("Root",   
    new XAttribute("NewAttribute", "n")  
);  
Console.WriteLine(root);  
  
// Double content:  
double dbl = 12.345;  
root = new XElement("Root", dbl);  
Console.WriteLine(root);  
  
// DateTime content:  
DateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);  
root = new XElement("Root", dt);  
Console.WriteLine(root);  
  
// String array content:  
// Any collection other than a collection of XElement or XAttribute objects  
// are converted to strings. The strings are concatenated and added.  
string[] stringArray = {  
    "abc",  
    "def",  
    "ghi"  
};  
root = new XElement("Root", stringArray);  
Console.WriteLine(root);  
  
// XElement object array content:  
XElement[] ellArray = {  
    new XElement("NewChild1", 1),  
    new XElement("NewChild2", 2),  
    new XElement("NewChild3", 3)  
};  
root = new XElement("Root", ellArray);  
Console.WriteLine(root);  
  
// XAttribute object array content:  
XAttribute[] attArray = {  
    new XAttribute("NewAtt1", 1),  
    new XAttribute("NewAtt2", 2),  
    new XAttribute("NewAtt3", 3)  
};  
root = new XElement("Root", attArray);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement  
  
' String content:  
root = <Root>Some text</Root>  
Console.WriteLine(root)  
  
' XElement object content:  
root = <Root>  
           <NewChild>n</NewChild>  
       </Root>  
Console.WriteLine(root)  
  
' XAttribute object content:  
root = <Root NewAttribute="n"/>  
Console.WriteLine(root)  
  
' Double content:  
Dim dbl As Double = 12.345  
root = <Root><%= dbl %></Root>  
Console.WriteLine(root)  
  
' DateTime content:  
Dim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)  
root = <Root><%= dt %></Root>  
Console.WriteLine(root)  
  
' String array content:  
' Any collection other than a collection of XElement or XAttribute objects  
' are converted to strings. The strings are concatenated and added.  
  
Dim stringArray As String() = { _  
    "abc", _  
    "def", _  
    "ghi" _  
}  
root = <Root><%= stringArray %></Root>  
Console.WriteLine(root)  
  
' XElement object array content:  
Dim ellArray As XElement() = { _  
    <NewChild1>1</NewChild1>, _  
    <NewChild2>2</NewChild2>, _  
    <NewChild3>3</NewChild3> _  
}  
  
root = <Root><%= ellArray %></Root>  
Console.WriteLine(root)  
  
' XAttribute object array content  
Dim attArray As XAttribute() = { _  
    New XAttribute("NewAtt1", 1), _  
    New XAttribute("NewAtt2", 2), _  
    New XAttribute("NewAtt3", 3) _  
}  
root = <Root><%= attArray %></Root>  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>Some text</Root>  
<Root>  
  <NewChild>n</NewChild>  
</Root>  
<Root NewAttribute="n" />  
<Root>12.345</Root>  
<Root>2006-10-06T12:30:00</Root>  
<Root>abcdefghi</Root>  
<Root>  
  <NewChild1>1</NewChild1>  
  <NewChild2>2</NewChild2>  
  <NewChild3>3</NewChild3>  
</Root>  
<Root NewAtt1="1" NewAtt2="2" NewAtt3="3" />  
```  
  
 次の例では、名前空間で XML ツリーを作成します。  
  
```csharp  
  
                // Create an XML tree in a namespace.  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XElement(aw + "Child", "child content")  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                ' Create an XML tree in a namespace.  
Dim root As XElement = _   
    <Root xmlns='http://www.adventure-works.com'>  
        <Child>child content</Child>  
    </Root>  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root xmlns="http://www.adventure-works.com">  
  <Child>child content</Child>  
</Root>  
```  
  
 次の例では、入れ子になった名前空間を持つ XML ツリーを作成します。  
  
```csharp  
  
                // Create an XML tree with nested namespaces.  
XNamespace aw = "http://www.adventure-works.com";  
XNamespace fc = "www.fourthcoffee.com";  
XElement root = new XElement(aw + "Root",  
    new XElement(fc + "Child",  
        new XElement(aw + "DifferentChild", "other content")  
    )  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                ' Create an XML tree with nested namespaces.  
Dim root As XDocument = _   
    <?xml version='1.0'?>  
    <Root xmlns='http://www.adventure-works.com'>  
        <Child xmlns='www.fourthcoffee.com'>  
        <DifferentChild xmlns='http://www.adventure-works.com'>other content</DifferentChild>  
        </Child>  
    </Root>  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root xmlns="http://www.adventure-works.com">  
  <Child xmlns="www.fourthcoffee.com">  
    <DifferentChild xmlns="http://www.adventure-works.com">other content</DifferentChild>  
  </Child>  
</Root>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AncestorsAndSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素およびこの要素の先祖を格納している、要素のコレクションを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるコレクション内の要素は、ドキュメントの逆順になっています。  
  
 このメソッドは遅延実行を使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
      </Docs>
    </MemberGroup>
    <Member MemberName="AncestorsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; AncestorsAndSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; AncestorsAndSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.AncestorsAndSelf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素およびこの要素の先祖を格納している、要素のコレクションを返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の <see cref="T:System.Xml.Linq.XElement" /> およびこの要素の先祖がこの要素を含む要素です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるコレクション内の要素は、ドキュメントの逆順になっています。  
  
 このメソッドは遅延実行を使用します。  
  
   
  
## 例  
 次の例では、XML ツリーを作成します。 次を検索して、 `GrandChild` 要素、および、その先祖の印刷します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XElement("Child",  
        new XElement("GrandChild", "element content")  
    )  
);  
XElement gc = xmlTree.Element("Child").Element("GrandChild");  
IEnumerable<XElement> aas =  
    from el in gc.AncestorsAndSelf()  
    select el;  
foreach (XElement el in aas)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
  
                Dim xmlTree As XElement = _   
    <Root>  
        <Child>  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim GC As XElement = xmlTree.<Child>.<GrandChild>(0)  
  
Dim aas As IEnumerable(Of XElement) = _  
    From el In GC.AncestorsAndSelf() _  
    Select el  
  
For Each el In aas  
    Console.WriteLine(el.Name)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                GrandChild  
Child  
Root  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
      </Docs>
    </Member>
    <Member MemberName="AncestorsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; AncestorsAndSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; AncestorsAndSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">照合する <see cref="T:System.Xml.Linq.XName" />。</param>
        <summary>この要素およびこの要素の先祖を格納している、フィルター処理された要素のコレクションを返します。 一致する要素だけ <see cref="T:System.Xml.Linq.XName" /> 、コレクションに含まれます。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の <see cref="T:System.Xml.Linq.XElement" /> およびこの要素の先祖がこの要素が含まれています。 一致する要素だけ <see cref="T:System.Xml.Linq.XName" /> 、コレクションに含まれます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるコレクション内の要素は、ドキュメントの逆順になっています。  
  
 このメソッドは遅延実行を使用します。  
  
   
  
## 例  
 次の例は、これを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XElement("Child",  
        new XElement("GrandChild", "element content")  
    )  
);  
XElement gc = xmlTree.Element("Child").Element("GrandChild");  
IEnumerable<XElement> aas = gc.AncestorsAndSelf("Child");  
foreach (XElement el in aas)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
  
                Dim xmlTree As XElement = _   
    <Root>  
        <Child>  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim GC As XElement = xmlTree.<Child>.<GrandChild>(0)  
Dim aas As IEnumerable(Of XElement) = GC.AncestorsAndSelf("Child")  
For Each el In aas  
    Console.WriteLine(el.Name)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Child  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
      </Docs>
    </Member>
    <Member MemberName="Attribute">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute Attribute (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XAttribute Attribute(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> の <see cref="T:System.Xml.Linq.XAttribute" /> を取得します。</param>
        <summary>返します。、 <see cref="T:System.Xml.Linq.XAttribute" /> この <see cref="T:System.Xml.Linq.XElement" /> を持つ、指定した <see cref="T:System.Xml.Linq.XName" />します。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XAttribute" /> を持つ、指定した <see cref="T:System.Xml.Linq.XName" />; <see langword="null" /> 場合は、指定した名前の属性がありません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 いくつかは、要素または属性のコレクションを返します。 このメソッドは、1 つの属性のみを返します。 これとも呼ば、 *シングルトン* \(とは異なり、 *コレクション*\)。  
  
 Visual Basic の場合は、統合属性軸を使用して、指定した名前の属性の値を取得できます。  
  
   
  
## 例  
 次の例では、属性を持つ要素を作成します。 このメソッドを使用して属性を取得します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att", "attribute content")  
);  
XAttribute att = xmlTree.Attribute("Att");  
Console.WriteLine(att);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root Att="attribute content"/>  
  
Dim att As XAttribute = xmlTree.Attribute("Att")  
Console.WriteLine(att)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Att="attribute content"  
```  
  
 同じ例を次に示しますが、ここで XML 名前空間。 詳細については、「[Working With Namespaces](http://msdn.microsoft.com/ja-jp/e3003209-3234-45be-a832-47feb7927430)」を参照してください。  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XAttribute(aw + "Att", "attribute content")  
);  
XAttribute att = xmlTree.Attribute(aw + "Att");  
Console.WriteLine(att);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root aw:Att="attribute content"/>  
  
        Dim att As XAttribute = xmlTree.Attribute(GetXmlNamespace(aw) + "Att")  
        Console.WriteLine(att)  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
aw:Att="attribute content"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Attributes">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素の属性のコレクションを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt; Attributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XAttribute&gt; Attributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素の属性のコレクションを返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の <see cref="T:System.Xml.Linq.XAttribute" /> のこの要素の属性です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるコレクション内の属性は、要素に追加されたことになっています。 XML から XML ツリーを解析すると、ドキュメントの順序で、属性が返されます。  
  
 このメソッドは遅延実行を使用します。  
  
   
  
## 例  
 次の例では、2 つの属性を持つ要素を作成します。 使用して、この要素のすべての属性を取得します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "content1"),  
    new XAttribute("Att2", "content2")  
);  
IEnumerable<XAttribute> attList =  
    from at in xmlTree.Attributes()  
    select at;  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root Att1="content1" Att2="content2"/>  
  
Dim attList As IEnumerable(Of XAttribute) = _  
From at In xmlTree.Attributes() _  
Select at  
  
For Each att In attList  
    Console.WriteLine(att)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Att1="content1"  
Att2="content2"  
```  
  
 同じ例を次に示しますが、ここで XML 名前空間。 詳細については、「[Working With Namespaces](http://msdn.microsoft.com/ja-jp/e3003209-3234-45be-a832-47feb7927430)」を参照してください。  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(aw + "Att1", "content1"),  
    new XAttribute(aw + "Att2", "content2"),  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com")  
);  
IEnumerable<XAttribute> attList =  
    from at in xmlTree.Attributes()  
    select at;  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root aw:Att1="content1" aw:Att2="content2"/>  
  
        Dim attList As IEnumerable(Of XAttribute) = _  
            From at In xmlTree.Attributes() _  
            Select at  
  
        For Each att In attList  
            Console.WriteLine(att)  
        Next  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                aw:Att1="content1"  
aw:Att2="content2"  
xmlns:aw="http://www.adventure-works.com"  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.Elements" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt; Attributes (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XAttribute&gt; Attributes(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">照合する <see cref="T:System.Xml.Linq.XName" />。</param>
        <summary>この要素の属性のフィルター処理されたコレクションを返します。 一致する要素だけ <see cref="T:System.Xml.Linq.XName" /> 、コレクションに含まれます。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の <see cref="T:System.Xml.Linq.XAttribute" /> この要素の属性を格納しています。 一致する要素だけ <see cref="T:System.Xml.Linq.XName" /> 、コレクションに含まれます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 属性名は、要素内で一意である必要があります。 したがって、1 つだけの属性を含むコレクションが返されるまたは空のコレクションを返すことができます。  
  
 このメソッドは遅延実行を使用します。  
  
   
  
## 例  
 次の例は、これを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "content1"),  
    new XAttribute("Att2", "content2")  
);  
IEnumerable<XAttribute> attList = xmlTree.Attributes("Att1");  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root Att1="content1" Att2="content2"/>  
  
Dim attList As IEnumerable(Of XAttribute) = xmlTree.Attributes("Att1")  
  
For Each att In attList  
    Console.WriteLine(att)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Att1="content1"  
```  
  
 同じ例を次に示しますが、ここで XML 名前空間。 詳細については、「[Working With Namespaces](http://msdn.microsoft.com/ja-jp/e3003209-3234-45be-a832-47feb7927430)」を参照してください。  
  
```csharp  
  
                XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XAttribute(aw + "Att1", "content1"),  
    new XAttribute(aw + "Att2", "content2")  
);  
IEnumerable<XAttribute> attList = xmlTree.Attributes(aw + "Att1");  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root aw:Att1="content1" aw:Att2="content2"/>  
  
        Dim attList As IEnumerable(Of XAttribute) = xmlTree.Attributes(GetXmlNamespace(aw) + "Att1")  
  
        For Each att In attList  
            Console.WriteLine(att)  
        Next  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
aw:Att1="content1"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodesAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; DescendantNodesAndSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; DescendantNodesAndSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素およびこの要素のすべての子孫ノードをドキュメント順で格納している、ノードのコレクションを返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の <see cref="T:System.Xml.Linq.XNode" /> この要素およびこのドキュメントの順序でこの要素のすべての子孫ノードが含まれています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用します。  
  
   
  
## 例  
 次の例では、XML ツリーを作成し、これを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    // Attributes are not nodes, so will not be returned by DescendantNodesAndSelf.  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XNode> dnas =  
    from node in xmlTree.DescendantNodesAndSelf()  
    select node;  
foreach (XNode node in dnas)  
{  
    if (node is XElement)  
        Console.WriteLine((node as XElement).Name);  
    else  
        Console.WriteLine(node);  
}  
```  
  
```vb  
  
                Dim xmlTree As XElement = _  
    <Root Att1="AttributeContent">  
        <Child>Some text<GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim dnas As IEnumerable(Of XNode) = _  
    From node In xmlTree.DescendantNodesAndSelf() _  
    Select node  
  
For Each node In dnas  
    If TypeOf node Is XElement Then  
        Console.WriteLine(DirectCast(node, XElement).Name)  
    Else  
        Console.WriteLine(node)  
    End If  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Root  
Child  
Some text  
GrandChild  
element content  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DescendantsAndSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素およびこの要素のすべての子孫要素をドキュメント順で格納している、要素のコレクションを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method uses deferred execution.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DescendantsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; DescendantsAndSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; DescendantsAndSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素およびこの要素のすべての子孫要素をドキュメント順で格納している、要素のコレクションを返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の <see cref="T:System.Xml.Linq.XElement" /> のドキュメントの順序でこの要素のすべての子孫要素および要素のこの要素が含まれています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用します。  
  
   
  
## 例  
 次の例では、XML ツリーを作成し、これを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> das =  
    from el in xmlTree.DescendantsAndSelf()  
    select el;  
foreach (XElement el in das)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
  
                Dim xmlTree As XElement = _  
    <Root Att1="AttributeContent">  
        <Child>Some text  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim das As IEnumerable(Of XElement) = _  
    From el In xmlTree.DescendantsAndSelf() _  
    Select el  
  
For Each el In das  
    Console.WriteLine(el.Name)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Root  
Child  
GrandChild  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantsAndSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; DescendantsAndSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; DescendantsAndSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">照合する <see cref="T:System.Xml.Linq.XName" />。</param>
        <summary>この要素およびこの要素のすべての子孫要素をドキュメント順で格納している、フィルター処理された要素のコレクションを返します。 一致する要素だけ <see cref="T:System.Xml.Linq.XName" /> 、コレクションに含まれます。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の <see cref="T:System.Xml.Linq.XElement" /> この要素およびこのドキュメントの順序でこの要素のすべての子孫要素が含まれています。 一致する要素だけ <see cref="T:System.Xml.Linq.XName" /> 、コレクションに含まれます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用します。  
  
   
  
## 例  
 次の例では、XML ツリーを作成し、これを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> das = xmlTree.DescendantsAndSelf("Child");  
foreach (XElement el in das)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
  
                Dim xmlTree As XElement = _  
    <Root Att1="AttributeContent">  
        <Child>Some text  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim das As IEnumerable(Of XElement) = xmlTree.DescendantsAndSelf("Child")  
  
For Each el In das  
    Console.WriteLine(el.Name)  
Next  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Child  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptySequence">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; EmptySequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; EmptySequence" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.EmptySequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の空のコレクションを取得します。</summary>
        <value>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の <see cref="T:System.Xml.Linq.XElement" /> 空のコレクションを格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは要素のコレクションを返すメソッドを記述するときにクラスの実装によって通常使用されます。 このプロパティを使用して、空のコレクションを取得する場合は、メソッドは要素を返すことがない必要があります、その <xref:System.Xml.Linq.XElement> オブジェクトです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute FirstAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XAttribute FirstAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.FirstAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の最初の属性を取得します。</summary>
        <value>
          <see cref="T:System.Xml.Linq.XAttribute" /> この要素の最初の属性を格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 属性は、要素に追加された順序で要素に格納されます。  
  
   
  
## 例  
 次の例では、このプロパティを使用します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
Console.WriteLine(xmlTree.FirstAttribute);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
Console.WriteLine(xmlTree.FirstAttribute)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Att1="1"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultNamespace">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNamespace GetDefaultNamespace ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XNamespace GetDefaultNamespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.GetDefaultNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定値を取得 <see cref="T:System.Xml.Linq.XNamespace" /> この <see cref="T:System.Xml.Linq.XElement" />します。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XNamespace" /> この既定の名前空間を含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 名前空間の宣言は、XML ツリー内の属性として永続化します。 これらの特別な属性では、既定の名前空間を含む、名前空間を宣言します。 このメソッドは、1 つを使用する必要がある場合は、既定の名前空間を宣言する名前空間宣言を検索し、返します、 <xref:System.Xml.Linq.XNamespace> の既定の名前空間。  
  
 既定の名前空間を宣言する属性がないかどうかは、このメソッドが戻る <xref:System.Xml.Linq.XNamespace.None%2A?displayProperty=fullName>します。  
  
 C\# を使用して XML ツリーを作成する場合でも、XML ツリーはシリアル化する既定の名前空間、名前空間が属性として XML ツリーに永続化しない場合、このメソッドは、名前空間を既定の名前空間として報告されません。  
  
 Visual Basic および XML リテラルを使用した XML ツリーを作成するには、Imports ステートメントを使用して、既定の名前空間で XML を作成する場合、し、名前空間の属性が作成、ツリーで、Visual Basic コンパイラによってされこのメソッドはその名前空間を報告します。  
  
   
  
## 例  
 次の例では、既定の名前空間を持つ XML ツリーを作成します。 このメソッドを使用して、既定の名前空間を取得します。  
  
```csharp  
  
                String xml = "<root xmlns='http://www.adventure-works.com'/>";  
XElement e = XElement.Parse(xml);  
Console.WriteLine("Default namespace: {0}", e.GetDefaultNamespace());  
```  
  
```vb  
  
                Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim e As XElement = <root/>  
        Console.WriteLine("Default namespace: {0}", e.GetDefaultNamespace())  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Default namespace: http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamespaceOfPrefix">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNamespace GetNamespaceOfPrefix (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XNamespace GetNamespaceOfPrefix(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">検索対象の名前空間プレフィックスを格納している文字列。</param>
        <summary>この特定のプレフィックスに関連付けられている名前空間を取得 <see cref="T:System.Xml.Linq.XElement" />します。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XNamespace" /> このプレフィックスに関連付けられている名前空間の <see cref="T:System.Xml.Linq.XElement" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、この要素のスコープ内の名前空間の属性の XML ツリーを検索します。 名前空間プレフィックスは、XML ツリー内にある名前空間属性で指定されます。  
  
   
  
## 例  
 次の例では、関連付けられているプレフィックスを持つ名前空間を持つ XML ツリーを作成します。 取得し、このメソッドを使用して、 <xref:System.Xml.Linq.XNamespace> のプリフィックス。  
  
```csharp  
  
                XElement xmlTree = XElement.Parse("<Root xmlns:aw='http://www.adventure-works.com'/>");  
XNamespace awNamespace = xmlTree.GetNamespaceOfPrefix("aw");  
Console.WriteLine("Namespace: {0}", awNamespace);  
```  
  
 Visual Basic を使用する場合は通常使用する、 [GetXmlNamespace](http://msdn.microsoft.com/ja-jp/d0d28cfd-0755-4896-ae0b-4981aa35517c) 演算子は、次のように  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root/>  
        Dim awNamespace As XNamespace = GetXmlNamespace(aw)  
        Console.WriteLine("Namespace: {0}", awNamespace)  
    End Sub  
End Module  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Namespace: http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrefixOfNamespace">
      <MemberSignature Language="C#" Value="public string GetPrefixOfNamespace (System.Xml.Linq.XNamespace ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPrefixOfNamespace(class System.Xml.Linq.XNamespace ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ns" Type="System.Xml.Linq.XNamespace" />
      </Parameters>
      <Docs>
        <param name="ns">
          <see cref="T:System.Xml.Linq.XNamespace" /> を検索します。</param>
        <summary>この名前空間に関連付けられたプリフィックスを取得 <see cref="T:System.Xml.Linq.XElement" />します。</summary>
        <returns>A <see cref="T:System.String" /> 名前空間プレフィックスを格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、この要素のスコープ内の名前空間の属性の XML ツリーを検索します。 名前空間プレフィックスは、XML ツリー内にある名前空間属性で指定されます。  
  
 名前空間は、既定の名前空間、名前空間のプレフィックスがない場合は、このメソッドは null を返します。  
  
   
  
## 例  
 次の例では、プレフィックスを持つ名前空間を含む XML ツリーを作成します。 このメソッドを使用して、名前空間のプレフィックスを取得します。 この例には、文字列からへの暗黙的な変換が使用されて <xref:System.Xml.Linq.XNamespace> このメソッドを呼び出すとします。  
  
```csharp  
  
                XElement xmlTree = XElement.Parse("<Root xmlns:aw='http://www.adventure-works.com'/>");  
string prefix = xmlTree.GetPrefixOfNamespace("http://www.adventure-works.com");  
Console.WriteLine("Prefix: {0}", prefix);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = <aw:Root/>  
        Dim prefix As String = xmlTree.GetPrefixOfNamespace("http://www.adventure-works.com")  
        Console.WriteLine("Prefix: {0}", prefix)  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Prefix: aw  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が 1 つ以上の属性を持っているかどうかを示す値を取得します。</summary>
        <value>この要素が 1 つ以上の属性を持っている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 The following example uses this property.  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XAttribute("Att1", 1)  
);  
Console.WriteLine(xmlTree1.HasAttributes);  
XElement xmlTree2 = new XElement("Root");  
Console.WriteLine(xmlTree2.HasAttributes);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = <Root Att1="1"/>  
Console.WriteLine(xmlTree1.HasAttributes)  
  
Dim xmlTree2 As XElement = <Root/>  
Console.WriteLine(xmlTree2.HasAttributes)  
  
```  
  
 This example produces the following output:  
  
```  
True  
False  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElements">
      <MemberSignature Language="C#" Value="public bool HasElements { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElements" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.HasElements" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が 1 つ以上の子要素を持っているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素には、少なくとも 1 つの子要素がある場合それ以外の場合 <see langword="false" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例では、このプロパティを使用します。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child", 1)  
);  
Console.WriteLine(xmlTree1.HasElements);  
XElement xmlTree2 = new XElement("Root", "contents");  
Console.WriteLine(xmlTree2.HasElements);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child>1</Child>  
        </Root>  
Console.WriteLine(xmlTree1.HasElements)  
  
Dim xmlTree2 As XElement = <Root>contents</Root>  
Console.WriteLine(xmlTree2.HasElements)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                True  
False  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に内容が格納されていないかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> この要素にコンテンツが含まれていない場合それ以外の場合 <see langword="false" />します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タグの間のコンテンツなしで開始と終了タグを含む要素が空の要素であると見なされませんことに注意してください。 長さのコンテンツがありません。 開始タグのみを含み、空の終了要素として表される要素だけを空にすると見なされます。  
  
   
  
## 例  
 次の例では、さまざまな XML ツリーを作成し、各ツリーには、このプロパティの値を示しています。  
  
```csharp  
  
                XElement el1 = new XElement("Root");  
Console.WriteLine(el1);  
Console.WriteLine(el1.IsEmpty);  
Console.WriteLine();  
XElement el2 = new XElement("Root", "content");  
Console.WriteLine(el2);  
Console.WriteLine(el2.IsEmpty);  
Console.WriteLine();  
XElement el3 = new XElement("Root", "");  
Console.WriteLine(el3);  
Console.WriteLine(el3.IsEmpty);  
Console.WriteLine();  
el3.ReplaceAll(null);  
Console.WriteLine(el3);  
Console.WriteLine(el3.IsEmpty);  
```  
  
```vb  
  
                Dim el1 As XElement = <Root/>  
Console.WriteLine(el1)  
Console.WriteLine(el1.IsEmpty)  
Console.WriteLine()  
Dim el2 As XElement = <Root>content</Root>  
Console.WriteLine(el2)  
Console.WriteLine(el2.IsEmpty)  
Console.WriteLine()  
Dim el3 As XElement = <Root></Root>  
Console.WriteLine(el3)  
Console.WriteLine(el3.IsEmpty)  
Console.WriteLine()  
el3.ReplaceAll(Nothing)  
Console.WriteLine(el3)  
Console.WriteLine(el3.IsEmpty)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root />  
True  
  
<Root>content</Root>  
False  
  
<Root></Root>  
False  
  
<Root />  
True  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute LastAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XAttribute LastAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.LastAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の最後の属性を取得します。</summary>
        <value>
          <see cref="T:System.Xml.Linq.XAttribute" /> この要素の最後の属性を格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 属性は、要素に追加された順序で要素に格納されます。  
  
   
  
## 例  
 次の例では、次の 3 つの属性を持つ XML ツリーを作成します。 これは、後の出力として最後に属性を書き込みます。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
Console.WriteLine(xmlTree.LastAttribute);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
Console.WriteLine(xmlTree.LastAttribute)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Att3="3"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新たに作成 <see cref="T:System.Xml.Linq.XElement" /> から、URI で指定したファイル、 <see cref="T:System.IO.TextReader" />, 、または、 <see cref="T:System.Xml.XmlReader" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドのオーバー ロードのいずれか、読み込みに使用できる、 <xref:System.Xml.Linq.XElement> ファイルから、 <xref:System.IO.TextReader>, 、または <xref:System.Xml.XmlReader>です。  
  
 作成する、 <xref:System.Xml.Linq.XElement> から XML を含む文字列を使用して <xref:System.Xml.Linq.XElement.Parse%2A>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XElement.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">XML データを格納しているストリーム。</param>
        <summary>新たに作成 <see cref="T:System.Xml.Linq.XElement" /> 指定のストリームを使用してインスタンス。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" /> オブジェクトのストリームに含まれているデータを読み取るために使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 読み込みオプションを制御する場合は、使用、 <xref:System.Xml.Linq.XElement.Load%2A> を受け取るオーバー ロード <xref:System.Xml.Linq.LoadOptions> をパラメーターとして。  
  
 XML の読み込み機能への LINQ の基盤となって <xref:System.Xml.XmlReader>します。 によってスローされる例外をキャッチするため、 <xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName> メソッドをオーバー ロードと <xref:System.Xml.XmlReader> メソッドで読み取りおよびドキュメントを解析します。  
  
 変更する必要がある場合 <xref:System.Xml.XmlReaderSettings>, 、以下の手順。  
  
1.  作成、 <xref:System.Xml.XmlReader> のいずれかを呼び出して、 <xref:System.Xml.XmlReader.Create%2A> を受け取るオーバー ロード <xref:System.Xml.XmlReaderSettings> をパラメーターとして。  
  
2.  渡す、 <xref:System.Xml.XmlReader> のいずれかに、 <xref:System.Xml.Linq.XElement>の <xref:System.Xml.Linq.XElement.Load%2A> を取るオーバー ロード <xref:System.Xml.XmlReader> をパラメーターとして。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.TextReader textReader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.TextReader textReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="textReader">A <see cref="T:System.IO.TextReader" /> として読み込む、 <see cref="T:System.Xml.Linq.XElement" /> コンテンツです。</param>
        <summary>読み込み、 <see cref="T:System.Xml.Linq.XElement" /> から、 <see cref="T:System.IO.TextReader" />です。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" /> 読み取られた XML を格納している指定された対象から <see cref="T:System.IO.TextReader" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、XML ツリーに生の XML を読み取ります。 ファイル内のすべての余分な空白を破棄します。  
  
 XML の読み込み機能への LINQ の基盤となって <xref:System.Xml.XmlReader>します。 によってスローされる例外をキャッチするため、 <xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName> メソッドをオーバー ロードと <xref:System.Xml.XmlReader> メソッドで読み取りおよびドキュメントを解析します。  
  
   
  
## 例  
 要素を読み込む例を次の <xref:System.IO.StringReader>です。  
  
```csharp  
  
                TextReader sr = new StringReader("<Root><Child/></Root>");  
XElement xmlTree = XElement.Load(sr);  
sr.Close();  
Console.WriteLine(xmlTree);  
```  
  
```vb  
  
                Dim sr As TextReader = New StringReader("<Root><Child/></Root>")  
Dim xmlTree As XElement = XElement.Load(sr)  
sr.Close()  
Console.WriteLine(xmlTree)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child />  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">新しいに読み込むファイルを参照している URI 文字列 <see cref="T:System.Xml.Linq.XElement" />します。</param>
        <summary>読み込み、 <see cref="T:System.Xml.Linq.XElement" /> ファイルからです。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" /> 指定されたファイルの内容を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、XML ツリーに生の XML を読み取ります。 ファイル内のすべての余分な空白を破棄します。  
  
 XML の読み込み機能への LINQ の基盤となって <xref:System.Xml.XmlReader>します。 によってスローされる例外をキャッチするため、 <xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName> メソッドをオーバー ロードと <xref:System.Xml.XmlReader> メソッドで読み取りおよびドキュメントを解析します。  
  
   
  
## 例  
 次の例は、XML ツリーを作成して、ファイルに保存し、このメソッドを使用して、ロード、 <xref:System.Xml.Linq.XElement> ファイルからです。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child", "content")  
);  
xmlTree1.Save("Tree.xml");  
  
XElement xmlTree2 = XElement.Load("Tree.xml");  
Console.WriteLine(xmlTree2.Name);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child>Content</Child>  
        </Root>  
xmlTree1.Save("Tree.xml")  
  
Dim xmlTree2 As XElement = XElement.Load("Tree.xml")  
Console.WriteLine(xmlTree2.Name)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Root  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XElement.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Xml.XmlReader" /> のコンテンツを読み込む、 <see cref="T:System.Xml.Linq.XElement" />です。</param>
        <summary>読み込み、 <see cref="T:System.Xml.Linq.XElement" /> から、 <see cref="T:System.Xml.XmlReader" />です。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" /> 読み取られた XML を格納している指定された対象から <see cref="T:System.Xml.XmlReader" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 作成することで、 <xref:System.Xml.XmlNodeReader> DOM ドキュメントとを使用してから、 <xref:System.Xml.XmlNodeReader> を作成する、 <xref:System.Xml.Linq.XElement>, 、LINQ to XML ツリーに DOM ドキュメントのコピーを作成するこのメソッドを使用できます。  
  
 XML の読み込み機能への LINQ の基盤となって <xref:System.Xml.XmlReader>します。 によってスローされる例外をキャッチするため、 <xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName> メソッドをオーバー ロードと <xref:System.Xml.XmlReader> メソッドで読み取りおよびドキュメントを解析します。  
  
   
  
## 例  
 次の例は、DOM のドキュメントを作成、作成、 <xref:System.Xml.XmlNodeReader> DOM ドキュメントから、リーダーからツリーをインスタンス化します。 このコードは、DOM のドキュメントを LINQ に、XML ツリーを効果的にコピーします。  
  
```csharp  
// Create a DOM document with some content.  
XmlDocument doc = new XmlDocument();  
XmlElement child = doc.CreateElement("Child");  
child.InnerText = "child contents";  
XmlElement root = doc.CreateElement("Root");  
root.AppendChild(child);  
doc.AppendChild(root);  
  
// Create a reader and move to the content.  
using (XmlNodeReader nodeReader = new XmlNodeReader(doc)) {  
    // the reader must be in the Interactive state in order to  
    // Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XElement xRoot = XElement.Load(nodeReader);  
    Console.WriteLine(xRoot);  
}  
```  
  
```vb  
' Create a DOM document with some content.  
Dim doc As XmlDocument = New XmlDocument()  
Dim child As XmlElement = doc.CreateElement("Child")  
child.InnerText = "child contents"  
Dim root As XmlElement = doc.CreateElement("Root")  
root.AppendChild(child)  
doc.AppendChild(root)  
  
' Create a reader and move to the content.  
Using nodeReader = New XmlNodeReader(doc)  
    ' the reader must be in the Interactive state in order to  
    ' Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XElement = XElement.Load(nodeReader)  
    Console.WriteLine(xRoot)  
End Using  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child>child contents</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.Stream stream, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="stream">XML データが含まれるストリーム。</param>
        <param name="options">A <see cref="T:System.Xml.Linq.LoadOptions" /> ベース URI と行情報を読み込むかどうかを指定するオブジェクト。</param>
        <summary>新たに作成 <see cref="T:System.Xml.Linq.XElement" /> インスタンスで指定されたストリームを使用して、必要に応じて空白の維持、ベース URI の設定および行情報を保持します。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" /> オブジェクトのストリームに含まれるデータを読み取るために使用します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 XML の読み込み機能への LINQ の基盤となって <xref:System.Xml.XmlReader>します。 によってスローされる例外をキャッチするため、 <xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName> メソッドをオーバー ロードと <xref:System.Xml.XmlReader> メソッドで読み取りおよびドキュメントを解析します。  
  
 変更する必要がある場合 <xref:System.Xml.XmlReaderSettings>, 、以下の手順。  
  
1.  作成、 <xref:System.Xml.XmlReader> のいずれかを呼び出して、 <xref:System.Xml.XmlReader.Create%2A> を受け取るオーバー ロード <xref:System.Xml.XmlReaderSettings> をパラメーターとして。  
  
2.  渡す、 <xref:System.Xml.XmlReader> のいずれかに、 <xref:System.Xml.Linq.XElement>の <xref:System.Xml.Linq.XElement.Load%2A> を取るオーバー ロード <xref:System.Xml.XmlReader> をパラメーターとして。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="textReader">A <see cref="T:System.IO.TextReader" /> として読み込む、 <see cref="T:System.Xml.Linq.XElement" /> コンテンツです。</param>
        <param name="options">A <see cref="T:System.Xml.Linq.LoadOptions" /> 空白の動作、およびベース URI と行情報を読み込むかどうかを指定します。</param>
        <summary>読み込み、 <see cref="T:System.Xml.Linq.XElement" /> から、 <see cref="T:System.IO.TextReader" />, 、必要に応じて空白の維持および行情報の保持を行います。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" /> 読み取られた XML を格納している指定された対象から <see cref="T:System.IO.TextReader" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定する場合は、元の XML はインデントは、 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> フラグ `options` により、ソース XML 内のすべての空白文字を読み取るリーダー。 型のノード <xref:System.Xml.Linq.XText> 両方は、有意の空白文字が作成されます。  
  
 設定しない場合は、元の XML はインデントは、 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> フラグ `options` ソース XML の余分な空白をすべて無視するリーダーを発生します。 意味のない空白のテキスト ノードなしは、XML ツリーが作成されます。  
  
 ソース XML がインデント付きでない場合、 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> フラグ `options` も何も起こりません。 有意の空白は維持され、詳細の空白文字のテキスト ノードの作成を引き起こす可能性のある有意の空白文字の範囲はありません。  
  
 詳細については、[Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/ja-jp/093a7169-a04e-4638-b08c-d1cb98aa650d) および [Preserving White Space While Serializing](http://msdn.microsoft.com/ja-jp/fb146217-0a49-4efc-ac84-7265b91d3939) を参照してください。  
  
 使用 <xref:System.Xml.Linq.XElement.Parse%2A> を作成する、 <xref:System.Xml.Linq.XElement> XML を含む文字列から。  
  
 設定 <xref:System.Xml.Linq.LoadOptions.SetBaseUri> 効果はありませんから読み込むときに、 <xref:System.IO.TextReader>です。  
  
 設定した場合は、パフォーマンスの低下、 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> フラグ。  
  
 行の情報は、XML ドキュメントの読み込み直後に正確です。 ドキュメントの読み込み後、XML ツリーを変更する場合は、行の情報が無意味になる可能性があります。  
  
 XML の読み込み機能への LINQ の基盤となって <xref:System.Xml.XmlReader>します。 によってスローされる例外をキャッチするため、 <xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName> メソッドをオーバー ロードと <xref:System.Xml.XmlReader> メソッドで読み取りおよびドキュメントを解析します。  
  
   
  
## 例  
 次の例では、ロード、 <xref:System.Xml.Linq.XElement> から、 <xref:System.IO.StringReader> 2 つの方法で: 空白、および空白を保持しません。 クエリを使用して、結果として得られる XML ツリー内の空白ノードの数を決定します。  
  
```csharp  
  
                TextReader sr;  
int whiteSpaceNodes;  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XElement xmlTree1 = XElement.Load(sr, LoadOptions.None);  
sr.Close();  
whiteSpaceNodes = xmlTree1  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes);  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XElement xmlTree2 = XElement.Load(sr, LoadOptions.PreserveWhitespace);  
sr.Close();  
whiteSpaceNodes = xmlTree2  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes);  
```  
  
```vb  
  
                Dim sr As TextReader  
Dim whiteSpaceNodes As Integer  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree1 As XElement = XElement.Load(sr, LoadOptions.None)  
sr.Close()  
whiteSpaceNodes = xmlTree1 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree2 As XElement = XElement.Load(sr, LoadOptions.PreserveWhitespace)  
sr.Close()  
whiteSpaceNodes = xmlTree2 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 次の例から読み込むように行情報を読み込みます、 <xref:System.IO.TextReader>です。 行の情報が印刷されます。  
  
```csharp  
  
                TextReader sr = new StringReader(  
@"<Root>  
  <Child>  
    <GrandChild1/>  
    <GrandChild2/>  
  </Child>  
</Root>");  
XElement po = XElement.Load(sr,  
    LoadOptions.SetLineInfo);  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in po.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
        ((IXmlLineInfo)e).LinePosition);  
```  
  
```vb  
  
                Dim sr As TextReader = New StringReader( _  
    "<Root>" & Environment.NewLine & _  
    "  <Child>" & Environment.NewLine & _  
    "    <GrandChild1/>" & Environment.NewLine & _  
    "    <GrandChild2/>" & Environment.NewLine & _  
    "  </Child>" & Environment.NewLine & _  
    "</Root>")  
Dim po As XElement = XElement.Load(sr, LoadOptions.SetLineInfo)  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In po.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
        (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
        (DirectCast(e, IXmlLineInfo)).LinePosition)  
Next  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    4  
    GrandChild1     3    6  
    GrandChild2     4    6  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (string uri, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(string uri, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="uri">読み込むファイルを参照する URI 文字列、<see cref="T:System.Xml.Linq.XElement" />です。</param>
        <param name="options">A<see cref="T:System.Xml.Linq.LoadOptions" />空白に関する動作、およびベース URI および行情報を読み込むかどうかを指定します。</param>
        <summary>読み込み、<see cref="T:System.Xml.Linq.XElement" />ファイルから、必要に応じて空白を保持する、ベース URI を設定および保持行情報。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" />指定されたファイルの内容を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ソース XML がインデントを設定できない場合は、設定、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>にフラグが設定`options`により、ソース XML 内のすべての空白文字を読み取るリーダー。 型のノード<xref:System.Xml.Linq.XText>両方は、有意の空白スペースを作成します。  
  
 設定しない場合は、ソース XML では、インデント、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>にフラグが設定`options`ソース XML で意味のない空白をすべて無視するリーダーをによりします。 意味のない空白のテキスト ノードなしは、XML ツリーが作成されます。  
  
 XML ソースがインデントを設定できない場合は、設定、<xref:System.Xml.Linq.LoadOptions.PreserveWhitespace>フラグ`options`も何も起こりません。 有意の空白は維持され、全体にわたる複数の空白テキスト ノードの作成を引き起こす可能性のある意味のない空白はありません。  
  
 詳細については、[Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/ja-jp/093a7169-a04e-4638-b08c-d1cb98aa650d) および [Preserving White Space While Serializing](http://msdn.microsoft.com/ja-jp/fb146217-0a49-4efc-ac84-7265b91d3939) を参照してください。  
  
 使用する<xref:System.Xml.Linq.XElement.Parse%2A>作成する、 <xref:System.Xml.Linq.XElement> XML を表す文字列から。  
  
 設定した場合は、パフォーマンスの低下、<xref:System.Xml.Linq.LoadOptions.SetBaseUri>と<xref:System.Xml.Linq.LoadOptions.SetLineInfo>フラグ。  
  
 ベース URI と行の情報は XML ドキュメントの読み込み後すぐに正確です。 ドキュメントの読み込み後、XML ツリーを変更する場合は、ベース URI および行の情報が無意味になる可能性があります。  
  
 XML の読み込み機能への LINQ の基盤となって<xref:System.Xml.XmlReader>です。 によってスローされる例外をキャッチするため、<xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName>メソッドをオーバー ロードおよび<xref:System.Xml.XmlReader>読み取り、ドキュメントを解析するメソッド。  
  
   
  
## 例  
 次の例、 <xref:System.Xml.Linq.XElement> 2 つの異なる方法でファイルから: 空白を保持して、空白を保持しません。 クエリを使用して、結果として得られる XML ツリー内の空白ノードの数を決定します。  
  
```csharp  
  
                XElement xmlTree1 = XElement.Parse("<Root> <Child>  </Child> </Root>", LoadOptions.PreserveWhitespace);  
xmlTree1.Save("Tree.xml");  
Console.WriteLine(xmlTree1);  
  
int whiteSpaceNodes;  
XElement xmlTree2 = XElement.Load("Tree.xml",  
    LoadOptions.None);  
whiteSpaceNodes = xmlTree2  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes);  
  
XElement xmlTree3 = XElement.Load("Tree.xml",  
    LoadOptions.PreserveWhitespace);  
whiteSpaceNodes = xmlTree3  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = XElement.Parse("<Root> <Child>  </Child> </Root>", LoadOptions.PreserveWhitespace)  
xmlTree1.Save("Tree.xml")  
Console.WriteLine(xmlTree1)  
  
Dim whiteSpaceNodes As Integer  
Dim xmlTree2 As XElement = XElement.Load("Tree.xml", LoadOptions.None)  
whiteSpaceNodes = xmlTree2 _  
                  .DescendantNodesAndSelf() _  
                  .OfType(Of XText)() _  
                  .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
                  .Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
Dim xmlTree3 As XElement = XElement.Load("Tree.xml", LoadOptions.PreserveWhitespace)  
whiteSpaceNodes = xmlTree3 _  
                  .DescendantNodesAndSelf() _  
                  .OfType(Of XText)() _  
                  .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
                  .Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root> <Child>  </Child> </Root>  
Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 次の例は、ファイルが読み込まれるベース URI および行の情報を読み込みます。 ベース URI と行の情報を出力します。  
  
 この例では次のリソース ファイル:[Sample XML File: Typical Purchase Order \(LINQ to XML\)](http://msdn.microsoft.com/ja-jp/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)です。  
  
```csharp  
  
                XElement po = XElement.Load("PurchaseOrder.xml",  
    LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);  
string[] splitUri = po.BaseUri.Split('/');  
Console.WriteLine("BaseUri: {0}", splitUri[splitUri.Length - 1]);  
Console.WriteLine();  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in po.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
        ((IXmlLineInfo)e).LinePosition);  
```  
  
```vb  
  
        Dim po As XElement = XElement.Load("PurchaseOrder.xml", LoadOptions.SetBaseUri Or LoadOptions.SetLineInfo)  
Dim splitUri() As String = po.BaseUri.Split("/")  
Console.WriteLine("BaseUri: {0}", splitUri(splitUri.Length - 1))  
Console.WriteLine()  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In po.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString()).PadRight(20), _  
        (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
        (DirectCast(e, IXmlLineInfo)).LinePosition)  
Next  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                BaseUri: PurchaseOrder.xml  
  
Element Name        Line Position  
------------        ---- --------  
PurchaseOrder       2    2  
  Address           3    4  
    Name            4    6  
    Street          5    6  
    City            6    6  
    State           7    6  
    Zip             8    6  
    Country         9    6  
  Address           11   4  
    Name            12   6  
    Street          13   6  
    City            14   6  
    State           15   6  
    Zip             16   6  
    Country         17   6  
  DeliveryNotes     19   4  
  Items             20   4  
    Item            21   6  
      ProductName   22   8  
      Quantity      23   8  
      USPrice       24   8  
      Comment       25   8  
    Item            27   6  
      ProductName   28   8  
      Quantity      29   8  
      USPrice       30   8  
      ShipDate      31   8  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Load (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Load(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Xml.XmlReader" /> のコンテンツを読み込む、 <see cref="T:System.Xml.Linq.XElement" />です。</param>
        <param name="options">A <see cref="T:System.Xml.Linq.LoadOptions" /> 空白の動作、およびベース URI と行情報を読み込むかどうかを指定します。</param>
        <summary>読み込み、 <see cref="T:System.Xml.Linq.XElement" /> から、 <see cref="T:System.Xml.XmlReader" />, 、必要に応じて空白の維持、ベース URI の設定および行情報を保持します。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" /> 読み取られた XML を格納している指定された対象から <see cref="T:System.Xml.XmlReader" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 作成することで、 <xref:System.Xml.XmlNodeReader> DOM ドキュメントとを使用してから、 <xref:System.Xml.XmlNodeReader> を作成する、 <xref:System.Xml.Linq.XElement>, 、LINQ to XML ツリーに DOM ドキュメントのコピーを作成するこのメソッドを使用できます。  
  
 使用 <xref:System.Xml.Linq.XElement.Parse%2A> を作成する、 <xref:System.Xml.Linq.XElement> XML を含む文字列から。  
  
 設定 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> からの読み込み時に、無効、 <xref:System.Xml.XmlReader>です。<xref:System.Xml.XmlReader> か、読み取りの空白に構成されます。 空白ノードを表示する LINQ to XML ツリーをリーダー サーフェスです。 かどうかに関係なく動作になります <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 設定されているか。  
  
 <xref:System.Xml.XmlReader> か、有効な基本 URI を持つことがあります。 設定した場合 <xref:System.Xml.Linq.LoadOptions.SetBaseUri>, 、ベース URI は、によって報告されるベース URI から XML ツリーに設定されます、 <xref:System.Xml.XmlReader>です。  
  
 <xref:System.Xml.XmlReader> か、有効な行の情報があります。 設定した場合 <xref:System.Xml.Linq.LoadOptions.SetLineInfo>, 、行の情報は、によって報告された行の情報から、XML ツリーに設定されます、 <xref:System.Xml.XmlReader>です。  
  
 設定した場合は、パフォーマンスの低下、 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> フラグ。  
  
 行の情報は、XML ドキュメントの読み込み直後に正確です。 ドキュメントの読み込み後、XML ツリーを変更する場合は、行の情報が無意味になる可能性があります。  
  
 XML の読み込み機能への LINQ の基盤となって <xref:System.Xml.XmlReader>します。 によってスローされる例外をキャッチするため、 <xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName> メソッドをオーバー ロードと <xref:System.Xml.XmlReader> メソッドで読み取りおよびドキュメントを解析します。  
  
   
  
## 例  
 次の例から読み込む行情報を読み込みます、 <xref:System.Xml.XmlReader>です。 行の情報が印刷されます。  
  
```csharp  
  
                string markup =  
@"<Root>  
    <Child>  
        <GrandChild/>  
    </Child>  
</Root>";  
  
// Create a reader and move to the content.  
using (XmlReader nodeReader = XmlReader.Create(new StringReader(markup)))  
{  
    // the reader must be in the Interactive state in order to  
    // Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XElement xRoot = XElement.Load(nodeReader, LoadOptions.SetLineInfo);  
    Console.WriteLine("{0}{1}{2}",  
        "Element Name".PadRight(20),  
        "Line".PadRight(5),  
        "Position");  
    Console.WriteLine("{0}{1}{2}",  
        "------------".PadRight(20),  
        "----".PadRight(5),  
        "--------");  
    foreach (XElement e in xRoot.DescendantsAndSelf())  
        Console.WriteLine("{0}{1}{2}",  
            ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
            ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
            ((IXmlLineInfo)e).LinePosition);  
}  
```  
  
```vb  
  
                Dim markup As String = _  
    "<Root>" & Environment.NewLine & _  
    "    <Child>" & Environment.NewLine & _  
    "        <GrandChild/>" & Environment.NewLine & _  
    "    </Child>" & Environment.NewLine & _  
    "</Root>"  
  
' Create a reader and move to the content.  
Using nodeReader As XmlReader = XmlReader.Create(New StringReader(markup))  
  
    ' the reader must be in the Interactive state in order to  
    ' Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XElement = XElement.Load(nodeReader, LoadOptions.SetLineInfo)  
    Console.WriteLine("{0}{1}{2}", _  
        "Element Name".PadRight(20), _  
        "Line".PadRight(5), _  
        "Position")  
    Console.WriteLine("{0}{1}{2}", _  
        "------------".PadRight(20), _  
        "----".PadRight(5), _  
        "--------")  
    For Each e As XElement In xRoot.DescendantsAndSelf()  
        Console.WriteLine("{0}{1}{2}", _  
            ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
            (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
            (DirectCast(e, IXmlLineInfo)).LinePosition)  
    Next  
End Using  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    6  
    GrandChild      3    10  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt; LoadAsync (System.IO.Stream stream, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XElement&gt; LoadAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.LoadAsync(System.IO.Stream,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt; LoadAsync (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XElement&gt; LoadAsync(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.LoadAsync(System.IO.TextReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textReader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt; LoadAsync (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XElement&gt; LoadAsync(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.LoadAsync(System.Xml.XmlReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XName Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XName Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の名前を取得または設定します。</summary>
        <value>
          <see cref="T:System.Xml.Linq.XName" /> この要素の名前を格納しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは生成の設定、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
   
  
## 例  
 次の例では、このプロパティを使用して、要素の名前を確認します。  
  
```csharp  
  
                XElement el1 = new XElement("Root", "content");  
Console.WriteLine(el1.Name);  
  
XNamespace ns = "http://www.adventure-works.com";  
XElement el2 = new XElement(ns + "Root", "content");  
Console.WriteLine(el2.Name);  
Console.WriteLine(el2.Name.Namespace);  
Console.WriteLine(el2.Name.LocalName);  
el2.Name = ns + "NewName";  
Console.WriteLine(el2.Name);  
```  
  
```vb  
  
                Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim el1 As XElement = <Root>content</Root>  
        Console.WriteLine(el1.Name)  
  
        Dim el2 As XElement = <aw:Root>content</aw:Root>  
        Console.WriteLine(el2.Name)  
        Console.WriteLine(el2.Name.Namespace)  
        Console.WriteLine(el2.Name.LocalName)  
        Dim aw as XNamespace = GetXmlNamespace(aw)  
        el2.Name = aw + "NewName"  
        Console.WriteLine(el2.Name)  
    End Sub  
End Module  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Root  
{http://www.adventure-works.com}Root  
http://www.adventure-works.com  
Root  
{http://www.adventure-works.com}NewName  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このノードのノード型を取得します。</summary>
        <value>ノード型。<see cref="T:System.Xml.Linq.XElement" /> オブジェクトに、この値は <see cref="F:System.Xml.XmlNodeType.Element" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 すべてのクラスから派生するので <xref:System.Xml.Linq.XObject> を含む、 <xref:System.Xml.Linq.XObject.NodeType%2A> プロパティには、具体的なサブクラスのコレクションで動作するコードを記述することができます <xref:System.Xml.Linq.XObject>します。 コードは、コレクション内の各ノードのノード型をテストできます。  
  
   
  
## 例  
 次の例では、このプロパティを使用して、要素のノード型を出力します。  
  
```csharp  
  
                XElement el1 = new XElement("Root", "content");  
Console.WriteLine(el1.NodeType);  
Console.WriteLine();  
```  
  
```vb  
  
                Dim el1 As XElement = <Root>content</Root>  
Console.WriteLine(el1.NodeType.ToString())  
Console.WriteLine()  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
Element  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static bool op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Boolean" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Boolean" />です。</summary>
        <returns>A <see cref="T:System.Boolean" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 変換するときに <xref:System.Boolean> 属性または要素の場合は、使用できる値は「0」、「1」と"true"を生成する文字列または"false"トリミングし、小文字に変換した後です。  
  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、ブール値をいくつかの要素を作成します。 キャストし <xref:System.Boolean>します。  
  
```csharp  
  
                XElement root = new XElement("Root",   
    new XElement("BoolValue1", true),  
    new XElement("BoolValue2", false)  
);  
bool bool1 = (bool)root.Element("BoolValue1");  
bool bool2 = (bool)root.Element("BoolValue2");  
Console.WriteLine("(bool)BoolValue1={0}", bool1);  
Console.WriteLine("(bool)BoolValue2={0}", bool2);  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root>  
            <BoolValue1>true</BoolValue1>  
            <BoolValue2>false</BoolValue2>  
        </Root>  
Dim bool1 As Boolean = CBool(root.Element("BoolValue1"))  
Dim bool2 As Boolean = CBool(root.Element("BoolValue2"))  
Console.WriteLine("(bool)BoolValue1={0}", bool1)  
Console.WriteLine("(bool)BoolValue2={0}", bool2)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                (bool)BoolValue1=True  
(bool)BoolValue2=False  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Boolean" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static DateTime op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.DateTime" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.DateTime" />です。</summary>
        <returns>A <see cref="T:System.DateTime" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 属性または日付と時刻のコンテンツを格納する要素の値の空白は ISO 8601 で説明されている日時に関連しています。 属性または日付と時刻のコンテンツを含む要素を作成する場合は、W3C 仕様に準拠した、属性または要素の値が書式設定されます。 詳細については、W3C 仕様を参照してください。  
  
 キャストする場合は、動作が厳密でない、 <xref:System.DateTime> 属性または要素からです。 値に適切に変換属性または要素の値が W3C 仕様に従って正確に書式設定しない場合でも、 <xref:System.DateTime>です。  
  
 この変換演算子を使用して <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName> から変換する、 <xref:System.DateTime>です。  
  
 The equivalent method for this operator is [Explicit 変換 \(XElement to](<!-- TODO: review code entity reference <xref:assetId:///op_Explicit(XElement>  --> element)?qualifyHint=True&autoUpgrade=False)  
  
## 例  
 次の例では、日付と時刻のコンテンツを持つ要素を作成します。 キャストし <xref:System.DateTime> 値を取得します。  
  
```csharp  
  
                // Behavior is strict when formatting an XML element or attribute from a DateTime,  
// but behavior is lax when casting to a DateTime from an element or attribute.  
XElement root = new XElement("Root", new DateTime(2006, 10, 6, 12, 30, 0));  
Console.WriteLine(root);  
  
// Cast from a strictly formatted XML element.  
DateTime dt = (DateTime)root;  
Console.WriteLine("dt={0}", dt);  
Console.WriteLine("-----");  
  
// If root is formatted in some different way:  
XElement dtElement = new XElement("OrderDate", "October 6, 2006");  
Console.WriteLine(dtElement);  
DateTime orderDate = (DateTime)dtElement;  
Console.WriteLine("orderDate={0:d}", orderDate);  
```  
  
```vb  
  
                ' Behavior is strict when formatting an XML element or attribute from a DateTime,  
' but behavior is lax when casting to a DateTime from an element or attribute.  
Dim root As XElement = <Root><%= New DateTime(2006, 10, 6, 12, 30, 0) %></Root>  
Console.WriteLine(root)  
  
' Cast from a strictly formatted XML element.  
Dim dt As DateTime = CType(root, DateTime)  
Console.WriteLine("dt={0}", dt)  
Console.WriteLine("-----")  
  
' If root is formatted in some different way:  
Dim dtElement As XElement = <OrderDate>October 6, 2006</OrderDate>  
Console.WriteLine(dtElement)  
Dim orderDate As DateTime = CType(dtElement, DateTime)  
Console.WriteLine("orderDate={0:d}", orderDate)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>2006-10-06T12:30:00</Root>  
dt=10/6/2006 12:30:00 PM  
-----  
<OrderDate>October 6, 2006</OrderDate>  
orderDate=10/6/2006  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.DateTime" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static DateTimeOffset op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTimeOffset op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.DateTimeOffset" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XAttribute" /> に、 <see cref="T:System.DateTimeOffset" />です。</summary>
        <returns>A <see cref="T:System.DateTimeOffset" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この変換演算子を使用して、 <xref:System.Xml.XmlConvert> 変換を実行するクラス。  
  
 The equivalent method for this operator is [Explicit 変換 \(XElement to](<!-- TODO: review code entity reference <xref:assetId:///op_Explicit(XAttribute>  --> attribute)?qualifyHint=True&autoUpgrade=False)  
  
## 例  
 次の例では、日付と時刻のコンテンツを持つ要素を作成します。 キャストし <xref:System.DateTimeOffset> 値を取得します。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child", new DateTimeOffset(new DateTime(2006, 10, 6, 12, 30, 0)))  
);  
Console.WriteLine(root);  
  
DateTimeOffset dt = (DateTimeOffset)root.Element("Child");  
Console.WriteLine("dt={0}", dt);  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root>  
        <Child><%= New DateTimeOffset(New DateTime(2006, 10, 6, 12, 30, 0)) %></Child>  
    </Root>  
Console.WriteLine(root)  
  
Dim dt As DateTimeOffset = CType(root.<Child>(0), DateTimeOffset)  
Console.WriteLine("dt={0}", dt)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>  
  <Child>2006-10-06T12:30:00-07:00</Child>  
</Root>  
dt=10/6/2006 12:30:00 PM -07:00  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.DateTimeOffset" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static decimal op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Decimal" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Decimal" />です。</summary>
        <returns>A <see cref="T:System.Decimal" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、10 進数の値を持つ要素を作成します。 キャストすることで、属性の値を取得し <xref:System.Decimal>します。  
  
```csharp  
  
                XElement root = new XElement("Root", "79228162514264337593543950335");  
decimal value = (decimal)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
  
                Dim root As XElement = <Root>79228162514264337593543950335</Root>  
Dim value As Decimal = CDec(root)  
Console.WriteLine("value={0}", value)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
value=79228162514264337593543950335  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Decimal" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static double op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Double" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Double" />です。</summary>
        <returns>A <see cref="T:System.Double" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例を使用して属性を作成する `double` コンテンツです。 キャストすることで値を取得し <xref:System.Double>します。  
  
```csharp  
  
                XElement root = new XElement("Root", 1.79769313486231e308);  
double value = (double)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
  
                Dim root As XElement = <Root>1.79769313486231E+308</Root>  
Dim value As Double = CDbl(root)  
Console.WriteLine("value={0}", value)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
value=1.79769313486231E+308  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Double" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Guid op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Guid op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Guid" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Guid" />です。</summary>
        <returns>A <see cref="T:System.Guid" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、コンテンツとして guid を持つ要素を作成します。 キャストすることで値を取得し <xref:System.Guid>します。  
  
```csharp  
  
                XElement root = new XElement("Root", new Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730"));  
Guid value = (Guid)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
  
                Dim root As XElement = <Root><%= New Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730") %></Root>  
Dim value As Guid = CType(root, Guid)  
Console.WriteLine("value={0}", value)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
value=3c1cc55b-baff-4b7a-9d17-077af3aa5730  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Guid" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static int op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Int32" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Int32" />です。</summary>
        <returns>A <see cref="T:System.Int32" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、コンテンツとして整数を含む要素を作成します。 キャストすることで値を取得し <xref:System.Int32>します。  
  
```csharp  
  
                XElement root = new XElement("Root", 2147483647);  
int value = (int)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
  
                Dim root As XElement = <Root>2147483647</Root>  
Dim value As Integer = CInt(root)  
Console.WriteLine("value={0}", value)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
value=2147483647  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Int32" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static long op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Int64" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Int64" />です。</summary>
        <returns>A <see cref="T:System.Int64" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、コンテンツとして長整数型で要素を作成します。 キャストすることで、要素の値を取得し <xref:System.Int64>します。  
  
```csharp  
  
                XElement root = new XElement("Root", 9223372036854775807);  
long value = (long)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
  
                Dim root As XElement = <Root>9223372036854775807</Root>  
Dim value As Long = CLng(root)  
Console.WriteLine("value={0}", value)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
value=9223372036854775807  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Int64" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;bool&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;bool&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.Boolean" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.Boolean" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.Boolean" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 変換するときに <xref:System.Nullable%601> の <xref:System.Boolean> 属性または要素の場合は、使用できる値は「0」、「1」と"true"を生成する文字列または"false"トリミングし、小文字に変換した後です。  
  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、ブール型のコンテンツを持つ要素を作成します。 キャストすることで値を取得し <xref:System.Nullable%601> の <xref:System.Boolean>です。  
  
```csharp  
  
                XElement root = new XElement("Root",   
    new XElement("BoolValue1", true),  
    new XElement("BoolValue2", false));  
bool? bool1 = (bool?)root.Element("BoolValue1");  
bool? bool2 = (bool?)root.Element("BoolValue2");  
Console.WriteLine("Nullable Boolean: value1={0}", bool1);  
Console.WriteLine("Nullable Boolean: value2={0}", bool2);  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root>  
            <BoolValue1>true</BoolValue1>  
            <BoolValue2>false</BoolValue2>  
        </Root>  
  
Dim value1 As Nullable(Of Boolean) = CType(root.Element("BoolValue1"), Nullable(Of Boolean))  
Dim value2 As Nullable(Of Boolean) = CType(root.Element("BoolValue2"), Nullable(Of Boolean))  
Console.WriteLine("Nullable Boolean: value1={0}", IIf(value1.HasValue, value1.ToString(), "null"))  
Console.WriteLine("Nullable Boolean: value2={0}", IIf(value2.HasValue, value2.ToString(), "null"))  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
Nullable Boolean: value1=True  
Nullable Boolean: value2=False  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Boolean" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;DateTime&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.DateTime&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.DateTime&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.DateTime" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.DateTime" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.DateTime" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 属性または日付と時刻のコンテンツを格納する要素の値の空白は ISO 8601 で説明されている日時に関連しています。 属性または日付と時刻のコンテンツを含む要素を作成する場合は、W3C 仕様に準拠した、属性または要素の値が書式設定されます。 詳細については、W3C 仕様を参照してください。  
  
 キャストする場合は、動作が厳密でない、 <xref:System.Nullable%601> の <xref:System.DateTime> 属性または要素からです。 値に適切に変換属性または要素の値が W3C 仕様に従って正確に書式設定しない場合でも、 <xref:System.Nullable%601> の <xref:System.DateTime>です。  
  
 この変換演算子を使用して <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName> から変換する、 <xref:System.DateTime>です。  
  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、日付と時刻の内容の要素を作成します。 キャストすることで値を取得し <xref:System.Nullable%601> の <xref:System.DateTime>です。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Value", new DateTime(2006, 10, 6, 12, 30, 0))  
);  
DateTime? value = (DateTime?)root.Element("Value");  
Console.WriteLine("Nullable DateTime: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
  
                Dim root As XElement = _   
    <Root>  
        <Value><%= New DateTime(2006, 10, 6, 12, 30, 0) %></Value>  
    </Root>  
Dim value As Nullable(Of DateTime) = CType(root.Element("Value"), Nullable(Of DateTime))  
Console.WriteLine("Nullable DateTime: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
Nullable DateTime: value=10/6/2006 12:30:00 PM  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.DateTime" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;DateTimeOffset&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.DateTimeOffset&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.DateTimeOffset" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.DateTimeOffset" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.DateTimeOffset" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この変換演算子を使用して、 <xref:System.Xml.XmlConvert> 変換を実行するクラス。  
  
 The equivalent method for this operator is [Explicit 変換 \(XElement to](<!-- TODO: review code entity reference <xref:assetId:///op_Explicit(X>  --> Element element )?qualifyHint=True&autoUpgrade=False)  
  
## 例  
 次の例では、日付と時刻のコンテンツを持つ要素を作成します。 キャストし <xref:System.Nullable%601> の <xref:System.DateTimeOffset> 値を取得します。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child", new DateTimeOffset(new DateTime(2006, 10, 6, 12, 30, 0)))  
);  
Console.WriteLine(root);  
  
DateTimeOffset? dt = (DateTimeOffset?)root.Element("Child");  
Console.WriteLine("dt={0}", dt);  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root>  
        <Child><%= New DateTimeOffset(New DateTime(2006, 10, 6, 12, 30, 0)) %></Child>  
    </Root>  
Console.WriteLine(root)  
  
Dim dt As Nullable(Of DateTimeOffset) = CType(root.<Child>(0), Nullable(Of DateTimeOffset))  
Console.WriteLine("dt={0}", dt)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>  
  <Child>2006-10-06T12:30:00-07:00</Child>  
</Root>  
dt=10/6/2006 12:30:00 PM -07:00  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.DateTimeOffset" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.Decimal" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.Decimal" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.Decimal" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、10 進数のコンテンツを持つ要素を作成します。 キャストすることで値を取得し <xref:System.Nullable%601> の <xref:System.Decimal>です。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Value", "79228162514264337593543950335")  
);  
decimal? value = (decimal?)root.Element("Value");  
Console.WriteLine("Nullable decimal: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
  
                Dim root As XElement = _   
    <Root>  
        <Value>79228162514264337593543950335</Value>  
    </Root>  
Dim value As Nullable(Of Decimal) = CType(root.Element("Value"), Nullable(Of Decimal))  
Console.WriteLine("Nullable decimal: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
Nullable decimal: value=79228162514264337593543950335  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Decimal" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;float64&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.Double" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.Double" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.Double" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、ポイントのコンテンツを浮動小数点精度が倍の要素を作成します。 キャストすることで値を取得し <xref:System.Nullable%601> の <xref:System.Double>です。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Value", 1.79769313486231e308)  
);  
double? value = (double?)root.Element("Value");  
Console.WriteLine("Nullable double: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
  
                Dim root As XElement = _  
        <Root>  
            <Value>1.79769313486231e308</Value>  
        </Root>  
  
Dim value As Nullable(Of Double) = CType(root.Element("Value"), Nullable(Of Double))  
Console.WriteLine("Nullable double: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
Nullable double: value=1.79769313486231E+308  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Double" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;Guid&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.Guid&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Guid&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.Guid" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.Guid" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.Guid" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、guid のコンテンツを持つ要素を作成します。 キャストすることで値を取得し <xref:System.Nullable%601> の <xref:System.Guid>です。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Value", new Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730"))  
);  
Guid? value = (Guid?)root.Element("Value");  
Console.WriteLine("Nullable Guid: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
  
                Dim root As XElement = _   
    <Root>  
        <Value><%= New Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730") %></Value>  
    </Root>  
Dim value As Nullable(Of Guid) = CType(root.Element("Value"), Nullable(Of Guid))  
Console.WriteLine("Nullable Guid: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
Nullable Guid: value=3c1cc55b-baff-4b7a-9d17-077af3aa5730  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Guid" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;int32&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.Int32" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.Int32" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.Int32" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、符号なし整数のコンテンツを持つ要素を作成します。 キャストすることで値を取得し <xref:System.Nullable%601> の <xref:System.Int32>です。  
  
```csharp  
  
                XElement root = new XElement("Root",   
    new XElement("Value", 2147483647)  
);  
int? value = (int?)root.Element("Value");  
Console.WriteLine("Nullable integer: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root>  
            <Value>2147483647</Value>  
        </Root>  
Dim value As Nullable(Of Integer) = CType(root.Element("Value"), Nullable(Of Integer))  
Console.WriteLine("Nullable integer: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
Nullable integer: value=2147483647  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Int32" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;int64&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.Int64" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.Int64" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.Int64" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、長整数型のコンテンツを持つ要素を作成します。 キャストすることで値を取得し <xref:System.Nullable%601> の <xref:System.Int64>です。  
  
```csharp  
  
                XElement root = new XElement("Root",    
    new XElement("Value", 9223372036854775807)  
);  
ulong? value = (ulong?)root.Element("Value");  
Console.WriteLine("Nullable ulong: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root>  
            <Value>9223372036854775807</Value>  
        </Root>  
Dim value As Nullable(Of ULong) = CType(root.Element("Value"), Nullable(Of ULong))  
Console.WriteLine("Nullable ulong: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
Nullable ulong: value=9223372036854775807  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Int64" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;float32&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.Single" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.Single" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.Single" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、ポイントのコンテンツを浮動 1 つの有効桁数を持つ要素を作成します。 キャストすることで値を取得し <xref:System.Nullable%601> の <xref:System.Single>です。  
  
```csharp  
  
                XElement root = new XElement("Root",   
    new XElement("Value", 3.402823e38)  
);  
float? value = (float?)root.Element("Value");  
Console.WriteLine("Nullable Single: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root>  
            <Value>3.402823e38</Value>  
        </Root>  
Dim value As Nullable(Of Single) = CType(root.Element("Value"), Nullable(Of Single))  
Console.WriteLine("Nullable Single: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
Nullable Single: value=3.402823E+38  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Single" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;TimeSpan&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.TimeSpan" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.TimeSpan" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.TimeSpan" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 属性や期間の内容を格納する要素の値空間は、ISO 8601 で説明されている期間の内容に密接に関連しています。 属性または期間の内容を含む要素を作成する場合は、W3C 仕様に準拠した、属性または要素の値が書式設定されます。 詳細については、W3C 仕様を参照してください。  
  
 キャストする場合は、動作が厳密でない、 <xref:System.Nullable%601> の <xref:System.TimeSpan> 属性または要素からです。 値に適切に変換属性または要素の値が W3C 仕様に従って正確に書式設定しない場合でも、 <xref:System.Nullable%601> の <xref:System.TimeSpan>です。  
  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例は作成タイム スパンに要素をコンテンツです。 キャストすることで値を取得し <xref:System.Nullable%601> の <xref:System.TimeSpan>です。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Value", new TimeSpan(1, 5, 30))  
);  
TimeSpan? value = (TimeSpan?)root.Element("Value");  
Console.WriteLine("Nullable TimeSpan: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root>  
        <Value><%= New TimeSpan(1, 5, 30) %></Value>  
    </Root>  
Dim value As Nullable(Of TimeSpan) = CType(root.Element("Value"), Nullable(Of TimeSpan))  
Console.WriteLine("Nullable TimeSpan: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
Nullable TimeSpan: value=01:05:30  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.TimeSpan" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;uint&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;unsigned int32&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.UInt32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.UInt32" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.UInt32" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.UInt32" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、符号なし整数のコンテンツを持つ要素を作成します。 キャストすることで値を取得し <xref:System.Nullable%601> の <xref:System.UInt32>です。  
  
```csharp  
  
                XElement root = new XElement("Root",   
    new XElement("Value", 4294967295)  
);  
uint? value = (uint?)root.Element("Value");  
Console.WriteLine("Nullable uint: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root>  
            <Value>4294967295</Value>  
        </Root>  
Dim value As Nullable(Of UInteger) = CType(root.Element("Value"), Nullable(Of UInteger))  
Console.WriteLine("Nullable uint: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
Nullable uint: value=4294967295  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.UInt32" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static Nullable&lt;ulong&gt; op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;unsigned int64&gt; op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.UInt64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Nullable`1" /> の <see cref="T:System.UInt64" />です。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Nullable`1" /> の <see cref="T:System.UInt64" />です。</summary>
        <returns>A <see cref="T:System.Nullable`1" /> の <see cref="T:System.UInt64" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、符号なし長整数のコンテンツを持つ要素を作成します。 キャストすることで値を取得し <xref:System.Nullable%601> の <xref:System.UInt64>です。  
  
```csharp  
  
                XElement root = new XElement("Root",   
    new XElement("Value", 9223372036854775807)  
);  
ulong? value = (ulong?)root.Element("Value");  
Console.WriteLine("Nullable ulong: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root>  
            <Value>9223372036854775807</Value>  
        </Root>  
  
Dim value As Nullable(Of ULong) = CType(root.Element("Value"), Nullable(Of ULong))  
Console.WriteLine("Nullable ulong: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
Nullable ulong: value=9223372036854775807  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.UInt64" /> 値。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static float op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.Single" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.Single" />です。</summary>
        <returns>A <see cref="T:System.Single" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、ポイントのコンテンツを浮動 1 つの有効桁数を持つ要素を作成します。 キャストすることで値を取得し <xref:System.Single>します。  
  
```csharp  
  
                XElement root = new XElement("Root", 3.402823e38);  
float value = (float)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
  
                Dim root As XElement = <Root>3.402823E+38</Root>  
Dim value As Single = CSng(root)  
Console.WriteLine("value={0}", value)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
value=3.402823E+38  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.Single" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static string op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname string op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.String" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.String" />です。</summary>
        <returns>A <see cref="T:System.String" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合、 <xref:System.Xml.Linq.XElement> 子を持ち、すべての要素のテキストと子のテキストの連結された文字列値が返されます。  
  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、文字列コンテンツを持つ要素を作成します。 キャストすることで値を取得し <xref:System.String>します。  
  
```csharp  
  
                XElement root = XElement.Parse("<Root>abc <b>def </b>ghi</Root>");  
Console.WriteLine("(string)root={0}", (string)root);  
```  
  
```vb  
  
                Dim root As XElement = <Root>abc <b>def </b>ghi</Root>  
Console.WriteLine("(string)root={0}", root.Value)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
(string)root=abc def ghi  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static TimeSpan op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.TimeSpan op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.TimeSpan" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.TimeSpan" />です。</summary>
        <returns>A <see cref="T:System.TimeSpan" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 属性や期間の内容を格納する要素の値空間は、ISO 8601 で説明されている期間の内容に密接に関連しています。 属性または期間の内容を含む要素を作成する場合は、W3C 仕様に準拠した、属性または要素の値が書式設定されます。 詳細については、W3C 仕様を参照してください。  
  
 キャストする場合は、動作が厳密でない、 <xref:System.TimeSpan> 属性または要素からです。 値に適切に変換属性または要素の値が W3C 仕様に従って正確に書式設定しない場合でも、 <xref:System.TimeSpan>です。  
  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例は作成タイム スパンに要素をコンテンツです。 キャストすることで値を取得し <xref:System.TimeSpan>します。  
  
```csharp  
  
                XElement root = new XElement("Root", new TimeSpan(1, 5, 30));  
TimeSpan value = (TimeSpan)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
  
                Dim root As XElement = <Root><%= New TimeSpan(1, 5, 30) %></Root>  
Dim value As TimeSpan = CType(root, TimeSpan)  
Console.WriteLine("value={0}", value)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
value=01:05:30  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.TimeSpan" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static uint op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.UInt32" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.UInt32" />です。</summary>
        <returns>A <see cref="T:System.UInt32" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、符号なし整数のコンテンツを持つ要素を作成します。 キャストすることで値を取得し <xref:System.UInt32>します。  
  
```csharp  
  
                XElement root = new XElement("Root", 4294967295);  
uint value = (uint)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
  
                Dim root As XElement = <Root>4294967295</Root>  
Dim value As UInteger = CUInt(root)  
Console.WriteLine("value={0}", value)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
value=4294967295  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.UInt32" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static ulong op_Explicit (System.Xml.Linq.XElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(class System.Xml.Linq.XElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Xml.Linq.XElement" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Xml.Linq.XElement" /> へのキャストを <see cref="T:System.UInt64" />します。</param>
        <summary>この値をキャスト <see cref="T:System.Xml.Linq.XElement" /> に、 <see cref="T:System.UInt64" />です。</summary>
        <returns>A <see cref="T:System.UInt64" /> このコンテンツを含む <see cref="T:System.Xml.Linq.XElement" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The equivalent method for this operator is ?qualifyHint=True&autoUpgrade=False  
  
## 例  
 次の例では、符号なし長整数のコンテンツを持つ要素を作成します。 キャストすることで値を取得し <xref:System.UInt64>します。  
  
```csharp  
  
                XElement root = new XElement("Root", 18446744073709551615);  
ulong value = (ulong)root;  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
  
                Dim root As XElement = <Root>18446744073709551615</Root>  
Dim value As ULong = CULng(root)  
Console.WriteLine("value={0}", value)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
value=18446744073709551615  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">要素値を含まない有効な <see cref="T:System.UInt64" /> 値。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Parse (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Parse(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Parse(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">A <see cref="T:System.String" /> XML を格納しています。</param>
        <summary>負荷、 <see cref="T:System.Xml.Linq.XElement" /> XML を含む文字列から。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" /> XML を表す文字列から取得されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドでは、空白は保持されません。 XML ツリー内の空白を維持する場合は、オーバー ロードを使用して、 <xref:System.Xml.Linq.XElement.Parse%2A> を受け取るメソッド <xref:System.Xml.Linq.LoadOptions> をパラメーターとして。 詳細については、[Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/ja-jp/093a7169-a04e-4638-b08c-d1cb98aa650d) および [Preserving White Space While Serializing](http://msdn.microsoft.com/ja-jp/fb146217-0a49-4efc-ac84-7265b91d3939) を参照してください。  
  
 XML の読み込み機能への LINQ の基盤となって <xref:System.Xml.XmlReader>します。 によってスローされる例外をキャッチするため、 <xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName> メソッドをオーバー ロードと <xref:System.Xml.XmlReader> メソッドで読み取りおよびドキュメントを解析します。  
  
   
  
## 例  
 次の例では、XML を含む文字列を作成します。 文字列を解析し、 <xref:System.Xml.Linq.XElement>です。  
  
```csharp  
  
                XElement xmlTree = XElement.Parse("<Root> <Child> </Child> </Root>");  
Console.WriteLine(xmlTree);  
```  
  
```vb  
  
                Dim xmlTree As XElement = <Root><Child></Child></Root>  
Console.WriteLine(xmlTree)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child></Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement Parse (string text, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement Parse(string text, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="text">A <see cref="T:System.String" /> XML を格納しています。</param>
        <param name="options">A <see cref="T:System.Xml.Linq.LoadOptions" /> 空白の動作、およびベース URI と行情報を読み込むかどうかを指定します。</param>
        <summary>負荷、 <see cref="T:System.Xml.Linq.XElement" /> から XML を含む文字列、必要に応じて、空白の維持および保持する行情報。</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" /> XML を表す文字列から取得されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定する場合は、元の XML はインデントは、 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> フラグ `options` により、ソース XML 内のすべての空白文字を読み取るリーダー。 型のノード <xref:System.Xml.Linq.XText> 両方は、有意の空白文字が作成されます。  
  
 設定しない場合は、元の XML はインデントは、 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> フラグ `options` ソース XML の余分な空白をすべて無視するリーダーを発生します。 意味のない空白のテキスト ノードなしは、XML ツリーが作成されます。  
  
 ソース XML がインデント付きでない場合、 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> フラグ `options` も何も起こりません。 有意の空白は維持され、詳細の空白文字のテキスト ノードの作成を引き起こす可能性のある有意の空白文字の範囲はありません。  
  
 詳細については、[Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/ja-jp/093a7169-a04e-4638-b08c-d1cb98aa650d) および [Preserving White Space While Serializing](http://msdn.microsoft.com/ja-jp/fb146217-0a49-4efc-ac84-7265b91d3939) を参照してください。  
  
 設定 <xref:System.Xml.Linq.LoadOptions.SetBaseUri> 効果はありませんから解析するときに、 <xref:System.String>です。  
  
 <xref:System.Xml.XmlReader> か、有効な行の情報があります。 設定した場合 <xref:System.Xml.Linq.LoadOptions.SetLineInfo>, 、行の情報は、によって報告された行の情報から、XML ツリーに設定されます、 <xref:System.Xml.XmlReader>です。  
  
 設定した場合は、パフォーマンスの低下、 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> フラグ。  
  
 行の情報は、XML ドキュメントの読み込み直後に正確です。 ドキュメントの読み込み後、XML ツリーを変更する場合は、行の情報が無意味になる可能性があります。  
  
 XML の読み込み機能への LINQ の基盤となって <xref:System.Xml.XmlReader>します。 によってスローされる例外をキャッチするため、 <xref:System.Xml.XmlReader.Create%2A?displayProperty=fullName> メソッドをオーバー ロードと <xref:System.Xml.XmlReader> メソッドで読み取りおよびドキュメントを解析します。  
  
   
  
## 例  
 次の例に文字列の解析、 <xref:System.Xml.Linq.XElement> 2 つの方法で: 空白、および空白の維持されません。 クエリを使用して、結果として得られる XML ツリー内の空白ノードの数を決定します。  
  
```csharp  
  
                int whiteSpaceNodes;  
  
XElement xmlTree1 = XElement.Parse("<Root> <Child> </Child> </Root>",  
    LoadOptions.None);  
whiteSpaceNodes = xmlTree1  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}",  
    whiteSpaceNodes);  
  
XElement xmlTree2 = XElement.Parse("<Root> <Child> </Child> </Root>",  
    LoadOptions.PreserveWhitespace);  
whiteSpaceNodes = xmlTree2  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}",  
    whiteSpaceNodes);  
```  
  
```vb  
  
                Dim whiteSpaceNodes As Integer  
  
Dim xmlTree1 As XElement = XElement.Parse("<Root> <Child> </Child> </Root>", LoadOptions.None)  
whiteSpaceNodes = xmlTree1 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
Dim xmlTree2 As XElement = XElement.Parse("<Root> <Child> </Child> </Root>", LoadOptions.PreserveWhitespace)  
whiteSpaceNodes = xmlTree2 _  
    .DescendantNodesAndSelf() _  
    .OfType(Of XText)() _  
    .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _  
    .Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 次の例では、文字列の解析時に、行の情報が保持されます。  
  
```csharp  
  
                string markup =  
@"<Root>  
    <Child>  
        <GrandChild/>  
    </Child>  
</Root>";  
  
XElement xRoot = XElement.Parse(markup, LoadOptions.SetLineInfo);  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in xRoot.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
        ((IXmlLineInfo)e).LinePosition);  
```  
  
```vb  
  
                Dim markup As String = _  
"<Root>" & Environment.NewLine & _  
"    <Child>" & Environment.NewLine & _  
"        <GrandChild/>" & Environment.NewLine & _  
"    </Child>" & Environment.NewLine & _  
"</Root>"  
  
Dim xRoot As XElement = XElement.Parse(markup, LoadOptions.SetLineInfo)  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In xRoot.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
        DirectCast(e, IXmlLineInfo).LineNumber.ToString().PadRight(5), _  
        DirectCast(e, IXmlLineInfo).LinePosition)  
Next  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    6  
    GrandChild      3    10  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public void RemoveAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.RemoveAll" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このノードおよび属性を削除 <see cref="T:System.Xml.Linq.XElement" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを発生させる、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
   
  
## 例  
 次の例では、属性と子要素を持つ要素を作成します。 これは、後、属性と子要素の両方を削除するには、このメソッドを呼び出します。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3),  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3)  
);  
root.RemoveAll();   // removes children elements and attributes of root  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root Attr1="1" Attr2="2" Attr3="3">  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
        </Root>  
  
root.RemoveAll()   ' removes children elements and attributes of root  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root />  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.RemoveAttributes" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAttributes">
      <MemberSignature Language="C#" Value="public void RemoveAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.RemoveAttributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この属性を削除する <see cref="T:System.Xml.Linq.XElement" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを発生させる、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
   
  
## 例  
 次の例では、属性と子要素を持つ要素を作成します。 これは、後、属性を削除するには、このメソッドを呼び出します。 子要素は残ります。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3),  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3)  
);  
root.RemoveAttributes();  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = _   
    <Root Attr1="1" Attr2="2" Attr3="3">  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
     </Root>  
  
root.RemoveAttributes()  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
</Root>   
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.RemoveAttributes" />
        <altmember cref="M:System.Xml.Linq.XElement.RemoveAll" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceAll">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素の子ノードおよび属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、スナップショットのセマンティクスを使用して、新しい内容で作成します。 つまり、現在の要素の内容を照会して、指定された新しい内容として、クエリの結果を使用できます。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「 [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/ja-jp/aee2d319-5c5f-4b99-9bb4-2f58232577ae)します。  
  
 このメソッドを発生させる、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
   
  
## 例  
 次の例では、LINQ クエリの結果を要素の内容に置き換えて、クエリの結果、このメソッドに渡します。 内容が置き換えられている要素を照会します。  
  
```csharp  
  
                XElement xmlTree = new XElement("Root",  
    new XElement("Data", 1),  
    new XElement("Data", 2),  
    new XElement("Data", 3),  
    new XElement("Data", 4),  
    new XElement("Data", 5)  
);  
  
Console.WriteLine(xmlTree);  
Console.WriteLine("-----");  
  
xmlTree.ReplaceAll(  
    from el in xmlTree.Elements()  
    where (int)el >= 3  
    select new XElement("NewData", (int)el)  
);  
  
Console.WriteLine(xmlTree);  
```  
  
```vb  
  
                Dim xmlTree As XElement = _  
    <Root>  
        <Data>1</Data>  
        <Data>2</Data>  
        <Data>3</Data>  
        <Data>4</Data>  
        <Data>5</Data>  
    </Root>  
  
Console.WriteLine(xmlTree)  
Console.WriteLine("-----")  
  
xmlTree.ReplaceAll( _  
    From el In xmlTree.Elements _  
    Where el.Value >= 3 _  
    Select <NewData><%= el.Value %></NewData> _  
)  
  
Console.WriteLine(xmlTree)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>  
  <Data>1</Data>  
  <Data>2</Data>  
  <Data>3</Data>  
  <Data>4</Data>  
  <Data>5</Data>  
</Root>  
-----  
<Root>  
  <NewData>3</NewData>  
  <NewData>4</NewData>  
  <NewData>5</NewData>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceAll">
      <MemberSignature Language="C#" Value="public void ReplaceAll (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAll(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAll(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">この要素の子ノードおよび属性を置き換える内容。</param>
        <summary>この要素の子ノードおよび属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、まず、既存のコンテンツおよび属性を削除します。 これは、後、追加、指定した `content`します。  
  
 このメソッドは、スナップショットのセマンティクスを使用して、新しい内容で作成します。 つまり、現在の要素の内容を照会して、指定された新しい内容として、クエリの結果を使用できます。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「 [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/ja-jp/aee2d319-5c5f-4b99-9bb4-2f58232577ae)します。  
  
 このメソッドを発生させる、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
   
  
## 例  
 次の例では、このメソッドを使用します。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
  
// ReplaceAll with an XElement object.  
root.ReplaceAll(new XElement("NewChild", "n"));  
Console.WriteLine(root);  
  
// ReplaceAll with an XAttribute object.  
root.ReplaceAll(new XAttribute("NewAttribute", "n"));  
Console.WriteLine(root);  
  
// ReplaceAll with a string.  
root.ReplaceAll("Some text");  
Console.WriteLine(root);  
  
// ReplaceAll with a double.  
double dbl = 12.345;  
root.ReplaceAll(dbl);  
Console.WriteLine(root);  
  
// ReplaceAll with a DateTime object.  
DateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);  
root.ReplaceAll(dt);  
Console.WriteLine(root);  
  
// ReplaceAll with a string array.  
// Any collection other than a collection of XElement or XAttribute objects  
// are converted to strings. The strings are concatenated and added.  
string[] stringArray = {  
    "abc",  
    "def",  
    "ghi"  
};  
root.ReplaceAll(stringArray);  
Console.WriteLine(root);  
  
// ReplaceAll with an array of XElement objects.  
XElement[] ellArray = {  
    new XElement("NewChild1", 1),  
    new XElement("NewChild2", 2),  
    new XElement("NewChild3", 3)  
};  
root.ReplaceAll(ellArray);  
Console.WriteLine(root);  
  
// ReplaceAll with an array of XAttribute objects.  
XAttribute[] attArray = {  
    new XAttribute("NewAtt1", 1),  
    new XAttribute("NewAtt2", 2),  
    new XAttribute("NewAtt3", 3)  
};  
root.ReplaceAll(attArray);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = _   
    <Root>  
        <Child>child content</Child>  
    </Root>  
  
' ReplaceAll with an XElement object.  
root.ReplaceAll(<NewChild>n</NewChild>)  
Console.WriteLine(root)  
  
' ReplaceAll with an XAttribute object.  
root.ReplaceAll(New XAttribute("NewAttribute", "n"))  
Console.WriteLine(root)  
  
' ReplaceAll with a string.  
root.ReplaceAll("Some text")  
Console.WriteLine(root)  
  
' ReplaceAll with a double.  
Dim dbl As Double = 12.345  
root.ReplaceAll(dbl)  
Console.WriteLine(root)  
  
' ReplaceAll with a DateTime object.  
Dim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)  
root.ReplaceAll(dt)  
Console.WriteLine(root)  
  
' ReplaceAll with a string array.  
' Any collection other than a collection of XElement or XAttribute objects  
' are converted to strings. The strings are concatenated and added.  
Dim stringArray As String() = { _  
    "abc", _  
    "def", _  
    "ghi" _  
}  
root.ReplaceAll(stringArray)  
Console.WriteLine(root)  
  
' ReplaceAll with an array of XElement objects.  
Dim ellArray As XElement() = { _  
    New XElement("NewChild1", 1), _  
    New XElement("NewChild2", 2), _  
    New XElement("NewChild3", 3) _  
}  
root.ReplaceAll(ellArray)  
Console.WriteLine(root)  
  
' ReplaceAll with an array of XAttribute objects.  
Dim attArray As XAttribute() = { _  
New XAttribute("NewAtt1", 1), _  
New XAttribute("NewAtt2", 2), _  
New XAttribute("NewAtt3", 3) _  
}  
root.ReplaceAll(attArray)  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>  
  <NewChild>n</NewChild>  
</Root>  
<Root NewAttribute="n" />  
<Root>Some text</Root>  
<Root>12.345</Root>  
<Root>2006-10-06T12:30:00</Root>  
<Root>abcdefghi</Root>  
<Root>  
  <NewChild1>1</NewChild1>  
  <NewChild2>2</NewChild2>  
  <NewChild3>3</NewChild3>  
</Root>  
<Root NewAtt1="1" NewAtt2="2" NewAtt3="3" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceAll">
      <MemberSignature Language="C#" Value="public void ReplaceAll (object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAll(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">コンテンツ オブジェクトのパラメーター リスト。</param>
        <summary>この要素の子ノードおよび属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、まず、既存のコンテンツおよび属性を削除します。 これは、後、追加、指定した `content`します。  
  
 このメソッドは、スナップショットのセマンティクスを使用して、新しい内容で作成します。 つまり、現在の要素の内容を照会して、指定された新しい内容として、クエリの結果を使用できます。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「 [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/ja-jp/aee2d319-5c5f-4b99-9bb4-2f58232577ae)します。  
  
 このメソッドを発生させる、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
   
  
## 例  
 次の例では、LINQ クエリの結果を要素の内容に置き換えて、クエリの結果、このメソッドに渡します。  
  
```csharp  
  
                XElement xmlTree1 = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
  
XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
  
root.ReplaceAll(  
    from el in xmlTree1.Elements()  
    where((int)el >= 3 && (int)el <= 5)  
    select el  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim xmlTree1 As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <Child6>6</Child6>  
        </Root>  
  
Dim root As XElement = <Root>  
                           <Child>child content</Child>  
                       </Root>  
  
root.ReplaceAll( _  
    From el In xmlTree1.Elements() _  
    Where el.Value >= 3 And el.Value <= 5 _  
    Select el _  
)  
  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceAttributes">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素の属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを発生させる、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「 [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/ja-jp/aee2d319-5c5f-4b99-9bb4-2f58232577ae)します。  
  
   
  
## 例  
 次の例では、次の 3 つの属性を持つ要素を作成します。 このメソッドを使用して、1 つの属性を持つすべての要素の属性を置き換えます。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
root.ReplaceAttributes(  
    new XAttribute("NewAtt1", 101)  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
root.ReplaceAttributes(New XAttribute("NewAtt1", 101))  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root NewAtt1="101" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceAttributes">
      <MemberSignature Language="C#" Value="public void ReplaceAttributes (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAttributes(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">この要素の属性を置き換える内容。</param>
        <summary>この要素の属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、まず既存の属性を削除します。 これは、後、追加、指定した `content`します。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「 [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/ja-jp/aee2d319-5c5f-4b99-9bb4-2f58232577ae)します。  
  
 このメソッドを発生させる、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
   
  
## 例  
 次の例では、次の 3 つの属性を持つ要素を作成します。 このメソッドを使用して、1 つの属性を持つすべての要素の属性を置き換えます。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
root.ReplaceAttributes(  
    new XAttribute("NewAtt1", 101)  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
root.ReplaceAttributes(New XAttribute("NewAtt1", 101))  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root NewAtt1="101" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceAttributes">
      <MemberSignature Language="C#" Value="public void ReplaceAttributes (object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceAttributes(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">コンテンツ オブジェクトのパラメーター リスト。</param>
        <summary>この要素の属性を、指定された内容で置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、まず既存の属性を削除します。 これは、後、追加、指定した `content`します。  
  
 この関数に渡すことができる有効なコンテンツに関する詳細については、「 [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/ja-jp/aee2d319-5c5f-4b99-9bb4-2f58232577ae)します。  
  
 このメソッドを発生させる、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
   
  
## 例  
 次の例では、次の 3 つの属性を持つ要素を作成します。 その他の属性を持つ属性を置き換えます。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3)  
);  
root.ReplaceAttributes(  
    new XAttribute("NewAtt1", 101),  
    new XAttribute("NewAtt2", 102),  
    new XAttribute("NewAtt3", 103)  
);  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = <Root Att1="1" Att2="2" Att3="3"/>  
root.ReplaceAttributes( _  
New XAttribute("NewAtt1", 101), _  
New XAttribute("NewAtt2", 102), _  
New XAttribute("NewAtt3", 103))  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root NewAtt1="101" NewAtt2="102" NewAtt3="103" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">これを出力先のストリーム <see cref="T:System.Xml.Linq.XElement" /> にします。</param>
        <summary>これは出力 <see cref="T:System.Xml.Linq.XElement" /> を指定した <see cref="T:System.IO.Stream" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シリアル化された XML はインデントされます。 すべての余分な空白は削除され、および、余分な空白は XML が適切なインデントも追加されます。 このメソッドの動作は、その意味のない空白は保持されません。  
  
 空白を制御する場合のオーバー ロードを使用して <xref:System.Xml.Linq.XElement.Save%2A> を受け取る <xref:System.Xml.Linq.SaveOptions> をパラメーターとして。 使用して、 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> インデントされていない XML を保存するオプションです。 これは、結果、すべての空白を XML ツリーで表されるとおりに正確に書き込み先のライターです。  
  
 使用して、 <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> 場合、重複する名前空間宣言を削除するオプションを選択します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter">A <see cref="T:System.IO.TextWriter" /> を <see cref="T:System.Xml.Linq.XElement" /> に書き込まれます。</param>
        <summary>この要素をシリアル化、 <see cref="T:System.IO.TextWriter" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シリアル化された XML はインデントされます。 すべての余分な空白は削除され、および、余分な空白は XML が適切なインデントも追加されます。 このメソッドの動作は、空白文字は保持されません。  
  
 空白を制御する場合は、オーバー ロードを使用して <xref:System.Xml.Linq.XElement.Save%2A> を指定することができます <xref:System.Xml.Linq.SaveOptions> をパラメーターとして。 詳細については、[Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/ja-jp/093a7169-a04e-4638-b08c-d1cb98aa650d) および [Preserving White Space While Serializing](http://msdn.microsoft.com/ja-jp/fb146217-0a49-4efc-ac84-7265b91d3939) を参照してください。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Xml.Linq.XElement>, にドキュメントを保存、 <xref:System.IO.StringWriter>, 、コンソールに文字列を出力します。  
  
```csharp  
  
                XElement root = XElement.Parse(@"<Root> <Child> Text </Child> </Root>");  
using (StringWriter sw = new StringWriter()) {  
    root.Save(sw);  
    Console.WriteLine(sw.ToString());  
}  
```  
  
```vb  
  
                Dim root As XElement = <Root><Child> Text </Child></Root>  
Using sw = New StringWriter()  
    root.Save(sw)  
    Console.WriteLine(sw.ToString())  
End Using  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child> Text </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> ファイルの名前を格納しています。</param>
        <summary>この要素をシリアル化してファイルに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 シリアル化された XML はインデントされます。 すべての余分な空白は削除され、および、余分な空白は XML が適切なインデントも追加されます。 このメソッドの動作は、XML ツリー内のノードは保持されません意味のない空白です。  
  
 空白を制御する場合は、オーバー ロードを使用して <xref:System.Xml.Linq.XElement.Save%2A> を指定することができます <xref:System.Xml.Linq.SaveOptions> をパラメーターとして。 詳細については、[Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/ja-jp/093a7169-a04e-4638-b08c-d1cb98aa650d) および [Preserving White Space While Serializing](http://msdn.microsoft.com/ja-jp/fb146217-0a49-4efc-ac84-7265b91d3939) を参照してください。  
  
   
  
## 例  
 次の例を作成し、 <xref:System.Xml.Linq.XElement>, 、ファイルにドキュメントを保存し、ファイルをコンソールに出力します。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
root.Save("Root.xml");  
string str = File.ReadAllText("Root.xml");  
Console.WriteLine(str);  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root>  
            <Child>child content</Child>  
        </Root>  
root.Save("Root.xml")  
Dim Str As String = File.ReadAllText("Root.xml")  
Console.WriteLine(Str)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>child content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.Xml.XmlWriter" /> を <see cref="T:System.Xml.Linq.XElement" /> に書き込まれます。</param>
        <summary>この要素をシリアル化、 <see cref="T:System.Xml.XmlWriter" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 <xref:System.Xml.Linq.XElement> を <xref:System.Xml.XmlWriter> に保存する方法を次の例に示します。  
  
```csharp  
  
                StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    XElement root = new XElement("Root",  
        new XElement("Child", "child content")  
    );  
    root.Save(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
  
                Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
Using xw = XmlWriter.Create(sb, xws)  
    Dim root As XElement = <Root>  
                               <Child>child content</Child>  
                           </Root>  
    root.Save(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root><Child>child content</Child></Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream">これを出力先のストリーム <see cref="T:System.Xml.Linq.XElement" /> にします。</param>
        <param name="options">A <see cref="T:System.Xml.Linq.SaveOptions" /> 書式設定動作を指定するオブジェクト。</param>
        <summary>これは出力 <see cref="T:System.Xml.Linq.XElement" /> を指定した <see cref="T:System.IO.Stream" />, をオプションで指定して書式指定動作します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、 `options` に設定されている <xref:System.Xml.Linq.SaveOptions.None>します。 このオプションは無関係で意味のない空白はすべて削除し、XML が適切なインデントになるように適切な余分な空白を追加します。  
  
 インデントされていない XML を保存する場合は、指定、 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> を示すフラグ `options`します。 これは、結果、すべての空白を XML ツリーで表されるとおりに正確に書き込み先のライターです。  
  
 使用 <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> 場合、重複する名前空間宣言を削除するオプションを選択します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter">
          <see cref="T:System.IO.TextWriter" /> に XML を出力します。</param>
        <param name="options">A <see cref="T:System.Xml.Linq.SaveOptions" /> 書式設定動作を指定します。</param>
        <summary>この要素をシリアル化、 <see cref="T:System.IO.TextWriter" />, 、書式設定オプションで無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデントされていない XML を保存する場合は、指定、 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> を示すフラグ `options`します。 これは、結果、すべての空白を XML ツリーで表されるとおりに正確に書き込み先のライターです。  
  
 インデントされた XML を保存する場合は指定しないで、 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> を示すフラグ `options`します。 これは、余分なで意味のない空白はすべてを削除し、XML が適切なインデントになるように適切な余分な空白を追加します。 これは、既定の動作とのオーバー ロードの動作、 <xref:System.Xml.Linq.XElement.Save%2A> メソッドがない `options` をパラメーターとして。  
  
 詳細については、[Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/ja-jp/093a7169-a04e-4638-b08c-d1cb98aa650d) および [Preserving White Space While Serializing](http://msdn.microsoft.com/ja-jp/fb146217-0a49-4efc-ac84-7265b91d3939) を参照してください。  
  
   
  
## 例  
 次の例では、このメソッドの 2 つの使用を示します。 最初に使用するには、空白が保持されます。 2 番目のシリアル化、 <xref:System.Xml.Linq.XElement> 書式を設定しています。 ドキュメントがあるないため空白文字で構築された、空白の維持インデントは設定されません XML が出力されます。  
  
```csharp  
  
                XElement root = XElement.Parse(@"<Root> <Child> Text </Child> </Root>");  
  
using (StringWriter sw = new StringWriter())  
{  
    root.Save(sw, SaveOptions.DisableFormatting);  
    Console.WriteLine(sw.ToString());  
}  
  
Console.WriteLine("=====");  
  
using (StringWriter sw = new StringWriter())  
{  
    root.Save(sw, SaveOptions.None);  
    Console.WriteLine(sw.ToString());  
}  
```  
  
```vb  
  
                Dim root As XElement = <Root><Child> Text </Child></Root>  
  
Using sw = New StringWriter()  
    root.Save(sw, SaveOptions.DisableFormatting)  
    Console.WriteLine(sw.ToString())  
End Using  
  
Console.WriteLine("=====")  
  
Using sw = New StringWriter()  
    root.Save(sw, SaveOptions.None)  
    Console.WriteLine(sw.ToString())  
End Using  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <?xml version="1.0" encoding="utf-16"?><Root><Child> Text </Child></Root>  
=====  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child> Text </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> ファイルの名前を格納しています。</param>
        <param name="options">A <see cref="T:System.Xml.Linq.SaveOptions" /> 書式設定動作を指定します。</param>
        <summary>この要素をシリアル化してファイルに書き込み、オプションで、書式設定を無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデントされていない XML を保存する場合は、指定、 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> を示すフラグ `options`します。 これは、結果、すべての空白を XML ツリーで表されるとおりに正確に書き込み先のライターです。  
  
 インデントされた XML を保存する場合は指定しないで、 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> を示すフラグ `options`します。 これは、余分なで意味のない空白はすべてを削除し、XML が適切なインデントになるように適切な余分な空白を追加します。 これは、既定の動作とのオーバー ロードの動作、 <xref:System.Xml.Linq.XElement.Save%2A> メソッドがない `options` をパラメーターとして。  
  
 詳細については、[Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/ja-jp/093a7169-a04e-4638-b08c-d1cb98aa650d) および [Preserving White Space While Serializing](http://msdn.microsoft.com/ja-jp/fb146217-0a49-4efc-ac84-7265b91d3939) を参照してください。  
  
   
  
## 例  
 次の例では、このメソッドの 2 つの使用を示します。 最初に使用するには、空白が保持されます。 2 つ目のシリアル化、 <xref:System.Xml.Linq.XElement> 書式を設定しています。  
  
```csharp  
  
                string str;  
XElement root = XElement.Parse(@"<Root> <Child> Text </Child> </Root>");  
  
root.Save("Root.xml", SaveOptions.DisableFormatting);  
str = File.ReadAllText("Root.xml");  
Console.WriteLine(str);  
  
Console.WriteLine("=====");  
  
root.Save("Root.xml", SaveOptions.None);  
str = File.ReadAllText("Root.xml");  
Console.WriteLine(str);  
```  
  
```vb  
  
                Dim str As String  
Dim root As XElement = <Root><Child> Text </Child></Root>  
  
root.Save("Root.xml", SaveOptions.DisableFormatting)  
str = File.ReadAllText("Root.xml")  
Console.WriteLine(str)  
  
Console.WriteLine("=====")  
  
root.Save("Root.xml", SaveOptions.None)  
str = File.ReadAllText("Root.xml")  
Console.WriteLine(str)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <?xml version="1.0" encoding="utf-8"?><Root><Child> Text </Child></Root>  
=====  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child> Text </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SaveAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.Stream stream, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SaveAsync(System.IO.Stream,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SaveAsync(System.IO.TextWriter,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textWriter">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAttributeValue">
      <MemberSignature Language="C#" Value="public void SetAttributeValue (System.Xml.Linq.XName name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAttributeValue(class System.Xml.Linq.XName name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> を変更する属性の名前を格納しています。</param>
        <param name="value">属性に代入する値。 値の場合、属性が削除された <see langword="null" />します。 値の文字列形式に変換されに割り当てられているのそれ以外の場合、 <see cref="P:System.Xml.Linq.XAttribute.Value" /> 属性のプロパティです。</param>
        <summary>属性の値を設定、属性の追加または属性を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、一連の属性として名前\/値ペアのリストを保持するが簡単に設計されています。 リストを保守する際に、ペアを追加のペアを変更またはペアを削除する必要があります。 属性として存在しない名前指定してこのメソッドを呼び出した場合、このメソッドは、属性を作成します。 既存の属性の名前を渡して、このメソッドを呼び出した場合、このメソッドは、指定した値を属性の値を変更します。 渡した場合 `null` の `value`, 、このメソッドは、属性を削除します。  
  
 このメソッドを発生させる、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
 値は、指定した名前を持つ属性に割り当てられます。 指定した名前を持つ属性が存在しない場合は、新しい属性が追加されます。 値の場合 `null`, 、指定した名前を持つ属性が存在する場合は、削除します。  
  
 詳細については、「[Maintaining Name\/Value Pairs](http://msdn.microsoft.com/ja-jp/fe9798bf-b5e2-4a3c-a86c-7f8638912691)」を参照してください。  
  
   
  
## 例  
 次の例では、属性を持つ要素を作成します。 このメソッドを使用して、属性の内容を置き換えます。  
  
```csharp  
// Create an element with no content.  
XElement root = new XElement("Root");  
  
// Add some name/value pairs.  
root.SetAttributeValue("Att1", 1);  
root.SetAttributeValue("Att2", 2);  
root.SetAttributeValue("Att3", 3);  
Console.WriteLine(root);  
  
// Modify one of the name/value pairs.  
root.SetAttributeValue("Att2", 22);  
Console.WriteLine(root);  
  
// Remove one of the name/value pairs.  
root.SetAttributeValue("Att3", null);  
Console.WriteLine(root);  
```  
  
```vb  
' Create an element with no content.  
Dim root As XElement = <Root/>  
  
' Add some name/value pairs.  
root.SetAttributeValue("Att1", 1)  
root.SetAttributeValue("Att2", 2)  
root.SetAttributeValue("Att3", 3)  
Console.WriteLine(root)  
  
' Modify one of the name/value pairs.  
root.SetAttributeValue("Att2", 22)  
Console.WriteLine(root)  
  
' Remove one of the name/value pairs.  
root.SetAttributeValue("Att3", Nothing)  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root Att1="1" Att2="2" Att3="3" />  
<Root Att1="1" Att2="22" Att3="3" />  
<Root Att1="1" Att2="22" />  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> のインスタンスは、 <see cref="T:System.Xml.Linq.XObject" />です。</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.SetValue(System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SetElementValue">
      <MemberSignature Language="C#" Value="public void SetElementValue (System.Xml.Linq.XName name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetElementValue(class System.Xml.Linq.XName name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> を変更する子要素の名前を格納しています。</param>
        <param name="value">子要素に代入する値。 値の場合、子要素が削除された <see langword="null" />します。 値の文字列形式に変換されに割り当てられているのそれ以外の場合、 <see cref="P:System.Xml.Linq.XElement.Value" /> 子要素のプロパティです。</param>
        <summary>子要素の値の設定、子要素の追加、または子要素の削除を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、一連の子要素として名前\/値ペアのリストを保持するが簡単に設計されています。 リストを保守する際に、ペアを追加のペアを変更またはペアを削除する必要があります。 子要素として存在しない名前指定してこのメソッドを呼び出した場合、このメソッドは、子要素を作成します。 既存の子要素の名前を渡して、このメソッドを呼び出した場合、このメソッドは、指定した値に子要素の値を変更します。 渡した場合 `null` の `value`, 、このメソッドは、子要素を削除します。  
  
 このメソッドは、イベントが発生します。  
  
 値は、指定した名前の最初の子要素に割り当てられます。 指定した名前を持つ子要素が存在しない場合は、新しい子要素が追加されます。 値が null の場合は、指定の名前を持つ最初の子要素、存在する場合は削除されます。  
  
 このメソッドは、指定した子要素に子ノードまたは属性を追加しません。 このメソッドは、任意のオブジェクトから派生した場合に例外をスロー <xref:System.Xml.Linq.XObject> として渡された `value`です。  
  
 詳細については、「[Maintaining Name\/Value Pairs](http://msdn.microsoft.com/ja-jp/fe9798bf-b5e2-4a3c-a86c-7f8638912691)」を参照してください。  
  
   
  
## 例  
 次の例では、子要素を持つ要素を作成します。 このメソッドを使用して、子要素の値を設定します。  
  
```csharp  
// Create an element with no content  
XElement root = new XElement("Root");  
  
// Add some name/value pairs.  
root.SetElementValue("Ele1", 1);  
root.SetElementValue("Ele2", 2);  
root.SetElementValue("Ele3", 3);  
Console.WriteLine(root);  
  
// Modify one of the name/value pairs.  
root.SetElementValue("Ele2", 22);  
Console.WriteLine(root);  
  
// Remove one of the name/value pairs.  
root.SetElementValue("Ele3", null);  
Console.WriteLine(root);  
```  
  
```vb  
' Create an element with no content.  
Dim root As XElement = <Root/>  
  
' Add some name/value pairs.  
root.SetElementValue("Ele1", 1)  
root.SetElementValue("Ele2", 2)  
root.SetElementValue("Ele3", 3)  
Console.WriteLine(root)  
  
' Modify one of the name/value pairs.  
root.SetElementValue("Ele2", 22)  
Console.WriteLine(root)  
  
' Remove one of the name/value pairs.  
root.SetElementValue("Ele3", Nothing)  
Console.WriteLine(root)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
                <Root>  
  <Ele1>1</Ele1>  
  <Ele2>2</Ele2>  
  <Ele3>3</Ele3>  
</Root>  
<Root>  
  <Ele1>1</Ele1>  
  <Ele2>22</Ele2>  
  <Ele3>3</Ele3>  
</Root>  
<Root>  
  <Ele1>1</Ele1>  
  <Ele2>22</Ele2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> のインスタンスは、 <see cref="T:System.Xml.Linq.XObject" />です。</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.SetValue(System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.SetValue(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">この要素に代入する値。 値は、文字列形式に変換されに割り当てられている、 <see cref="P:System.Xml.Linq.XElement.Value" /> プロパティです。</param>
        <summary>現在の要素の値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを発生させる、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
 派生したクラスのインスタンスを渡すことはできません <xref:System.Xml.Linq.XObject>, など <xref:System.Xml.Linq.XElement>します。  
  
   
  
## 例  
 次の例では、子要素が含まれる要素を作成します。 このメソッドを使用して要素の値を設定します。  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child", "child content")  
);  
root.SetValue("new content");  
Console.WriteLine(root);  
```  
  
```vb  
  
                Dim root As XElement = _   
        <Root>  
            <Child>child content</Child>  
        </Root>  
  
root.SetValue("new content")  
Console.WriteLine(root)  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
<Root>new content</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> は、 <see cref="T:System.Xml.Linq.XObject" />です。</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.SetValue(System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このオブジェクトの XML 表現を記述する XML スキーマ定義を取得します。</summary>
        <returns>
          <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> メソッドによって生成され、<see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> メソッドによって処理されるオブジェクトの XML 表現を記述する <see cref="T:System.Xml.Schema.XmlSchema" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの実装の一部である、 <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスです。  
  
 このメソッドは、LINQ には to XML オブジェクトが含まれているオブジェクト グラフをシリアル化するために、内部的に使用されます。 LINQ to XML オブジェクトを含むオブジェクト グラフをシリアル化の例は、次を参照してください。 [Serializing Object Graphs that Contain XElement or XDocument Objects](http://msdn.microsoft.com/ja-jp/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> 、オブジェクトが逆シリアル化します。</param>
        <summary>オブジェクトの XML 表現からオブジェクトを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドの実装の一部である、 <xref:System.Xml.Serialization.IXmlSerializable> インターフェイスです。  
  
 このメソッドは、LINQ には to XML オブジェクトが含まれているオブジェクト グラフをシリアル化するために、内部的に使用されます。 LINQ to XML オブジェクトを含むオブジェクト グラフをシリアル化の例は、次を参照してください。 [Serializing Object Graphs that Contain XElement or XDocument Objects](http://msdn.microsoft.com/ja-jp/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> このオブジェクトがシリアル化します。</param>
        <summary>オブジェクトを XML 表現に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、LINQ には to XML オブジェクトが含まれているオブジェクト グラフをマーシャ リングするために、内部的に使用されます。 LINQ to XML オブジェクトを含むオブジェクト グラフをシリアル化の例は、次を参照してください。 [Serializing Object Graphs that Contain XElement or XDocument Objects](http://msdn.microsoft.com/ja-jp/443d7904-a6f0-450a-b1a4-5d7ed869d1d5)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XElement.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の連結されたテキスト コンテンツを取得または設定します。</summary>
        <value>A <see cref="T:System.String" /> すべてこの要素のテキスト コンテンツを格納しています。 複数のテキスト ノードがある場合は、連結されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを使用して、取得または要素の値を設定します。  
  
 このプロパティは生成の設定、 <xref:System.Xml.Linq.XObject.Changed> と <xref:System.Xml.Linq.XObject.Changing> イベントです。  
  
 明示的な変換演算子を使用するなど、要素を null 許容型に割り当てる方が便利ですが存在することを確認されない要素の値を取得するコンピュータが場合、 `string` または <xref:System.Nullable%601> の <xref:System.Int32>です。 Null 許容型に設定されている要素が存在しない場合 `null`します。 これに対し、このプロパティを使用する場合は、するように注意してください、 <xref:System.Xml.Linq.XContainer.Element%2A> メソッドは返しません `null` このプロパティにアクセスする前にします。  
  
   
  
## 例  
 次の例では、このプロパティを使用して、混合コンテンツを持つ要素のテキストを取得します。  
  
```csharp  
  
                XElement el = XElement.Parse("<Root>This is <b>mixed</b> content</Root>");  
Console.WriteLine("{0}", el.Value);  
```  
  
```vb  
  
                Dim el As XElement = <Root>This is <b>mixed</b> content</Root>  
Console.WriteLine("{0}", el.Value)  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```  
  
This is mixed content  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> にこのメソッドが作成されます。</param>
        <summary>この要素を書き込み、 <see cref="T:System.Xml.XmlWriter" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例を記述する方法を示しています、 <xref:System.Xml.Linq.XElement> に、 <xref:System.Xml.XmlWriter>です。 この例が、XML 宣言を作成していないことに注意してください。  
  
```csharp  
  
                StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    xw.WriteStartElement("Root");  
  
    XElement child1 = new XElement("Child",  
        new XElement("GrandChild", "some content")  
    );  
    child1.WriteTo(xw);  
  
    XElement child2 = new XElement("AnotherChild",  
        new XElement("GrandChild", "different content")  
    );  
    child2.WriteTo(xw);  
  
    xw.WriteEndElement();  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
  
                Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    xw.WriteStartElement("Root")  
    Dim child1 As XElement = _  
        <Child>  
            <GrandChild>some content</GrandChild>  
        </Child>  
    child1.WriteTo(xw)  
    Dim child2 As XElement = _   
        <AnotherChild>  
            <GrandChild>different content</GrandChild>  
        </AnotherChild>  
    child2.WriteTo(xw)  
    xw.WriteEndElement()  
End Using  
  
Console.WriteLine(sb.ToString())  
  
```  
  
 この例を実行すると、次の出力が生成されます。  
  
```xml  
  
                <Root>  
  <Child>  
    <GrandChild>some content</GrandChild>  
  </Child>  
  <AnotherChild>  
    <GrandChild>different content</GrandChild>  
  </AnotherChild>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XElement.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>負荷、 <see cref="T:System.Xml.Linq.XElement" /> から XML を含む文字列、必要に応じて、空白の維持および保持する行情報。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素の基になる XML ツリーをシリアル化します。 出力は、ファイルに保存できます、 <see cref="T:System.Xml.XmlTextWriter" />, 、 <see cref="T:System.IO.TextWriter" />, 、または <see cref="T:System.Xml.XmlWriter" />です。 必要に応じて、書式設定 \(インデント\) を無効にできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>