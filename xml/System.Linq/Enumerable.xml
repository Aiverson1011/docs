<Type Name="Enumerable" FullName="System.Linq.Enumerable">
  <TypeSignature Language="C#" Value="public static class Enumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Enumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Enumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>セットを提供 <see langword="static" /> \(<see langword="Shared" /> Visual basic\) を実装するオブジェクトをクエリするためメソッド <see cref="T:System.Collections.Generic.IEnumerable`1" />します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 このクラスのメソッドは、その実装をソース データを照会するために標準クエリ演算子の実装を提供 <xref:System.Collections.Generic.IEnumerable%601>します。 標準クエリ演算子は次の汎用のメソッド、 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] パターンされ、いずれかでデータを走査、フィルター、およびプロジェクション操作を表現することもできます。NET ベースのプログラミング言語です。  
  
 このクラスのメソッドの大部分を拡張する拡張メソッドとして定義されている <xref:System.Collections.Generic.IEnumerable%601>します。 つまりを実装する任意のオブジェクトのインスタンス メソッドと同様に呼び出すことができる <xref:System.Collections.Generic.IEnumerable%601>です。  
  
 値のシーケンスを返すクエリで使用されるメソッドは、クエリ オブジェクトが列挙されるまでターゲット データを消費しません。 これは、遅延実行と呼ばれます。 シングルトン値を返すクエリで使用するメソッドを実行し、ターゲット データをすぐに使用します。  
  
   
  
## 例  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 集計対象にします。</param>
        <param name="func">各要素に対して呼び出すアキュムレータ関数。</param>
        <summary>シーケンスにアキュムレータ関数を適用します。</summary>
        <returns>最終的なアキュムレータ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> メソッドでは、一連の値に対して計算を実行する単純なです。 このメソッドを呼び出すことで機能 `func` の各要素に対して 1 回 `source`最初の 1 つを除きます。 毎回 `func` が呼び出されると、 <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> 、両方の要素のシーケンスと集計値を渡します \(1 番目の引数として `func`\)。 最初の要素 `source` は最初の集計値として使用します。 結果 `func` 以前の集計値が置き換えられます。<xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> 最終的な結果を返す `func`します。  
  
 このオーバー ロード、 <xref:System.Linq.Enumerable.Aggregate%2A>methodisn't の最初の要素を使用してすべての casesbecause に適した `source` 最初の集計値として。 戻り値での要素のみを含める場合は、別のオーバー ロードを選択してください `source` 、特定の条件に一致します。 たとえば、このオーバー ロードに偶数の合計を計算する reliableif `source`します。 結果は最初の要素があってもではなく奇数の場合は正しくなります。  
  
 一般的な集計操作を簡略化標準クエリ演算子も含める汎用 count メソッドでは、 <xref:System.Linq.Enumerable.Count%2A>, 、および 4 つの数値の集計メソッドつまり <xref:System.Linq.Enumerable.Min%2A>, 、<xref:System.Linq.Enumerable.Max%2A>, 、<xref:System.Linq.Enumerable.Sum%2A>, 、および <xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## 例  
 次のコード例を使用して、文字列内の単語の順序を反転<xref:System.Linq.Enumerable.Aggregate%2A>します。  
  
 [!code-csharp[System.Linq.Enumerable\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#1)]
 [!code-vb[System.Linq.Enumerable\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="func" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TAccumulate">アキュムレータ値の型。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 集計対象にします。</param>
        <param name="seed">最初のアキュムレータ値。</param>
        <param name="func">各要素に対して呼び出すアキュムレータ関数。</param>
        <summary>シーケンスにアキュムレータ関数を適用します。 指定されたシード値が最初のアキュムレータ値として使用されます。</summary>
        <returns>最終的なアキュムレータ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> メソッドでは、一連の値に対して計算を実行する単純なです。 このメソッドを呼び出すことで機能 `func` の各要素に対して 1 回 `source`します。 毎回 `func` が呼び出されると、 <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> 、両方の要素のシーケンスと集計値を渡します \(1 番目の引数として `func`\)。 値、 `seed` パラメーターは最初の集計値として使用します。 結果 `func` 以前の集計値が置き換えられます。<xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> 最終的な結果を返す `func`します。  
  
 一般的な集計操作を簡略化標準クエリ演算子も含める汎用 count メソッドでは、 <xref:System.Linq.Enumerable.Count%2A>, 、および 4 つの数値の集計メソッドつまり <xref:System.Linq.Enumerable.Min%2A>, 、<xref:System.Linq.Enumerable.Max%2A>, 、<xref:System.Linq.Enumerable.Sum%2A>, 、および <xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Aggregate%2A> をアキュムレータ関数を適用し、シード値を使用します。  
  
 [!code-csharp[System.Linq.Enumerable\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#2)]
 [!code-vb[System.Linq.Enumerable\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="func" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TAccumulate">アキュムレータ値の型。</typeparam>
        <typeparam name="TResult">結果の値の型。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 集計対象にします。</param>
        <param name="seed">最初のアキュムレータ値。</param>
        <param name="func">各要素に対して呼び出すアキュムレータ関数。</param>
        <param name="resultSelector">最終的なアキュムレータ値を結果値に変換する関数。</param>
        <summary>シーケンスにアキュムレータ関数を適用します。 指定したシード値は最初のアキュムレータ値として使用され、指定した関数は結果値の選択に使用されます。</summary>
        <returns>変換された最終的なアキュムレータ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29> メソッドでは、一連の値に対して計算を実行する単純なです。 このメソッドを呼び出すことで機能 `func` の各要素に対して 1 回 `source`します。 毎回 `func` が呼び出されると、 <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29> 、両方の要素のシーケンスと集計値を渡します \(1 番目の引数として `func`\)。 値、 `seed` パラメーターは最初の集計値として使用します。 結果 `func` 以前の集計値が置き換えられます。 最終的な結果 `func` に渡される `resultSelector` の最終的な結果を取得する <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>です。  
  
 一般的な集計操作を簡略化標準クエリ演算子も含める汎用 count メソッドでは、 <xref:System.Linq.Enumerable.Count%2A>, 、および 4 つの数値の集計メソッドつまり <xref:System.Linq.Enumerable.Min%2A>, 、<xref:System.Linq.Enumerable.Max%2A>, 、<xref:System.Linq.Enumerable.Sum%2A>, 、および <xref:System.Linq.Enumerable.Average%2A>です。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Aggregate%2A> アキュムレータ関数と結果のセレクターを適用します。  
  
 [!code-csharp[System.Linq.Enumerable\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#3)]
 [!code-vb[System.Linq.Enumerable\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="func" />、または <paramref name="resultSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 述語を適用する要素を格納します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>シーケンスのすべての要素が条件を満たすかどうかを決定します。</summary>
        <returns>
          <see langword="true" /> ソース シーケンスのすべての要素を指定の述語で、テストに合格している場合、または、シーケンスが空です。それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  このメソッドは、コレクションのすべての要素を返しません。 代わりに、コレクションのすべての要素が条件を満たすかどうかを決定します。  
  
 列挙体 `source` 、結果を特定すると、すぐに停止します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into All()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.All%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.All%2A> シーケンス内のすべての要素が条件を満たすかどうかを決定します。 変数 `allStartWithB` true は、すべてのペットの名前が"B"で開始する場合、または場合、 `pets` 配列が空です。  
  
 [!code-csharp[System.Linq.Enumerable\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#4)]
 [!code-vb[System.Linq.Enumerable\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#4)]  
  
 ブール値を <xref:System.Linq.Enumerable.All%2A> メソッドは、通常の述語で使用を返します、 `where` 句 \(`Where` 句 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) またはへの直接呼び出し、 <xref:System.Linq.Enumerable.Where%2A> メソッドです。 次の例では、このように使用する、 `All` メソッドです。  
  
 [!code-csharp[System.Linq.Enumerable\#129](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#129)]
 [!code-vb[System.Linq.Enumerable\#129](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#129)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 空かを確認します。</param>
        <summary>シーケンスがすべての要素を含めるかどうかを決定します。</summary>
        <returns>
          <see langword="true" /> ソース シーケンスには、すべての要素が含まれている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  このメソッドは、コレクションの要素のいずれかを返しません。 代わりに、すべての要素がコレクションに含まれるかどうかを決定します。  
  
 列挙体 `source` 、結果を特定すると、すぐに停止します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Any()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Any%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Any%2A> に任意の要素がシーケンスに含まれるかどうかを確認します。  
  
 [!code-csharp[System.Linq.Enumerable\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#5)]
 [!code-vb[System.Linq.Enumerable\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#5)]  
  
 ブール値を <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドは、通常の述語で使用を返します、 `where` 句 \(`Where` 句 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) またはへの直接呼び出し、 <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> メソッドです。 次の例では、このように使用する、 `Any` メソッドです。  
  
 [!code-csharp[System.Linq.Enumerable\#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#130)]
 [!code-vb[System.Linq.Enumerable\#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 述語を適用する要素を格納します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>シーケンスの任意の要素が条件を満たすかどうかを決定します。</summary>
        <returns>
          <see langword="true" /> ソース シーケンス内の各要素では、テストを指定した述語に渡す場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  このメソッドは、コレクションの要素のいずれかを返しません。 代わりに、コレクションのすべての要素が条件を満たすかどうかを決定します。  
  
 列挙体 `source` 、結果を特定すると、すぐに停止します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Any()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Any%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Any%2A> シーケンス内の任意の要素が条件を満たすかどうかを決定します。  
  
 [!code-csharp[System.Linq.Enumerable\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#6)]
 [!code-vb[System.Linq.Enumerable\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">入力シーケンス <see cref="T:System.Collections.Generic.IEnumerable`1" />します。</param>
        <summary>として型指定された入力返す <see cref="T:System.Collections.Generic.IEnumerable`1" />します。</summary>
        <returns>として型指定された入力シーケンス <see cref="T:System.Collections.Generic.IEnumerable`1" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドも何も起こりません以外のコンパイル時の型を変更する `source` を実装する型から <xref:System.Collections.Generic.IEnumerable%601> に <xref:System.Collections.Generic.IEnumerable%601> 自体です。  
  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> シーケンスを実装すると、クエリの実装のどちらかを選択することできます <xref:System.Collections.Generic.IEnumerable%601> も使用可能なパブリック クエリ メソッドの別のセットを持ちます。 たとえば、ジェネリック クラスを指定 `Table` を実装する <xref:System.Collections.Generic.IEnumerable%601> 、独自のメソッドのなど `Where`, 、`Select`, 、および `SelectMany`, への呼び出し `Where` は起動して、パブリック `Where` メソッドの `Table`です。 A `Table` をデータベース テーブルを表す型でしたが、 `Where`式ツリーとして表された述語の引数を受け取り、リモート実行ツリーを SQL に変換するメソッドです。 リモート実行が必要ない場合、たとえば、述語には、ローカルのメソッドが呼び出されて、 <xref:System.Linq.Enumerable.AsEnumerable%2A> メソッドは、独自のメソッドを非表示にし、代わりに、標準クエリ演算子を使用するために使用できます。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> の型を非表示にするカスタム `Where` メソッドは、標準クエリ演算子の実装を必要とします。  
  
 [!code-csharp[System.Linq.Enumerable\#108](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#108)]
 [!code-vb[System.Linq.Enumerable\#108](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#108)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Decimal" /> 値の平均を計算します。</param>
        <summary>一連の平均値を計算 <see cref="T:System.Decimal" /> 値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> 値のシーケンスの平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Double" /> 値の平均を計算します。</param>
        <summary>一連の平均値を計算 <see cref="T:System.Double" /> 値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素の合計が大きすぎてとして表すかどうか、 <xref:System.Double>, 、このメソッドには、正または負の無限大が返されます。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Int32" /> 値の平均を計算します。</param>
        <summary>一連の平均値を計算 <see cref="T:System.Int32" /> 値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> 平均を計算します。  
  
 [!code-csharp[System.Linq.Enumerable\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Int64" /> 値の平均を計算します。</param>
        <summary>一連の平均値を計算 <see cref="T:System.Int64" /> 値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Decimal" /> 値の平均を計算します。</param>
        <summary>Null 許容型のシーケンスの平均を計算 <see cref="T:System.Decimal" /> 値。</summary>
        <returns>値のシーケンスの平均値、または <see langword="null" /> ソース シーケンスが空かは値のみを含むかどうか <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例を使用して <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計を超える <see cref="F:System.Decimal.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Double" /> 値の平均を計算します。</param>
        <summary>Null 許容型のシーケンスの平均を計算 <see cref="T:System.Double" /> 値。</summary>
        <returns>値のシーケンスの平均値、または <see langword="null" /> ソース シーケンスが空かは値のみを含むかどうか <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素の合計が大きすぎてとして表すかどうか、 <xref:System.Double>, 、このメソッドには、正または負の無限大が返されます。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例を使用して <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">平均を計算する Null 許容型の <see cref="T:System.Int32" /> 値のシーケンス。</param>
        <summary>Null 許容型の <see cref="T:System.Int32" /> 値のシーケンスの平均を計算します。</summary>
        <returns>値のシーケンスの平均値、または、ソース シーケンスが空または <see langword="null" /> である値のみを含む場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 In [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] query expression syntax, an `Aggregate Into Average()` clause translates to an invocation of <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## 例  
 The following code example demonstrates how to use <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> to calculate an average.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計は <see cref="F:System.Int64.MaxValue" /> を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Int64" /> 値の平均を計算します。</param>
        <summary>Null 許容型のシーケンスの平均を計算 <see cref="T:System.Int64" /> 値。</summary>
        <returns>値のシーケンスの平均値、または <see langword="null" /> ソース シーケンスが空かは値のみを含むかどうか <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例を使用して <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> 平均を計算します。  
  
 [!code-csharp[System.Linq.Enumerable\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計を超える <see cref="F:System.Int64.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Single" /> 値の平均を計算します。</param>
        <summary>Null 許容型のシーケンスの平均を計算 <see cref="T:System.Single" /> 値。</summary>
        <returns>値のシーケンスの平均値、または <see langword="null" /> ソース シーケンスが空かは値のみを含むかどうか <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例を使用して <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Single" /> 値の平均を計算します。</param>
        <summary>一連の平均値を計算 <see cref="T:System.Single" /> 値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">平均値の計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>一連の平均値を計算 <see cref="T:System.Decimal" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計を超える <see cref="F:System.Decimal.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>一連の平均値を計算 <see cref="T:System.Double" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>一連の平均値を計算 <see cref="T:System.Int32" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 平均を計算します。  
  
 [!code-csharp[System.Linq.Enumerable\#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable\#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計を超える <see cref="F:System.Int64.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">source の要素の型。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>一連の平均値を計算 <see cref="T:System.Int64" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> 平均を計算します。  
  
 [!code-csharp[System.Linq.Enumerable\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計を超える <see cref="F:System.Int64.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容型のシーケンスの平均を計算 <see cref="T:System.Decimal" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値、または <see langword="null" /> ソース シーケンスが空かは値のみを含むかどうか <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計を超える <see cref="F:System.Decimal.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容型のシーケンスの平均を計算 <see cref="T:System.Double" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値、または <see langword="null" /> ソース シーケンスが空かは値のみを含むかどうか <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容型のシーケンスの平均を計算 <see cref="T:System.Int32" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値、または <see langword="null" /> ソース シーケンスが空かは値のみを含むかどうか <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable\#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">シーケンス内の要素の合計を超える <see cref="F:System.Int64.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容型のシーケンスの平均を計算 <see cref="T:System.Int64" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値、または <see langword="null" /> ソース シーケンスが空かは値のみを含むかどうか <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable\#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容型のシーケンスの平均を計算 <see cref="T:System.Single" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値、または <see langword="null" /> ソース シーケンスが空かは値のみを含むかどうか <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable\#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">平均を計算する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>一連の平均値を計算 <see cref="T:System.Single" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>値のシーケンスの平均値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Average()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Average%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 平均を計算します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable\#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">要素をキャストする型 <c>source</c> にします。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.IEnumerable" /> 型にキャストする要素を含む <c>TResult</c>します。</param>
        <summary>要素をキャスト、 <see cref="T:System.Collections.IEnumerable" /> 指定した型にします。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 、指定した型にキャストするソース シーケンスの各要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> メソッドが必要な型情報を提供することによって、非ジェネリック コレクションで呼び出される標準クエリ演算子を使用します。 など <xref:System.Collections.ArrayList> は実装しない <xref:System.Collections.Generic.IEnumerable%601>, を呼び出す <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> 上、 <xref:System.Collections.ArrayList> オブジェクトのシーケンスを照会する、標準クエリ演算子を使用し、ことができます。  
  
 要素は、型にキャストできない場合 `TResult`, 、このメソッドは例外をスローします。 型にキャスト可能な要素のみを取得する `TResult`, を使用して、 <xref:System.Linq.Enumerable.OfType%2A> メソッドの代わりに <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>します。  
  
 クエリ式での呼び出しに変換する明示的に型指定された反復変数 <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>します。 この例では、明示的に型指定された範囲変数の構文を使用します。  
  
```csharp  
from int i in objects  
```  
  
```vb  
From i As Integer In objects  
```  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> で標準クエリ演算子の使用を有効にする、 <xref:System.Collections.ArrayList>です。  
  
 [!code-csharp[System.Linq.Enumerable\#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#19)]
 [!code-vb[System.Linq.Enumerable\#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidCastException">シーケンス内の要素は、型にキャストできません <paramref name="TResult" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first">連結する最初のシーケンス。</param>
        <param name="second">最初のシーケンスに連結するシーケンス。</param>
        <summary>2 つのシーケンスを連結します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 2 つの入力シーケンスの連結された要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドとは異なります、 <xref:System.Linq.Enumerable.Union%2A> メソッドのため、 <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドは、入力シーケンスの元のすべての要素を返します。<xref:System.Linq.Enumerable.Union%2A> メソッドは、一意の要素のみを返します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> を 2 つのシーケンスを連結します。  
  
 [!code-csharp[System.Linq.Enumerable\#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#20)]
 [!code-vb[System.Linq.Enumerable\#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#20)]  
  
 コレクション、配列などのシーケンスを作成し、適用する 2 つのシーケンスを連結する方法も、 <xref:System.Linq.Enumerable.SelectMany%2A> id セレクター関数を引数としてメソッドです。 次の例ではこの使用 <xref:System.Linq.Enumerable.SelectMany%2A>します。  
  
 [!code-csharp[System.Linq.Enumerable\#112](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#112)]
 [!code-vb[System.Linq.Enumerable\#112](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">値の検索対象となるシーケンス。</param>
        <param name="value">シーケンス内で検索する値。</param>
        <summary>シーケンスが既定の等値比較子を使用して、指定した要素を含めるかどうかを決定します。</summary>
        <returns>
          <see langword="true" /> ソース シーケンスには、指定した値を持つ要素が含まれている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合の種類 `source` を実装する <xref:System.Collections.Generic.ICollection%601>, 、 `Contains` 結果を取得するその実装でメソッドが呼び出されます。 それ以外の場合、このメソッドを決定するかどうか `source` 指定した要素が含まれています。  
  
 列挙体は、一致する要素が見つかるとすぐに終了します。  
  
 要素が既定の等値比較子を使用して、指定した値と比較して <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Contains%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> を配列に特定の要素が含まれるかどうかを確認します。  
  
 [!code-csharp[System.Linq.Enumerable\#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#21)]
 [!code-vb[System.Linq.Enumerable\#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">値の検索対象となるシーケンス。</param>
        <param name="value">シーケンス内で検索する値。</param>
        <param name="comparer">値を比較する等値比較子。</param>
        <summary>指定したを使用して指定された要素がシーケンスに含まれているかどうか判断 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />します。</summary>
        <returns>
          <see langword="true" /> ソース シーケンスには、指定した値を持つ要素が含まれている場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 列挙体は、一致する要素が見つかるとすぐに終了します。  
  
 C 場合`omparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、指定された値の要素を比較するために使用します。  
  
   
  
## 例  
 次の例で使用する等値比較子を実装する方法を示しています、 <xref:System.Linq.Enumerable.Contains%2A> メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer\#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装すると後のシーケンスを使用することができます `Product` 内のオブジェクト、 <xref:System.Linq.Enumerable.Contains%2A> メソッドを次の例に示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer\#6](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#6)]
 [!code-vb[CSLINQCustomComparer\#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">カウントする要素が格納されているシーケンス。</param>
        <summary>シーケンス内の要素の数を返します。</summary>
        <returns>入力シーケンス内の要素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合のタイプ `source` 実装 <xref:System.Collections.Generic.ICollection%601>, 、その実装を使用して、数の要素を取得します。 それ以外の場合、このメソッドは、数を決定します。  
  
 使用して、 <xref:System.Linq.Enumerable.LongCount%2A> を超える結果を許可するしている場合は、メソッド <xref:System.Int32.MaxValue>します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Count()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Count%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 配列の要素をカウントします。  
  
 [!code-csharp[System.Linq.Enumerable\#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#22)]
 [!code-vb[System.Linq.Enumerable\#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">要素数 <paramref name="source" /> よりも大きい <see cref="F:System.Int32.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">テストおよびカウントする要素が格納されているシーケンス。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定されたシーケンス内の要素が条件を満たすを表す数値を返します。</summary>
        <returns>述語関数の条件を満たす、シーケンス内の要素数を表す数値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合のタイプ `source` 実装 <xref:System.Collections.Generic.ICollection%601>, 、その実装を使用して、数の要素を取得します。 それ以外の場合、このメソッドは、数を決定します。  
  
 使用する必要があります、 <xref:System.Linq.Enumerable.LongCount%2A> を超える結果を許可するしている場合は、メソッド <xref:System.Int32.MaxValue>します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Count()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Count%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 配列内の条件に一致する要素をカウントします。  
  
 [!code-csharp[System.Linq.Enumerable\#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#23)]
 [!code-vb[System.Linq.Enumerable\#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">要素数 <paramref name="source" /> よりも大きい <see cref="F:System.Int32.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">シーケンスが空の場合に、既定値を返すシーケンス。</param>
        <summary>シーケンスが空の場合は、シングルトン コレクションに指定されたシーケンスまたは型パラメーターの既定値の要素を返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の既定値を格納しているオブジェクト、 <paramref name="TSource" /> 入力 <paramref name="source" /> 空の場合、それ以外の場合は、 <paramref name="source" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 参照および null 許容型の既定値は `null`です。  
  
 このメソッドと結合されているときに、左外部結合の生成に使用できます、 <xref:System.Linq.Enumerable.GroupJoin%2A>\) メソッドです。  
  
   
  
## 例  
 次のコード例を使用する方法を示します <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> にソース シーケンスが空である場合に、既定値を指定します。  
  
 この例では、空のシーケンスを使用します。  
  
 [!code-csharp[System.Linq.Enumerable\#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#24)]
 [!code-vb[System.Linq.Enumerable\#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#24)]  
  
 この例では、空のシーケンスを使用します。  
  
 [!code-csharp[System.Linq.Enumerable\#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#25)]
 [!code-vb[System.Linq.Enumerable\#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">シーケンスが空の場合に、指定された値を返すシーケンス。</param>
        <param name="defaultValue">シーケンスが空の場合に返す値。</param>
        <summary>シーケンスが空の場合は、シングルトン コレクションに指定されたシーケンスまたは指定した値の要素を返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を含む <paramref name="defaultValue" /> 場合 <paramref name="source" /> 空の場合、それ以外の場合は、 <paramref name="source" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 このメソッドと結合されているときに、左外部結合の生成に使用できます、 <xref:System.Linq.Enumerable.GroupJoin%2A>\) メソッドです。  
  
   
  
## 例  
 次のコード例では、使用して、 <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> メソッド、既定値を指定します。 最初のシーケンスが空でない、2 番目のシーケンスが空です。  
  
 [!code-csharp[System.Linq.Enumerable\#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#26)]
 [!code-vb[System.Linq.Enumerable\#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シーケンスから一意の要素を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 結果のシーケンスが順序付きではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">重複する要素を削除する対象となるシーケンス。</param>
        <summary>値を比較する既定の等値比較子を使用して、シーケンスから一意の要素を返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> ソース シーケンスから一意の要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドは、重複する値が含まれていない順序なしのシーケンスを返します。 既定の等値比較子を使用して <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Distinct` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Distinct%2A>します。  
  
 既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、実装する型の値を比較に使用される、 <xref:System.IEquatable%601> ジェネリック インターフェイスです。 カスタム データ型を比較する必要がありますこのインターフェイスを実装でき、独自 <xref:System.Object.GetHashCode%2A> と <xref:System.Object.Equals%2A> の型のメソッドです。  
  
 使用例について <xref:System.Collections.Generic.IEqualityComparer%601>カスタム比較子を定義するを参照してください。 <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> を整数のシーケンスから一意の要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#27)]
 [!code-vb[System.Linq.Enumerable\#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#27)]  
  
 実装する必要があるいくつかのカスタム データ型のオブジェクトのシーケンスから一意の要素を返す場合は、 <xref:System.IEquatable%601> クラスのジェネリック インターフェイスです。 カスタム データ型にこのインターフェイスを実装でき、次のコード例に示します <xref:System.Object.GetHashCode%2A> と <xref:System.Object.Equals%2A> メソッドです。  
  
 [!code-csharp[CSLINQEncapsulatedComparer\#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#1)]
 [!code-vb[CSLINQEncapsulatedComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#1)]  
  
 このインターフェイスを実装した後のシーケンスを使用することができます `Product` 内のオブジェクト、 <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドを次の例に示すようにします。  
  
 [!code-csharp[CSLINQEncapsulatedComparer\#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#5)]
 [!code-vb[CSLINQEncapsulatedComparer\#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">重複する要素を削除する対象となるシーケンス。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 値を比較します。</param>
        <summary>指定したを使用してシーケンスから一意の要素を返します <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 値を比較します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> ソース シーケンスから一意の要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> メソッドは、重複する値が含まれていない順序なしのシーケンスを返します。 C 場合`omparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、値を比較するために使用します。  
  
   
  
## 例  
 次の例で使用する等値比較子を実装する方法を示しています、 <xref:System.Linq.Enumerable.Distinct%2A> メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer\#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装すると後のシーケンスを使用することができます `Product` 内のオブジェクト、 <xref:System.Linq.Enumerable.Distinct%2A> メソッドを次の例に示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer\#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#5)]
 [!code-vb[CSLINQCustomComparer\#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> から要素を返します。</param>
        <param name="index">取得する要素の、0 から始まるインデックス。</param>
        <summary>シーケンスの指定したインデックス位置にある要素を返します。</summary>
        <returns>ソース シーケンス内の指定された位置にある要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合の種類 `source` 実装 <xref:System.Collections.Generic.IList%601>, 、その実装を使用して、指定したインデックス位置にある要素を入手します。 それ以外の場合、このメソッドは、指定した要素を取得します。  
  
 このメソッドは例外をスロー `index` が範囲外です。 指定したインデックスが範囲外にある場合に、既定値を返すを使用して、 <xref:System.Linq.Enumerable.ElementAtOrDefault%2A> メソッドです。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.ElementAt%2A> 特定の位置に要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#28)]
 [!code-vb[System.Linq.Enumerable\#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小さい 0 またはより大きいか内の要素の数と等しく <paramref name="source" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> から要素を返します。</param>
        <param name="index">取得する要素の、0 から始まるインデックス。</param>
        <summary>シーケンス内の指定したインデックス位置にある要素を返します。インデックスが範囲外の場合は既定値を返します。</summary>
        <returns>
          <see langword="default" />\(<paramref name="TSource" />\) インデックスがソース シーケンスの範囲外にある場合、それ以外の場合、ソース シーケンスで指定した位置にある要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合の種類 `source` 実装 <xref:System.Collections.Generic.IList%601>, 、その実装を使用して、指定したインデックス位置にある要素を入手します。 それ以外の場合、このメソッドは、指定した要素を取得します。  
  
 参照および null 許容型の既定値は `null`です。  
  
   
  
## 例  
 <xref:System.Linq.Enumerable.ElementAtOrDefault%2A> を使用する方法を次のコード例に示します。 この例では、配列の境界外にあるインデックスを使用します。  
  
 [!code-csharp[System.Linq.Enumerable\#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#29)]
 [!code-vb[System.Linq.Enumerable\#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Empty``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">返されるジェネリック型パラメーターに割り当てる型 <see cref="T:System.Collections.Generic.IEnumerable`1" />します。</typeparam>
        <summary>空白を返します <see cref="T:System.Collections.Generic.IEnumerable`1" /> を持つ指定した型引数。</summary>
        <returns>空 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 、型引数が <paramref name="TResult" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Empty%60%601> メソッドは型の空のシーケンスをキャッシュ `TResult`します。 返されるオブジェクトを列挙すると、要素は生成されません。  
  
 場合によっては、このメソッドは、ユーザー定義のメソッドに空のシーケンスを渡すことは、 <xref:System.Collections.Generic.IEnumerable%601>です。 などのメソッドに対応する中立的な要素の生成に使用することもできます <xref:System.Linq.Enumerable.Union%2A>します。 このように使用する例について例を参照してください <xref:System.Linq.Enumerable.Empty%60%601>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Empty%60%601> 空を生成する <xref:System.Collections.Generic.IEnumerable%601>です。  
  
 [!code-csharp[System.Linq.Enumerable\#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#30)]
 [!code-vb[System.Linq.Enumerable\#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#30)]  
  
 次のコード例に示しますの可能性のあるアプリケーション、 <xref:System.Linq.Enumerable.Empty%60%601> メソッドです。<xref:System.Linq.Enumerable.Aggregate%2A> メソッドは文字列配列のコレクションに適用します。 コレクション内の各配列の要素、その結果に追加されます <xref:System.Collections.Generic.IEnumerable%601> その配列には、次の 4 つまたは複数の要素が含まれている場合のみです。<xref:System.Linq.Enumerable.Empty%2A> シード値を生成するために使用 <xref:System.Linq.Enumerable.Aggregate%2A> ため、コレクション内の配列に 4 つまたは複数の要素が存在しない場合、空のシーケンスだけが返されます。  
  
 [!code-csharp[System.Linq.Enumerable\#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#31)]
 [!code-vb[System.Linq.Enumerable\#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 含まれていない要素が <c>second</c> が返されます。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> それらの要素が返されるシーケンスから削除すると、最初のシーケンスでも発生する要素を格納します。</param>
        <summary>既定の等値比較子を使用して値を比較することには、2 つのシーケンスの差集合を生成します。</summary>
        <returns>2 つのシーケンスの要素の差集合が格納されているシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 2 つの差集合は、2 番目のセットに記載されていない最初のセットのメンバーとして定義されます。  
  
> [!NOTE]
>  このメソッドは、これらの要素を返します。 `first` にいないと思われる `second`です。 これらの要素にも返されません `second` にいないと思われる `first`です。  
  
 既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、実装する型の値を比較に使用される、 <xref:System.Collections.Generic.IEqualityComparer%601> ジェネリック インターフェイスです。 カスタム データ型を比較する必要がありますこのインターフェイスを実装でき、独自 <xref:System.Object.GetHashCode%2A> と <xref:System.Object.Equals%2A> の型のメソッドです。  
  
   
  
## 例  
 次のコード例を使用して、 <xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> を 2 つの数値のシーケンスを比較し、要素を返すメソッドが最初のシーケンスにのみ表示されます。  
  
 [!code-csharp[System.Linq.Enumerable\#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#34)]
 [!code-vb[System.Linq.Enumerable\#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#34)]  
  
 実装する必要があるいくつかのカスタム データ型のオブジェクトのシーケンスを比較する場合、 <xref:System.Collections.Generic.IEqualityComparer%601> 、helperclass でジェネリック インターフェイスです。 カスタム データ型にこのインターフェイスを実装でき、次のコード例に示します <xref:System.Object.GetHashCode%2A> と <xref:System.Object.Equals%2A> メソッドです。  
  
 [!code-csharp[CSLINQEncapsulatedComparer\#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 このインターフェイスを実装した後は、シーケンスを使用して `ProductA` 内のオブジェクト、 <xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドを次の例に示すようにします。  
  
 [!code-csharp[CSLINQEncapsulatedComparer\#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#7)]
 [!code-vb[CSLINQEncapsulatedComparer\#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 含まれていない要素が <c>second</c> が返されます。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> それらの要素が返されるシーケンスから削除すると、最初のシーケンスでも発生する要素を格納します。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 値を比較します。</param>
        <summary>指定されたを使用して 2 つのシーケンスの差集合を生成 <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 値を比較します。</summary>
        <returns>2 つのシーケンスの要素の差集合が格納されているシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 C 場合`omparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、値を比較するために使用します。  
  
   
  
## 例  
 次の例で使用する等値比較子を実装する方法を示しています、 <xref:System.Linq.Enumerable.Except%2A> メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer\#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装した後は、シーケンスを使用して `Product` 内のオブジェクト、 <xref:System.Linq.Enumerable.Except%2A> メソッドを次の例に示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer\#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#7)]
 [!code-vb[CSLINQCustomComparer\#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の最初の要素を返します。</param>
        <summary>シーケンスの最初の要素を返します。</summary>
        <returns>指定されたシーケンスの最初の要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 場合、メソッドが例外をスロー `source` 要素が含まれていません。 ソース シーケンスが空の場合は、既定値を返す代わりを使用して、 <xref:System.Linq.Enumerable.FirstOrDefault%2A> メソッドです。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> を配列の最初の要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#35)]
 [!code-vb[System.Linq.Enumerable\#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">ソース シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> から要素を返します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定された条件を満たす、シーケンスの最初の要素を返します。</summary>
        <returns>指定された述語関数でテストに合格する、シーケンスの最初の要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> で一致する要素が見つからない場合、メソッドが例外をスロー `source`します。 一致する要素が見つからない場合に、既定値を返すを使用して、 <xref:System.Linq.Enumerable.FirstOrDefault%2A> メソッドです。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 条件を満たす、配列の最初の要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#36)]
 [!code-vb[System.Linq.Enumerable\#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">条件を満たす要素がない <paramref name="predicate" />します。  
  
 または  
  
 ソース シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の最初の要素を返します。</param>
        <summary>シーケンスの最初の要素を返します。シーケンスに要素が含まれていない場合は既定値を返します。</summary>
        <returns>
          <see langword="default" />\(<paramref name="TSource" />\) 場合 <paramref name="source" /> が空の場合、それ以外の場合の最初の要素 <paramref name="source" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 参照および null 許容型の既定値は `null`です。  
  
 <xref:System.Linq.Enumerable.FirstOrDefault%2A> メソッドは、既定値を指定する方法を提供していません。 以外の場合、既定値を指定する場合は、 `default`\(`TSource`\) を使用して、 <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> 例」のセクションで説明するメソッドです。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> に空の配列。  
  
 [!code-csharp[System.Linq.Enumerable\#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#37)]
 [!code-vb[System.Linq.Enumerable\#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#37)]  
  
 値も `default`\(`TSource`\) が、コレクションに要素が含まれていない場合に使用する既定値はありません。 不要な既定値の結果をチェックし、必要に応じてを変更して、代わりに使用することができます、 <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> コレクションが空の場合に使用する既定値を指定します。 次に、呼び出す <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> を最初の要素を取得します。 次のコード例では、両方の手法を使用して、月を表す数値のコレクションが空の場合は、1 の既定値を取得します。 整数の既定値が 0 で、任意の月に対応していないであるため既定値必要があります 1 として代わりに指定します。 クエリの実行が完了した後、不要な既定値の最初の結果変数がチェックされます。 使用して 2 つ目の結果変数が取得 <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> を既定値は 1 を指定します。  
  
 [!code-csharp[System.Linq.Enumerable\#126](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#126)]
 [!code-vb[System.Linq.Enumerable\#126](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#126)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> から要素を返します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>条件を満たす、シーケンスの最初の要素を返します。このような要素が見つからない場合は既定値を返します。</summary>
        <returns>
          <see langword="default" />\(<paramref name="TSource" />\) 場合 <paramref name="source" /> が空または要素がで指定されたテストに合格しないかどうかは <paramref name="predicate" />、それ以外の最初の要素 <paramref name="source" /> で指定されたテストに合格した <paramref name="predicate" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 参照および null 許容型の既定値は `null`です。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 述語に渡すことです。 メソッドの 2 番目の呼び出しで要素が存在しない、条件を満たす、配列にします。  
  
 [!code-csharp[System.Linq.Enumerable\#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#38)]
 [!code-vb[System.Linq.Enumerable\#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <summary>指定されたキー セレクター関数に従ってシーケンスの要素をグループ化します。</summary>
        <returns>
          <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> C\# の場合、または <c>IEnumerable(Of IGrouping(Of TKey, TSource))</c> で Visual Basic 、各 <see cref="T:System.Linq.IGrouping`2" /> オブジェクトには、オブジェクトとキーのシーケンスが含まれています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
> [!NOTE]
>  例については `GroupBy`, 、次のトピックを参照してください。  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> メソッドのコレクションを返します <xref:System.Linq.IGrouping%602> オブジェクト、発生した個別のキーごとに 1 つです。<xref:System.Linq.IGrouping%602> は、 <xref:System.Collections.Generic.IEnumerable%601> をもその要素に関連付けられたキーを持ちます。  
  
 <xref:System.Linq.IGrouping%602> 内の要素の順序に基づいて注文でオブジェクトが返されます `source` それぞれの最初のキーを生成する <xref:System.Linq.IGrouping%602>です。 表示されている順序でグループ内の要素が返されます `source`します。  
  
 既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較するために使用します。  
  
 クエリ式の構文で、 `group by` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Group By Into` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.GroupBy%2A>します。 詳細と使用例については、次を参照してください。 [group clause \(C\# Reference\)](http://msdn.microsoft.com/ja-jp/c817242e-b12c-4baa-a57e-73ee138f34d1) と [Group By Clause \(Visual Basic\)](http://msdn.microsoft.com/ja-jp/b1b5dcea-6654-473b-a2db-01f7e4c265d7)です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> キーを比較します。</param>
        <summary>指定された比較子を使用してキーを比較して、指定されたキー セレクター関数に従ってシーケンスの要素をグループ化します。</summary>
        <returns>
          <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> C\# の場合または <c>IEnumerable(Of IGrouping(Of TKey, TSource))</c> で Visual Basic 、各 <see cref="T:System.Linq.IGrouping`2" /> オブジェクトには、オブジェクトとキーのコレクションが含まれています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
> [!NOTE]
>  例については `GroupBy`, 、次のトピックを参照してください。  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> メソッドのコレクションを返します <xref:System.Linq.IGrouping%602> オブジェクト、発生した個別のキーごとに 1 つです。<xref:System.Linq.IGrouping%602> は、 <xref:System.Collections.Generic.IEnumerable%601> をもその要素に関連付けられたキーを持ちます。  
  
 <xref:System.Linq.IGrouping%602> 内の要素の順序に基づいて注文でオブジェクトが返されます `source` それぞれの最初のキーを生成する <xref:System.Linq.IGrouping%602>です。 表示されている順序でグループ内の要素が返されます `source`します。  
  
 場合 `comparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較するために使用します。  
  
 」の手順に従って 2 つのキーが等しい場合 `comparer`, 、最初のキーがそのグループ化キーとして選択します。  
  
 クエリ式の構文で、 `group by` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Group By Into` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.GroupBy%2A>します。 詳細と使用例については、次を参照してください。 [group clause \(C\# Reference\)](http://msdn.microsoft.com/ja-jp/c817242e-b12c-4baa-a57e-73ee138f34d1) と [Group By Clause \(Visual Basic\)](http://msdn.microsoft.com/ja-jp/b1b5dcea-6654-473b-a2db-01f7e4c265d7)です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <typeparam name="TElement">
          <see cref="T:System.Linq.IGrouping`2" /> 内の要素の型。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="elementSelector">各ソース要素を内の要素にマップする関数、 <see cref="T:System.Linq.IGrouping`2" />です。</param>
        <summary>指定されたキー セレクター関数と、指定された関数を使用して各グループの要素を射影に従ってシーケンスの要素をグループ化します。</summary>
        <returns>
          <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> C\# の場合または <c>IEnumerable(Of IGrouping(Of TKey, TElement))</c> で Visual Basic 、各 <see cref="T:System.Linq.IGrouping`2" /> オブジェクトには、型のオブジェクトのコレクションが含まれています。 <paramref name="TElement" /> とキー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> メソッドのコレクションを返します <xref:System.Linq.IGrouping%602> オブジェクト、発生した個別のキーごとに 1 つです。<xref:System.Linq.IGrouping%602> は、 <xref:System.Collections.Generic.IEnumerable%601> をもその要素に関連付けられたキーを持ちます。  
  
 <xref:System.Linq.IGrouping%602> 内の要素の順序に基づいて注文でオブジェクトが返されます `source` それぞれの最初のキーを生成する <xref:System.Linq.IGrouping%602>です。 作成した要素が出現する順序でグループ内の要素が返されます `source`します。  
  
 既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較するために使用します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> シーケンスの要素をグループ化します。  
  
 [!code-csharp[System.Linq.Enumerable\#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#39)]
 [!code-vb[System.Linq.Enumerable\#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#39)]  
  
 クエリ式の構文で、 `group by` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Group By Into` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.GroupBy%2A>します。 次の例では、クエリ式の変換は、上記の例ではクエリと同等です。  
  
 [!code-csharp[System.Linq.Enumerable\#122](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#122)]
 [!code-vb[System.Linq.Enumerable\#122](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#122)]  
  
> [!NOTE]
>  [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] への呼び出しでそれらの引数位置から発生する逆の順序でのクエリ式では、要素およびキーの選択式、 <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <typeparam name="TElement">
          <see cref="T:System.Linq.IGrouping`2" /> 内の要素の型。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="elementSelector">各ソース要素を内の要素にマップする関数、 <see cref="T:System.Linq.IGrouping`2" />です。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> キーを比較します。</param>
        <summary>キー セレクター関数に従ってシーケンスの要素をグループ化します。 キーの比較には、比較子を使用し、各グループの要素の射影には、指定された関数を使用します。</summary>
        <returns>
          <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> C\# の場合または <c>IEnumerable(Of IGrouping(Of TKey, TElement))</c> で Visual Basic 、各 <see cref="T:System.Linq.IGrouping`2" /> オブジェクトには、型のオブジェクトのコレクションが含まれています。 <paramref name="TElement" /> とキー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
> [!NOTE]
>  例については `GroupBy`, 、次のトピックを参照してください。  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> メソッドのコレクションを返します <xref:System.Linq.IGrouping%602> オブジェクト、発生した個別のキーごとに 1 つです。<xref:System.Linq.IGrouping%602> は、 <xref:System.Collections.Generic.IEnumerable%601> をもその要素に関連付けられたキーを持ちます。  
  
 <xref:System.Linq.IGrouping%602> 内の要素の順序に基づいて注文でオブジェクトが返されます `source` それぞれの最初のキーを生成する <xref:System.Linq.IGrouping%602>です。 作成した要素が出現する順序でグループ内の要素が返されます `source`します。  
  
 場合 `comparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較するために使用します。  
  
 」の手順に従って 2 つのキーが等しい場合 `comparer`, 、最初のキーがそのグループ化キーとして選択します。  
  
 クエリ式の構文で、 `group by` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Group By Into` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.GroupBy%2A>します。 詳細と使用例については、次を参照してください。 [group clause \(C\# Reference\)](http://msdn.microsoft.com/ja-jp/c817242e-b12c-4baa-a57e-73ee138f34d1) と [Group By Clause \(Visual Basic\)](http://msdn.microsoft.com/ja-jp/b1b5dcea-6654-473b-a2db-01f7e4c265d7)です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <typeparam name="TResult">によって返される結果の値の型 <c>resultSelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="resultSelector">各グループから結果値を作成する関数。</param>
        <summary>指定されたキー セレクター関数に従ってシーケンスの要素をグループ化し、各グループとそのキーから結果値を作成します。</summary>
        <returns>型の要素のコレクション <paramref name="TResult" /> の各要素が、グループとそのキーを投影を表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クエリ式の構文で、 `group by` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Group By Into` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.GroupBy%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29> シーケンスの要素をグループ化し、プロジェクトの種類の結果のシーケンス `TResult`します。  
  
 [!code-csharp[System.Linq.Enumerable\#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#15)]
 [!code-vb[System.Linq.Enumerable\#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <typeparam name="TResult">によって返される結果の値の型 <c>resultSelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="resultSelector">各グループから結果値を作成する関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> でキーを比較します。</param>
        <summary>指定されたキー セレクター関数に従ってシーケンスの要素をグループ化し、各グループとそのキーから結果値を作成します。 キーの比較には、指定された比較子を使用します。</summary>
        <returns>型の要素のコレクション <paramref name="TResult" /> の各要素が、グループとそのキーを投影を表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <typeparam name="TElement">各要素の型 <see cref="T:System.Linq.IGrouping`2" />します。</typeparam>
        <typeparam name="TResult">によって返される結果の値の型 <c>resultSelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="elementSelector">各ソース要素を内の要素にマップする関数、 <see cref="T:System.Linq.IGrouping`2" />です。</param>
        <param name="resultSelector">各グループから結果値を作成する関数。</param>
        <summary>指定されたキー セレクター関数に従ってシーケンスの要素をグループ化し、各グループとそのキーから結果値を作成します。 各グループの要素は、指定された関数を使用して射影されます。</summary>
        <returns>型の要素のコレクション <paramref name="TResult" /> の各要素が、グループとそのキーを投影を表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クエリ式の構文で、 `group by` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Group By Into` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.GroupBy%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29> シーケンスの射影された要素をグループ化し、次の種類の結果のシーケンスにプロジェクト `TResult`します。  
  
 [!code-csharp[System.Linq.Enumerable\#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#125)]
 [!code-vb[System.Linq.Enumerable\#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#125)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <typeparam name="TElement">各要素の型 <see cref="T:System.Linq.IGrouping`2" />します。</typeparam>
        <typeparam name="TResult">によって返される結果の値の型 <c>resultSelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> をグループ化する要素を格納します。</param>
        <param name="keySelector">各要素のキーを抽出する関数。</param>
        <param name="elementSelector">各ソース要素を内の要素にマップする関数、 <see cref="T:System.Linq.IGrouping`2" />です。</param>
        <param name="resultSelector">各グループから結果値を作成する関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> でキーを比較します。</param>
        <summary>指定されたキー セレクター関数に従ってシーケンスの要素をグループ化し、各グループとそのキーから結果値を作成します。 キー値の比較には、指定された比較子を使用し、各グループの要素の射影には、指定された関数を使用します。</summary>
        <returns>型の要素のコレクション <paramref name="TResult" /> の各要素が、グループとそのキーを投影を表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">最初のシーケンスの要素の型。</typeparam>
        <typeparam name="TInner">2 番目のシーケンスの要素の型。</typeparam>
        <typeparam name="TKey">キー セレクター関数によって返されるキーの型。</typeparam>
        <typeparam name="TResult">結果の要素の型。</typeparam>
        <param name="outer">結合する最初のシーケンス。</param>
        <param name="inner">最初のシーケンスに結合するシーケンス。</param>
        <param name="outerKeySelector">最初のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="innerKeySelector">2 番目のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="resultSelector">最初のシーケンスの要素と、2 番目のシーケンスの一致する要素のコレクションから結果の要素を作成する関数。</param>
        <summary>結果をグループ化キーが等しいかどうかに基づいて 2 つのシーケンスの要素相互に関連付けます。 キーの比較には既定の等値比較子が使用されます。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の要素を含む <paramref name="TResult" /> 2 つのシーケンスをグループ化結合を実行することによって取得されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、ハッシュし、キーを比較するために使用します。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> つまり生成階層的な結果の要素を `outer` 一致する要素のコレクションと組み合わされ、 `inner`です。`GroupJoin` 各要素に一致するもののセット全体の結果を基にでは、 `outer`です。  
  
> [!NOTE]
>  相関関係を持つ要素がない場合 `inner` の指定された要素の `outer`, 、その要素の一致結果のシーケンスが空になりますが、結果に引き続き表示されます。  
  
 `resultSelector` 関数ごとに一度だけ `outer` 要素のすべてのコレクションと共に、 `inner` と一致する要素、 `outer` 要素。 これに対し、 <xref:System.Linq.Enumerable.Join%2A> から 1 つの要素の組に結果のセレクター関数が呼び出されたメソッド `outer` と 1 つの要素から `inner`します。  
  
 `GroupJoin` 要素の順序を維持 `outer`, の各要素に対して `outer`, から一致する要素の順序 `inner`します。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> 従来のリレーショナル データベース用語で直接相当するものを持ちません。 ただし、このメソッドは内部結合と左外部結合のスーパー セットを実装します。 グループ化結合では、これらの操作の両方を記述できます。 「[Join Operations](http://msdn.microsoft.com/ja-jp/442d176d-028c-4beb-8d22-407d4ef89107)」を参照してください。  
  
 クエリ式の構文で、 `join … into` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Group Join` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.GroupJoin%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.GroupJoin%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%29> 2 つのシーケンスに対してグループ化結合を実行します。  
  
 [!code-csharp[System.Linq.Enumerable\#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#40)]
 [!code-vb[System.Linq.Enumerable\#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> または <paramref name="inner" /> または <paramref name="outerKeySelector" /> または <paramref name="innerKeySelector" /> または <paramref name="resultSelector" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">最初のシーケンスの要素の型。</typeparam>
        <typeparam name="TInner">2 番目のシーケンスの要素の型。</typeparam>
        <typeparam name="TKey">キー セレクター関数によって返されるキーの型。</typeparam>
        <typeparam name="TResult">結果の要素の型。</typeparam>
        <param name="outer">結合する最初のシーケンス。</param>
        <param name="inner">最初のシーケンスに結合するシーケンス。</param>
        <param name="outerKeySelector">最初のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="innerKeySelector">2 番目のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="resultSelector">最初のシーケンスの要素と、2 番目のシーケンスの一致する要素のコレクションから結果の要素を作成する関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> をハッシュしてキーを比較します。</param>
        <summary>結果をグループ化キーの等値に基づいて 2 つのシーケンスの要素相互に関連付けます。 指定した <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> キーを比較するために使用します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の要素を含む <paramref name="TResult" /> 2 つのシーケンスをグループ化結合を実行することによって取得されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 C 場合`omparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、ハッシュし、キーを比較するために使用します。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> つまり生成階層的な結果の要素を `outer` 一致する要素のコレクションと組み合わされ、 `inner`です。`GroupJoin` 各要素に一致するもののセット全体の結果を基にでは、 `outer`です。  
  
> [!NOTE]
>  相関関係を持つ要素がない場合 `inner` の指定された要素の `outer`, 、その要素の一致結果のシーケンスが空になりますが、結果に引き続き表示されます。  
  
 `resultSelector` 関数ごとに一度だけ `outer` 要素のすべてのコレクションと共に、 `inner` と一致する要素、 `outer` 要素。 これに対し、 <xref:System.Linq.Enumerable.Join%2A> から 1 つの要素の組に結果のセレクター関数が呼び出されるメソッド `outer` と 1 つの要素から `inner`します。  
  
 `GroupJoin` 要素の順序を維持 `outer`, の各要素に対して `outer`, から一致する要素の順序 `inner`します。  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> 従来のリレーショナル データベース用語で直接相当するものを持ちません。 ただし、このメソッドは内部結合と左外部結合のスーパー セットを実装します。 グループ化結合では、これらの操作の両方を記述できます。 「[Performing Join Operations](http://msdn.microsoft.com/ja-jp/442d176d-028c-4beb-8d22-407d4ef89107)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> または <paramref name="inner" /> または <paramref name="outerKeySelector" /> または <paramref name="innerKeySelector" /> または <paramref name="resultSelector" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />にも表示される一意の要素を持つ<c>second</c>が返されます。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />最初のシーケンスにも表示される一意の要素が返されます。</param>
        <summary>値を比較する既定の等値比較子を使用して、2 つのシーケンスの積集合を生成します。</summary>
        <returns>2 つのシーケンスの積集合を構成する要素が格納されているシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 2 つのセット A と B の積集合は、A、B にも表示されるのすべての要素ではないその他の要素を含むセットとして定義されます。  
  
 このメソッドによって返されるオブジェクトを列挙すると、<xref:System.Linq.Enumerable.Intersect%2A>に現れる順序で両方のシーケンスで発生する一意の要素を生成`first`です。  
  
 既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>、実装する型の値を比較するために使用、<xref:System.Collections.Generic.IEqualityComparer%601>ジェネリック インターフェイス。 カスタム データ型を比較する必要がありますをこのインターフェイスを実装し、独自<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>の型のメソッドです。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています<xref:System.Linq.Enumerable.Intersect%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>を整数の 2 つのシーケンスの各で表示される要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#41)]
 [!code-vb[System.Linq.Enumerable\#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#41)]  
  
 カスタム データ型のオブジェクトのシーケンスを比較する場合を実装する必要がある、<xref:System.Collections.Generic.IEqualityComparer%601>ヘルパー クラスでジェネリック インターフェイス。 次のコード例は、カスタム データ型でこのインターフェイスを実装して提供する方法を示しています。<xref:System.Object.GetHashCode%2A>と<xref:System.Object.Equals%2A>メソッドです。  
  
 [!code-csharp[CSLINQEncapsulatedComparer\#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 このインターフェイスを実装した後のシーケンスを使用することができます`ProductA`内のオブジェクト、<xref:System.Linq.Enumerable.Intersect%2A>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#3)]
[!code-vb[CSLINQEncapsulatedComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />にも表示される一意の要素を持つ<c>second</c>が返されます。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />最初のシーケンスにも表示される一意の要素が返されます。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" />値を比較します。</param>
        <summary>指定されたを使用して 2 つのシーケンスの積集合を生成<see cref="T:System.Collections.Generic.IEqualityComparer`1" />値を比較します。</summary>
        <returns>2 つのシーケンスの積集合を構成する要素が格納されているシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 2 つのセット A と B の積集合は、A、B にも表示されるのすべての要素ではないその他の要素を含むセットとして定義されます。  
  
 このメソッドによって返されるオブジェクトを列挙すると、<xref:System.Linq.Enumerable.Intersect%2A>に現れる順序で両方のシーケンスで発生する一意の要素を生成`first`です。  
  
 場合`comparer`は`null`、既定の等値比較子<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>値を比較するために使用します。  
  
   
  
## 例  
 次の例で使用できる等値比較子を実装する方法を示しています、<xref:System.Linq.Enumerable.Intersect%2A>メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer\#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装すると後のシーケンスを使用することができます`Product`内のオブジェクト、<xref:System.Linq.Enumerable.Intersect%2A>メソッドを次の例で示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#3)]
[!code-vb[CSLINQCustomComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">最初のシーケンスの要素の型。</typeparam>
        <typeparam name="TInner">2 番目のシーケンスの要素の型。</typeparam>
        <typeparam name="TKey">キー セレクター関数によって返されるキーの型。</typeparam>
        <typeparam name="TResult">結果の要素の型。</typeparam>
        <param name="outer">結合する最初のシーケンス。</param>
        <param name="inner">最初のシーケンスに結合するシーケンス。</param>
        <param name="outerKeySelector">最初のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="innerKeySelector">2 番目のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="resultSelector">一致する 2 つの要素から結果の要素を作成する関数。</param>
        <summary>一致するキーに基づいて 2 つのシーケンスの要素を基準になります。 キーの比較には既定の等値比較子が使用されます。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の要素を持つ <paramref name="TResult" /> 2 つのシーケンスに対して内部結合を実行することによって取得されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、ハッシュし、キーを比較するために使用します。  
  
 結合は、共通のキーに基づいた情報の 2 つのソースの要素を関連付ける操作を参照します。<xref:System.Linq.Enumerable.Join%2A> 2 つの情報源と、1 つのメソッドの呼び出しでまとめて照合されますキーが表示されます。 これに対しを使用して `SelectMany`, 、1 つ以上のメソッド呼び出し、同じ操作を実行する必要があります。  
  
 <xref:System.Linq.Enumerable.Join%2A> 要素の順序を維持 `outer`, 、およびこれらの要素の一致する要素の順序は、各 `inner`します。  
  
 クエリ式の構文で、 `join` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Join` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.Join%2A>します。  
  
 リレーショナル データベース用語で、 <xref:System.Linq.Enumerable.Join%2A> メソッドは内部の等結合を実装します。 「内部」は、他のシーケンスに一致する要素のみが結果に含まれることを意味します。 "等結合 ' 結合は、等しいかどうか比較されるキーにします。 左外部結合操作は専用標準クエリ演算子でしか使用して実行を持たない、 <xref:System.Linq.Enumerable.GroupJoin%2A> メソッドです。 「[Joining](http://msdn.microsoft.com/ja-jp/442d176d-028c-4beb-8d22-407d4ef89107)」を参照してください。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Join%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%29> を共通のキーに基づいて 2 つのシーケンスの内部結合を実行します。  
  
 [!code-csharp[System.Linq.Enumerable\#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#42)]
 [!code-vb[System.Linq.Enumerable\#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> または <paramref name="inner" /> または <paramref name="outerKeySelector" /> または <paramref name="innerKeySelector" /> または <paramref name="resultSelector" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">最初のシーケンスの要素の型。</typeparam>
        <typeparam name="TInner">2 番目のシーケンスの要素の型。</typeparam>
        <typeparam name="TKey">キー セレクター関数によって返されるキーの型。</typeparam>
        <typeparam name="TResult">結果の要素の型。</typeparam>
        <param name="outer">結合する最初のシーケンス。</param>
        <param name="inner">最初のシーケンスに結合するシーケンス。</param>
        <param name="outerKeySelector">最初のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="innerKeySelector">2 番目のシーケンスの各要素から結合キーを抽出する関数。</param>
        <param name="resultSelector">一致する 2 つの要素から結果の要素を作成する関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> をハッシュしてキーを比較します。</param>
        <summary>一致するキーに基づいて 2 つのシーケンスの要素を基準になります。 指定した <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> キーを比較するために使用します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の要素を持つ <paramref name="TResult" /> 2 つのシーケンスに対して内部結合を実行することによって取得されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 C 場合`omparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、ハッシュし、キーを比較するために使用します。  
  
 結合は、共通のキーに基づいた情報の 2 つのソースの要素を関連付ける操作を参照します。<xref:System.Linq.Enumerable.Join%2A> 2 つの情報源と、1 つのメソッドの呼び出しでまとめて照合されますキーが表示されます。 これに対しを使用して `SelectMany`, 、1 つ以上のメソッド呼び出し、同じ操作を実行する必要があります。  
  
 <xref:System.Linq.Enumerable.Join%2A> 要素の順序を維持 `outer`, 、およびこれらの要素の一致する要素の順序は、各 `inner`します。  
  
 リレーショナル データベース用語で、 <xref:System.Linq.Enumerable.Join%2A> メソッドは内部の等結合を実装します。 「内部」は、他のシーケンスに一致する要素のみが結果に含まれることを意味します。 "等結合 ' 結合は、等しいかどうか比較されるキーにします。 左外部結合操作は専用標準クエリ演算子でしか使用して実行を持たない、 <xref:System.Linq.Enumerable.GroupJoin%2A> メソッドです。 「[Joining](http://msdn.microsoft.com/ja-jp/442d176d-028c-4beb-8d22-407d4ef89107)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> または <paramref name="inner" /> または <paramref name="outerKeySelector" /> または <paramref name="innerKeySelector" /> または <paramref name="resultSelector" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の最後の要素を返します。</param>
        <summary>シーケンスの最後の要素を返します。</summary>
        <returns>ソース シーケンスの最後の位置にある値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 場合、メソッドが例外をスロー `source` 要素が含まれていません。 ソース シーケンスが空の場合は、既定値を返す代わりを使用して、 <xref:System.Linq.Enumerable.LastOrDefault%2A> メソッドです。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> を配列の最後の要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#43)]
 [!code-vb[System.Linq.Enumerable\#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">ソース シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> から要素を返します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定された条件を満たす、シーケンスの最後の要素を返します。</summary>
        <returns>指定された述語関数でテストに合格する、シーケンスの最後の要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> で一致する要素が見つからない場合、メソッドが例外をスロー `source`します。 一致する要素が見つからない場合に、既定値を返すを使用して、 <xref:System.Linq.Enumerable.LastOrDefault%2A> メソッドです。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 条件を満たす、配列の最後の要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#44)]
 [!code-vb[System.Linq.Enumerable\#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">条件を満たす要素がない <paramref name="predicate" />します。  
  
 または  
  
 ソース シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の最後の要素を返します。</param>
        <summary>シーケンスの最後の要素を返します。シーケンスに要素が含まれていない場合は既定値を返します。</summary>
        <returns>
          <see langword="default" />\(<paramref name="TSource" />\) 場合は、ソース シーケンスが空の場合、それ以外の場合の最後の要素、 <see cref="T:System.Collections.Generic.IEnumerable`1" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 参照および null 許容型の既定値は `null`です。  
  
 <xref:System.Linq.Enumerable.LastOrDefault%2A> メソッドは、既定値を指定する方法を提供していません。 以外の場合、既定値を指定する場合は、 `default`\(`TSource`\) を使用して、 <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> 例」のセクションで説明するメソッドです。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> に空の配列。  
  
 [!code-csharp[System.Linq.Enumerable\#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#45)]
 [!code-vb[System.Linq.Enumerable\#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#45)]  
  
 値も `default`\(`TSource`\) が、コレクションに要素が含まれていない場合に使用する既定値はありません。 不要な既定値の結果をチェックし、必要に応じてを変更して、代わりに使用することができます、 <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> コレクションが空の場合に使用する既定値を指定します。 次に、呼び出す <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> を最後の要素を取得します。 次のコード例では、両方の手法を使用して、月の日付の数値のコレクションが空の場合は、1 の既定値を取得します。 整数の既定値が 0 であり、月の日に対応していないであるため既定値必要があります 1 として代わりに指定します。 クエリの実行が完了した後、不要な既定値の最初の結果変数がチェックされます。 使用して 2 つ目の結果変数が取得 <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> を既定値は 1 を指定します。  
  
 [!code-csharp[System.Linq.Enumerable\#127](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#127)]
 [!code-vb[System.Linq.Enumerable\#127](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#127)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> から要素を返します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>条件を満たす、シーケンスの最後の要素を返します。このような要素が見つからない場合は既定値を返します。</summary>
        <returns>
          <see langword="default" />\(<paramref name="TSource" />\)、シーケンスが空か、要素、述語関数でテスト渡されない場合それ以外の場合、最後の要素をテストに合格述語関数の場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 参照および null 許容型の既定値は `null`です。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 述語に渡すことです。 メソッドの 2 番目の呼び出しで要素が存在しない、条件を満たすシーケンスにします。  
  
 [!code-csharp[System.Linq.Enumerable\#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#46)]
 [!code-vb[System.Linq.Enumerable\#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <c>source</c> の要素の型。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" />カウントする要素を格納しています。</param>
        <summary>返します、<see cref="T:System.Int64" />シーケンス内の要素の合計数を表すです。</summary>
        <returns>ソース シーケンス内の要素の数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用してなく<xref:System.Linq.Enumerable.Count%2A>よりも長くなるように結果を予期したタイミング<xref:System.Int32.MaxValue>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]クエリ式の構文、`Aggregate Into LongCount()`の呼び出しに変換される句<xref:System.Linq.Enumerable.LongCount%2A>です。  
  
   
  
## 例  
 次のコード例は、使用する方法を示します<xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>配列内の要素をカウントします。  
  
 [!code-csharp[System.Linq.Enumerable\#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#47)]
 [!code-vb[System.Linq.Enumerable\#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">要素の数を超える<see cref="F:System.Int64.MaxValue" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> をカウントする要素を格納します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>返します。、 <see cref="T:System.Int64" /> 条件を満たすシーケンス内の要素の数を表します。</summary>
        <returns>述語関数の条件を満たす、シーケンス内の要素数を表す数値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用してなく <xref:System.Linq.Enumerable.Count%2A> を超える結果を予期したタイミング <xref:System.Int32.MaxValue>します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into LongCount()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.LongCount%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 配列内の条件に一致する要素をカウントします。  
  
 [!code-csharp[System.Linq.Enumerable\#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#48)]
 [!code-vb[System.Linq.Enumerable\#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">一致する要素の数を超える <see cref="F:System.Int64.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Decimal" /> の最大値を確認します。</param>
        <summary>シーケンスの最大値を返します <see cref="T:System.Decimal" /> 値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> メソッドの使用方法、 <xref:System.Decimal> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> シーケンス内の最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable\#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Double" /> の最大値を確認します。</param>
        <summary>シーケンスの最大値を返します <see cref="T:System.Double" /> 値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> メソッドの使用方法、 <xref:System.Double> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> シーケンス内の最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable\#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Int32" /> の最大値を確認します。</param>
        <summary>シーケンスの最大値を返します <see cref="T:System.Int32" /> 値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> メソッドの使用方法、 <xref:System.Int32> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> シーケンス内の最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable\#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Int64" /> の最大値を確認します。</param>
        <summary>シーケンスの最大値を返します <see cref="T:System.Int64" /> 値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> メソッドの使用方法、 <xref:System.Int64> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> シーケンス内の最大値を決定します。  
  
 [!code-csharp[System.Linq.Enumerable\#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable\#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Decimal" /> の最大値を確認します。</param>
        <summary>Null 許容型のシーケンスの最大値を返す <see cref="T:System.Decimal" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Decimal&gt;</c> C\# の場合、または <c>Nullable(Of Decimal)</c> で Visual Basic シーケンスの最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> メソッドの使用方法、 <xref:System.Decimal> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか `null`, 、この関数が返す `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> シーケンス内の最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable\#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Double" /> の最大値を確認します。</param>
        <summary>Null 許容型のシーケンスの最大値を返す <see cref="T:System.Double" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Double&gt;</c> C\# の場合、または <c>Nullable(Of Double)</c> で Visual Basic シーケンスの最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> メソッドの使用方法、 <xref:System.Double> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか `null`, 、この関数が返す `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> シーケンス内の最大値を決定します。  
  
 [!code-csharp[System.Linq.Enumerable\#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable\#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Int32" /> の最大値を確認します。</param>
        <summary>Null 許容型のシーケンスの最大値を返す <see cref="T:System.Int32" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Int32&gt;</c> C\# の場合、または <c>Nullable(Of Int32)</c> で Visual Basic シーケンスの最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> メソッドの使用方法、 <xref:System.Int32> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか `null`, 、この関数が返す `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> シーケンス内の最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable\#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Int64" /> の最大値を確認します。</param>
        <summary>Null 許容型のシーケンスの最大値を返す <see cref="T:System.Int64" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Int64&gt;</c> C\# の場合、または <c>Nullable(Of Int64)</c> で Visual Basic シーケンスの最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> メソッドの使用方法、 <xref:System.Int64> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか `null`, 、この関数が返す `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> シーケンス内の最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable\#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Single" /> の最大値を確認します。</param>
        <summary>Null 許容型のシーケンスの最大値を返す <see cref="T:System.Single" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Single&gt;</c> C\# の場合、または <c>Nullable(Of Single)</c> で Visual Basic シーケンスの最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> メソッドの使用方法、 <xref:System.Single> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか `null`, 、この関数が返す `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> シーケンス内の最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable\#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Single" /> の最大値を確認します。</param>
        <summary>シーケンスの最大値を返します <see cref="T:System.Single" /> 値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> メソッドの使用方法、 <xref:System.Single> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> シーケンス内の最大値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable\#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <summary>ジェネリック シーケンスの最大値を返します。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合型 `TSource` 実装 <xref:System.IComparable%601>, 、 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドでは、その実装を使用して、値を比較します。 それ以外の場合型 `TSource` 実装 <xref:System.IComparable>, 、その実装を使用して値を比較します。  
  
 場合 `TSource` 参照型であると、ソース シーケンスが空か、値のみが含まれています `null`, 、このメソッドが戻る `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> のシーケンスの最大値を決定する <xref:System.IComparable%601> オブジェクトです。  
  
 [!code-csharp[System.Linq.Enumerable\#57](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#57)]
 [!code-vb[System.Linq.Enumerable\#57](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最大値を返します <see cref="T:System.Decimal" /> 値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29> メソッドの使用方法、 <xref:System.Decimal> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Decimal>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最大値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable\#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最大値を返します <see cref="T:System.Double" /> 値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> メソッドの使用方法、 <xref:System.Double> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Double>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最大値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable\#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最大値を返します <see cref="T:System.Int32" /> 値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> メソッドの使用方法、 <xref:System.Int32> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Int32>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最大値を確認します。  
  
 [!code-csharp[System.Linq.Enumerable\#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable\#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最大値を返します <see cref="T:System.Int64" /> 値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> メソッドの使用方法、 <xref:System.Int64> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Int64>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最大値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable\#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、null 許容最大値を返します <see cref="T:System.Decimal" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Decimal&gt;</c> C\# の場合、または <c>Nullable(Of Decimal)</c> で Visual Basic シーケンスの最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29> メソッドの使用方法、 <xref:System.Decimal> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Decimal>` C\# の場合、または `Nullable(Of Decimal)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最大値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable\#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、null 許容最大値を返します <see cref="T:System.Double" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Double&gt;</c> C\# の場合、または <c>Nullable(Of Double)</c> で Visual Basic シーケンスの最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29> メソッドの使用方法、 <xref:System.Double> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Double>` C\# の場合、または `Nullable(Of Double)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最大値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable\#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、null 許容最大値を返します <see cref="T:System.Int32" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Int32&gt;</c> C\# の場合、または <c>Nullable(Of Int32)</c> で Visual Basic シーケンスの最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29> メソッドの使用方法、 <xref:System.Int32> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Int32>` C\# の場合、または `Nullable(Of Int32)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最大値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable\#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、null 許容最大値を返します <see cref="T:System.Int64" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Int64&gt;</c> C\# の場合、または <c>Nullable(Of Int64)</c> で Visual Basic シーケンスの最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29> メソッドの使用方法、 <xref:System.Int64> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Int64>` C\# の場合、または `Nullable(Of Int64)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最大値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable\#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、null 許容最大値を返します <see cref="T:System.Single" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Single&gt;</c> C\# の場合、または <c>Nullable(Of Single)</c> で Visual Basic シーケンスの最大値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29> メソッドの使用方法、 <xref:System.Single> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Single>` C\# の場合、または `Nullable(Of Single)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最大値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable\#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最大値を返します <see cref="T:System.Single" /> 値。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> メソッドの使用方法、 <xref:System.Single> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Single>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最大値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable\#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TResult">によって返される値の型 <c>selector</c>します。</typeparam>
        <param name="source">最大値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>ジェネリック シーケンスの各要素に対して変換関数の呼び出しを結果の最大値を返します。</summary>
        <returns>シーケンスの最大値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合型 `TResult` 実装 <xref:System.IComparable%601>, 、このメソッドでは、その実装を使用して、値を比較します。 それ以外の場合型 `TResult` 実装 <xref:System.IComparable>, 、その実装を使用して値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Max()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Max%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最大値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable\#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Decimal" /> の最小値を確認します。</param>
        <summary>シーケンスの最小値を返します <see cref="T:System.Decimal" /> 値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> メソッドの使用方法、 <xref:System.Decimal> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable\#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Double" /> の最小値を確認します。</param>
        <summary>シーケンスの最小値を返します <see cref="T:System.Double" /> 値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> メソッドの使用方法、 <xref:System.Double> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> シーケンス内の最小値を決定します。  
  
 [!code-csharp[System.Linq.Enumerable\#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable\#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Int32" /> の最小値を確認します。</param>
        <summary>シーケンスの最小値を返します <see cref="T:System.Int32" /> 値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> メソッドの使用方法、 <xref:System.Int32> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable\#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Int64" /> の最小値を確認します。</param>
        <summary>シーケンスの最小値を返します <see cref="T:System.Int64" /> 値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> メソッドの使用方法、 <xref:System.Int64> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable\#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Decimal" /> の最小値を確認します。</param>
        <summary>Null 許容型のシーケンスの最小値を返す <see cref="T:System.Decimal" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Decimal&gt;</c> C\# の場合、または <c>Nullable(Of Decimal)</c> で Visual Basic 、シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> メソッドの使用方法、 <xref:System.Decimal> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか `null`, 、この関数が返す `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable\#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Double" /> の最小値を確認します。</param>
        <summary>Null 許容型のシーケンスの最小値を返す <see cref="T:System.Double" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Double&gt;</c> C\# の場合、または <c>Nullable(Of Double)</c> で Visual Basic 、シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> メソッドの使用方法、 <xref:System.Double> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか `null`, 、この関数が返す `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable\#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Int32" /> の最小値を確認します。</param>
        <summary>Null 許容型のシーケンスの最小値を返す <see cref="T:System.Int32" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Int32&gt;</c> C\# の場合、または <c>Nullable(Of Int32)</c> で Visual Basic 、シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> メソッドの使用方法、 <xref:System.Int32> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか `null`, 、この関数が返す `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> シーケンス内の最小値を決定します。  
  
 [!code-csharp[System.Linq.Enumerable\#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable\#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Int64" /> の最小値を確認します。</param>
        <summary>Null 許容型のシーケンスの最小値を返す <see cref="T:System.Int64" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Int64&gt;</c> C\# の場合、または <c>Nullable(Of Int64)</c> で Visual Basic 、シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> メソッドの使用方法、 <xref:System.Int64> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか `null`, 、この関数が返す `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable\#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Single" /> の最小値を確認します。</param>
        <summary>Null 許容型のシーケンスの最小値を返す <see cref="T:System.Single" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Single&gt;</c> C\# の場合、または <c>Nullable(Of Single)</c> で Visual Basic 、シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> メソッドの使用方法、 <xref:System.Single> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 ソース シーケンスが空かは値のみを含むかどうか `null`, 、この関数が返す `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable\#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Single" /> の最小値を確認します。</param>
        <summary>シーケンスの最小値を返します <see cref="T:System.Single" /> 値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> メソッドの使用方法、 <xref:System.Single> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> シーケンス内の最小値を決定します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable\#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <summary>ジェネリック シーケンスの最小値を返します。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合型 `TSource` 実装 <xref:System.IComparable%601>, 、このメソッドでは、その実装を使用して、値を比較します。 それ以外の場合型 `TSource` 実装 <xref:System.IComparable>, 、その実装を使用して値を比較します。  
  
 場合 `TSource` 参照型であると、ソース シーケンスが空か、値のみが含まれています `null`, 、この関数が返す `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> のシーケンスの最小値を決定する <xref:System.IComparable%601> オブジェクトです。  
  
 [!code-csharp[System.Linq.Enumerable\#67](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#67)]
 [!code-vb[System.Linq.Enumerable\#67](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を返します <see cref="T:System.Decimal" /> 値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29> メソッドの使用方法、 <xref:System.Decimal> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Decimal>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最小値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable\#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を返します <see cref="T:System.Double" /> 値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> メソッドの使用方法、 <xref:System.Double> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Double>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最小値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable\#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を返します <see cref="T:System.Int32" /> 値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> メソッドの使用方法、 <xref:System.Int32> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Int32>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最小値を確認します。  
  
 [!code-csharp[System.Linq.Enumerable\#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable\#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を返します <see cref="T:System.Int64" /> 値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> メソッドの使用方法、 <xref:System.Int64> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Int64>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最小値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable\#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を null 許容型を返します <see cref="T:System.Decimal" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Decimal&gt;</c> C\# の場合、または <c>Nullable(Of Decimal)</c> で Visual Basic 、シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29> メソッドの使用方法、 <xref:System.Decimal> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Decimal>` C\# の場合、または `Nullable(Of Decimal)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最小値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable\#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を null 許容型を返します <see cref="T:System.Double" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Double&gt;</c> C\# の場合、または <c>Nullable(Of Double)</c> で Visual Basic 、シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29> メソッドの使用方法、 <xref:System.Double> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Double>` C\# の場合、または `Nullable(Of Double)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最小値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable\#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を null 許容型を返します <see cref="T:System.Int32" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Int32&gt;</c> C\# の場合、または <c>Nullable(Of Int32)</c> で Visual Basic 、シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29> メソッドの使用方法、 <xref:System.Int32> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, 、具体的には、数値型にソースのメンバーを射影する `Nullable<Int32>` C\# の場合または `Nullable(Of Int32)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最小値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable\#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を null 許容型を返します <see cref="T:System.Int64" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Int64&gt;</c> C\# の場合、または <c>Nullable(Of Int64)</c> で Visual Basic 、シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29> メソッドの使用方法、 <xref:System.Int64> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Int64>` C\# の場合、または `Nullable(Of Int64)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最小値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable\#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を null 許容型を返します <see cref="T:System.Single" /> 値。</summary>
        <returns>型の値 <c>Nullable&lt;Single&gt;</c> C\# の場合、または <c>Nullable(Of Single)</c> で Visual Basic 、シーケンス内の最小値に対応します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29> メソッドの使用方法、 <xref:System.Single> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Single>` C\# の場合、または `Nullable(Of Single)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最小値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable\#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素に対して変換関数を呼び出し、最小値を返します <see cref="T:System.Single" /> 値。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> メソッドの使用方法、 <xref:System.Single> の実装 <xref:System.IComparable%601> 値を比較します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Single>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最小値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable\#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 要素が含まれない。</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TResult">によって返される値の型 <c>selector</c>します。</typeparam>
        <param name="source">最小値を確認する対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>ジェネリック シーケンスの各要素に対して変換関数の呼び出しを結果の最小値を返します。</summary>
        <returns>シーケンスの最小値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合型 `TResult` 実装 <xref:System.IComparable%601>, 、このメソッドでは、その実装を使用して、値を比較します。 それ以外の場合型 `TResult` 実装 <xref:System.IComparable>, 、その実装を使用して値を比較します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Min()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Min%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> 射影された値のシーケンスの最小値を確認します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable\#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">シーケンスの要素をフィルター処理する型。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.IEnumerable" /> フィルターを適用する要素を格納します。</param>
        <summary>要素をフィルター処理、 <see cref="T:System.Collections.IEnumerable" /> 、指定した型に基づいています。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 型の入力シーケンスから要素を含む <paramref name="TResult" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.OfType%60%601%28System.Collections.IEnumerable%29> メソッドの要素のみを返します `source` 型にキャストできる `TResult`です。 要素は、型にキャストできない場合、代わりに例外を発生させる `TResult`, を使用して <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>します。  
  
 このメソッドは、非パラメーター化の種類をようになっているコレクションに適用できるいくつかの標準クエリ演算子メソッドのいずれか、 <xref:System.Collections.ArrayList>です。 これは、ため <xref:System.Linq.Enumerable.OfType%2A> 、型を拡張 <xref:System.Collections.IEnumerable>します。<xref:System.Linq.Enumerable.OfType%2A> 使用するコレクションにのみ適用できません、パラメーター化された \[ <xref:System.Collections.Generic.IEnumerable%601> 型ではなく、非パラメーター化に基づくコレクション <xref:System.Collections.IEnumerable> も入力します。  
  
 適用することで <xref:System.Linq.Enumerable.OfType%2A> を実装するコレクションに <xref:System.Collections.IEnumerable>, 、標準クエリ演算子を使用して、コレクションを照会することができます。 などの型引数を指定する <xref:System.Object> に <xref:System.Linq.Enumerable.OfType%2A> 型のオブジェクトを返すよう `IEnumerable<Object>` C\# の場合または `IEnumerable(Of Object)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)], 、標準クエリ演算子を適用できます。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.OfType%2A> の要素をフィルター処理する、 <xref:System.Collections.IEnumerable>です。  
  
 [!code-csharp[System.Linq.Enumerable\#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#69)]
 [!code-vb[System.Linq.Enumerable\#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">順序付ける値のシーケンス。</param>
        <param name="keySelector">要素からキーを抽出する関数。</param>
        <summary>キーに従って昇順のシーケンスの要素を並べ替えます。</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 要素がキーに従って並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 要素自体の値によって、シーケンスを注文するには、identity 関数を指定 \(`x => x` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `Function(x) x` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の `keySelector`です。  
  
 2 つのメソッドを定義して型を拡張する <xref:System.Linq.IOrderedEnumerable%601>, 、これは、このメソッドの戻り値の型。 これら 2 つの方法では、つまり `ThenBy` と `ThenByDescending`, 、シーケンスを並べ替えるには、追加の並べ替え条件を指定できます。`ThenBy``ThenByDescending` を返すことも、 <xref:System.Linq.IOrderedEnumerable%601>, 、任意の数を連続して呼び出すをつまり `ThenBy` または `ThenByDescending` 可能であります。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601> から継承 <xref:System.Collections.Generic.IEnumerable%601>, 、呼び出すことができます <xref:System.Linq.Enumerable.OrderBy%2A> または <xref:System.Linq.Enumerable.OrderByDescending%2A> への呼び出しの結果に <xref:System.Linq.Enumerable.OrderBy%2A>, 、<xref:System.Linq.Enumerable.OrderByDescending%2A>, 、<xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリ順序以前確立された順序を無視するが導入されています。  
  
 このメソッドは、既定の比較子を使用してキーを比較 <xref:System.Collections.Generic.Comparer%601.Default%2A>します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
 クエリ式の構文で、 `orderby` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Order By` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.OrderBy%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.OrderBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> シーケンスの要素を並べ替える。  
  
 [!code-csharp[System.Linq.Enumerable\#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#70)]
 [!code-vb[System.Linq.Enumerable\#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">順序付ける値のシーケンス。</param>
        <param name="keySelector">要素からキーを抽出する関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> キーを比較します。</param>
        <summary>指定された比較子を使用して、昇順のシーケンスの要素を並べ替えます。</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 要素がキーに従って並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 要素自体の値によって、シーケンスを注文するには、identity 関数を指定 \(`x => x` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `Function(x) x` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の `keySelector`です。  
  
 2 つのメソッドを定義して型を拡張する <xref:System.Linq.IOrderedEnumerable%601>, 、これは、このメソッドの戻り値の型。 これら 2 つの方法では、つまり `ThenBy` と `ThenByDescending`, 、シーケンスを並べ替えるには、追加の並べ替え条件を指定できます。`ThenBy``ThenByDescending` を返すことも、 <xref:System.Linq.IOrderedEnumerable%601>, 、任意の数を連続して呼び出すをつまり `ThenBy` または `ThenByDescending` 可能であります。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601> から継承 <xref:System.Collections.Generic.IEnumerable%601>, 、呼び出すことができます <xref:System.Linq.Enumerable.OrderBy%2A> または <xref:System.Linq.Enumerable.OrderByDescending%2A> への呼び出しの結果に <xref:System.Linq.Enumerable.OrderBy%2A>, 、<xref:System.Linq.Enumerable.OrderByDescending%2A>, 、<xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリ順序以前確立された順序を無視するが導入されています。  
  
 場合 `comparer` は `null`, 、既定の比較子 <xref:System.Collections.Generic.Comparer%601.Default%2A> キーを比較するために使用します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">順序付ける値のシーケンス。</param>
        <param name="keySelector">要素からキーを抽出する関数。</param>
        <summary>キーに従って降順のシーケンスの要素を並べ替えます。</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 要素がキーに従って降順に並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 要素自体の値によって、シーケンスを注文するには、identity 関数を指定 \(`x => x` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `Function(x) x` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の `keySelector`です。  
  
 このメソッドの例は、次を参照してください。 <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>します。  
  
 2 つのメソッドを定義して型を拡張する <xref:System.Linq.IOrderedEnumerable%601>, 、これは、このメソッドの戻り値の型。 これら 2 つの方法では、つまり `ThenBy` と `ThenByDescending`, 、シーケンスを並べ替えるには、追加の並べ替え条件を指定できます。`ThenBy``ThenByDescending` を返すことも、 <xref:System.Linq.IOrderedEnumerable%601>, 、任意の数を連続して呼び出すをつまり `ThenBy` または `ThenByDescending` 可能であります。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601> から継承 <xref:System.Collections.Generic.IEnumerable%601>, 、呼び出すことができます <xref:System.Linq.Enumerable.OrderBy%2A> または <xref:System.Linq.Enumerable.OrderByDescending%2A> への呼び出しの結果に <xref:System.Linq.Enumerable.OrderBy%2A>, 、<xref:System.Linq.Enumerable.OrderByDescending%2A>, 、<xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリ順序以前確立された順序を無視するが導入されています。  
  
 このメソッドは、既定の比較子を使用してキーを比較 <xref:System.Collections.Generic.Comparer%601.Default%2A>します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
 クエリ式の構文で、 `orderby descending` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Order By Descending` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.OrderByDescending%2A>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">順序付ける値のシーケンス。</param>
        <param name="keySelector">要素からキーを抽出する関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> キーを比較します。</param>
        <summary>指定された比較子を使用してシーケンスの要素を降順に並べ替えます。</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 要素がキーに従って降順に並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 要素自体の値によって、シーケンスを注文するには、identity 関数を指定 \(`x => x` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `Function(x) x` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の `keySelector`です。  
  
 2 つのメソッドを定義して型を拡張する <xref:System.Linq.IOrderedEnumerable%601>, 、これは、このメソッドの戻り値の型。 これら 2 つの方法では、つまり `ThenBy` と `ThenByDescending`, 、シーケンスを並べ替えるには、追加の並べ替え条件を指定できます。`ThenBy``ThenByDescending` を返すことも、 <xref:System.Linq.IOrderedEnumerable%601>, 、任意の数を連続して呼び出すをつまり `ThenBy` または `ThenByDescending` 可能であります。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601> から継承 <xref:System.Collections.Generic.IEnumerable%601>, 、呼び出すことができます <xref:System.Linq.Enumerable.OrderBy%2A> または <xref:System.Linq.Enumerable.OrderByDescending%2A> への呼び出しの結果に <xref:System.Linq.Enumerable.OrderBy%2A>, 、<xref:System.Linq.Enumerable.OrderByDescending%2A>, 、<xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリ順序以前確立された順序を無視するが導入されています。  
  
 場合 `comparer` は `null`, 、既定の比較子 <xref:System.Collections.Generic.Comparer%601.Default%2A> キーを比較するために使用します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> 変換関数とカスタムの比較演算子を使用して降順のシーケンスの要素を並べ替えます。  
  
 [!code-csharp[System.Linq.Enumerable\#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#71)]
 [!code-vb[System.Linq.Enumerable\#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">シーケンス内の最初の整数の値。</param>
        <param name="count">生成する連続した整数の数。</param>
        <summary>指定した範囲内の整数のシーケンスを生成します。</summary>
        <returns>
          <c>IEnumerable&lt;Int32&gt;</c> C\# の場合、または <c>IEnumerable(Of Int32)</c> で Visual Basic 連続した整数の範囲を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Range%2A> 値のシーケンスを生成します。  
  
 [!code-csharp[System.Linq.Enumerable\#72](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#72)]
 [!code-vb[System.Linq.Enumerable\#72](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。  
  
 または  
  
 <paramref name="start" /> \+ <paramref name="count" /> \-1 を超える <see cref="F:System.Int32.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Repeat``1(``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">結果のシーケンスで繰り返される値の型。</typeparam>
        <param name="element">繰り返される値。</param>
        <param name="count">生成されたシーケンスで値を繰り返す回数。</param>
        <summary>繰り返される 1 つの値を格納しているシーケンスを生成します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 繰り返される値を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Repeat%2A> 繰り返される値のシーケンスを生成します。  
  
 [!code-csharp[System.Linq.Enumerable\#73](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#73)]
 [!code-vb[System.Linq.Enumerable\#73](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">反転させる値のシーケンス。</param>
        <summary>シーケンス内の要素の順序を反転します。</summary>
        <returns>要素が入力シーケンスの要素に逆順で対応しているシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 異なり <xref:System.Linq.Enumerable.OrderBy%2A>, 、この並べ替え方法も、順序の決定に自体実際の値が考慮されません。 代わりに、要素を返すだけが生成される元の逆の順序で、基になるソースでします。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Reverse%2A> 配列内の要素の順序を逆にします。  
  
 [!code-csharp[System.Linq.Enumerable\#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#74)]
 [!code-vb[System.Linq.Enumerable\#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TResult">によって返される値の型 <c>selector</c>します。</typeparam>
        <param name="source">変換関数を呼び出す対象となる値のシーケンス。</param>
        <param name="selector">各ソース要素に適用する変換関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <summary>要素のインデックスを組み込むことにより、新しいフォームにシーケンスの各要素を射影します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 方の各要素に対して変換関数の呼び出しの結果を要素 <paramref name="source" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 最初の引数に `selector` を処理する要素を表します。 2 番目の引数 `selector` ソース シーケンス内の要素の 0 から始まるインデックスを表します。 既知の順序に要素があり、たとえば特定のインデックス位置にある要素を実際に操作を実行する場合、これは役立つあります。 1 つまたは複数の要素のインデックスを取得する場合に便利ですできます。  
  
 この投影メソッドは変換関数を必要と `selector`, 、ソース シーケンス内の各値の 1 つの値を生成する `source`です。 場合 `selector` 、サブシーケンスを手動で走査するコンシューマーの責任です自体がコレクションの値を返します。 このような場合は、値の 1 つの結合されたシーケンスを返すようにクエリにとってより良い場合があります。 そのため、使用、 <xref:System.Linq.Enumerable.SelectMany%2A> メソッドの代わりに <xref:System.Linq.Enumerable.Select%2A>します。`SelectMany` 同じように動作 `Select`, 、変換関数がによっては、展開し、コレクションを取得するには異なる `SelectMany` に返されます。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%29> 値のシーケンスにわたるプロジェクトおよび各要素のインデックスを使用します。  
  
 [!code-csharp[System.Linq.Enumerable\#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#76)]
 [!code-vb[System.Linq.Enumerable\#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TResult">によって返される値の型 <c>selector</c>します。</typeparam>
        <param name="source">変換関数を呼び出す対象となる値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素を新しいフォームに射影します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 方の各要素に対して変換関数の呼び出しの結果を要素 <paramref name="source" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 この投影メソッドは変換関数を必要と `selector`, 、ソース シーケンス内の各値の 1 つの値を生成する `source`です。 場合 `selector` 、サブシーケンスを手動で走査するコンシューマーの責任です自体がコレクションの値を返します。 このような場合は、値の 1 つの結合されたシーケンスを返すようにクエリにとってより良い場合があります。 そのため、使用、 <xref:System.Linq.Enumerable.SelectMany%2A> メソッドの代わりに <xref:System.Linq.Enumerable.Select%2A>します。`SelectMany` 同じように動作 `Select`, 、変換関数がによっては、展開し、コレクションを取得するには異なる `SelectMany` に返されます。  
  
 クエリ式の構文で、 `select` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Select` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.Select%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> 値のシーケンスにわたるプロジェクトにします。  
  
 [!code-csharp[System.Linq.Enumerable\#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#75)]
 [!code-vb[System.Linq.Enumerable\#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TResult">によって返されるシーケンスの要素の型 <c>selector</c>します。</typeparam>
        <param name="source">射影する値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素、 <see cref="T:System.Collections.Generic.IEnumerable`1" /> し、結果のシーケンスを 1 つのシーケンスに平坦化します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 要素が入力シーケンスの各要素に対して一対多の変換関数の呼び出しの結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> メソッドは、入力シーケンスを列挙、各要素にマップする変換関数を使用して、 <xref:System.Collections.Generic.IEnumerable%601>, を列挙して、各などの要素が返さ <xref:System.Collections.Generic.IEnumerable%601> オブジェクトです。 つまりの各要素に対して `source`, 、`selector` が呼び出される一連の値が返されます。<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> この 2 次元のコレクションを 1 次元のコレクションをフラット化し、 <xref:System.Collections.Generic.IEnumerable%601> しそれを取得します。 たとえば、次のクエリで使用される <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> の注文を取得する \(型の `Order`\) データベース内の各顧客について、結果は型は `IEnumerable<Order>` C\# の場合または `IEnumerable(Of Order)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。 クエリの代わりに使用する場合 <xref:System.Linq.Enumerable.Select%2A> 、注文を取得するには、注文のコレクションのコレクションを組み合わせることはできませんし、結果は型の `IEnumerable<List<Order>>` C\# の場合、または `IEnumerable(Of List(Of Order))` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 クエリ式の構文で各 `from` 句 \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `From` 句 \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに 1 つは変換の頭文字の後 <xref:System.Linq.Enumerable.SelectMany%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> を配列の一対多の射影を実行します。  
  
 [!code-csharp[System.Linq.Enumerable\#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#77)]
 [!code-vb[System.Linq.Enumerable\#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TResult">によって返されるシーケンスの要素の型 <c>selector</c>します。</typeparam>
        <param name="source">射影する値のシーケンス。</param>
        <param name="selector">各ソース要素に適用する変換関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <summary>シーケンスの各要素、 <see cref="T:System.Collections.Generic.IEnumerable`1" />, 、結果のシーケンスを 1 つのシーケンスにフラット化します。 各ソース要素のインデックスは、その要素の射影されたフォームで使用されます。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 要素が入力シーケンスの各要素に対して一対多の変換関数の呼び出しの結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> メソッドは、入力シーケンスを列挙、各要素にマップする変換関数を使用して、 <xref:System.Collections.Generic.IEnumerable%601>, を列挙して、各などの要素が返さ <xref:System.Collections.Generic.IEnumerable%601> オブジェクトです。 つまりの各要素に対して `source`, 、`selector` が呼び出される一連の値が返されます。<xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> この 2 次元のコレクションを 1 次元のコレクションをフラット化し、 <xref:System.Collections.Generic.IEnumerable%601> しそれを取得します。 たとえば、次のクエリで使用される <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> の注文を取得する \(型の `Order`\) データベース内の各顧客について、結果は型は `IEnumerable<Order>` C\# の場合または `IEnumerable(Of Order)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。 クエリの代わりに使用する場合 <xref:System.Linq.Enumerable.Select%2A> 、注文を取得するには、注文のコレクションのコレクションを組み合わせることはできませんし、結果は型の `IEnumerable<List<Order>>` C\# の場合、または `IEnumerable(Of List(Of Order))` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 最初の引数に `selector` を処理する要素を表します。 2 番目の引数 `selector` ソース シーケンス内の要素の 0 から始まるインデックスを表します。 既知の順序に要素があり、たとえば特定のインデックス位置にある要素を実際に操作を実行する場合、これは役立つあります。 1 つまたは複数の要素のインデックスを取得する場合に便利ですできます。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> 配列に対して一対多の射影を実行し、外部の各要素のインデックスを使用します。  
  
 [!code-csharp[System.Linq.Enumerable\#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#78)]
 [!code-vb[System.Linq.Enumerable\#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TCollection">によって収集される中間要素の型 <c>collectionSelector</c>します。</typeparam>
        <typeparam name="TResult">結果のシーケンスの要素の型。</typeparam>
        <param name="source">射影する値のシーケンス。</param>
        <param name="collectionSelector">入力シーケンスの各要素に適用する変換関数。</param>
        <param name="resultSelector">中間のシーケンスの各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素、 <see cref="T:System.Collections.Generic.IEnumerable`1" />, 、結果のシーケンスを 1 つのシーケンスに平坦化し、そこにある各要素に対して結果のセレクター関数を呼び出します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 要素が一対多の変換関数を呼び出した結果 <paramref name="collectionSelector" /> の各要素に対して <paramref name="source" /> し、各シーケンス要素とそれに対応するソース要素を結果の要素にマップします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> メソッドは、の要素を保持する必要がある場合に便利な `source` への呼び出し後に発生するクエリ ロジックのスコープ内 <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>します。 コード例については、「使用例」のセクションを参照してください。 型のオブジェクト間の双方向関係があるかどうか `TSource` と型のオブジェクト `TCollection`, 、つまり、型のオブジェクト `TCollection` を取得するプロパティを提供、 `TSource` 、これを生成したオブジェクトのこのオーバー ロードを必要としない <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>します。 使用する代わりに、 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> に戻ると、 `TSource` オブジェクトを通じて、 `TCollection` オブジェクトです。  
  
 クエリ式の構文で各 `from` 句 \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `From` 句 \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに 1 つは変換の頭文字の後 <xref:System.Linq.Enumerable.SelectMany%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> 配列に対して一対多の射影を実行し、結果のセレクター関数を使用して、それぞれ対応する要素をソース シーケンスの最後の呼び出しのスコープ内から `Select`します。  
  
 [!code-csharp[System.Linq.Enumerable\#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#124)]
 [!code-vb[System.Linq.Enumerable\#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="collectionSelector" />、または <paramref name="resultSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TCollection">によって収集される中間要素の型 <c>collectionSelector</c>します。</typeparam>
        <typeparam name="TResult">結果のシーケンスの要素の型。</typeparam>
        <param name="source">射影する値のシーケンス。</param>
        <param name="collectionSelector">各ソース要素に適用する変換関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <param name="resultSelector">中間のシーケンスの各要素に適用する変換関数。</param>
        <summary>シーケンスの各要素、 <see cref="T:System.Collections.Generic.IEnumerable`1" />, 、結果のシーケンスを 1 つのシーケンスに平坦化し、そこにある各要素に対して結果のセレクター関数を呼び出します。 各ソース要素のインデックスは、その要素の中間の射影されたフォームで使用されます。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 要素が一対多の変換関数を呼び出した結果 <paramref name="collectionSelector" /> の各要素に対して <paramref name="source" /> し、各シーケンス要素とそれに対応するソース要素を結果の要素にマップします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> メソッドは、の要素を保持する必要がある場合に便利な `source` への呼び出し後に発生するクエリ ロジックのスコープ内 <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>します。 コード例については、「使用例」のセクションを参照してください。 型のオブジェクト間の双方向関係があるかどうか `TSource` と型のオブジェクト `TCollection`, 、つまり、型のオブジェクト `TCollection` を取得するプロパティを提供、 `TSource` 、これを生成したオブジェクトのこのオーバー ロードを必要としない <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>します。 使用する代わりに、 <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> に戻ると、 `TSource` オブジェクトを通じて、 `TCollection` オブジェクトです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="collectionSelector" />、または <paramref name="resultSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> と比較する <c>second</c>です。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 最初のシーケンスと比較します。</param>
        <summary>型に対して既定の等値比較子を使用して要素を比較することで、2 つのシーケンスが等しいかどうかを決定します。</summary>
        <returns>
          <see langword="true" /> 要素は、その型の既定の等値比較子に従って等しい場合は 2 つのソース シーケンスが同じ長さで、それに対応します。それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドは、2 つのソース シーケンスを並列を列挙し、対応する要素を比較するには、既定の等値比較子を使用して `TSource`, 、<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>です。 既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、実装する型の値を比較に使用される、 <xref:System.Collections.Generic.IEqualityComparer%601> ジェネリック インターフェイスです。 カスタム データ型を比較する必要がありますこのインターフェイスを実装でき、独自 <xref:System.Object.GetHashCode%2A> と <xref:System.Object.Equals%2A> の型のメソッドです。  
  
   
  
## 例  
 次のコード例を使用する方法を示します <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> 2 つのシーケンスが等しいかどうかを確認します。 最初の 2 つの例では、このメソッドは、比較対象のシーケンスが同じオブジェクトへの参照を含めるかどうかを判定します。 3 番目と 4 番目の例では、メソッドは、シーケンス内のオブジェクトの実際のデータを比較します。  
  
 この例では、シーケンスが等しいです。  
  
 [!code-csharp[System.Linq.Enumerable\#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#32)]
 [!code-vb[System.Linq.Enumerable\#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#32)]  
  
 次のコード例では、等しくない 2 つのシーケンスを比較します。 シーケンスが同一のデータを含むが、含まれるオブジェクトに別の参照があるため、シーケンスは考慮されませんと同じことに注意してください。  
  
 [!code-csharp[System.Linq.Enumerable\#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#33)]
 [!code-vb[System.Linq.Enumerable\#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#33)]  
  
 実装する必要の参照を比較するだけではなくシーケンス内のオブジェクトの実際のデータを比較する場合、 <xref:System.Collections.Generic.IEqualityComparer%601> クラスのジェネリック インターフェイスです。 次のコード例は、ヘルパー クラスでこのインターフェイスを実装して提供する方法を示しています。 <xref:System.Object.GetHashCode%2A> と <xref:System.Object.Equals%2A> メソッドです。  
  
 [!code-csharp[CSLINQEncapsulatedComparer\#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 このインターフェイスを実装した後は、シーケンスを使用して `ProductA` 内のオブジェクト、 <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドを次の例に示すようにします。  
  
 [!code-csharp[CSLINQEncapsulatedComparer\#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#8)]
 [!code-vb[CSLINQEncapsulatedComparer\#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> と比較する <c>second</c>です。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 最初のシーケンスと比較します。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 要素の比較に使用します。</param>
        <summary>使用して、その要素を比較することによって 2 つのシーケンスが等しいかどうかを判断 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />します。</summary>
        <returns>
          <see langword="true" /> 同じ長さの 2 つのソース シーケンスがあり、対応する要素と等しいと見なさに従って <paramref name="comparer" />。 そうしないと、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> メソッドは、2 つのソース シーケンスを並列を列挙し、対応する要素を比較するには、指定して <xref:System.Collections.Generic.IEqualityComparer%601>します。 C 場合`omparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、要素を比較するために使用します。  
  
   
  
## 例  
 次の例で使用する等値比較子を実装する方法を示しています、 <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer\#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装した後は、シーケンスを使用して `Product` 内のオブジェクト、 <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> メソッドを次の例に示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer\#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#8)]
 [!code-vb[CSLINQCustomComparer\#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の 1 つの要素を返します。</param>
        <summary>シーケンスの唯一の要素を返し、シーケンス内の要素が 1 つだけでない場合は例外をスローします。</summary>
        <returns>入力シーケンスの 1 つの要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 入力シーケンスが空の場合、メソッドが例外をスローします。 返すには `null` 入力シーケンスが空である場合、使用して <xref:System.Linq.Enumerable.SingleOrDefault%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> を配列の唯一の要素を選択します。  
  
 [!code-csharp[System.Linq.Enumerable\#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#79)]
 [!code-vb[System.Linq.Enumerable\#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#79)]  
  
 次のコード例に示しますを <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 、シーケンスに 1 個の要素が含まれていない場合は例外をスローします。  
  
 [!code-csharp[System.Linq.Enumerable\#80](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#80)]
 [!code-vb[System.Linq.Enumerable\#80](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">入力シーケンスには、複数の要素が含まれています。  
  
 または  
  
 入力シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> から 1 つの要素を返します。</param>
        <param name="predicate">要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定された条件を満たす、シーケンスの唯一の要素を返し、そのような要素が複数存在する場合は例外をスローします。</summary>
        <returns>条件を満たす、入力シーケンスの 1 つの要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> メソッドは、入力シーケンスに一致する要素が含まれていない場合に例外をスローします。 返すには `null` 一致する要素が見つからないときに使用して <xref:System.Linq.Enumerable.SingleOrDefault%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 条件を満たす、配列の唯一の要素を選択します。  
  
 [!code-csharp[System.Linq.Enumerable\#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#81)]
 [!code-vb[System.Linq.Enumerable\#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#81)]  
  
 次のコード例に示しますを <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 、シーケンスに条件を満たす要素が 1 つだけが含まれていない場合は例外をスローします。  
  
 [!code-csharp[System.Linq.Enumerable\#82](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#82)]
 [!code-vb[System.Linq.Enumerable\#82](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">条件を満たす要素がない <paramref name="predicate" />します。  
  
 または  
  
 1 つ以上の要素の条件を満たす <paramref name="predicate" />します。  
  
 または  
  
 ソース シーケンスが空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> の 1 つの要素を返します。</param>
        <summary>シーケンスが空である場合は、シーケンス、または既定値の唯一の要素を返しますこのメソッドは、シーケンス内に複数の要素がある場合に例外をスローします。</summary>
        <returns>入力シーケンスの 1 つの要素または <see langword="default" />\(<paramref name="TSource" />\) 場合は、シーケンスに要素が含まれていません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 参照および null 許容型の既定値は `null`です。  
  
 <xref:System.Linq.Enumerable.SingleOrDefault%2A> メソッドは、既定値を指定する方法を提供していません。 以外の場合、既定値を指定する場合は、 `default`\(`TSource`\) を使用して、 <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> 例」のセクションで説明するメソッドです。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> を配列の唯一の要素を選択します。  
  
 [!code-csharp[System.Linq.Enumerable\#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#83)]
 [!code-vb[System.Linq.Enumerable\#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#83)]  
  
 次のコード例に示しますを <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 、シーケンスに 1 個の要素が含まれていない場合は、既定値を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#84](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#84)]
 [!code-vb[System.Linq.Enumerable\#84](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#84)]  
  
 値も `default`\(`TSource`\) が、コレクションに要素が含まれていない場合に使用する既定値はありません。 不要な既定値の結果をチェックし、必要に応じてを変更して、代わりに使用することができます、 <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> コレクションが空の場合に使用する既定値を指定します。 次に、呼び出す <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> 要素を取得します。 次のコード例では、両方の手法を使用して、ページ番号のコレクションが空の場合は、1 の既定値を取得します。 整数の既定値が 0 ではない通常有効なページ番号であるため既定値必要があります 1 として代わりに指定します。 クエリの実行が完了した後、不要な既定値の最初の結果変数がチェックされます。 使用して 2 つ目の結果変数が取得 <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> を既定値は 1 を指定します。  
  
 [!code-csharp[System.Linq.Enumerable\#128](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#128)]
 [!code-vb[System.Linq.Enumerable\#128](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#128)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">入力シーケンスには、複数の要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> から 1 つの要素を返します。</param>
        <param name="predicate">要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定された条件を満たすシーケンスの唯一の要素、またはそのような要素がない場合は既定値を返します。このメソッドは、複数の要素が条件を満たす場合に例外をスローします。</summary>
        <returns>条件を満たす入力シーケンスの 1 つの要素または <see langword="default" />\(<paramref name="TSource" />\) このような要素が存在しない場合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 参照および null 許容型の既定値は `null`です。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 条件を満たす、配列の唯一の要素を選択します。  
  
 [!code-csharp[System.Linq.Enumerable\#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#85)]
 [!code-vb[System.Linq.Enumerable\#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#85)]  
  
 次のコード例に示しますを <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 、シーケンスに条件を満たす要素が 1 つだけが含まれていない場合は、既定値を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#86](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#86)]
 [!code-vb[System.Linq.Enumerable\#86](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 要素を返します。</param>
        <param name="count">残りの要素を返す前にスキップする要素の数。</param>
        <summary>指定された数のシーケンス内の要素をバイパスし、残りの要素を返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 入力シーケンスで指定したインデックスの後に出現する要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 場合 `source` より短くなる `count` 要素、空 <xref:System.Collections.Generic.IEnumerable%601> が返されます。 場合 `count` がゼロのすべての要素に小さい `source` が生成されます。  
  
 <xref:System.Linq.Enumerable.Take%2A> と <xref:System.Linq.Enumerable.Skip%2A> メソッドは、機能を補完します。 シーケンスを指定した `coll` および整数 `n`, の結果を連結する `coll.Take(n)` と `coll.Skip(n)` と同じシーケンスが生成されます `coll`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Skip` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Skip%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Skip%2A> 並べ替えられた配列の要素の指定した数をスキップし、残りの要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#87)]
 [!code-vb[System.Linq.Enumerable\#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 要素を返します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定した条件が true で、残りの要素を返す限りは、シーケンス内の要素をバイパスします。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> で指定されたテストに合格しなかった線系列の最初の要素を起点として入力シーケンスから要素を含む <paramref name="predicate" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> メソッドは遅延実行を使用して実装します。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 このメソッドの各要素はテスト `source` を使用して `predicate` し、結果がの場合、要素をスキップ `true`します。 述語関数から制御が戻た後 `false` 要素、その要素との残りの要素の `source` が生成のない複数の呼び出しがあると `predicate`です。  
  
 場合 `predicate` 返します `true` すべての要素シーケンス、空の <xref:System.Collections.Generic.IEnumerable%601> が返されます。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A> と <xref:System.Linq.Enumerable.SkipWhile%2A> メソッドは、機能を補完します。 シーケンスを指定した `coll` と純粋関数 `p`, の結果を連結する `coll.TakeWhile(p)` と `coll.SkipWhile(p)` と同じシーケンスが生成されます `coll`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Skip While` の呼び出しに変換される句 <xref:System.Linq.Enumerable.SkipWhile%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 条件が true の場合に限り、配列の要素をスキップします。  
  
 [!code-csharp[System.Linq.Enumerable\#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#88)]
 [!code-vb[System.Linq.Enumerable\#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 要素を返します。</param>
        <param name="predicate">各ソース要素が条件に当てはまるかどうかをテストする関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <summary>指定した条件が true で、残りの要素を返す限りは、シーケンス内の要素をバイパスします。 要素のインデックスは、述語関数のロジックで使用されます。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> で指定されたテストに合格しなかった線系列の最初の要素を起点として入力シーケンスから要素を含む <paramref name="predicate" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> メソッドの各要素はテスト `source` を使用して `predicate` し、結果がの場合、要素をスキップ `true`します。 述語関数から制御が戻た後 `false` 要素、その要素との残りの要素の `source` が生成のない複数の呼び出しがあると `predicate`です。  
  
 場合 `predicate` 返します `true` すべての要素シーケンス、空の <xref:System.Collections.Generic.IEnumerable%601> が返されます。  
  
 最初の引数 `predicate` をテストする要素を表します。 2 番目の引数内の要素の 0 から始まるインデックスを表す `source`します。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A> と <xref:System.Linq.Enumerable.SkipWhile%2A> メソッドは、機能を補完します。 シーケンスを指定した `coll` と純粋関数 `p`, の結果を連結する `coll.TakeWhile(p)` と `coll.SkipWhile(p)` と同じシーケンスが生成されます `coll`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Skip While` の呼び出しに変換される句 <xref:System.Linq.Enumerable.SkipWhile%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> 要素のインデックスに依存している条件が true の場合に限り、配列の要素をスキップします。  
  
 [!code-csharp[System.Linq.Enumerable\#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#89)]
 [!code-vb[System.Linq.Enumerable\#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Decimal" /> 値の合計を計算します。</param>
        <summary>一連の合計を計算 <see cref="T:System.Decimal" /> 値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> 場合は 0 を返します `source` 要素が含まれていません。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> 一連の値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable\#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Decimal.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Double" /> 値の合計を計算します。</param>
        <summary>一連の合計を計算 <see cref="T:System.Double" /> 値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> 一連の値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable\#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Int32" /> 値の合計を計算します。</param>
        <summary>一連の合計を計算 <see cref="T:System.Int32" /> 値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> 一連の値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable\#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Int32.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Int64" /> 値の合計を計算します。</param>
        <summary>一連の合計を計算 <see cref="T:System.Int64" /> 値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> 一連の値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable\#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Int64.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Decimal" /> 値の合計を計算します。</param>
        <summary>Null 許容型のシーケンスの合計を計算 <see cref="T:System.Decimal" /> 値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 結果はは値を含めません `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> 一連の値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable\#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Decimal.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Double" /> 値の合計を計算します。</param>
        <summary>Null 許容型のシーケンスの合計を計算 <see cref="T:System.Double" /> 値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 結果が値を含まない `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> 一連の値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable\#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Int32" /> 値の合計を計算します。</param>
        <summary>Null 許容型のシーケンスの合計を計算 <see cref="T:System.Int32" /> 値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 結果が値を含まない `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> 一連の値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable\#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Int32.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Int64" /> 値の合計を計算します。</param>
        <summary>Null 許容型のシーケンスの合計を計算 <see cref="T:System.Int64" /> 値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 結果が値を含まない `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> 一連の値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable\#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Int64.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Null 許容型のシーケンス <see cref="T:System.Single" /> 値の合計を計算します。</param>
        <summary>Null 許容型のシーケンスの合計を計算 <see cref="T:System.Single" /> 値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 結果が値を含まない `null`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> 一連の値を合計します。  
  
 [!code-csharp[System.Linq.Enumerable\#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable\#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">一連の <see cref="T:System.Single" /> 値の合計を計算します。</param>
        <summary>一連の合計を計算 <see cref="T:System.Single" /> 値。</summary>
        <returns>シーケンス内の値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> 一連の値を合計します。  
  
 [!code-csharp[System.Linq.Enumerable\#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable\#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの合計を計算 <see cref="T:System.Decimal" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>射影された値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Decimal>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> すると、シーケンスの射影された値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable\#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Decimal.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの合計を計算 <see cref="T:System.Double" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>射影された値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Double>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> すると、シーケンスの射影された値を合計します。  
  
 [!code-csharp[System.Linq.Enumerable\#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable\#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの合計を計算 <see cref="T:System.Int32" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>射影された値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Int32>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> すると、シーケンスの射影された値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable\#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Int32.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの合計を計算 <see cref="T:System.Int64" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>射影された値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Int64>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> すると、シーケンスの射影された値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable\#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Int64.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容型のシーケンスの合計を計算 <see cref="T:System.Decimal" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>射影された値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 結果には値が含まれていない `null`します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Decimal>` C\# の場合、または `Nullable(Of Decimal)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> すると、シーケンスの射影された値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable\#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Decimal.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容型のシーケンスの合計を計算 <see cref="T:System.Double" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>射影された値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 結果が値を含まない `null`します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Double>` C\# の場合、または `Nullable(Of Double)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> すると、シーケンスの射影された値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable\#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容型のシーケンスの合計を計算 <see cref="T:System.Int32" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>射影された値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 結果が値を含まない `null`します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Int32>` C\# の場合、または `Nullable(Of Int32)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> すると、シーケンスの射影された値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable\#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Int32.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容型のシーケンスの合計を計算 <see cref="T:System.Int64" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>射影された値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 結果が値を含まない `null`します。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には `Nullable<Int64>` C\# の場合または `Nullable(Of Int64)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> すると、シーケンスの射影された値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable\#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.OverflowException">合計を超える <see cref="F:System.Int64.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>Null 許容型のシーケンスの合計を計算 <see cref="T:System.Single" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>射影された値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが戻る場合は 0 `source` 要素が含まれていません。  
  
 結果が値を含まない `null`します。  
  
 関数を指定する場合は、任意の値のシーケンスにこのメソッドを適用できます `selector`, のメンバーのプロジェクトを `source` 数値型に具体的には `Nullable<Single>` C\# の場合、または `Nullable(Of Single)` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> すると、シーケンスの射影された値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable\#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">合計を計算に使用される値のシーケンス。</param>
        <param name="selector">各要素に適用する変換関数。</param>
        <summary>シーケンスの合計を計算 <see cref="T:System.Single" /> 入力シーケンスの各要素に対して変換関数を呼び出すことによって取得される値。</summary>
        <returns>射影された値の合計です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> 場合は 0 を返します `source` 要素が含まれていません。  
  
 関数を提供する場合にこのメソッドを任意の値のシーケンスに適用できる `selector`, のメンバーを射影する `source` 数値型に具体的には <xref:System.Single>です。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Aggregate Into Sum()` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Sum%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> すると、シーケンスの射影された値を合計します。  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable\#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable\#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="selector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">要素を返すシーケンス。</param>
        <param name="count">返す要素数。</param>
        <summary>シーケンスの先頭から指定した数の連続する要素を返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 入力シーケンスの先頭から要素の指定した数を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.Take%2A> 列挙 `source` までの要素を生成 `count` 要素が生成されてまたは `source`ない多くの要素が含まれています。 場合 `count` 内の要素の数を超える `source`, のすべての要素 `source`が返されます。  
  
 場合 `count` が 0、小さい `source` が列挙され、空の <xref:System.Collections.Generic.IEnumerable%601> が返されます。  
  
 <xref:System.Linq.Enumerable.Take%2A> と <xref:System.Linq.Enumerable.Skip%2A> メソッドは、機能を補完します。 シーケンスを指定した `coll` および整数 `n`, の結果を連結する `coll.Take(n)` と `coll.Skip(n)` と同じシーケンスが生成されます `coll`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Take` の呼び出しに変換される句 <xref:System.Linq.Enumerable.Take%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Take%2A> をシーケンスの先頭から要素を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#99)]
 [!code-vb[System.Linq.Enumerable\#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">要素を返すシーケンス。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>指定された条件が true の場合に限り、シーケンスから要素を返します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> テストに合格不要になった要素の前に出現する入力シーケンスから要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> メソッドの各要素はテスト `source` を使用して `predicate` 場合は、結果は要素を生成および `true`です。 述語関数が戻るときに列挙が停止した `false` 要素の場合、または `source` ない多くの要素が含まれています。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A> と <xref:System.Linq.Enumerable.SkipWhile%2A> メソッドは、機能を補完します。 シーケンスを指定した `coll` と純粋関数 `p`, の結果を連結する `coll.TakeWhile(p)` と `coll.SkipWhile(p)` と同じシーケンスが生成されます `coll`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Take While` の呼び出しに変換される句 <xref:System.Linq.Enumerable.TakeWhile%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> 条件が true の場合に限り、シーケンスの先頭から要素を返す。  
  
 [!code-csharp[System.Linq.Enumerable\#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#100)]
 [!code-vb[System.Linq.Enumerable\#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">要素を返すシーケンス。</param>
        <param name="predicate">各ソース要素が条件に当てはまるかどうかをテストする関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <summary>指定された条件が true の場合に限り、シーケンスから要素を返します。 要素のインデックスは、述語関数のロジックで使用されます。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> テストに合格不要になった要素の前に出現する入力シーケンスから要素を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> メソッドの各要素はテスト `source` を使用して `predicate` 場合は、結果は要素を生成および `true`です。 述語関数が戻るときに列挙が停止した `false` 要素の場合、または `source` ない多くの要素が含まれています。  
  
 最初の引数 `predicate` をテストする要素を表します。 2 番目の引数内の要素の 0 から始まるインデックスを表す `source`します。  
  
 <xref:System.Linq.Enumerable.TakeWhile%2A> と <xref:System.Linq.Enumerable.SkipWhile%2A> メソッドは、機能を補完します。 シーケンスを指定した `coll` と純粋関数 `p`, の結果を連結する `coll.TakeWhile(p)` と `coll.SkipWhile(p)` と同じシーケンスが生成されます `coll`します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Take While` の呼び出しに変換される句 <xref:System.Linq.Enumerable.TakeWhile%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> 要素のインデックスを使用する条件が満たされる限り、シーケンスの先頭から要素を返す。  
  
 [!code-csharp[System.Linq.Enumerable\#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#101)]
 [!code-vb[System.Linq.Enumerable\#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 並べ替える要素を格納しています。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <summary>キーに従って昇順のシーケンス内の要素の後続の並べ替えを実行します。</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 要素がキーに従って並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 要素自体の値によって、シーケンスを注文するには、identity 関数を指定 \(`x => x` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `Function(x) x` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の `keySelector`です。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> <xref:System.Linq.Enumerable.ThenByDescending%2A> 型を拡張が定義されている <xref:System.Linq.IOrderedEnumerable%601>, 、これらのメソッドの戻り値の型でもあります。 この設計では、任意の数を適用することで複数の並べ替えの条件を指定できます。 <xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A> メソッドです。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601> から継承 <xref:System.Collections.Generic.IEnumerable%601>, 、呼び出すことができます <xref:System.Linq.Enumerable.OrderBy%2A> または <xref:System.Linq.Enumerable.OrderByDescending%2A> への呼び出しの結果に <xref:System.Linq.Enumerable.OrderBy%2A>, 、<xref:System.Linq.Enumerable.OrderByDescending%2A>, 、<xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリ順序以前確立された順序を無視するが導入されています。  
  
 このメソッドは、既定の比較子を使用してキーを比較 <xref:System.Collections.Generic.Comparer%601.Default%2A>します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
 クエリ式の構文で、 `orderby [first criterion], [second criterion]` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Order By [first criterion], [second criterion]` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.ThenBy%2A>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.ThenBy%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> シーケンス内の要素の順序付けセカンダリを実行します。  
  
 [!code-csharp[System.Linq.Enumerable\#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#102)]
 [!code-vb[System.Linq.Enumerable\#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 並べ替える要素を格納しています。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> キーを比較します。</param>
        <summary>指定された比較子を使用して、昇順のシーケンス内の要素の後続の並べ替えを実行します。</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 要素がキーに従って並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 要素自体の値によって、シーケンスを注文するには、identity 関数を指定 \(`x => x` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `Function(x) x` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の `keySelector`です。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> <xref:System.Linq.Enumerable.ThenByDescending%2A> 型を拡張が定義されている <xref:System.Linq.IOrderedEnumerable%601>, 、これらのメソッドの戻り値の型でもあります。 この設計では、任意の数を適用することで複数の並べ替えの条件を指定できます。 <xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A> メソッドです。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601> から継承 <xref:System.Collections.Generic.IEnumerable%601>, 、呼び出すことができます <xref:System.Linq.Enumerable.OrderBy%2A> または <xref:System.Linq.Enumerable.OrderByDescending%2A> への呼び出しの結果に <xref:System.Linq.Enumerable.OrderBy%2A>, 、<xref:System.Linq.Enumerable.OrderByDescending%2A>, 、<xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリ順序以前確立された順序を無視するが導入されています。  
  
 場合 `comparer` は `null`, 、既定の比較子 <xref:System.Collections.Generic.Comparer%601.Default%2A> キーを比較するために使用します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 並べ替える要素を格納しています。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <summary>キーに従って降順に並べ替え、シーケンス内の要素の後続の並べ替えを実行します。</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 要素がキーに従って降順に並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 要素自体の値によって、シーケンスを注文するには、identity 関数を指定 \(`x => x` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `Function(x) x` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の `keySelector`です。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> <xref:System.Linq.Enumerable.ThenByDescending%2A> 型を拡張が定義されている <xref:System.Linq.IOrderedEnumerable%601>, 、これらのメソッドの戻り値の型でもあります。 この設計では、任意の数を適用することで複数の並べ替えの条件を指定できます。 <xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A> メソッドです。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601> から継承 <xref:System.Collections.Generic.IEnumerable%601>, 、呼び出すことができます <xref:System.Linq.Enumerable.OrderBy%2A> または <xref:System.Linq.Enumerable.OrderByDescending%2A> への呼び出しの結果に <xref:System.Linq.Enumerable.OrderBy%2A>, 、<xref:System.Linq.Enumerable.OrderByDescending%2A>, 、<xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリ順序以前確立された順序を無視するが導入されています。  
  
 この並べ替えメソッドは、既定の比較子を使用してキーを比較 <xref:System.Collections.Generic.Comparer%601.Default%2A>します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
 [!INCLUDE[csprcs](~/includes/csprcs-md.md)] クエリ式の構文、 `orderby [first criterion], [second criterion] descending` の呼び出しに変換される句 <xref:System.Linq.Enumerable.ThenByDescending%2A>します。  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] クエリ式の構文、 `Order By [first criterion], [second criterion] Descending` の呼び出しに変換される句 <xref:System.Linq.Enumerable.ThenByDescending%2A>します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 並べ替える要素を格納しています。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> キーを比較します。</param>
        <summary>指定された比較子を使用して、降順のシーケンス内の要素の後続の並べ替えを実行します。</summary>
        <returns>
          <see cref="T:System.Linq.IOrderedEnumerable`1" /> 要素がキーに従って降順に並べ替えられています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 要素自体の値によって、シーケンスを注文するには、identity 関数を指定 \(`x => x` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `Function(x) x` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の `keySelector`です。  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> <xref:System.Linq.Enumerable.ThenByDescending%2A> 型を拡張が定義されている <xref:System.Linq.IOrderedEnumerable%601>, 、これらのメソッドの戻り値の型でもあります。 この設計では、任意の数を適用することで複数の並べ替えの条件を指定できます。 <xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A> メソッドです。  
  
> [!NOTE]
>  <xref:System.Linq.IOrderedEnumerable%601> から継承 <xref:System.Collections.Generic.IEnumerable%601>, 、呼び出すことができます <xref:System.Linq.Enumerable.OrderBy%2A> または <xref:System.Linq.Enumerable.OrderByDescending%2A> への呼び出しの結果に <xref:System.Linq.Enumerable.OrderBy%2A>, 、<xref:System.Linq.Enumerable.OrderByDescending%2A>, 、<xref:System.Linq.Enumerable.ThenBy%2A> または <xref:System.Linq.Enumerable.ThenByDescending%2A>です。 これを行うには、新しいプライマリ順序以前確立された順序を無視するが導入されています。  
  
 場合 `comparer` は `null`, 、既定の比較子 <xref:System.Collections.Generic.Comparer%601.Default%2A> キーを比較するために使用します。  
  
 このメソッドは、安定した並べ替えを実行します。つまり、2 つの要素のキーが等しい場合は、要素の順序が保持されます。 これに対し、不安定な並べ替えでは、同じキーを持つ要素の順序は保持されません。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.ThenByDescending%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> カスタム比較子を使用して、降順のシーケンス内の要素の順序付けセカンダリを実行します。  
  
 [!code-csharp[System.Linq.Enumerable\#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#103)]
 [!code-vb[System.Linq.Enumerable\#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> から配列を作成します。</param>
        <summary>配列を作成、 <see cref="T:System.Collections.Generic.IEnumerable`1" />です。</summary>
        <returns>入力シーケンスの要素を含む配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.ToArray%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドがクエリの即時の評価が強制し、クエリの結果を格納する配列を返します。 このメソッドは、クエリ結果のキャッシュされたコピーを取得するために、クエリに追加できます。  
  
 <xref:System.Linq.Enumerable.ToList%2A> 同様の動作を返しますが、 <xref:System.Collections.Generic.List%601> 、配列の代わりにします。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.ToArray%2A> を強制的にクエリの即時評価し、結果の配列を返します。  
  
 [!code-csharp[System.Linq.Enumerable\#104](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#104)]
 [!code-vb[System.Linq.Enumerable\#104](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を作成する、 <see cref="T:System.Collections.Generic.Dictionary`2" /> からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <summary>作成、 <see cref="T:System.Collections.Generic.Dictionary`2" /> から、 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 指定されたキー セレクター関数に従ってします。</summary>
        <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> キーと値が含まれています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> メソッドは、既定の等値比較子を使用して <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> を作成する、 <xref:System.Collections.Generic.Dictionary%602> されたキー セレクターを使用しています。  
  
 [!code-csharp[System.Linq.Enumerable\#105](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#105)]
 [!code-vb[System.Linq.Enumerable\#105](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。  
  
 または  
  
 <paramref name="keySelector" /> キーを生成する <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> 生成するには、2 つの要素のキーが重複しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を作成する、 <see cref="T:System.Collections.Generic.Dictionary`2" /> からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> キーを比較します。</param>
        <summary>作成、 <see cref="T:System.Collections.Generic.Dictionary`2" /> から、 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 指定されたキー セレクター関数およびキーの比較子に従ってします。</summary>
        <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> キーと値が含まれています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `comparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較するために使用します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。  
  
 または  
  
 <paramref name="keySelector" /> キーを生成する <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> 生成するには、2 つの要素のキーが重複しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <typeparam name="TElement">によって返される値の型 <c>elementSelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を作成する、 <see cref="T:System.Collections.Generic.Dictionary`2" /> からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="elementSelector">各要素から結果の要素値を生成する変換関数。</param>
        <summary>作成、 <see cref="T:System.Collections.Generic.Dictionary`2" /> から、 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 指定されたキー セレクター関数および要素セレクター関数に従ってします。</summary>
        <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> 型の値を含む <paramref name="TElement" /> 入力シーケンスから選択します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.ToDictionary%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> メソッドは、既定の等値比較子を使用して <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。  
  
 または  
  
 <paramref name="keySelector" /> キーを生成する <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> 生成するには、2 つの要素のキーが重複しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <typeparam name="TElement">によって返される値の型 <c>elementSelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を作成する、 <see cref="T:System.Collections.Generic.Dictionary`2" /> からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="elementSelector">各要素から結果の要素値を生成する変換関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> キーを比較します。</param>
        <summary>作成、 <see cref="T:System.Collections.Generic.Dictionary`2" /> から、 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 指定されたキー セレクター関数、比較演算子、および要素セレクター関数に従ってします。</summary>
        <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> 型の値を含む <paramref name="TElement" /> 入力シーケンスから選択します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `comparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較するために使用します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。  
  
 または  
  
 <paramref name="keySelector" /> キーを生成する <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> 生成するには、2 つの要素のキーが重複しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を作成する、 <see cref="T:System.Collections.Generic.List`1" /> からです。</param>
        <summary>作成、 <see cref="T:System.Collections.Generic.List`1" /> から、 <see cref="T:System.Collections.Generic.IEnumerable`1" />です。</summary>
        <returns>A <see cref="T:System.Collections.Generic.List`1" /> 入力シーケンスから要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.ToList%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドがクエリの即時の評価が強制し、返します、 <xref:System.Collections.Generic.List%601> クエリの結果を格納しています。 このメソッドは、クエリ結果のキャッシュされたコピーを取得するために、クエリに追加できます。  
  
 <xref:System.Linq.Enumerable.ToArray%2A> 同様の動作の代わりに配列を返しますが、 <xref:System.Collections.Generic.List%601>です。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.ToList%2A> を強制的にクエリの即時の評価を返す、 <xref:System.Collections.Generic.List%601> クエリの結果を格納しています。  
  
 [!code-csharp[System.Linq.Enumerable\#106](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#106)]
 [!code-vb[System.Linq.Enumerable\#106](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を作成する、 <see cref="T:System.Linq.Lookup`2" /> からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <summary>作成、 <see cref="T:System.Linq.Lookup`2" /> から、 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 指定されたキー セレクター関数に従ってします。</summary>
        <returns>A <see cref="T:System.Linq.Lookup`2" /> キーと値が含まれています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> メソッドが返される、 <xref:System.Linq.Lookup%602>, 、値のコレクションにキーをマップする一対多のディクショナリ。 A <xref:System.Linq.Lookup%602> と異なる、 <xref:System.Collections.Generic.Dictionary%602>, 、単一の値をキーの一対一のマッピングを実行します。  
  
 既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較するために使用します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を作成する、 <see cref="T:System.Linq.Lookup`2" /> からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> キーを比較します。</param>
        <summary>作成、 <see cref="T:System.Linq.Lookup`2" /> から、 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 指定されたキー セレクター関数およびキーの比較子に従ってします。</summary>
        <returns>A <see cref="T:System.Linq.Lookup`2" /> キーと値が含まれています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> メソッドが返される、 <xref:System.Linq.Lookup%602>, 、値のコレクションにキーをマップする一対多のディクショナリ。 A <xref:System.Linq.Lookup%602> 異なりますが、 <xref:System.Collections.Generic.Dictionary%602>, 、単一の値をキーの一対一のマッピングを実行します。  
  
 場合 `comparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較するために使用します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="keySelector" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <typeparam name="TElement">によって返される値の型 <c>elementSelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を作成する、 <see cref="T:System.Linq.Lookup`2" /> からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="elementSelector">各要素から結果の要素値を生成する変換関数。</param>
        <summary>作成、 <see cref="T:System.Linq.Lookup`2" /> から、 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 指定されたキー セレクター関数および要素セレクター関数に従ってします。</summary>
        <returns>A <see cref="T:System.Linq.Lookup`2" /> 型の値を含む <paramref name="TElement" /> 入力シーケンスから選択します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> メソッドが返される、 <xref:System.Linq.Lookup%602>, 、値のコレクションにキーをマップする一対多のディクショナリ。 A <xref:System.Linq.Lookup%602> と異なる、 <xref:System.Collections.Generic.Dictionary%602>, 、単一の値をキーの一対一のマッピングを実行します。  
  
 既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較するために使用します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> を作成する、 <xref:System.Linq.Lookup%602> されたキー セレクター関数および要素セレクター関数を使用しています。  
  
 [!code-csharp[System.Linq.Enumerable\#107](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#107)]
 [!code-vb[System.Linq.Enumerable\#107](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <typeparam name="TKey">によって返されるキーの種類 <c>keySelector</c>します。</typeparam>
        <typeparam name="TElement">によって返される値の型 <c>elementSelector</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> を作成する、 <see cref="T:System.Linq.Lookup`2" /> からです。</param>
        <param name="keySelector">各要素からキーを抽出する関数。</param>
        <param name="elementSelector">各要素から結果の要素値を生成する変換関数。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> キーを比較します。</param>
        <summary>作成、 <see cref="T:System.Linq.Lookup`2" /> から、 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 指定されたキー セレクター関数、比較演算子、および要素セレクター関数に従ってします。</summary>
        <returns>A <see cref="T:System.Linq.Lookup`2" /> 型の値を含む <paramref name="TElement" /> 入力シーケンスから選択します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> メソッドが返される、 <xref:System.Linq.Lookup%602>, 、値のコレクションにキーをマップする一対多のディクショナリ。 A <xref:System.Linq.Lookup%602> と異なる、 <xref:System.Collections.Generic.Dictionary%602>, 、単一の値をキーの一対一のマッピングを実行します。  
  
 場合 `comparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> キーを比較するために使用します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />、<paramref name="keySelector" />、または <paramref name="elementSelector" /> は、<see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 共用体の最初のセットを形成する異なる要素を格納します。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 和集合の 2 番目のセットを形成する異なる要素を格納します。</param>
        <summary>既定の等値比較子を使用して 2 つのシーケンスの和集合を生成します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 重複部分を除く、両方の入力シーケンスから要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 このメソッドは、返されるセットから重複部分を除外します。 これは、異なる動作を <xref:System.Linq.Enumerable.Concat%2A> メソッドで、重複も含めて入力シーケンスのすべての要素を返します。  
  
 既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、実装する型の値を比較に使用される、 <xref:System.Collections.Generic.IEqualityComparer%601> ジェネリック インターフェイスです。 カスタム データ型を比較する必要がありますこのインターフェイスを実装でき、独自 <xref:System.Object.GetHashCode%2A> と <xref:System.Object.Equals%2A> の型のメソッドです。  
  
 このメソッドによって返されるオブジェクトを列挙した場合に <xref:System.Linq.Enumerable.Union%2A> 列挙 `first` と `second` に順にし、既に生成されていない各要素を生成します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> を整数の 2 つのシーケンスの和集合を取得します。  
  
 [!code-csharp[System.Linq.Enumerable\#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#109)]
 [!code-vb[System.Linq.Enumerable\#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#109)]  
  
 実装する必要があるカスタム データ型のオブジェクトのシーケンスを比較する場合、 <xref:System.Collections.Generic.IEqualityComparer%601> 、helperclass でジェネリック インターフェイスです。 カスタム データ型にこのインターフェイスを実装でき、次のコード例に示します <xref:System.Object.GetHashCode%2A> と <xref:System.Object.Equals%2A> メソッドです。  
  
 [!code-csharp[CSLINQEncapsulatedComparer\#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 このインターフェイスを実装した後は、シーケンスを使用して `ProductA` 内のオブジェクト、 <xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> メソッドを次の例に示すようにします。  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#4)]
[!code-vb[CSLINQEncapsulatedComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">入力シーケンスの要素の型。</typeparam>
        <param name="first">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 共用体の最初のセットを形成する異なる要素を格納します。</param>
        <param name="second">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 和集合の 2 番目のセットを形成する異なる要素を格納します。</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> 値を比較します。</param>
        <summary>指定したを使用して 2 つのシーケンスの和集合を生成 <see cref="T:System.Collections.Generic.IEqualityComparer`1" />します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 重複部分を除く、両方の入力シーケンスから要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 C 場合`omparer` は `null`, 、既定の等値比較子 <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, 、値を比較するために使用します。  
  
 このメソッドによって返されるオブジェクトを列挙した場合に <xref:System.Linq.Enumerable.Union%2A> 列挙 `first` と `second` に順にし、既に生成されていない各要素を生成します。  
  
 <xref:System.Linq.Enumerable.Concat%2A> メソッドとは異なります、 <xref:System.Linq.Enumerable.Union%2A> メソッドのため、 <xref:System.Linq.Enumerable.Concat%2A> メソッドは、一方、重複を含む入力シーケンスのすべての要素を返します <xref:System.Linq.Enumerable.Union%2A> 一意の値のみを返します。  
  
   
  
## 例  
 次の例で使用する等値比較子を実装する方法を示しています、 <xref:System.Linq.Enumerable.Union%2A> メソッドです。  
  
 [!code-csharp[CSLINQCustomComparer\#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer\#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 この比較演算子を実装した後は、シーケンスを使用して `Product` 内のオブジェクト、 <xref:System.Linq.Enumerable.Union%2A> メソッドを次の例に示すようにします。  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#4)]
[!code-vb[CSLINQCustomComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> をフィルター処理します。</param>
        <param name="predicate">各要素が条件を満たしているかどうかをテストする関数。</param>
        <summary>述語に基づいて値のシーケンスをフィルター処理します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 条件を満たす入力シーケンスから要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 クエリ式の構文で、 `where` \([!INCLUDE[csprcs](~/includes/csprcs-md.md)]\) または `Where` \([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]\) の呼び出しに変換される句 <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> シーケンスをフィルター処理します。  
  
 [!code-csharp[System.Linq.Enumerable\#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#110)]
 [!code-vb[System.Linq.Enumerable\#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">要素の型 <c>source</c>します。</typeparam>
        <param name="source">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> をフィルター処理します。</param>
        <param name="predicate">各ソース要素が条件に当てはまるかどうかをテストする関数。この関数の 2 つ目のパラメーターは、ソース要素のインデックスを表します。</param>
        <summary>述語に基づいて値のシーケンスをフィルター処理します。 各要素のインデックスは、述語関数のロジックで使用されます。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 条件を満たす入力シーケンスから要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 すぐに、値は、操作を実行するために必要なすべての情報を格納するオブジェクトを返します。 オブジェクトのいずれかを呼び出すことが列挙されるまで、このメソッドで表されるクエリは実行されません、 `GetEnumerator` メソッドを使用して直接または `foreach` で [!INCLUDE[csprcs](~/includes/csprcs-md.md)] または `For Each` で [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]します。  
  
 最初の引数 `predicate` をテストする要素を表します。 2 番目の引数内の要素の 0 から始まるインデックスを表す `source`します。  
  
   
  
## 例  
 次のコード例では、使用して <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> を各要素のインデックスを含む述語に基づいてシーケンスをフィルター処理します。  
  
 [!code-csharp[System.Linq.Enumerable\#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#111)]
 [!code-vb[System.Linq.Enumerable\#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> または <paramref name="predicate" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">最初の入力シーケンスの要素の型。</typeparam>
        <typeparam name="TSecond">2 番目の入力シーケンスの要素の型。</typeparam>
        <typeparam name="TResult">結果のシーケンスの要素の型。</typeparam>
        <param name="first">マージする最初のシーケンス。</param>
        <param name="second">マージする 2 番目のシーケンス。</param>
        <param name="resultSelector">2 つのシーケンスから要素をマージする方法を指定する関数。</param>
        <summary>結果のシーケンスを生成する、2 つのシーケンスの対応する要素に指定された関数を適用します。</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> 2 つの入力シーケンスのマージされた要素を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは遅延実行を使用して実装されます。 即時の戻り値は、操作を実行するために必要なすべての情報を格納するオブジェクトです。 オブジェクトのいずれかを呼び出したが列挙されるまで、このメソッドで表されるクエリが実行されていませんが、`GetEnumerator`メソッド直接、またはを使用して`foreach`で[!INCLUDE[csprcs](~/includes/csprcs-md.md)]または`For Each`で[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]です。  
  
 メソッドは、最初のシーケンスの各要素を 2 番目のシーケンスで、同じインデックスを持つ要素とをマージします。 シーケンスには、同じ数の要素がないと、シーケンスは、それらのいずれかの末尾に達するまでに、メソッドによりマージします。 たとえば、1 つのシーケンスに 3 つの要素があり、ユーザーが 4 つが、もう 1 つは、結果のシーケンスがのみの 3 つの要素。  
  
   
  
## 例  
 次のコード例を使用する方法を示しています、 <xref:System.Linq.Enumerable.Zip%2A> 2 つのシーケンスにマージするメソッド。  
  
 [!code-csharp[System.Linq.Enumerable\#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#200)]
 [!code-vb[System.Linq.Enumerable\#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> または <paramref name="second" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>その要素が見つからない場合は、シーケンス、または既定値の 1 つの特定の要素を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>昇順のシーケンス内の要素の後続の並べ替えを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シーケンスの要素をグループ化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シーケンスの 1 つの特定の要素を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>一致するキーに基づいて 2 つのシーケンスの要素を基準になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つのシーケンスの積集合を生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シーケンスの要素を降順に並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シーケンスの最後の要素を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>要素が存在しない場合は、シーケンス、または既定値の最後の要素を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ToLookup&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ジェネリック型を作成 <see cref="T:System.Linq.Lookup`2" /> から、 <see cref="T:System.Collections.Generic.IEnumerable`1" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シーケンスの最初の要素を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シーケンスの各要素を新しいフォームに射影します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>数値のシーケンスの合計を計算します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>作成、 <see cref="T:System.Collections.Generic.Dictionary`2" /> から、 <see cref="T:System.Collections.Generic.IEnumerable`1" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した条件が true で、残りの要素を返す限りは、シーケンス内の要素をバイパスします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つのシーケンスの差集合を生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値のシーケンスの最大値を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>数値のシーケンスの平均を計算します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値のシーケンスの最小値を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>降順のシーケンス内の要素の後続の並べ替えを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>結果をグループ化キーの等値に基づいて 2 つのシーケンスの要素相互に関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>要素が存在しない場合は、シーケンス、または既定値の最初の要素を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シーケンス内の要素の数を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返します。、 <see cref="T:System.Int64" /> シーケンス内の要素の数を表します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シーケンスの任意の要素が存在するか、条件を満たすかどうかを決定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した要素を格納するシーケンスがサポートされるかどうかを決定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>述語に基づいて値のシーケンスをフィルター処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>2 つのシーケンスの和集合を生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シーケンスの各要素、 <see cref="T:System.Collections.Generic.IEnumerable`1" /> し、結果のシーケンスを 1 つのシーケンスに平坦化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>昇順のシーケンスの要素を並べ替えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>要素を返す、 <see cref="T:System.Collections.Generic.IEnumerable`1" />, 、シーケンスが空の場合、既定値はシングルトン コレクションを値またはです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した条件が true の場合、残りの要素をスキップする限り、シーケンスから要素を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>等値比較子に従って 2 つのシーケンスが等しいかどうかを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>