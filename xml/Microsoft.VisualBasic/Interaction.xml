<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see langword="Interaction" /> モジュールには、オブジェクト、アプリケーション、およびシステムと対話するための手順が含まれています。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 このモジュールは、Visual Basic 言語のキーワードとランタイム ライブラリ メンバーを他のプログラムを実行、メソッドまたはプロパティを呼び出す、コンピューターのビープ音、コマンドライン文字列の入力、COM オブジェクトの操作、ダイアログ ボックスの制御をサポートします。  
  
   
  
## 例  
 次の例では、 `Shell` 、ユーザーが指定したアプリケーションを実行する関数。 指定する <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=fullName> 、2 つ目の引数アプリケーションで標準サイズが開き、フォーカスを移します。  
  
```  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
' The preceding path is for Windows XP.  
' The Windows 2000 path is C:\WINNT\system32\calc.exe.  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ProcessId">
          <see langword="Integer" />このプロセスに割り当てられている Win32 プロセス ID 番号を指定します。 によって返される ID を使用することができます、 <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />0 ではない提供します。</param>
        <summary>既に実行されているアプリケーションをアクティブにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用する`AppActivate`にアプリケーションのアクティブ ウィンドウにフォーカスを取り込みます。 ハンドルまたはアクティブなウィンドウへの参照がありませんか特定の時点で、どのウィンドウがアクティブに気付いて可能性があります。 このような場合は、使用することはできません、<xref:System.Windows.Forms.Control.Focus%2A>メソッドです。  
  
 `AppActivate`関数は、名前付きアプリケーションまたはウィンドウにフォーカスしますが、最大化または最小化するかどうかは影響しません。 ユーザーがいくつかの操作にフォーカスを変更したり、ウィンドウを閉じるときに、フォーカスはアクティブ化されたアプリケーション ウィンドウから移動します。 使用することができます、`Shell`アプリケーションを起動し、ウィンドウのスタイルを設定する関数。  
  
 使用する場合、`Title`パラメーター、`AppActivate`大文字と小文字を使用しますが、それ以外の場合、タイトル バーの内容と正確に一致が必要です。 また、最上位レベルの windows を使用し、子ウィンドウをまず検索します。 一致を見つけられない、スロー、<xref:System.ArgumentException>です。  
  
 使用することができます`AppActivate`のみの windows を所有するプロセスです。 ほとんどのコンソール アプリケーションでは、プロセスの一覧に表示されませんが、windows を所有していない`AppActivate`ものを検索します。 コンソール アプリケーションから実行すると、システムは、アプリケーションを実行する別のプロセスを作成し、コンソール プロセスに出力を返します。 その結果、現在のプロセス ID を要求するときに取得するコンソール アプリケーションのプロセス ID ではなく、この個別のプロセスのプロセス ID  
  
 実行時に、`AppActivate`関数と一致するタイトル付きの実行中のアプリケーションをアクティブに`Title`または一致するプロセス ID を持つ`ProcessId`します。 完全一致がない場合のタイトル文字列で終わるすべてのアプリケーションがアクティブ化`Title`です。 という名前の複数のアプリケーションがあるかどうかは`Title`、`AppActivate`関数が任意にアクティブ化する 1 つを選択します。  
  
> [!NOTE]
>  `AppActivate`関数に必要な`UIPermission`で、<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>レベルで、部分的に信頼された状況での実行に影響を与える可能性があります。 詳細については、「<xref:System.Security.Permissions.UIPermission>」を参照してください。  
  
   
  
## 例  
 この例のさまざまな使用を示しています、`AppActivate`アプリケーション ウィンドウにアクティブにします。 メモ帳のプロセスが実行されていない場合がスローされます、<xref:System.ArgumentException>です。`Shell`プロシージャでは、アプリケーションは、指定されたパスに前提としています。  
  
 [!code-vb[VbVbalrCatRef\#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Title">
          <see langword="String" />アクティブ化するアプリケーションのタイトル バーのタイトルを指定する式。 起動したときに、アプリケーションに割り当てられているタイトルを使用することができます。</param>
        <summary>既に実行されているアプリケーションをアクティブにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用する`AppActivate`にアプリケーションのアクティブ ウィンドウにフォーカスを取り込みます。 ハンドルまたはアクティブなウィンドウへの参照がありませんか特定の時点で、どのウィンドウがアクティブに気付いて可能性があります。 このような場合は、使用することはできません、<xref:System.Windows.Forms.Control.Focus%2A>メソッドです。  
  
 `AppActivate`関数は、名前付きアプリケーションまたはウィンドウにフォーカスしますが、最大化または最小化するかどうかは影響しません。 ユーザーがいくつかの操作にフォーカスを変更したり、ウィンドウを閉じるときに、フォーカスはアクティブ化されたアプリケーション ウィンドウから移動します。 使用することができます、`Shell`アプリケーションを開始し、ウィンドウのスタイルを設定する関数。  
  
 使用する場合、`Title`パラメーター、`AppActivate`大文字と小文字を使用しますが、それ以外の場合、タイトル バーの内容と正確に一致が必要です。 また、最上位レベルの windows を使用し、子ウィンドウをまず検索します。 一致を見つけられない、スロー、<xref:System.ArgumentException>です。  
  
 使用することができます`AppActivate`のみの windows を所有するプロセスです。 ほとんどのコンソール アプリケーションでは、プロセスの一覧に表示されませんが、windows を所有していない`AppActivate`ものを検索します。 コンソール アプリケーションから実行すると、システムは、アプリケーションを実行する別のプロセスを作成し、コンソール プロセスに出力を返します。 その結果、現在のプロセス ID を要求するときに取得するコンソール アプリケーションのプロセス ID ではなく、この個別のプロセスのプロセス ID  
  
 実行時に、`AppActivate`機能のタイトルが一致する任意の実行中のアプリケーションをアクティブに`Title`または一致するプロセス ID を持つ`ProcessId`です。 完全一致がない場合のタイトル文字列で終わるすべてのアプリケーションがアクティブ化`Title`です。 という名前の複数のアプリケーションがあるかどうかは`Title`、`AppActivate`関数が任意にアクティブ化する 1 つを選択します。  
  
> [!NOTE]
>  `AppActivate`関数に必要な`UIPermission`で、<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>レベルで、部分的に信頼された状況での実行に影響を与える可能性があります。 詳細については、「<xref:System.Security.Permissions.UIPermission>」を参照してください。  
  
   
  
## 例  
 この例のさまざまな使用を示しています、`AppActivate`アプリケーション ウィンドウにアクティブにします。 メモ帳のプロセスが実行されていない場合がスローされます、<xref:System.ArgumentException>です。`Shell`プロシージャでは、アプリケーションは、指定されたパスに前提としています。  
  
 [!code-vb[VbVbalrCatRef\#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コンピューターのスピーカーを鳴らします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ビープ音の期間、ピッチ、ハードウェアおよびシステム ソフトウェアに依存し、そのため、コンピューターによって異なります。  
  
> [!NOTE]
>  `Beep`関数に必要な`UIPermission`で、<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>レベルで、部分的に信頼された状況での実行に影響を与える可能性があります。 詳細については、「<xref:System.Security.Permissions.UIPermission>」を参照してください。  
  
   
  
## 例  
 この例では、`Beep`をコンピューターのスピーカーで音を鳴らす関数。  
  
 [!code-vb[VbVbalrCatRef\#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">必須です。<see langword="Object" />。 プロパティまたはメソッドを公開しているオブジェクトへのポインター。</param>
        <param name="ProcName">必須です。<see langword="String" />。 プロパティまたはオブジェクトのメソッドの名前を含む文字列式です。</param>
        <param name="UseCallType">必須です。 型の列挙体のメンバー<see cref="T:Microsoft.VisualBasic.CallType" />呼び出されるプロシージャの種類を表すです。 The value of <see langword="CallType" /> can be <see langword="Method" />, <see langword="Get" />, or <see langword="Set" />.</param>
        <param name="Args">省略可能です。<see langword="ParamArray" />。 プロパティまたは呼び出されるメソッドに渡される引数を含むパラメーター配列を返します。</param>
        <summary>オブジェクトに対してメソッドを実行またはまたは設定オブジェクトのプロパティを返します。</summary>
        <returns>オブジェクトに対してメソッドを実行またはまたは設定オブジェクトのプロパティを返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `CallByName`プロパティを取得する、プロパティを設定またはメソッドの呼び出しを実行時に関数が使用されます。  
  
   
  
## 例  
 次の例では、最初の行を使用して`CallByName`を設定する、`Text`テキスト ボックスのプロパティの値を取得する 2 番目の行、`Text`プロパティ、および 3 番目の行を呼び出す、`Move`テキスト ボックスを移動する方法です。  
  
 [!code-vb[VbVbalrFunctions\#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions\#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 次の例では、`CallByName`呼び出す関数を`Add`と`Item`コレクション オブジェクトのメソッドです。  
  
 [!code-vb[VbVbalrFunctions\#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">無効な<paramref name="UseCallType" />値; の必要があります<see langword="Method" />、 <see langword="Get" />、または<see langword="Set" />です。</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" />
        <Parameter Name="Choice" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">必須です。<see langword="Double" />。 1 ~ 要素の数の値に評価される数値式が渡された、<c>Choice</c>引数。</param>
        <param name="Choice">必須です。<see langword="Object" />パラメーターの配列。 1 つの変数またはに評価される式のいずれかを指定することができます、<see langword="Object" />リストへのデータ型、<see langword="Object" />コンマ、またはの 1 次元配列を変数または式で区切られた<see langword="Object" />要素。</param>
        <summary>選択して、引数の一覧から値を返します。</summary>
        <returns>選択して、引数の一覧から値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `Choose`関数に渡される一覧のメンバーを返します`Choice()`の値に基づいて、`Index`です。 一覧の最初のメンバーが選択されているときに`Index`は 1 です。 一覧の最後のメンバーが選択されているときに`Index`は`UBound`\(`Choice()`\)。 場合`Index`がこれらの制限の範囲外`Choose`返します`Nothing`です。  
  
 場合`Index`が整数では、評価される前に、最も近い整数に丸められます。  
  
 使用することができます`Choose`候補のリスト内の値を検索します。  
  
> [!NOTE]
>  引数リスト内の式は、関数呼び出しを含めることができます。 呼び出しの引数リストの準備の一環として`Choose`、Visual Basic コンパイラは、すべての式ですべての関数を呼び出します。 つまり別の式が選択されている場合は、呼び出されていない特定の関数には使用できません`Index`です。  
  
   
  
## 例  
 この例では、`Choose`でプロシージャに渡されたインデックスへの応答で名前を表示する関数、`Ind`パラメーター。  
  
 [!code-vb[VbVbalrFunctions\#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Visual Basic で開発された Visual Basic または実行可能プログラムを開始するためのコマンドラインの引数の部分を返します。<see langword="My" />生産性とよりもパフォーマンスが向上を提供する機能、<see langword="Command " />機能します。 詳細については、「<see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />」を参照してください。</summary>
        <returns>Visual Basic で開発された Visual Basic または実行可能プログラムを開始するためのコマンドラインの引数の部分を返します。  
  
 <see langword="My" />生産性とよりもパフォーマンスが向上を提供する機能、<see langword="Command " />機能します。 詳細については、「<see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 引数が返された後は、空白文字、スラッシュ、ハイフン、または引用符、分割または個別のパラメーターの文字列を検索するなど、一般的な区切り記号を検索できます。  
  
 Visual Basic を使用して開発および .exe ファイルにコンパイルされたアプリケーションに対して、`Command`関数は、このフォームでのコマンド ラインで、アプリケーションの名前の後に指定した任意の引数を返します:`MyApp(cmdlineargs)`です。  
  
   
  
## 例  
 この例では、`Command`配列を含むオブジェクトのコマンドライン引数を返す関数。  
  
 [!code-vb[VbVbalrCatRef\#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">必須です。<see langword="String" />。 作成するオブジェクトのプログラム ID。</param>
        <param name="ServerName">省略可能です。<see langword="String" />。 オブジェクトを作成するネットワーク サーバーの名前。 場合<c>ServerName</c>空の文字列 \(""\)、ローカル コンピューターが使用されます。</param>
        <summary>作成し、COM オブジェクトへの参照を返します。<see langword="CreateObject" />Visual Basic でこれらのクラスが COM コンポーネントとして明示的に公開されている場合を除き、クラスのインスタンスを作成するのには使用できません。</summary>
        <returns>作成し、COM オブジェクトへの参照を返します。<see langword="CreateObject" />Visual Basic でこれらのクラスが COM コンポーネントとして明示的に公開されている場合を除き、クラスのインスタンスを作成するのには使用できません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 COM コンポーネントのインスタンスを作成するには、によって返される、オブジェクトを割り当てる`CreateObject`オブジェクト変数に格納します。  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 使用して、返されたオブジェクトを格納するオブジェクト変数の型は、アプリケーションのパフォーマンスに影響を与えることができます。 オブジェクト変数を宣言する、`As Object`句は、どの型のオブジェクトへの参照を含めることができる変数を作成します。 ただし、その変数を介してそのオブジェクトへのアクセスは*遅延バインディング*、プログラムの実行時に、バインディングに発生します。 アプリケーションのパフォーマンスを低下など、遅延バインディングを避ける必要があります、さまざまな理由があります。  
  
 事前バインディングをオブジェクト変数を作成するなど、プログラムがコンパイルされるときに、バインディングします。 これを行うから、オブジェクトのタイプ ライブラリへの参照を追加、 **COM**のタブ、**参照の追加** ダイアログ ボックスで、**プロジェクト**メニュー。 特定の種類のオブジェクトのオブジェクト変数を宣言できます。 ほとんどの場合、使用する方が効率的です、`Dim`ステートメントおよびオブジェクトを作成するには、使用するよりもプライマリ相互運用機能アセンブリ、`CreateObject`関数。  
  
## アンマネージ コードとの対話  
 別の問題は、COM オブジェクトがアンマネージ コードを使用するなど、共通言語ランタイムの利点もコード。 COM からアンマネージ コードと Visual Basic のマネージ コードの混合に関係する複雑さの程度があります COM オブジェクトへの参照を追加するときに Visual Basic は、そのライブラリのプライマリ相互運用機能アセンブリ \(PIA\) の検索します。見つかった場合、それが使用されます。 PIA が見つからない場合は、ローカルの相互運用性クラス、COM ライブラリの各クラスを含む相互運用アセンブリが作成されます。 詳細については、「[COM Interoperability in .NET Framework Applications](http://msdn.microsoft.com/ja-jp/f5a72143-c268-4dff-a019-974ad940e17d)」を参照してください。  
  
 一般に、厳密にバインドされたオブジェクトと可能な限りのプライマリ相互運用機能アセンブリを使用してください。 使用して以下の例、`CreateObject`デモについては、Microsoft Office オブジェクトを持つ関数する目的でのみです。 ただし、これらのオブジェクトを使いやすくする適切なプライマリ相互運用機能アセンブリを使用すると、信頼性が高くします。  
  
## リモート コンピューター上のオブジェクトを作成します。  
 リモート ネットワーク コンピューター上にオブジェクトを作成するには、コンピューターの名前を渡すことによって、`ServerName`の引数、`CreateObject`関数。 その名前は、共有名のコンピューター名の部分と同じ:"\\\\MyServer\\Public、"という名前の共有の`ServerName`は、"MyServer"  
  
> [!NOTE]
>  COM のマニュアルを参照してください \(Microsoft Developer Network を参照してください\) の詳細について、リモート ネットワークに接続されたコンピューターでアプリケーションにアクセスできるようにします。 アプリケーションのレジストリ キーを追加する必要があります。  
  
 次のコードを返しますという名前のリモート コンピューターで実行されている Excel のインスタンスのバージョン番号`MyServer`:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 リモート サーバー名が正しくない場合、またはが利用できない場合は、実行時エラーが発生します。  
  
> [!NOTE]
>  使用して`CreateObject`オブジェクトの現在のインスタンスがない場合。 オブジェクトのインスタンスが既に実行されている場合は、新しいインスタンスを開始すると、し、指定した型のオブジェクトを作成します。 現在のインスタンスを使用するか、アプリケーションを起動し、ファイルを読み込むを使用して、`GetObject`関数。 オブジェクトがそれ自体を単独のオブジェクトとして登録している場合、オブジェクトの 1 つだけのインスタンスが作成、方法に関係なく何度も`CreateObject`を実行します。  
  
## Framework のオブジェクトを作成します。  
 使用することができます、 `CreateObject` COM オブジェクトを作成するためのものです。 .NET Framework オブジェクトを作成するため正確な同等のメカニズムはありません、<xref:System.Activator>で、<xref:System>名前空間には、ローカルまたはリモート オブジェクトを作成するメソッドが含まれています。 具体的には、<xref:System.Activator.CreateInstance%2A>メソッドまたは<xref:System.Activator.CreateInstanceFrom%2A>メソッドも役にあります。  
  
> [!IMPORTANT]
>  `CreateObject`関数が、アンマネージ コード アクセス許可が必要です。 詳細については、次を参照してください。<xref:System.Security.Permissions.SecurityPermission>と[コード アクセス許可](http://msdn.microsoft.com/ja-jp/e5ae402f-6dda-4732-bbe8-77296630f675)です。  
  
   
  
## 例  
 次の例では、`CreateObject`関数の Microsoft Excel ワークシートを作成して、ファイルにワークシートを保存します。 この例を使用するには、Excel はプログラムを実行するコンピューターにインストールする必要があります。 また、タイプ ライブラリへの参照を追加する必要があります、 **COM**のタブ、**参照の追加** ダイアログ ボックスで、**プロジェクト**メニュー。 タイプ ライブラリの名前は、コンピューターにインストールされている Excel のバージョンによって異なります。 たとえば、excel のタイプ ライブラリの名前は**Microsoft Excel 10.0 オブジェクト ライブラリ**です。  
  
 [!code-vb[VbVbalrExcelObject\#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">サーバーは使用できません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定した型のオブジェクトは存在しません</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">必須です。<see langword="String" /> アプリケーションまたはセクションまたはキーの設定を適用するプロジェクトの名前を含む式です。</param>
        <param name="Section">必須です。<see langword="String" /> キーの設定の削除されたセクションの名前を含む式です。 のみ <c>AppName</c> と <c>Section</c> の指定した場合、指定されたセクションが関連するすべてのキー設定と共に削除します。</param>
        <param name="Key">省略可能です。<see langword="String" /> 削除するキーの設定の名前を含む式です。</param>
        <summary>Windows レジストリ内のアプリケーションのエントリからセクションまたはキーの設定を削除します。<see langword="My" /> 機能を使用する生産性とパフォーマンスが向上よりもレジストリ操作、 <see langword="DeleteSetting " />関数です。 詳細については、「<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 すべての引数を指定しない場合は、指定の設定が削除されます。 使用しようとすると、実行時エラーが発生 `DeleteSetting` 存在していません。 セクションまたはキーの設定にします。  
  
 `DeleteSetting` ユーザーの下で動作するためログインする必要があります、 `HKEY_LOCAL_USER` レジストリ キーは、ユーザーが対話的にログオンするまでアクティブではありません。  
  
 \(Mtx.exe\) などの非対話型プロセスからアクセスされるレジストリ設定を格納するか、 `HKEY_LOCAL_MACHINE\Software\` または `HKEY_USER\DEFAULT\Software` レジストリ キーです。  
  
   
  
## 例  
 次の例を使用して、 `SaveSetting` の Windows レジストリにエントリを作成する手順、 `MyApp` アプリケーション、および、使用、 `DeleteSetting` 関数を削除します。 ない `Key` 引数を指定すると、全体 `Startup` セクションを削除すると、セクション名、およびそのキー含まれます。  
  
 [!code-vb[VbVbalrCatRef\#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ユーザーがログインしていません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Expression">必須です。 環境変数、または環境文字列テーブル内の環境文字列の数値の順序に対応する整数の名前を含む文字列を評価する式。</param>
        <summary>オペレーティング システム環境変数に関連付けられている文字列を返します。</summary>
        <returns>オペレーティング システム環境変数に関連付けられている文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `Expression` 、文字列が含まれています、 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 関数は、指定された環境の文字列に割り当てられたテキストを返します: 環境変数の環境文字列テーブルに等号 \(\=\) の後のテキストは、です。 場合に文字列 `Expression` 表内の環境文字列、長さ 0 の文字列が見つかりません \(""\) が返されます。  
  
 場合 `Expression` 環境文字列テーブル内の数値の位置が返されることを占有している文字列、整数が含まれています。 この場合、 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> のすべての環境変数の名前を含むテキストを返します。 指定された位置での環境文字列がない場合 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 長さ 0 の文字列を返します。  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 関数には、環境アクセス許可が必要です。 詳細については、次を参照してください。 <xref:System.Security.Permissions.SecurityPermission> と [コード アクセス許可](http://msdn.microsoft.com/ja-jp/e5ae402f-6dda-4732-bbe8-77296630f675)します。  
  
   
  
## 例  
 この例では、 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> エントリ数と長さを指定する関数、 `PATH` 環境ストリング テーブルからステートメントです。  
  
 [!code-vb[VbVbalrCatRef\#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> 指定されていません。</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">必須です。 環境変数、または環境文字列テーブル内の環境文字列の数値の順序に対応する整数の名前を含む文字列を評価する式。</param>
        <summary>オペレーティング システム環境変数に関連付けられている文字列を返します。</summary>
        <returns>オペレーティング システム環境変数に関連付けられている文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `Expression` 、文字列が含まれています、 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 関数は、指定された環境の文字列に割り当てられたテキストを返します: 環境変数の環境文字列テーブルに等号 \(\=\) の後のテキストは、です。 場合に文字列 `Expression` 表内の環境文字列、長さ 0 の文字列が見つかりません \(""\) が返されます。  
  
 場合 `Expression` 環境文字列テーブル内の数値の位置が返されることを占有している文字列、整数が含まれています。 この場合、 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> のすべての環境変数の名前を含むテキストを返します。 指定された位置での環境文字列がない場合 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 長さ 0 の文字列を返します。  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A> 関数には、環境アクセス許可が必要です。 詳細については、次を参照してください。 <xref:System.Security.Permissions.SecurityPermission> と [コード アクセス許可](http://msdn.microsoft.com/ja-jp/e5ae402f-6dda-4732-bbe8-77296630f675)します。  
  
   
  
## 例  
 この例では、 <xref:Microsoft.VisualBasic.Interaction.Environ%2A> エントリ数と長さを指定する関数、 `PATH` 環境ストリング テーブルからステートメントです。  
  
 [!code-vb[VbVbalrCatRef\#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> 指定されていません。</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">必須です。<see langword="String" /> アプリケーションまたはキーの設定を持つプロジェクトの名前を含む式です。</param>
        <param name="Section">必須です。<see langword="String" /> キー設定を取得するセクションの名前を含む式です。<see langword="GetAllSettings" /> 文字列の 2 次元配列を含むオブジェクトを返します。 文字列には、すべてのキー設定では、指定されたセクションと、対応する値が含まれます。</param>
        <summary>キーの設定とそれぞれの値の一覧を返します \(もともとで作成された <see langword="SaveSetting" />\)、Windows レジストリ内のアプリケーションのエントリからです。 使用して、 <see langword="My" /> 機能を使用する生産性とパフォーマンスが向上よりもレジストリ操作 <see langword="GetAllSettings" />します。 詳細については、「<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />」を参照してください。</summary>
        <returns>キーの設定とそれぞれの値の一覧を返します \(もともとで作成された <see langword="SaveSetting" />\)、Windows レジストリ内のアプリケーションのエントリからです。  
  
 使用して、 <see langword="My" /> 機能を使用する生産性とパフォーマンスが向上よりもレジストリ操作 <see langword="GetAllSettings" />します。 詳細については、「<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `GetAllSettings` 初期化されていない返します `Object` いずれか `AppName` または `Section` が存在しません。  
  
 下で稼働しているため、 `HKEY_LOCAL_USER` レジストリ キーは、無効なユーザーが対話的にログオンするまで、 `GetAllSettings` 、ユーザーがログオンしている必要があります。  
  
 \(Mtx.exe\) などの非対話型プロセスからアクセスされるレジストリ設定を格納するか、 `HKEY_LOCAL_MACHINE\Software\` または `HKEY_USER\DEFAULT\Software` レジストリ キーです。  
  
   
  
## 例  
 この例を使用して、 `SaveSetting` として指定されたアプリケーションの Windows レジストリにエントリを作成する関数 `AppName`, を使用して、 `GetAllSettings` 関数の設定を表示します。 そのアプリケーションに注意してください名と `Section` と名を取得することはできません `GetAllSettings`します。 最後に、 `DeleteSetting` 関数は、アプリケーションのエントリを削除します。  
  
 [!code-vb[VbVbalrCatRef\#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ユーザーがログインしていません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Class" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">省略可能です。<see langword="String" />。 完全パスと取得するオブジェクトを含むファイルの名前。 場合 <c>PathName</c> を省略すると、 <c>Class</c> が必要です。</param>
        <param name="Class">必要な場合 <c>PathName</c> が指定されていません。<see langword="String" />。 オブジェクトのクラスを表す文字列。<c>Class</c> 引数は、次の構文と部分が存在します。  
  
 <c>appname</c> <c>.</c> <c>objecttype</c>  
  
 \[1 | 1\]パラメーター  
  
 \[1 | 2\]。説明  
  
 \[2|1\] <c>appname</c>  
  
 \[2 | 2\]必須。<see langword="String" />。 オブジェクトを提供するアプリケーションの名前です。  
  
 \[3|1\] <c>objecttype</c>  
  
 \[3 | 2\]必須。<see langword="String" />。 作成する型またはオブジェクトのクラスです。</param>
        <summary>COM コンポーネントから提供されたオブジェクトへの参照を返します。</summary>
        <returns>COM コンポーネントから提供されたオブジェクトへの参照を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 `GetObject` ファイルから COM コンポーネントのインスタンスを読み込みます。 次に例を示します。  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 このコードを実行すると、指定した関連付けられたアプリケーション `PathName` が起動し、指定したファイルのオブジェクトがアクティブにします。  
  
## 既定の場合  
 場合 `PathName` が長さ 0 の文字列 \(`""`\)、 `GetObject` 指定されたクラス型の新しいオブジェクト インスタンスを返します。 場合、 `PathName` 引数を省略すると、 `GetObject` で指定されたクラス型の現在アクティブなオブジェクトを返します `Class`します。 指定した型のオブジェクトが存在しない場合、エラーが発生します。  
  
## サブオブジェクトへのアクセス  
 一部のアプリケーションを使用すると、ファイルに関連付けられているサブオブジェクトをアクティブにできます。 これを行うには、感嘆符を追加します \(`!`\) に従って、ファイル名の末尾に、ファイルの一部を識別する文字列を使用してアクティブにします。 この文字列を作成する方法については、オブジェクトを作成したアプリケーションのマニュアルを参照してください。  
  
 たとえば、描画アプリケーションで複数のレイヤーに描画をファイルに格納されているがある可能性があります。 次のコードを使用して記述すると、レイヤーをアクティブにでした `schema.cad`します。  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## クラスを指定します。  
 オブジェクトの指定しなかった場合 `Class`, 、オートメーションは、入力したファイルの名前に基づくをアクティブ化すると、アプリケーションを開始し、オブジェクトを決定します。 ただし、一部のファイルは、オブジェクトの 1 つ以上のクラスをサポートできます。 たとえば、図面は次の 3 つの異なる種類のオブジェクトをサポート可能性があります。 `Application` オブジェクト、 `Drawing` オブジェクトと `Toolbar` 同じファイルの一部であるすべてのオブジェクト。 省略可能なを使用してアクティブ化するファイルのどのオブジェクトを指定する `Class` 引数。 次に例を示します。  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 前の例で `Figment` 描画アプリケーションの名前を指定し、 `Drawing` がサポートされるオブジェクトの種類の 1 つです。  
  
## オブジェクトの使用  
 オブジェクトがアクティブになると、参照することを宣言して、オブジェクト変数を使用して、コードで。 オブジェクト変数を使用して新しいオブジェクトのプロパティとメソッドにアクセスする前の例で `drawObj`します。 次に例を示します。  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  使用して、 `GetObject` オブジェクトの現在のインスタンスがある場合、または読み込まれたファイルで、オブジェクトを作成する場合に機能します。 現在のインスタンスがないと、オブジェクトの使用を開始したくない場合は、ファイルを読み込む、 <xref:Microsoft.VisualBasic.Interaction.CreateObject%2A> 関数です。  
>   
>  ActiveX 単一インスタンスのオブジェクトとして登録されているオブジェクトの場合、オブジェクトの 1 つだけのインスタンスを作成かに関係なく何度も `CreateObject` が呼び出されます。 単一インスタンス オブジェクトを持つ `GetObject` 常に長さ 0 の文字列で呼び出されたときに、同じインスタンスを返します \(`""`\) 構文、およびその場合はエラーが発生、 `PathName` 引数を省略します。 使用することはできません `GetObject` を Visual Basic で作成したクラスへの参照を取得します。  
  
> [!IMPORTANT]
>  `GetObject` 関数には、アンマネージ コード アクセス許可が必要です。 詳細については、次を参照してください。 <xref:System.Security.Permissions.SecurityPermission> と [コード アクセス許可](http://msdn.microsoft.com/ja-jp/e5ae402f-6dda-4732-bbe8-77296630f675)します。  
  
   
  
## 例  
 次の例では、 `GetObject` 特定の Microsoft Excel ワークシートへの参照を取得します \(`excelObj`\)。 使用して、ワークシートの `Application` Excel を閉じて、その他の操作を表示するプロパティです。 2 つの API 呼び出しを使用して、 `detectExcel` プロシージャは、Excel が検索され、実行されている場合は、オブジェクトを実行しているテーブルで入力します。 最初の呼び出し `GetObject` Excel は、既に実行されていない場合、この例で、エラーが発生原因、 `excelWasNotRunning` に設定するフラグ `True`します。 2 番目の呼び出し `GetObject` を開くにはファイルを指定します。 Excel が実行されていない場合は、2 つ目の呼び出しにより起動され、指定したファイルで表されるワークシートへの参照を返します `test.xls`します。 指定した場所にファイルが存在する必要があります。Visual Basic のそれ以外の場合、スロー、 <xref:System.IO.FileNotFoundException>です。 次に、コード例は、Excel や表示されている指定のワークシートを含むウィンドウの両方になります。  
  
 この例は `Option Strict Off` 遅延バインディングを使用しているためでオブジェクトが割り当てられる型の変数に `Object`します。 指定できます `Option Strict On` から Excel のタイプ ライブラリへの参照を追加する場合は、特定のオブジェクトの種類のオブジェクトを宣言し、 **COM** のタブ、 **参照の追加** のダイアログ ボックス、 **プロジェクト** Visual Studio のメニュー。  
  
 [!code-vb[VbVbalrExcelObject\#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject\#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject\#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 呼び出すと、 `getExcel` 関数の場合、Excel が既に実行されているかどうかに検査を行います。 そうでない場合は、インスタンスが作成されます。  
  
> [!IMPORTANT]
>  前の例をわかりやすいようには、任意のウィンドウと呼ばれることと想定しています `XLMAIN` Microsoft Excel のインスタンスに属しています。 不正な方法で起動された別のオブジェクトは、その名前を持つウィンドウを作成、これは Excel の意図したすべてのメッセージを受け取ります。 運用環境に使用するアプリケーションでいることを確認するより厳格なテストを含める必要があります `XLMAIN` 本当に Excel に属しています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">指定されたクラス型のオブジェクトは存在しません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定されたパスとファイル名を持つオブジェクトが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Default" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">必須です。<see langword="String" /> アプリケーションまたはキー設定が必要となるプロジェクトの名前を含む式です。</param>
        <param name="Section">必須です。<see langword="String" /> キーの設定が掲載されているセクションの名前を含む式です。</param>
        <param name="Key">必須です。<see langword="String" /> 返されるキーの設定の名前を含む式です。</param>
        <param name="Default">省略可能です。 値が設定されていないかどうかに返される値を含む式、 <c>Key</c> 設定します。 省略した場合、 <c>Default</c> 長さ 0 の文字列と見なされます \(""\) です。</param>
        <summary>Windows レジストリ内のアプリケーションのエントリからキーの設定値を返します。<see langword="My" /> 機能を使用する生産性とパフォーマンスが向上よりもレジストリ操作 <see langword="GetAllSettings" />します。 詳細については、「<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />」を参照してください。</summary>
        <returns>Windows レジストリ内のアプリケーションのエントリからキーの設定値を返します。  
  
 <see langword="My" /> 機能を使用する生産性とパフォーマンスが向上よりもレジストリ操作 <see langword="GetAllSettings" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された項目のいずれかの場合、 `GetSetting` 引数が存在しない `GetSetting` の値を返します `Default`します。  
  
 下で稼働しているため、 `HKEY_LOCAL_USER` レジストリ キーは、無効なユーザーが対話的にログオンするまで、 `GetSetting` 、ユーザーがログオンしている必要があります。  
  
 \(Mtx.exe\) などの非対話型プロセスからアクセスされるレジストリ設定を格納するか、 `HKEY_LOCAL_MACHINE\Software\` または `HKEY_USER\DEFAULT\Software` レジストリ キーです。  
  
 `GetSetting` 必要があります `Read`<xref:System.Security.Permissions.RegistryPermission> します。  
  
   
  
## 例  
 この例を使用して、 `SaveSetting` として指定されたアプリケーションの Windows レジストリにエントリを作成する関数 `AppName`, 、し、使用して、 `GetSetting` 、設定のいずれかを表示します。`Default` 引数を指定すると、いくつかの値が必ず返されます。 注意する `Section` と名を取得することはできません `GetSetting`します。 最後に、 `DeleteSetting` 関数は、アプリケーションのすべてのエントリを削除します。  
  
 [!code-vb[VbVbalrCatRef\#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">1 つまたは複数の引数が <see langword="String" /> 式、またはユーザーがログインしていません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">必須です。<see langword="Boolean" />。 評価する式です。</param>
        <param name="TruePart">必須です。<see langword="Object" />。 返された場合 <c>Expression</c> に評価 <see langword="True" />します。</param>
        <param name="FalsePart">必須です。<see langword="Object" />。 返された場合 <c>Expression</c> に評価 <see langword="False" />します。</param>
        <summary>式の評価によって、2 つのオブジェクトのいずれかを返します。</summary>
        <returns>式の評価によって、2 つのオブジェクトのいずれかを返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `IIf` 関数は、3 項相当するものを提供 [Conditional Operator: ? :](http://msdn.microsoft.com/ja-jp/88643ee8-7100-4f86-880a-705ec22b6271) Visual C でします。  
  
   
  
## 例  
 この例では、 `IIf` を評価する関数、 `testMe` のパラメーター、 `checkIt` プロシージャを返す単語「Large」場合容量が 1000 より大きい。 それ以外の場合、それを返します単語"小"です。  
  
 [!code-vb[VbVbalrFunctions\#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 場合 `Option Strict` は `On`, 、使用する必要があります、 `CStr` からの戻り値を明示的に変換するキーワード `Object` に `String`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" />
        <Parameter Name="Title" Type="System.String" />
        <Parameter Name="DefaultResponse" Type="System.String" />
        <Parameter Name="XPos" Type="System.Int32" />
        <Parameter Name="YPos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Prompt">必要な <see langword="String" /> 式\] ダイアログ ボックスにメッセージとして表示されます。 最大長 <c>Prompt</c> は約 1024年文字によって使用される文字の幅。 場合 <c>Prompt</c> で構成されています 1 つ以上の行のキャリッジ リターン文字を使用して線を分離することができます \(<see langword="Chr(" />13<see langword=")" />\)、改行文字 \(<see langword="Chr(" />10<see langword=")" />\)、キャリッジ リターン\/ライン フィードの組み合わせ、または \(<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />\) 各行の間です。</param>
        <param name="Title">省略可能です。<see langword="String" /> 式\] ダイアログ ボックスのタイトル バーに表示されます。 省略すると <c>Title</c>, 、アプリケーション名は、タイトル バーに配置されます。</param>
        <param name="DefaultResponse">省略可能です。<see langword="String" /> 入力しない場合、既定の応答として、テキスト ボックスに表示される式が提供されます。 省略すると <c>DefaultResponse</c>, 、表示されているテキスト ボックスが空です。</param>
        <param name="XPos">省略可能です。 長さ、画面の左端からダイアログ ボックスの左端までの距離を指定する数値式。 省略すると <c>XPos</c>, 、ダイアログ ボックスは水平方向に中央揃えされます。</param>
        <param name="YPos">省略可能です。 長さ、画面の上部にあるダイアログ ボックスの上端までの距離を指定する数値式。 省略すると <c>YPos</c>, 、ダイアログ ボックスには、画面の下の方法の垂直方向に約 1\/3 が配置されています。</param>
        <summary>ダイアログ ボックスで、プロンプトが表示されます、ユーザーがテキストを入力するか、ボタンをクリックするを待機し、テキスト ボックスのコンテンツを含む文字列を返します。</summary>
        <returns>ダイアログ ボックスで、プロンプトが表示されます、ユーザーがテキストを入力するか、ボタンをクリックするを待機し、テキスト ボックスのコンテンツを含む文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ユーザーがクリックすると **キャンセル**, 、長さ 0 の文字列が返されます。  
  
 使用する必要があります以上の最初の引数を指定する、 `InputBox` 関数の式。 位置指定引数を省略する場合は、対応するコンマ区切り記号を保持する必要があります。  
  
> [!NOTE]
>  `InputBox` 関数に必要な `UIPermission` で、 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> レベルで、部分的に信頼された状況では、その実行に影響を受ける可能性があります。 詳細については、次を参照してください。 と <xref:System.Security.Permissions.UIPermission> です。  
  
   
  
## 例  
 この例を使用するさまざまな方法を示しています、 `InputBox` 値を入力するユーザー入力を求める関数です。 場合、x と y の位置を省略すると、ダイアログ ボックスが自動的に各軸の中央に配置します。 変数 `MyValue` 、ユーザーが \[ok\] をクリックするか、ENTER キーを押した場合に、ユーザーが入力した値が含まれています。  
  
 [!code-vb[VbVbalrCatRef\#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" />
        <Parameter Name="Title" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Prompt">必須です。<see langword="String" /> 式は、ダイアログ ボックスにメッセージとして表示されます。 最大長 <c>Prompt</c> は約 1024年文字によって使用される文字の幅。 場合 <c>Prompt</c> で構成されています 1 つ以上の行のキャリッジ リターン文字を使用して線を分離することができます \(<see langword="Chr(" />13<see langword=")" />\)、改行文字 \(<see langword="Chr(" />10<see langword=")" />\)、または復帰\/改行文字の組み合わせ \(<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />\) 各行の間です。</param>
        <param name="Buttons">省略可能です。 既定のボタンの id とメッセージ ボックスのモーダルかどうかを使用するアイコンのスタイルを表示するには、数とボタンの種類を指定する値を加算した数値式。 省略すると <c>Buttons</c>, 、既定値は 0 です。</param>
        <param name="Title">省略可能です。<see langword="String" /> 式\] ダイアログ ボックスのタイトル バーに表示されます。 省略すると <c>Title</c>, 、アプリケーション名は、タイトル バーに配置されます。</param>
        <summary>ダイアログ ボックスにメッセージを表示、ユーザーがボタンをクリックする待機し、ユーザーがクリックされたボタンを示す整数を返します。</summary>
        <returns>
          <list type="table">  
<item>  
<term> 定数  
  
 </term>  
<description> 値  
  
 </description>  
</item>  
<item>  
<term> <see langword="OK" />  
  
 </term>  
<description> 1  
  
 </description>  
</item>  
<item>  
<term> <see langword="Cancel" />  
  
 </term>  
<description> 2  
  
 </description>  
</item>  
<item>  
<term> <see langword="Abort" />  
  
 </term>  
<description> 3  
  
 </description>  
</item>  
<item>  
<term> <see langword="Retry" />  
  
 </term>  
<description> 4  
  
 </description>  
</item>  
<item>  
<term> <see langword="Ignore" />  
  
 </term>  
<description> 5  
  
 </description>  
</item>  
<item>  
<term> <see langword="Yes" />  
  
 </term>  
<description> 6  
  
 </description>  
</item>  
<item>  
<term> <see langword="No" />  
  
 </term>  
<description> 7  
  
 </description>  
</item>  
</list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 位置指定引数を省略する場合は、対応するコンマ区切り記号を保持する必要があります。  
  
 ダイアログ ボックスが表示された場合、 **キャンセル** ESC キーを押して、ボタンがクリックした場合と同じ効果を持ちます **キャンセル**  
  
 ダイアログ ボックスが含まれている場合、 **ヘルプ** ボタン、状況依存のヘルプがダイアログ ボックスに用意されています。 ただし、他のボタンのいずれかを選択するまでの値は返されません。 選択する Windows フォーム アプリケーションで、 **ヘルプ** ボタンの実行、 <xref:System.Windows.Forms.Control.HelpRequested> フォームのイベントです。  
  
> [!NOTE]
>  `MsgBox` 関数に必要な `UIPermission` で、 <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> レベルで、部分的に信頼された状況では、その実行に影響を受ける可能性があります。 詳細については、「<xref:System.Security.Permissions.UIPermission>」を参照してください。  
  
 `MsgBoxStyle` 列挙値は、次の表に一覧表示されます。  
  
||||  
|-|-|-|  
|メンバー|値|説明|  
|`OKOnly`|0|表示 \[ok\] ボタンの場合のみです。|  
|`OKCancel`|1|\[キャンセル\] ボタンおよび \[ok\] を表示します。|  
|`AbortRetryIgnore`|2|Abort、再試行を行い、および \[無視\] ボタンが表示されます。|  
|`YesNoCancel`|3|\[はい\] が表示されますが、キャンセル ボタンとします。|  
|`YesNo`|4|\[はい\] と \[いいえ\] ボタンが表示されます。|  
|`RetryCancel`|5|\[再試行\] および \[キャンセル\] ボタンが表示されます。|  
|`Critical`|16|メッセージの重要なアイコンを表示します。|  
|`Question`|32|警告クエリ アイコンを表示します。|  
|`Exclamation`|48|警告メッセージのアイコンを表示します。|  
|`Information`|64|情報メッセージのアイコンを表示します。|  
|`DefaultButton1`|0|最初のボタンは、既定値です。|  
|`DefaultButton2`|256|2 番目のボタンは、既定値です。|  
|`DefaultButton3`|512|3 番目のボタンは、既定値です。|  
|`ApplicationModal`|0|アプリケーションがモーダルでします。 ユーザーは、現在のアプリケーションで作業を続行する前に、メッセージ ボックスに応答する必要があります。|  
|`SystemModal`|4096|システムはモーダルです。 ユーザーがメッセージ ボックスに応答するまで、すべてのアプリケーションが中断されます。|  
|`MsgBoxSetForeground`|65536|\[前面のウィンドウとして、メッセージ ボックス ウィンドウを指定します。|  
|`MsgBoxRight`|524288|テキストは右揃えします。|  
|`MsgBoxRtlReading`|1048576|テキストは右から左のヘブライ語やアラビア語のシステムでの読み取りでの表示を指定します。|  
  
 値 \(0 ~ 5\) の最初のグループは、ダイアログ ボックスに表示されるボタンの種類と数について説明します。 2 番目のグループ \(16、32、48、64\) では、アイコンのスタイルについて説明します。 3 番目のグループ \(0、256、512\) は、どのボタンが既定値を決定します。 4 番目のグループ \(0, 4096\) がメッセージ ボックスのモーダルかどうかを決定し、5 番目のグループは、メッセージ ボックス ウィンドウが前面のウィンドウの配置とテキストの方向かどうかを指定します。 最後の値を作成する番号を追加するときに、 `Buttons` 引数、各グループから 1 つの数値を使用します。  
  
   
  
## 例  
 この例では、 `MsgBox` \[はい\] と \[いいえ\] ボタンを使用して、ダイアログ ボックスで、重大なエラー メッセージを表示する関数。 \[いいえ\] ボタンは、既定の応答として指定されます。 これは、結合することで、 `MsgBox` 1 つの数値式の定数値です。 ここでは、4 の追加 \(、はい\/いいえ\] ボタンの組み合わせ\) と 16 \(、 **メッセージの重要な** ウィンドウ\) 合計 276 256 \(既定のボタンとして 2 番目のボタン\) とします。 によって返される値、 `MsgBox` 関数は、ユーザーが選択したボタンに依存します \[はい\] の値が 6; を返します。7 の値を返しますがありません。  
  
 [!code-vb[VbVbalrCatRef\#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Prompt" /> <see langword="String" /> 式、または <paramref name="Title" /> が無効です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスがユーザー対話モードで実行されていません。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">1 つ以上のパラメーターのメンバーではないの <see langword="MsgBoxResult" /> または <see langword="MsgBoxStyle" /> 列挙します。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" />
        <Parameter Name="Start" Type="System.Int64" />
        <Parameter Name="Stop" Type="System.Int64" />
        <Parameter Name="Interval" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="Number">必須です。<see langword="Long" />。 計算済みの範囲のいずれかに存在する整数です。</param>
        <param name="Start">必須です。<see langword="Long" />。 一連の計算の範囲の始点を表す整数です。<c>Start</c> 0 より小さくすることはできません。</param>
        <param name="Stop">必須です。<see langword="Long" />。 一連の計算の範囲の終了を示す整数です。<c>Stop</c> 以下にすることはできません <c>Start</c>します。</param>
        <param name="Interval">必須です。<see langword="Long" />。 各範囲のサイズを示す整数の計算の間で <c>Start</c> と <c>Stop</c>です。<c>Interval</c> 1 未満にすることはできません。</param>
        <summary>数値を含んだ計算の範囲を表す文字列を返します。</summary>
        <returns>数値を含んだ計算の範囲を表す文字列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `Partition` 関数を計算し、一連の数値の範囲で指定された値の数を含む各 `Interval`します。 最初の範囲から始まります `Start`, 、最後の範囲の終点と `Stop`です。`Partition` どの範囲が含まれる関数が、識別 `Number` し、その範囲を記述する文字列を返します。 として文字列の範囲を示す"*最大*:*最小*"ここで、範囲の下限 \(*最大*\) は、ハイ エンドから分離 \(*最小*\)、コロン \(:\) でします。  
  
 必要に応じて、 `Partition` 関数は、前に、先頭のスペースを挿入します。 *最大* と *最小* 値の文字列形式と同じ文字数が持つようにする \(`Stop` \+ 1\)。 出力を使用する場合は、これにより、 `Partition` のいくつかの値を持つ関数 `Number`, 、以後の並べ替え操作中に、生成されるテキストを正しく処理されます。  
  
 次の表は、3 つのセットを使用して計算範囲のいくつかの文字列の例を示しています。 `Start`, 、`Stop`, 、および `Interval`です。 「最初の範囲」と「最後の範囲」の列範囲を表して、最低と最高の値に基づいて `Start` と `Stop`です。 列の値に対して返される文字列の表示"前の最初の範囲"に、と"変更後の最後の範囲" `Number` より小さい `Start` とよりも大きい `Stop`, 、それぞれします。  
  
||||||||  
|-|-|-|-|-|-|-|  
|`Start`|`Stop`|`Interval`|最初の範囲の前に|最初の範囲|最後の範囲|最後の範囲の後|  
|0|99|5|"   : \-1"|"  0:  4"|" 95: 99"|"100:   "|  
|20|199|10|"   : 19"|" 20: 29"|"190:199"|"200:   "|  
|100|1010|20|"    : 99"|" 100: 119"|"1000:1010"|"1011:    "|  
  
 上記の表には、3 番目の行は結果を示します。 ときに `Start` と `Stop` で均等に割ることはできません番号のセットを定義 `Interval`します。 最後の範囲の終点 `Stop`, 、やすくは 11 桁も `Interval` は 20 です。  
  
 場合 `Interval` 1 に設定されて範囲は、"`Number`:`Number`"に関係なく、 `Start` と `Stop` 引数。 たとえば場合、 `Number` 267 は、 `Stop` 1000 と `Interval` 1 に設定されて `Partition` 「267: 267」が返されます。  
  
 `Partition` データベース クエリを構築するときに役に立ちます。 001 ~ 2,000年に請求書の値は 1 ~ 1000年のなどのさまざまな値の範囲内で発生する注文の数を示す SELECT クエリを作成することができます。  
  
   
  
## 例  
 次の例では、1950 2049 から何十年もの範囲を設定します。 値では、検索、 `year` 内で適切な範囲を返します、 `String` 値の範囲を表示します。 場合 `year` 1984 年の値は、たとえば、 `Partition` 「1980:1989」を返します。  
  
 [!code-vb[VbVbalrFunctions\#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt; 0、 <paramref name="Stop" /> &lt; \= <paramref name="Start" />, 、または <paramref name="Interval" /> &lt; 1 です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Setting" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">必須です。<see langword="String" /> アプリケーションや、設定を適用するプロジェクトの名前を含む式です。</param>
        <param name="Section">必須です。<see langword="String" /> キーの設定を保存するセクションの名前を含む式です。</param>
        <param name="Key">必須です。<see langword="String" /> 保存されているキーの設定の名前を含む式です。</param>
        <param name="Setting">必須です。 式に値を含む <c>Key</c> が設定されています。</param>
        <summary>保存または Windows レジストリにアプリケーションのエントリを作成します。<see langword="My" /> 機能を使用する生産性とパフォーマンスが向上よりもレジストリ操作 <see langword="SaveSetting" />します。 詳細については、「<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `SaveSetting` 関数を追加するキー `HKEY_CURRENT_USER\Software\VB and VBA Program Settings`します。  
  
 何らかの理由でキーの設定を保存できない場合、エラーが発生します。  
  
 `SaveSetting` ユーザーの下で動作するためログインする必要があります、 `HKEY_LOCAL_USER` レジストリ キーは、ユーザーが対話的にログオンするまでアクティブではありません。  
  
 \(Mtx.exe\) などの非対話型プロセスからアクセスされるレジストリ設定を格納するか、 `HKEY_LOCAL_MACHINE\Software\` または `HKEY_USER\DEFAULT\Software` レジストリ キーです。  
  
 `SaveSetting` 必要があります `Write` と `Create`<xref:System.Security.Permissions.RegistryPermission> します。  
  
   
  
## 例  
 次の例を使用して、 `SaveSetting` の Windows レジストリにエントリを作成する関数、 `MyApp` アプリケーションで、使用して、 `DeleteSetting` 関数を削除します。  
  
 [!code-vb[VbVbalrCatRef\#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">レジストリ キーを作成できませんでした、またはユーザーがサインインしていません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" />
        <Parameter Name="Wait" Type="System.Boolean" />
        <Parameter Name="Timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="PathName">必須です。<see langword="String" />。 すべての必須の引数とコマンド ライン スイッチを実行するプログラムの名前。<c>PathName</c> ドライブとディレクトリ パスまたはフォルダーを組み入れることができます。  
  
 使用することができます、プログラムへのパスがわからない場合、 <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> を検索します。 たとえば、呼び出す <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>, 、という名前のすべてのファイルの完全なパスを返すことを <c>testFile.txt</c> C:\\ ドライブに任意の場所。</param>
        <param name="Style">省略可能です。<see langword="AppWinStyle" />。 選択した値、 <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> プログラムを実行するウィンドウのスタイルを指定します。 場合 <c>Style</c> を省略すると、 <see langword="Shell" /> を使用して <see langword="AppWinStyle.MinimizedFocus" />, 、最小化されていると、フォーカスのあるプログラムを開始します。</param>
        <param name="Wait">省略可能です。<see langword="Boolean" />。 示す値かどうか、 <see langword="Shell" /> 関数は、プログラムの完了を待つ必要があります。 場合 <c>Wait</c> を省略すると、 <see langword="Shell" /> を使用して <see langword="False" />します。</param>
        <param name="Timeout">省略可能です。<see langword="Integer" />。 場合の完了を待機するミリ秒数 <c>Wait</c> は <see langword="True" />です。 場合 <c>Timeout</c> を省略すると、 <see langword="Shell" /> \-1 で、タイムアウトが存在しないことを意味を使用し、 <see langword="Shell" /> プログラムが完了するまで戻りません。 そのため、省略すると <c>Timeout</c> または\-1 の場合、it には、可能なセットを <see langword="Shell" /> プログラムに制御を返すことはありませんが。</param>
        <summary>実行可能プログラムを実行し、まだ実行されている場合は、プログラムのプロセス ID を表す整数を返します。</summary>
        <returns>実行可能プログラムを実行し、まだ実行されている場合は、プログラムのプロセス ID を表す整数を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 戻り値、 `Shell` 関数で、プログラムを指定するかどうかに依存 `PathName` がまだ実行中いつ `Shell` を返します。 設定した場合 `Wait` に `True` タイムアウト時間が経過する前に、プログラムが終了して `Shell` は 0 を返します。 省略した場合またはタイムアウトになると、 `Wait` かに設定して `False`, 、`Shell` プログラムのプロセス ID を返します。 プロセス ID とは、実行中のプログラムを識別する一意の番号です。  
  
## 起動の失敗  
 場合、 `Shell` 関数は、名前付きのプログラムを起動できません、 <xref:System.IO.FileNotFoundException> エラーが発生します。 これを行う例など、16 ビット プログラムを実行しようとするときに `command.com`, を使用して、アプリケーションから <xref:System.Windows.Forms?displayProperty=fullName>します。 この問題を回避するには、目的の 16 ビット プログラムを呼び出す、32 ビット プログラムを実行することができます。 場合に `command.com`, 、行うことができます `cmd.exe` 代わりにします。  
  
## 完了を待機しています。  
 既定では、 `Shell` 関数は、プログラムを非同期的に実行します。 つまりでプログラムを開始、 `Shell` 関数では、ステートメントの次の前に実行しても終了しなくても、 `Shell` 関数を実行します。 続行する前に終了するプログラムを待機する場合は設定 `Wait` に `True`します。  
  
## 終了コードを決定します。  
 プロセスを返すことができます、 *終了コード* が終了したとき。 ただし、使用することはできません `Shell` ために、この終了コードを取得する `Shell` の終了を待機している場合は 0 ともから別のオブジェクト、プロセスが実行されているため `Shell`です。  
  
 プロセスの終了コードを取得するには、プロセスを開始、終了まで待機するコードを記述する必要があります。 次の例では、プロセスを開始、終了するまで待機し、終了コードを取得する方法を示します。  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## ファイルの仕様を保護します。  
 全体のパスとファイルの仕様は、次の例のように、引用符で常に囲む必要があります。  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 隣接する二重引用符の各ペア \(`" "`\)、文字列内のリテラル文字列内の 1 つの二重引用符文字として解釈されます。 そのため、前の例に次の文字列を表示、 `Shell` 関数。  
  
```  
"C:\Program Files\display.exe" -a -q  
```  
  
 Windows はという名前のファイルを探します引用符で囲まれたパスをしなかった場合 `Program.exe` 、C:\\ ディレクトリ内の代わりに `display.exe` C:\\Program Files ディレクトリにします。  
  
> [!IMPORTANT]
>  引用符で囲まれたパスとファイルの仕様を囲まなかった場合、ファイル名またはパスのノードにスペースが含まれている場合にセキュリティ リスクが存在します。 前の例では、パス ノードで `\Program Files` スペースが含まれています。 仕様引用符とという名前のプログラムの内部されなかったかどうか `Program.exe` インストールされていたで C:\\、不正な改ざんなどによって Windows が実行の代わりに `display.exe`します。  
  
> [!IMPORTANT]
>  `Shell` 関数には、アンマネージ コード アクセス許可が必要です。 詳細については、次を参照してください。 <xref:System.Security.Permissions.SecurityPermission> と [コード アクセス許可](http://msdn.microsoft.com/ja-jp/e5ae402f-6dda-4732-bbe8-77296630f675)します。  
  
   
  
## 例  
 次の例では、 `Shell` 、ユーザーが指定したアプリケーションを実行する関数。 指定する <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=fullName> 、2 つ目の引数アプリケーションで標準サイズが開き、フォーカスを移します。  
  
 [!code-vb[VbVbalrFunctions\#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Style" /> 0 から 9 までの範囲内にないためです。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <see langword="Shell" /> 見つけられない、 <paramref name="PathName" /> ファイルです。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="PathName" /> は <see langword="Nothing" /> です。</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">必須です。<see langword="Object" /> パラメーターの配列。 偶数個の要素が必要です。 一覧を指定する <see langword="Object" /> 変数または式がコンマ、または、1 次元の配列で区切られた <see langword="Object" /> 要素。</param>
        <summary>式を返すの一覧を評価、 <see langword="Object" /> であるリストで最初の式に対応する値 <see langword="True" />です。</summary>
        <returns>式を返すの一覧を評価、 <see langword="Object" /> であるリストで最初の式に対応する値 <see langword="True" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定された引数 `VarExpr` ペアになる式と値で構成されます。`Switch` 関数内の最上位のインデックスに小さい方から奇数式を評価して `VarExpr`, 、され、最初に評価された式に関連付けられている偶数の値を返す `True`します。 など場合 `VarExpr(0)` は `True`, 、`Switch` を返します `VarExpr(1)`, 、場合 `VarExpr(0)` は `False` が `VarExpr(2)` は `True`, 、`Switch` を返します `VarExpr(3)`, 、という具合です。  
  
 指定しない場合、 `VarExpr` 引数 `Switch` 返します `Nothing`します。  
  
> [!NOTE]
>  引数リスト内の式は、関数呼び出しを含めることができます。 呼び出しの引数リストを準備の一環として `Switch`, 、Visual Basic コンパイラでは、すべての式ですべての関数を呼び出します。 つまり、引数リストの前の式の場合は、呼び出されていない特定の関数には使用できません `True`します。  
  
   
  
## 例  
 次の例では、 `Switch` 、市区町村の名前に一致する言語の名前を返す関数。 必要があります `Option Strict` する `Off`です。  
  
 [!code-vb[VbVbalrFunctions\#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 <xref:System.Diagnostics> 名前空間は、というクラスも含まれています。 <xref:System.Diagnostics.Switch>, 、への呼び出し、 `Switch` で関数を修飾する必要があります、 <xref:Microsoft.VisualBasic> 名前空間。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数の数は奇数です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>オペレーティング システム環境変数に関連付けられている文字列を返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に実行されているアプリケーションをアクティブにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>