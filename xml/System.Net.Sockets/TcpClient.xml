<Type Name="TcpClient" FullName="System.Net.Sockets.TcpClient">
  <TypeSignature Language="C#" Value="public class TcpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpClient" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>TCP ネットワーク サービス用のクライアント接続を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Net.Sockets.TcpClient> class provides simple methods for connecting, sending, and receiving stream data over a network in synchronous blocking mode.  
  
 In order for <xref:System.Net.Sockets.TcpClient> to connect and exchange data, a <xref:System.Net.Sockets.TcpListener> or <xref:System.Net.Sockets.Socket> created with the TCP <xref:System.Net.Sockets.ProtocolType> must be listening for incoming connection requests. You can connect to this listener in one of the following two ways:  
  
-   Create a <xref:System.Net.Sockets.TcpClient> and call one of the three available <xref:System.Net.Sockets.TcpClient.Connect%2A> methods.  
  
-   Create a <xref:System.Net.Sockets.TcpClient> using the host name and port number of the remote host. This constructor will automatically attempt a connection.  
  
> [!NOTE]
>  If you want to send connectionless datagrams in synchronous blocking mode, use the <xref:System.Net.Sockets.UdpClient> class.  
  
   
  
## 例  
 The following code example establishes a <xref:System.Net.Sockets.TcpClient> connection.  
  
 [!code-cpp[System.Net.Sockets.TcpClient\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CPP/tcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CS/tcpclient.cs#1)]
 [!code-vb[System.Net.Sockets.TcpClient\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/VB/tcpclient.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Permission to establish an outgoing connection or accept an incoming request.</permission>
    <block subset="none" type="overrides">
      <para>To send and receive data, use the <see cref="M:System.Net.Sockets.TcpClient.GetStream" /> method to obtain a <see cref="T:System.Net.Sockets.NetworkStream" />. Call the <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> methods of the <see cref="T:System.Net.Sockets.NetworkStream" /> to send and receive data with the remote host. Use the <see cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" /> method to release all resources associated with the <see cref="T:System.Net.Sockets.TcpClient" />.</para>
    </block>
    <altmember cref="T:System.Net.Sockets.TcpListener" />
    <altmember cref="T:System.Net.Sockets.NetworkStream" />
    <altmember cref="T:System.Net.Sockets.Socket" />
    <altmember cref="T:System.Net.Sockets.ProtocolType" />
    <altmember cref="T:System.Net.IPEndPoint" />
    <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.TcpClient" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This constructor creates a new <xref:System.Net.Sockets.TcpClient> and allows the underlying service provider to assign the most appropriate local IP address and port number. You must first call the <xref:System.Net.Sockets.TcpClient.Connect%2A> method before sending and receiving data.  
  
> [!NOTE]
>  This constructor works only with IPv4 address types.  
  
> [!NOTE]
>  This member outputs trace information when you enable network tracing in your application. For more information, see [&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## 例  
 The following code example demonstrates how to use the default constructor to create a new <xref:System.Net.Sockets.TcpClient>.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#4](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">TCP <see cref="T:System.Net.Sockets.Socket" /> のバインド先の <see cref="T:System.Net.IPEndPoint" />。</param>
        <summary>
          <see cref="T:System.Net.Sockets.TcpClient" /> クラスの新しいインスタンスを初期化し、指定したローカル エンドポイントにバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターが、新たに作成 <xref:System.Net.Sockets.TcpClient> にバインドし、 <xref:System.Net.IPEndPoint> によって指定された、 `localEP` パラメーター。 このコンス トラクターを呼び出す前に作成する必要があります、 <xref:System.Net.IPEndPoint> データを送受信する IP アドレスとポート番号を使用します。 接続および通信する前にローカル IP アドレスとポート番号を指定する必要はありません。 作成する場合、 <xref:System.Net.Sockets.TcpClient> 他の任意のコンス トラクターを使用して、基になるサービス プロバイダーは最も適切なローカル IP アドレスとポート番号を割り当てられます。  
  
 呼び出す必要があります、 <xref:System.Net.Sockets.TcpClient.Connect%2A> データを送受信する前に、のメソッドです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、インスタンスを作成、 <xref:System.Net.Sockets.TcpClient> クラスのローカル エンドポイントを使用します。  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> パラメーターは <see langword="null" />です。</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family">IP プロトコルの <see cref="P:System.Net.IPAddress.AddressFamily" />。</param>
        <summary>ファミリを指定して、<see cref="T:System.Net.Sockets.TcpClient" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、インスタンスを作成、 <xref:System.Net.Sockets.TcpClient> クラスです。  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#15](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#15](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="family" /> パラメーターが AddressFamily.InterNetwork と等しくないです。  
  
 または  
  
 <paramref name="family" /> パラメーターが AddressFamily.InterNetworkV6 と等しくないです。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.String,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">接続先のリモート ホストの DNS 名。</param>
        <param name="port">接続先のリモート ホストのポート番号。</param>
        <summary>
          <see cref="T:System.Net.Sockets.TcpClient" /> クラスの新しいインスタンスを初期化し、指定したホストの指定したポートに接続します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターが、新たに作成 <xref:System.Net.Sockets.TcpClient> 、同期接続しようと指定されたホスト名とポート番号。 基になるサービス プロバイダーでは、最も適切なローカル IP アドレスとポート番号を割り当てます。<xref:System.Net.Sockets.TcpClient> 接続するか失敗するまでブロックされます。 このコンス トラクターを使用すると、初期化、DNS のホスト名の解決、および 1 つの便利な手順で接続できます。  
  
 IPv6 が有効になっている場合、 <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29> メソッドが呼び出され、IPv6 の両方に解決されるホストに接続し、IPv4 アドレス、IPv6 のアドレスへの接続を IPv4 アドレスの前に最初の試行します。 これには、ホストが IPv6 アドレスでリッスンしていない場合は、接続を確立するために時間が遅延の影響があります。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを取得した後に、Windows ソケット バージョン 2 API エラー コードのドキュメントを MSDN エラーの詳細について参照できます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、インスタンスを作成、 <xref:System.Net.Sockets.TcpClient> クラスのホスト名を使用して、ポート番号。  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#3](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#3](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostname" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> パラメーターが <see cref="F:System.Net.IPEndPoint.MinPort" /> と <see cref="F:System.Net.IPEndPoint.MaxPort" /> の間にありません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <altmember cref="Overload:System.Net.Sockets.TcpClient.#ctor" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続されたかどうかを示す値を取得または設定します。</summary>
        <value>接続されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Classes deriving from <xref:System.Net.Sockets.TcpClient> can use this property to determine if a connection attempt has succeeded. It does not monitor the ongoing connection state of <xref:System.Net.Sockets.TcpClient>. If the remote host closes the connection, <xref:System.Net.Sockets.TcpClient.Active%2A> will not be updated. If you are deriving from <xref:System.Net.Sockets.TcpClient> and require closer attention to the connection state, use the <xref:System.Net.Sockets.Socket.Connected%2A> property of the <xref:System.Net.Sockets.Socket> returned by the <xref:System.Net.Sockets.TcpClient.Client%2A> method.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.Connected" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネットワークから受信した、読み取り可能なデータ量を取得します。</summary>
        <value>ネットワークから受信した、読み取り可能なデータのバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.TcpClient.Available%2A> is a way to determine whether data is queued for reading. If data is available, call <xref:System.Net.Sockets.NetworkStream.Read%2A> to get the data. The available data is the total amount of data queued in the network buffer for reading. If no data is queued in the network buffer, <xref:System.Net.Sockets.TcpClient.Available%2A> returns 0.  
  
 If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.TcpClient.Available%2A> may throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in the MSDN library at [http:\/\/msdn.microsoft.com\/library](http://msdn.microsoft.com/library) for a detailed description of the error.  
  
   
  
## 例  
 The following code example shows the use of the <xref:System.Net.Sockets.TcpClient.Available%2A> property.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient1\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <c>requestCallback</c> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 リモート ホストは、<see cref="T:System.Net.IPAddress" /> とポート番号 \(<see cref="T:System.Int32" />\) で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期の <xref:System.Net.Sockets.TcpClient.BeginConnect%2A> を呼び出して操作を完了する必要があります、 <xref:System.Net.Sockets.TcpClient.EndConnect%2A> メソッドです。 通常、このメソッドはによって、 `asyncCallback` を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、 <xref:System.Net.Sockets.TcpClient.Connect%2A> メソッドのオーバー ロードします。  
  
 非同期プログラミング モデルの使用に関する詳細については、次を参照してください。 [Asynchronous Programming Overview](http://msdn.microsoft.com/ja-jp/41972034-92ed-450a-9664-ab93fcc6f1fb)します。  
  
   
  
## 例  
 次のコード例を作成、 <xref:System.Net.Sockets.TcpClient> し、リモート ホストに接続します。  
  
 [!code-cpp[System.Net.Sockets.TcpClient1\#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpClient1\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストを指定する 1 つ以上の <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <c>requestCallback</c> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 リモート ホストは、<see cref="T:System.Net.IPAddress" /> 配列とポート番号 \(<see cref="T:System.Int32" />\) で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期の [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.TcpClient.BeginConnect%2A> を呼び出して操作を完了する必要があります、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.TcpClient.EndConnect%2A> メソッドです。 通常、このメソッドはによって、 `asyncCallback` を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.TcpClient.Connect%2A> メソッドのオーバー ロードします。  
  
 非同期プログラミング モデルの使用に関する詳細については、次を参照してください。 [Asynchronous Programming Overview](http://msdn.microsoft.com/ja-jp/41972034-92ed-450a-9664-ab93fcc6f1fb)します。  
  
 このメソッドへの呼び出しの直後に通常使用、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Dns.BeginGetHostAddresses%2A> メソッドで、1 つのホストの複数の IP アドレスを返すことができます。  
  
   
  
## 例  
 次のコード例を作成、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.TcpClient> し、リモート ホストに接続します。  
  
 [!code-cpp[System.Net.Sockets.TcpClient1\#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpClient1\#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <c>requestCallback</c> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 リモート ホストは、ホスト名 \(<see cref="T:System.String" />\) とポート番号 \(<see cref="T:System.Int32" />\) で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The asynchronous <xref:System.Net.Sockets.TcpClient.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.TcpClient.EndConnect%2A> method. Typically, the method is invoked by the **parameterReference tag is not supported!!!!**  
 delegate.  
  
 This method does not block until the operation completes. To block until the operation completes, use one of the <xref:System.Net.Sockets.TcpClient.Connect%2A> method overloads.  
  
 For detailed information about using the asynchronous programming model, see [Asynchronous Programming Overview](http://msdn.microsoft.com/ja-jp/41972034-92ed-450a-9664-ab93fcc6f1fb).  
  
   
  
## 例  
 The following code example creates a <xref:System.Net.Sockets.TcpClient> and connects to a remote host.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1\#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.TcpClient1\#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Client" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になる <see cref="T:System.Net.Sockets.Socket" /> を取得または設定します。</summary>
        <value>基になるネットワーク <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.TcpClient> creates a <xref:System.Net.Sockets.Socket> to send and receive data over a network. Classes deriving from <xref:System.Net.Sockets.TcpClient> can use this property to get or set this <xref:System.Net.Sockets.Socket>. Use the underlying <xref:System.Net.Sockets.Socket> returned from <xref:System.Net.Sockets.TcpClient.Client%2A> if you require access beyond that which <xref:System.Net.Sockets.TcpClient> provides. You can also use <xref:System.Net.Sockets.TcpClient.Client%2A> to set the underlying <xref:System.Net.Sockets.Socket> to an existing <xref:System.Net.Sockets.Socket>. This might be useful if you want to take advantage of the simplicity of <xref:System.Net.Sockets.TcpClient> using a pre\-existing <xref:System.Net.Sockets.Socket>.  
  
   
  
## 例  
 The following code example demonstrates the use of the <xref:System.Net.Sockets.TcpClient.Client%2A> property. In this example, the receive buffer size of the underlying <xref:System.Net.Sockets.Socket> is changed.  
  
 [!code-csharp[TcpClientProtectedMethodsAndPropertiesExample\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[TcpClientProtectedMethodsAndPropertiesExample\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Net.Sockets.TcpClient" /> インスタンスを破棄し、基になる TCP 接続を終了するように要求します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Net.Sockets.TcpClient.Close%2A> method marks the instance as disposed and requests that the associated <xref:System.Net.Sockets.Socket> close the TCP connection. Based on the <xref:System.Net.Sockets.TcpClient.LingerState%2A> property, the TCP connection may stay open for some time after the <xref:System.Net.Sockets.TcpClient.Close%2A> method is called when data remains to be sent. There is no notification provided when the underlying connection has completed closing.  
  
 Calling this method will eventually result in the close of the associated <xref:System.Net.Sockets.Socket> and will also close the associated <xref:System.Net.Sockets.NetworkStream> that is used to send and receive data if one was created.  
  
> [!NOTE]
>  This member outputs trace information when you enable network tracing in your application. For more information, see [&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## 例  
 The following code example demonstrates closing a <xref:System.Net.Sockets.TcpClient> by calling the <xref:System.Net.Sockets.TcpClient.Close%2A> method.  
  
 [!code-cpp[NCLTCPClientSync\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLTcpClientSync/CPP/tcpclient.cpp#1)]
 [!code-csharp[NCLTCPClientSync\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPEndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">接続先の <see cref="T:System.Net.IPEndPoint" />。</param>
        <summary>指定されたリモート ネットワーク エンドポイントを使用してリモート TCP ホストにクライアントを接続します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定した同期のリモート ホスト接続を確立するには、このメソッドを呼び出す <xref:System.Net.IPEndPoint>します。 呼び出す前に <xref:System.Net.Sockets.TcpClient.Connect%2A> のインスタンスを作成する必要があります、 <xref:System.Net.IPEndPoint> クラスの IP アドレスとポート番号を使用します。 これを使用して <xref:System.Net.IPEndPoint> として、 `remoteEP` パラメーター。<xref:System.Net.Sockets.TcpClient.Connect%2A> メソッドは接続するか失敗するまでブロックします。 リモート ホストに接続すると、使用、 <xref:System.Net.Sockets.TcpClient.GetStream%2A> メソッドは、基になるかを取得する <xref:System.Net.Sockets.NetworkStream>です。 これを使用して <xref:System.Net.Sockets.NetworkStream> データを送受信します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを取得した後に、Windows ソケット バージョン 2 API エラー コードのドキュメントを MSDN エラーの詳細について参照できます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、 <xref:System.Net.IPEndPoint> リモート ホストと接続します。  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#7](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#7](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEp" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> が閉じられます。</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">接続先ホストの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">接続先のポート番号。</param>
        <summary>指定された IP アドレスとポート番号を使用してクライアントをリモート TCP ホストに接続します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定した同期のリモート ホスト接続を確立するには、このメソッドを呼び出す <xref:System.Net.IPAddress> とポート番号。<xref:System.Net.Sockets.TcpClient.Connect%2A> メソッドは接続するか失敗するまでブロックします。 リモート ホストに接続すると、使用、 <xref:System.Net.Sockets.TcpClient.GetStream%2A> メソッドは、基になるかを取得する <xref:System.Net.Sockets.NetworkStream>です。 これを使用して <xref:System.Net.Sockets.NetworkStream> データを送受信します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを取得した後に、Windows ソケット バージョン 2 API エラー コードのドキュメントを MSDN エラーの詳細について参照できます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、IP アドレスとポート番号を使用して、リモート ホストに接続します。  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#6](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#6](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> 間 <see cref="F:System.Net.IPEndPoint.MinPort" /> と <see cref="F:System.Net.IPEndPoint.MaxPort" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> は閉じています。</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] ipAddresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] ipAddresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipAddresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ipAddresses">接続先ホストの <see cref="T:System.Net.IPAddress" /> 配列。</param>
        <param name="port">接続先のポート番号。</param>
        <summary>指定された IP アドレスとポート番号を使用してクライアントをリモート TCP ホストに接続します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドへの呼び出しの直後に通常使用、 [Connect メソッド \(IPAddress\<xref:System.Net.Dns.BeginGetHostAddresses%2A> メソッドで、1 つのホストの複数の IP アドレスを返すことができます。 呼び出す、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.TcpClient.Connect%2A> メソッドの配列で指定されたホストへの同期リモート ホスト接続を確立するために [Connect メソッド \(IPAddress\<xref:System.Net.IPAddress> 要素とポート番号。[Connect メソッド \(IPAddress\<xref:System.Net.Sockets.TcpClient.Connect%2A> メソッドは接続するか失敗するまでブロックします。 リモート ホストに接続すると、使用、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.TcpClient.GetStream%2A> メソッドは、基になるかを取得する [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.NetworkStream>です。 これを使用して [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.NetworkStream> データを送受信します。  
  
> [!NOTE]
>  表示された場合、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.SocketException>, を使用して [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを入手したらことができます MSDN ライブラリで Windows ソケット バージョン 2 API エラー コード ドキュメントを参照してください。 [http:\/\/msdn.microsoft.com\/library](http://msdn.microsoft.com/library) エラーの詳細な説明をします。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、IP アドレスとポート番号を使用して、リモート ホストに接続します。  
  
 [!code-cpp[System.Net.Sockets.TcpClient1\#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#8)]
 [!code-csharp[System.Net.Sockets.TcpClient1\#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ipAddresses" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドを使用するソケットの有効な <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> フラグまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> フラグ。</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">接続先のリモート ホストの DNS 名。</param>
        <param name="port">接続先のリモート ホストのポート番号。</param>
        <summary>指定されたホストの指定されたポートにクライアントを接続します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Call this method to establish a synchronous remote host connection to the specified host name and port number. The <xref:System.Net.Sockets.TcpClient.Connect%2A> method will block until it either connects or fails. After connecting with the remote host, use the <xref:System.Net.Sockets.TcpClient.GetStream%2A> method to obtain the underlying <xref:System.Net.Sockets.NetworkStream>. Use this <xref:System.Net.Sockets.NetworkStream> to send and receive data.  
  
 If IPv6 is enabled and the <xref:System.Net.Sockets.TcpClient.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address. This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.  
  
> [!NOTE]
>  If you receive a <xref:System.Net.Sockets.SocketException>, use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.  
  
> [!NOTE]
>  This member outputs trace information when you enable network tracing in your application. For more information, see [&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## 例  
 The following code example uses the host name and port number to connect with a remote host.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#5](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#5](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostname" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> パラメーターが <see cref="F:System.Net.IPEndPoint.MinPort" /> と <see cref="F:System.Net.IPEndPoint.MaxPort" /> の間にありません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> は閉じています。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">接続先ホストの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">接続先のポート番号。</param>
        <summary>指定された IP アドレスとポート番号を使用して、非同期操作としてクライアントをリモート TCP ホストに接続します。</summary>
        <returns>
          <see cref="T:System.Threading.Tasks.Task" /> を返します。  
  
 非同期操作を表すタスク オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この操作はブロックされません。 返される戻り値を <xref:System.Threading.Tasks.Task> オブジェクトは、TCP 接続が確立された後に完了します。 このメソッドは、接続要求を処理中に、呼び出し元のスレッドをブロックしません。  
  
 指定した同期のリモート ホスト接続を確立するには、このメソッドを呼び出す <xref:System.Net.IPAddress> と非同期の操作とポート番号。 リモート ホストに接続すると、使用、 <xref:System.Net.Sockets.TcpClient.GetStream%2A> メソッドは、基になるかを取得する <xref:System.Net.Sockets.NetworkStream>です。 これを使用して <xref:System.Net.Sockets.NetworkStream> データを送受信します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを取得した後に、Windows ソケット バージョン 2 API エラー コードのドキュメントを MSDN エラーの詳細について参照できます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> 間 <see cref="F:System.Net.IPEndPoint.MinPort" /> と <see cref="F:System.Net.IPEndPoint.MaxPort" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> は閉じています。</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">接続先ホストの <see cref="T:System.Net.IPAddress" /> 配列。</param>
        <param name="port">接続先のポート番号。</param>
        <summary>指定された IP アドレスとポート番号を使用して、非同期操作としてクライアントをリモート TCP ホストに接続します。</summary>
        <returns>
          <see cref="T:System.Threading.Tasks.Task" /> を返します。  
  
 非同期操作を表すタスク オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 この操作はブロックされません。 返される戻り値を [ConnectAsync メソッド \(IPAddress\<xref:System.Threading.Tasks.Task> オブジェクトは、TCP 接続が確立された後に完了します。 このメソッドは、接続要求を処理中に、呼び出し元のスレッドをブロックしません。  
  
 このメソッドへの呼び出しの直後に通常使用、 [ConnectAsync メソッド \(IPAddress\<xref:System.Net.Dns.BeginGetHostAddresses%2A> メソッドで、1 つのホストの複数の IP アドレスを返すことができます。 配列で指定されたホストへの同期リモート ホスト接続を確立するためには、このメソッドを呼び出す [ConnectAsync メソッド \(IPAddress\<xref:System.Net.IPAddress> 要素および非同期の操作とポート番号。 リモート ホストに接続すると、使用、 [ConnectAsync メソッド \(IPAddress\<xref:System.Net.Sockets.TcpClient.GetStream%2A> メソッドは、基になるかを取得する [ConnectAsync メソッド \(IPAddress\<xref:System.Net.Sockets.NetworkStream>です。 これを使用して [ConnectAsync メソッド \(IPAddress\<xref:System.Net.Sockets.NetworkStream> データを送受信します。  
  
> [!NOTE]
>  表示された場合、 [ConnectAsync メソッド \(IPAddress\<xref:System.Net.Sockets.SocketException>, を使用して [ConnectAsync メソッド \(IPAddress\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを入手したらことができます MSDN ライブラリで Windows ソケット バージョン 2 API エラー コード ドキュメントを参照してください。 [http:\/\/msdn.microsoft.com\/library](http://msdn.microsoft.com/library) エラーの詳細な説明をします。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ipAddresses" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドを使用するソケットの有効な <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> フラグまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> フラグ。</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">接続先のリモート ホストの DNS 名。</param>
        <param name="port">接続先のリモート ホストのポート番号。</param>
        <summary>非同期操作として、クライアントを、指定したホストの指定した TCP ポートに接続します。</summary>
        <returns>
          <see cref="T:System.Threading.Tasks.Task" /> を返します。  
  
 非同期操作を表すタスク オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This operation will not block. The returned Returns <xref:System.Threading.Tasks.Task> object will complete after the TCP connection has been established. This method does not block the calling thread while the connection request is underway.  
  
 Call this method to establish a synchronous remote host connection to the specified host name and port number as an asynchronous operation. After connecting with the remote host, use the <xref:System.Net.Sockets.TcpClient.GetStream%2A> method to obtain the underlying <xref:System.Net.Sockets.NetworkStream>. Use this <xref:System.Net.Sockets.NetworkStream> to send and receive data.  
  
 If IPv6 is enabled and the <xref:System.Net.Sockets.TcpClient.ConnectAsync%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address. This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.  
  
> [!NOTE]
>  If you receive a <xref:System.Net.Sockets.SocketException>, use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.  
  
> [!NOTE]
>  This member outputs trace information when you enable network tracing in your application. For more information, see [&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostname" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> パラメーターが <see cref="F:System.Net.IPEndPoint.MinPort" /> と <see cref="F:System.Net.IPEndPoint.MaxPort" /> の間にありません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> は閉じています。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.TcpClient" /> の基になる <see cref="T:System.Net.Sockets.Socket" /> がリモート ホストに接続されているかどうかを示す値を取得します。</summary>
        <value>最後に実行された操作の時点で、<see cref="P:System.Net.Sockets.TcpClient.Client" /> ソケットがリモート リソースに接続されていた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Net.Sockets.TcpClient.Connected%2A> property gets the connection state of the <xref:System.Net.Sockets.TcpClient.Client%2A> socket as of the last I\/O operation. When it returns **languageKeyword tag is not supported!!!!**  
, the <xref:System.Net.Sockets.TcpClient.Client%2A> socket was either never connected, or is no longer connected.  
  
 Because the <xref:System.Net.Sockets.TcpClient.Connected%2A> property only reflects the state of the connection as of the most recent operation, you should attempt to send or receive a message to determine the current state. After the message send fails, this property no longer returns **languageKeyword tag is not supported!!!!**  
. Note that this behavior is by design. You cannot reliably test the state of the connection because, in the time between the test and a send\/receive, the connection could have been lost. Your code should assume the socket is connected, and gracefully handle failed transmissions.  
  
   
  
## 例  
 The following code example connects to a remote endpoint and then verifies the connection.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpClient1\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.TcpClient" /> によって使用されているマネージ リソースおよびアンマネージ リソースを解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" /> に設定し、アンマネージ リソースだけを解放する場合は <see langword="false" /> に設定します。</param>
        <summary>
          <see cref="T:System.Net.Sockets.TcpClient" /> によって使用されているアンマネージ リソースを解放し、オプションでマネージ リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is called by the public **languageKeyword tag is not supported!!!!**  
 method and the <xref:System.Object.Finalize%2A> method. **languageKeyword tag is not supported!!!!**  
 invokes this method with the **parameterReference tag is not supported!!!!**  
 parameter set to **languageKeyword tag is not supported!!!!**  
. <xref:System.Object.Finalize%2A> invokes this method with **parameterReference tag is not supported!!!!**  
 set to **languageKeyword tag is not supported!!!!**  
.  
  
 When the **parameterReference tag is not supported!!!!**  
 parameter is **languageKeyword tag is not supported!!!!**  
, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.TcpClient> references. It does this by invoking the **languageKeyword tag is not supported!!!!**  
 method of each referenced object.  
  
> [!NOTE]
>  This member outputs trace information when you enable network tracing in your application. For more information, see [&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> can be called multiple times by other objects. When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />. For more information about how to implement <see langword="Dispose(Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" /> の呼び出しによって返される <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>保留中の非同期接続の試行を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドはブロックするまで、操作を完了します。 この操作を同期的に実行するを使用して、 <xref:System.Net.Sockets.TcpClient.Connect%2A> メソッドです。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを入手したらことができます MSDN ライブラリで Windows ソケット バージョン 2 API エラー コード ドキュメントを参照してください。 [http:\/\/msdn.microsoft.com\/library](http://msdn.microsoft.com/library) エラーの詳細な説明をします。  
  
   
  
## 例  
 次のコード例では、非同期接続の試行を終了します。  
  
 [!code-cpp[System.Net.Sockets.TcpClient1\#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.TcpClient1\#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> への呼び出しによって、パラメーターは返されませんでした、 <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" /> メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" /> 非同期接続のメソッドが呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">アクセスするときにエラーが発生しました、 <see cref="T:System.Net.Sockets.Socket" />です。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">基になる <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.TcpClient" /> で 1 つのクライアントだけがポートを使用できるかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.TcpClient" /> で、1 つのクライアントだけが特定のポートを使用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、Windows Server 2003 および Windows XP Service Pack 2 以降では <see langword="true" /> で、その他のすべてのバージョンでは <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、複数のクライアントが特定のポートを使用できます。ただし、クライアントの 1 つだけでは、ポートに送信されるネットワーク トラフィックの操作を実行できます。 使用することができます、 <xref:System.Net.Sockets.TcpClient.ExclusiveAddressUse%2A> プロパティを複数のクライアントが特定のポートを使用するを防ぐためにします。  
  
 基になるソケットは、クライアントのポートにバインドされる前に、このプロパティを設定する必要があります。 呼び出した場合 <xref:System.Net.Sockets.TcpClient.Connect%2A>, 、<xref:System.Net.Sockets.TcpClient.BeginConnect%2A>, 、<xref:System.Net.Sockets.TcpClient.%23ctor%28System.Net.IPEndPoint%29>, 、または <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29>, 、クライアントのポートが、メソッドの副作用としてバインドされているし、後で設定することはできません、 <xref:System.Net.Sockets.TcpClient.ExclusiveAddressUse%2A> プロパティ  
  
   
  
## 例  
 次のコード例を作成、 <xref:System.Net.Sockets.TcpClient> を取得しの値を設定し、 <xref:System.Net.Sockets.TcpClient.ExclusiveAddressUse%2A> プロパティです。  
  
 [!code-cpp[System.Net.Sockets.TcpClient1\#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpClient1\#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">基になるソケットにアクセスするときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">基になる <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.TcpClient" /> クラスによって使用されていたリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method overrides <xref:System.Object.Finalize%2A?displayProperty=fullName>. Application code should not call this method; an object's <xref:System.Object.Finalize%2A> method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.  
  
 The <xref:System.Net.Sockets.TcpClient> class finalizer closes the TCP connection and releases all managed resources associated with the <xref:System.Net.Sockets.TcpClient>. These resources include the underlying <xref:System.Net.Sockets.Socket> used for connecting with the remote host, and the <xref:System.Net.Sockets.NetworkStream> used to send and receive data. The finalizer does not release any unmanaged resources.  
  
 For more information, see [Finalize Methods and Destructors](http://msdn.microsoft.com/ja-jp/fd376774-1643-499b-869e-9546a3aeea70), [&#91;\<topic:\/\/cpconCleaningUpUnmanagedResources\>&#93;](http://msdn.microsoft.com/ja-jp/a17b0066-71c2-4ba4-9822-8e19332fc213), and [Overriding the Finalize Method](http://msdn.microsoft.com/ja-jp/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.NetworkStream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.NetworkStream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.GetStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.NetworkStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>データの送受信に使用する <see cref="T:System.Net.Sockets.NetworkStream" /> を返します。</summary>
        <returns>基になる <see cref="T:System.Net.Sockets.NetworkStream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.TcpClient.GetStream%2A> 返します、 <xref:System.Net.Sockets.NetworkStream> データの送受信に使用することできます。<xref:System.Net.Sockets.NetworkStream> クラスから継承、 <xref:System.IO.Stream> メソッドとネットワーク通信を容易にするために使用されるプロパティの豊富なコレクションを提供するクラス。  
  
 呼び出す必要があります、 <xref:System.Net.Sockets.TcpClient.Connect%2A> メソッド、または <xref:System.Net.Sockets.TcpClient.GetStream%2A> メソッドをスロー、 <xref:System.InvalidOperationException>です。 取得した後、 <xref:System.Net.Sockets.NetworkStream>, を呼び出す、 <xref:System.Net.Sockets.NetworkStream.Write%2A> リモート ホストにデータを送信する方法です。 呼び出す、 <xref:System.Net.Sockets.NetworkStream.Read%2A> リモート ホストから着信するデータを受信する方法です。 これら両方のメソッドは、指定された操作が実行されるまでブロックします。 チェックして、読み取り操作してブロックを回避できる、 <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> プロパティです。 A `true` 値は、データがリモート ホストから届いたし、読み取り可能ことを意味します。 この場合、 <xref:System.Net.Sockets.NetworkStream.Read%2A> をすぐに完了することが保証されます。 リモート ホストがシャット ダウンをその接続である場合 <xref:System.Net.Sockets.NetworkStream.Read%2A> ですぐに 0 バイトが返されます。  
  
> [!NOTE]
>  閉じる必要があります、 <xref:System.Net.Sockets.NetworkStream> を通じてデータを送受信します。 閉じる <xref:System.Net.Sockets.TcpClient> 解放されず、 <xref:System.Net.Sockets.NetworkStream>です。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを取得した後に、Windows ソケット バージョン 2 API エラー コードのドキュメントを MSDN エラーの詳細について参照できます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では <xref:System.Net.Sockets.TcpClient.GetStream%2A> させることが、基になる <xref:System.Net.Sockets.NetworkStream>します。 取得した後、 <xref:System.Net.Sockets.NetworkStream>, を使用して送受信してその <xref:System.Net.Sockets.NetworkStream.Write%2A> と <xref:System.Net.Sockets.NetworkStream.Read%2A> メソッドです。  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#14](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#14)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#14](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#14)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.TcpClient" /> リモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられているソケットの待機状態に関する情報を取得または設定します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.LingerOption" /> 既定では、接続の待機は無効です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Net.Sockets.TcpClient.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves. This property when set modifies the conditions under which the connection can be reset by Winsock. Connection resets can still occur based on the IP protocol behavior.  
  
 This property controls the length of time that the TCP connection will remain open after a call to <xref:System.Net.Sockets.TcpClient.Close%2A> when data remains to be sent. When you call the <xref:System.Net.Sockets.NetworkStream.Write%2A> method, data is placed in the outgoing network buffer. This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.  
  
 To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.TcpClient.LingerState%2A> property to this instance.  
  
 The following table describes the behavior of the <xref:System.Net.Sockets.TcpClient.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.TcpClient.LingerState%2A> property.  
  
|LingerState.Enabled|LingerState.LingerTime|Behavior|  
|-------------------------|----------------------------|--------------|  
|`false` \(disabled\), the default value|The time\-out is not applicable, \(default\).|Attempts to send pending data until the default IP protocol time\-out expires.|  
|`true` \(enabled\)|A nonzero time\-out|Attempts to send pending data until the specified time\-out expires, and if the attempt fails, then Winsock resets the connection.|  
|`true` \(enabled\)|A zero timeout.|Discards any pending data and Winsock resets the connection.|  
  
 The IP stack computes the default IP protocol time\-out period to use based on the round trip time of the connection. In most cases, the time\-out computed by the stack is more relevant than one defined by an application. This is the default behavior for a socket when the <xref:System.Net.Sockets.TcpClient.LingerState%2A> property is not set.  
  
 When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.TcpClient.LingerState%2A> property is set greater than the default IP protocol time\-out, the default IP protocol time\-out will still apply and override.  
  
   
  
## 例  
 The following code example sets and gets the sockets linger time.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#12](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#12)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#12](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#12)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.LingerOption" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>送信バッファーまたは受信バッファーが設定されているサイズを超えていない場合に、遅延を無効にする値を取得または設定します。</summary>
        <value>遅延が無効になっている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ときに<xref:System.Net.Sockets.TcpClient.NoDelay%2A>は`false`、<xref:System.Net.Sockets.TcpClient>まで送信しませんパケット、ネットワーク経由で大量の送信データを収集しました。 TCP セグメントのオーバーヘッドの量、ため少量のデータを送信する効果がありません。 ただし、状況は非常に少量のデータを送信、またはすぐに送信した各パケット応答を期待する必要がある存在します。 決定するうえでは、ネットワーク効率は、アプリケーションの要件との相対的な重要度比較検討する必要があります。  
  
   
  
## 例  
 次のコード例では、遅延が無効にします。 値をチェックし、<xref:System.Net.Sockets.TcpClient.NoDelay%2A>プロパティが正常に設定されていることを確認します。  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#13](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#13](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>受信バッファーのサイズを取得または設定します。</summary>
        <value>受信バッファー サイズ \(バイト単位\)。 既定値は 8192 バイトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.TcpClient.ReceiveBufferSize%2A> プロパティを取得またはそれぞれの読み取り操作の受信バッファーに格納することを予期しているバイト数を設定します。 このプロパティは、実際には、受信データに割り当てられたネットワーク バッファー領域を操作します。  
  
 ネットワーク バッファーはアプリケーション バッファーを呼び出したときに、必要なデータが使用できることを確認するには、少なくとものサイズである必要があります、 <xref:System.Net.Sockets.NetworkStream.Read%2A?displayProperty=fullName> メソッドです。 使用して、 <xref:System.Net.Sockets.TcpClient.ReceiveBufferSize%2A> このサイズを設定するプロパティです。 アプリケーションが大量のデータを受信する場合、 <xref:System.Net.Sockets.NetworkStream.Read%2A> メソッド非常に大きいアプリケーション バッファー。  
  
 要求のネットワーク バッファーがデータの量より小さい場合、 <xref:System.Net.Sockets.NetworkStream.Read%2A> メソッド、しないことができます必要な 1 つの読み取り操作のデータ量を取得します。 これは、それ以上の呼び出しのオーバーヘッドを生じさせます、 <xref:System.Net.Sockets.NetworkStream.Read%2A> メソッドです。  
  
   
  
## 例  
 次のコード例では、設定し、受信バッファー サイズを取得します。  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#8](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#8](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">バッファー サイズを設定するときにエラーが発生しました。  
  
 または  
  
 .NET Compact Framework アプリケーションでは、このプロパティを設定することはできません。 この問題を回避するには、「解説」プラットフォーム メモを参照してください。</exception>
        <altmember cref="P:System.Net.Sockets.TcpClient.SendBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み取り操作が開始された後に <see cref="T:System.Net.Sockets.TcpClient" /> がデータの受信を待機する時間を取得または設定します。</summary>
        <value>接続のタイムアウト値 \(ミリ秒単位\)。 既定値は 0 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Net.Sockets.TcpClient.ReceiveTimeout%2A> property determines the amount of time that the <xref:System.Net.Sockets.NetworkStream.Read%2A> method will block until it is able to receive data. This time is measured in milliseconds. If the time\-out expires before <xref:System.Net.Sockets.NetworkStream.Read%2A> successfully completes, <xref:System.Net.Sockets.TcpClient> throws a <xref:System.IO.IOException>. There is no time\-out by default.  
  
   
  
## 例  
 The following code example sets and gets the receive time out.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#10](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#10](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.SendTimeout" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>送信バッファーのサイズを取得または設定します。</summary>
        <value>送信バッファー サイズ \(バイト単位\)。 既定値は 8192 バイトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Net.Sockets.TcpClient.SendBufferSize%2A> property gets or sets the number of bytes that you are expecting to send in each call to the <xref:System.Net.Sockets.NetworkStream.Write%2A?displayProperty=fullName> method. This property actually manipulates the network buffer space allocated for send operation.  
  
 Your network buffer should be at least as large as your application buffer to ensure that the desired data will be stored and sent in one operation. Use the <xref:System.Net.Sockets.TcpClient.SendBufferSize%2A> property to set this size. If your application will be sending bulk data, you should pass the <xref:System.Net.Sockets.NetworkStream.Write%2A> method a very large application buffer.  
  
 If the network buffer is smaller than the amount of data you provide the <xref:System.Net.Sockets.NetworkStream.Write%2A> method, several network send operations will be performed for every call you make to the <xref:System.Net.Sockets.NetworkStream.Write%2A> method. You can achieve greater data throughput by ensuring that your network buffer is at least as large as your application buffer.  
  
   
  
## 例  
 The following code example sets and gets the send buffer size.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#9](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#9](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>送信操作が正常に完了するのを <see cref="T:System.Net.Sockets.TcpClient" /> が待機する時間を取得または設定します。</summary>
        <value>送信のタイムアウト値 \(ミリ秒単位\)。 既定値は 0 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Net.Sockets.TcpClient.SendTimeout%2A> property determines the amount of time that the <xref:System.Net.Sockets.Socket.Send%2A> method will block until it is able to return successfully. This time is measured in milliseconds.  
  
 After you call the <xref:System.Net.Sockets.NetworkStream.Write%2A> method, the underlying <xref:System.Net.Sockets.Socket> returns the number of bytes actually sent to the host. The <xref:System.Net.Sockets.TcpClient.SendTimeout%2A> property determines the amount of time a <xref:System.Net.Sockets.TcpClient> will wait before receiving the number of bytes returned. If the time\-out expires before the <xref:System.Net.Sockets.Socket.Send%2A> method successfully completes, <xref:System.Net.Sockets.TcpClient> will throw a <xref:System.Net.Sockets.SocketException>. There is no time\-out by default.  
  
   
  
## 例  
 The following code example sets and gets the <xref:System.Net.Sockets.TcpClient.SendTimeout%2A> value.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#11](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample\#11](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample\#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.System#IDisposable#Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたホスト名とポート番号を使用して、非同期操作としてクライアントをリモート TCP ホストに接続します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.TcpClient" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたホスト名とポート番号を使用してクライアントをリモート TCP ホストに接続します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>