<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Berkeley ソケット インターフェイスを実装します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket> クラスは、ネットワーク通信のメソッドとプロパティの豊富なセットを提供します。<xref:System.Net.Sockets.Socket> クラスを使用すると、両方を実行する同期および非同期データ転送を使用して通信プロトコルのいずれかに示されている、 <xref:System.Net.Sockets.ProtocolType> 列挙します。  
  
 <xref:System.Net.Sockets.Socket> クラスが非同期メソッドの場合は、.NET Framework 名前付けパターンに従います。 たとえば、同期 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドに非同期対応 <xref:System.Net.Sockets.Socket.BeginReceive%2A> と <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドです。  
  
 アプリケーションには、実行中に 1 つのスレッドのみ必要とする場合は、同期操作モード用に設計された、次のメソッドを使用します。  
  
-   使用した接続に、サーバーがリッスンできる TCP などの接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Listen%2A> メソッドです。<xref:System.Net.Sockets.Socket.Accept%2A> メソッド プロセスの着信接続を要求し、返します、 <xref:System.Net.Sockets.Socket> リモート ホストにデータをやり取りするために使用することできます。 この返さ <xref:System.Net.Sockets.Socket> を呼び出して、 <xref:System.Net.Sockets.Socket.Send%2A> または <xref:System.Net.Sockets.Socket.Receive%2A> メソッドです。 呼び出す、 <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す前に、 <xref:System.Net.Sockets.Socket.Listen%2A> メソッド ローカル IP アドレスとポート番号を指定する場合。 サービス プロバイダーは、空いているポートを割り当てる、基になる場合は、ゼロのポート番号を使用します。 リッスンしているホストに接続する場合を呼び出す、 <xref:System.Net.Sockets.Socket.Connect%2A> メソッドです。 データを通信するために呼び出す、 <xref:System.Net.Sockets.Socket.Send%2A> または <xref:System.Net.Sockets.Socket.Receive%2A> メソッドです。  
  
-   UDP などのコネクションレスのプロトコルを使用している場合は、すべての接続をリッスンする必要はありません。 呼び出す、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 、受信データグラムを許可するメソッドです。 使用して、 <xref:System.Net.Sockets.Socket.SendTo%2A> データグラムをリモート ホストに送信するメソッドです。  
  
 実行中に個別のスレッドを使用して通信を処理するには、非同期の操作モード用に設計された、次のメソッドを使用します。  
  
-   TCP などの接続指向のプロトコルを使用している場合は使用して、 <xref:System.Net.Sockets.Socket>, 、<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、および <xref:System.Net.Sockets.Socket.EndConnect%2A> リッスン中のホストに接続する方法です。 使用して、 <xref:System.Net.Sockets.Socket.BeginSend%2A> と <xref:System.Net.Sockets.Socket.EndSend%2A> または <xref:System.Net.Sockets.Socket.BeginReceive%2A> と <xref:System.Net.Sockets.Socket.EndReceive%2A> データを非同期的に通信するメソッドです。 使用して接続要求を処理できる <xref:System.Net.Sockets.Socket.BeginAccept%2A> と <xref:System.Net.Sockets.Socket.EndAccept%2A>です。  
  
-   UDP などのコネクションレスのプロトコルを使用している場合は、行うこともできます <xref:System.Net.Sockets.Socket.BeginSendTo%2A> と <xref:System.Net.Sockets.Socket.EndSendTo%2A> 、データグラムを送信して <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>と<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> データグラムを受信します。  
  
 ソケットでの複数の非同期操作を実行する場合、必ずしもで完了しなかった開始される順序。  
  
 送信およびデータ受信を完了したらを使用して、 <xref:System.Net.Sockets.Socket.Shutdown%2A> 無効にする方法、 <xref:System.Net.Sockets.Socket>です。 呼び出した後 <xref:System.Net.Sockets.Socket.Shutdown%2A>, を呼び出す、 <xref:System.Net.Sockets.Socket.Close%2A> に関連付けられているすべてのリソースを解放するメソッド、 <xref:System.Net.Sockets.Socket>です。  
  
 <xref:System.Net.Sockets.Socket> クラスでは、構成、 <xref:System.Net.Sockets.Socket> を使用して、 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドです。 使用してこれらの設定を取得、 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドです。  
  
> [!NOTE]
>  比較的単純なアプリケーションを記述して、最大のパフォーマンスを必要としない場合は、使用を検討して <xref:System.Net.Sockets.TcpClient>, 、<xref:System.Net.Sockets.TcpListener>, 、および <xref:System.Net.Sockets.UdpClient>です。 これらのクラスに簡単になりよりわかりやすいインターフェイスを提供する <xref:System.Net.Sockets.Socket> 通信します。  
  
   
  
## 例  
 次のコード例に示す方法、 <xref:System.Net.Sockets.Socket> HTTP サーバーにデータを送信し、応答を受信するクラスを使用することができます。 この例は、ページ全体を受信するまでブロックします。  
  
 [!code-cpp[System.Net.Sockets.Socket\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">To establish an outgoing connection or accept an incoming request.</permission>
    <threadsafe>このクラスのインスタンスでは、スレッド セーフです。</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">によって返されるソケット情報 <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />します。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Net.Sockets.Socket" /> クラスから返される値を指定して <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出した場合、 <xref:System.Net.Sockets.Socket.%23ctor%2A> の各呼び出しの引数と同じバイト配列で複数回コンス トラクターは、複数の管理を作成、 <xref:System.Net.Sockets.Socket>同じ基になるソケットとします。 この方法はお勧めします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Net.Sockets.Socket" /> クラスの指定したソケットの種類およびプロトコルを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `socketType` パラメーターの型を指定、 <xref:System.Net.Sockets.Socket> クラスおよび `protocolType` パラメーターで使用されるプロトコルを指定 <xref:System.Net.Sockets.Socket>します。 2 つのパラメーターでは、依存しません。 多くの場合、 <xref:System.Net.Sockets.Socket> 型は、プロトコルで暗黙的に定義します。 場合の組み合わせ <xref:System.Net.Sockets.Socket> 型とプロトコルは、結果を型が無効 <xref:System.Net.Sockets.Socket>, 、このコンス トラクターのスロー、 <xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  このコンス トラクターをスローした場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets のバージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">組み合わせ  <paramref name="socketType" /> と <paramref name="protocolType" /> 結果、ソケットは無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">
          <see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか 1 つ。</param>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Net.Sockets.Socket" /> クラスの指定したアドレス ファミリ、ソケットの種類およびプロトコルを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `addressFamily` パラメーターを指定するアドレス指定スキーム、<xref:System.Net.Sockets.Socket> クラスは、 `socketType` パラメーターの型を指定、 <xref:System.Net.Sockets.Socket> クラス、および `protocolType` パラメーターで使用されるプロトコルを指定 <xref:System.Net.Sockets.Socket>します。 3 つのパラメーターでは、依存しません。 一部のアドレス ファミリを制限、および多くの場合に使用できるプロトコル、 <xref:System.Net.Sockets.Socket> 型は、プロトコルで暗黙的に定義します。 場合はアドレス ファミリを組み合わせた <xref:System.Net.Sockets.Socket> 型、およびプロトコルの種類は、無効な <xref:System.Net.Sockets.Socket>, 、このコンス トラクターをスロー、 <xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  このコンス トラクターをスローした場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets のバージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、インスタンスを作成、 <xref:System.Net.Sockets.Socket> クラスです。  
  
 [!code-cpp[Socket\_Send\_Recieve\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket\_Send\_Recieve\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket\_Send\_Recieve\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">組み合わせ <paramref name="addressFamily" />, 、<paramref name="socketType" />, 、および <paramref name="protocolType" /> 結果、ソケットは無効です。</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新たに作成 <see cref="T:System.Net.Sockets.Socket" /> の新しく作成された接続。</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> の新しく作成された接続。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.Accept%2A> 同期的に待機中のソケットの接続要求のキューから最初の保留中の接続要求を抽出しを作成し、新しい返します <xref:System.Net.Sockets.Socket>します。 返されるこれを使用することはできません <xref:System.Net.Sockets.Socket> 接続キューからその他の接続を受け入れるようにします。 ただし、呼び出すことができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたメソッド <xref:System.Net.Sockets.Socket> をリモート ホストのネットワーク アドレスとポート番号を識別します。  
  
 ブロッキング モードで <xref:System.Net.Sockets.Socket.Accept%2A> 受信接続の試行がキューに登録するまでブロックします。 接続が受け入れられると、元の <xref:System.Net.Sockets.Socket> キューの着信接続を要求するまで閉じることを継続します。  
  
 非ブロッキングを使用してこのメソッドを呼び出すかどうか <xref:System.Net.Sockets.Socket>, 、および要求がキューに置かれた接続がない <xref:System.Net.Sockets.Socket.Accept%2A> スロー、 <xref:System.Net.Sockets.SocketException>です。 表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  呼び出しの前に、 <xref:System.Net.Sockets.Socket.Accept%2A> メソッドでは、最初に呼び出す必要があります、 <xref:System.Net.Sockets.Socket.Listen%2A> をリッスンし、接続要求をキューのメソッドです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例は、単純な <xref:System.Net.Sockets.Socket> 接続します。  
  
 [!code-cpp[Classic Socket.Accept Example\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">接続の受け入れ元のソケットがリッスンしていません。 呼び出す必要があります <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> と <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 呼び出す前に <see cref="M:System.Net.Sockets.Socket.Accept" />します。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>着信接続の試行をそのまま使用する非同期操作を開始します。</summary>
        <returns>返します。 <see langword="true" /> I\/O 操作が保留中の場合。<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターが操作の完了時に発生します。  
  
 返します。 <see langword="false" /> 場合は、I\/O 操作が同期的に完了します。<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターは発生しません、 <paramref name="e" /> 操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向プロトコルを使用して、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッドを非同期的に受信接続を処理しようとします。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 呼び出しの前に、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッドを呼び出す必要があります、 <xref:System.Net.Sockets.Socket.Listen%2A> をリッスンし、接続要求をキューのメソッドです。  
  
 完了の通知を受信する、EventHandler \< SocketAsyncEventArgs \> を実装は委任し、それには、コールバック メソッドを作成する必要があります、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> イベントです。  
  
 次のプロパティおよびイベントに、 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> オブジェクトが必要。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  
  
 呼び出し元は、既存のオプションで指定できます <xref:System.Net.Sockets.Socket> を指定することにより、着信接続を使用する、 <xref:System.Net.Sockets.Socket> で使用する、 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> プロパティです。  
  
 場合、 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> プロパティが null の場合、新しい <xref:System.Net.Sockets.Socket> が同じで構築されて <xref:System.Net.Sockets.Socket.AddressFamily%2A>, 、<xref:System.Net.Sockets.Socket.SocketType%2A>, 、および <xref:System.Net.Sockets.Socket.ProtocolType%2A> 現在 <xref:System.Net.Sockets.Socket> として設定し、 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> プロパティです。  
  
 呼び出し元の設定、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> プロパティを呼び出す前に必要なユーザーの状態オブジェクト、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 必要に応じて後、ソケット上のデータの最初のブロックを受信するバッファーを指定することがあります、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドが成功しました。 ここで、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> プロパティを受信するデータを含むバッファーに設定する必要があり、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> プロパティは、バッファー内に受信するデータのバイトの最大数に設定する必要があります。 これらのプロパティの設定を使用して、 <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=fullName> メソッドです。 渡されたバッファーの一部で使用するために、内部的に使用される、基になる Winsock AcceptEx 呼び出しです。 つまり、返されるデータの量は常の値より小さい、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> プロパティを <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> 指定されたインスタンス。 内部的に使用されるバッファーの容量は、ソケットのアドレス ファミリに変わります。 必要な最小バッファー サイズは、288 バイトです。 大きなバッファー サイズが指定されている場合、 <xref:System.Net.Sockets.Socket> Winsock AcceptEx 呼び出しが受信するアドレス データ以外のいくつかの余分なデータを求めるし、この余分なデータを受信するまで待機します。 タイムアウトが発生した場合、接続がリセットされます。 ように余分なデータが特定の量と予想される場合、最小バッファー サイズとこの金額にバッファー サイズを設定する必要があります。  
  
 完了コールバック メソッドを調べる必要があります、 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> プロパティかどうかを <xref:System.Net.Sockets.Socket.AcceptAsync%2A> 操作は成功しました。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> イベントは接続が許可されていない場合に発生して、発生する、 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> プロパティに設定する <xref:System.Net.Sockets.SocketError.ConnectionReset>です。 これは、ポートを半開 SYN の種類のスキャンを使用してスキャンの結果として発生 \(SYN SYN ACK\]\-\> \[RST シーケンス \-\>\)。 アプリケーションを使用して、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッドは、この状態の処理に準備する必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、提供されるバッファーの大きさがない場合に発生します。 バッファーが 2 以上にする必要があります \* \(sizeof\(SOCKADDR\_STORAGE \+ 16\) バイトです。  
  
 この例外は、複数のバッファーを指定する場合にも発生、 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null でないです。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">引数が範囲外です。 場合に例外が発生した、 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> が 0 未満です。</exception>
        <exception cref="T:System.InvalidOperationException">無効な操作が要求されました。 場合にこの例外が発生した承諾 <see cref="T:System.Net.Sockets.Socket" /> が承諾または接続のリッスンしていないソケットをバインドします。  
  
 呼び出す必要があります、 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> と <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> メソッドを呼び出す前に、 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドです。  
  
 この例外は、ソケットは既に接続しているか、ソケット操作は、既に指定して進行状況にいた場合にも発生 <paramref name="e" /> パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降がこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アドレス ファミリを取得、 <see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value>
          <see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.AddressFamily> をアドレス指定スキームを指定のインスタンス、 <xref:System.Net.Sockets.Socket> クラスを使用できます。 このプロパティは読み取り専用と設定されている場合に、 <xref:System.Net.Sockets.Socket> が作成されます。  
  
   
  
## 例  
 次のコード例を表示、 <xref:System.Net.Sockets.AddressFamily>, 、<xref:System.Net.Sockets.SocketType>, 、および <xref:System.Net.Sockets.ProtocolType> コンソールにします。  
  
 [!code-cpp[Socket\_Socket\_Options\#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket\_Socket\_Options\#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket\_Socket\_Options\#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネットワークから受信した、読み取り可能なデータ量を取得します。</summary>
        <value>ネットワークから受信した、読み取り可能なデータのバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If you are using a non\-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>. The available data is the total amount of data queued in the network buffer for reading. If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.  
  
 If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  
  
> [!NOTE]
>  This member outputs trace information when you enable network tracing in your application. For more information, see [&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## 例  
 The following code example compares the results of calling IOControl with FIONREAD and the Available property.  
  
 [!code-cpp[NCLSocketIoControl\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>着信接続の試行をそのまま使用する非同期操作を開始します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期を参照する <see cref="T:System.Net.Sockets.Socket" /> 作成します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向プロトコルを使用して、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを非同期的に受信接続を処理しようとします。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 呼び出しの前に、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出す必要があります、 <xref:System.Net.Sockets.Socket.Listen%2A> をリッスンし、接続要求をキューのメソッドです。  
  
 実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任し、その名前を渡す、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。 そのためには、極端に言えば、リッスンを渡す必要があります <xref:System.Net.Sockets.Socket> オブジェクトを <xref:System.Net.Sockets.Socket.BeginAccept%2A> を通じて、 `state` パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 <xref:System.Net.Sockets.Socket> およびその他の必要な情報です。 このクラスのインスタンスを渡す、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドです。 アプリケーションを呼び出すと <xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、システムは通常、個別のスレッドを使用して、指定されたコールバック メソッドを実行しでブロック <xref:System.Net.Sockets.Socket.EndAccept%2A> 保留中の接続が取得されるまでです。<xref:System.Net.Sockets.Socket.EndAccept%2A> 新しい戻ります <xref:System.Net.Sockets.Socket> リモート ホストとのデータの送受信に使用できるオブジェクトします。 返されるこれを使用することはできません <xref:System.Net.Sockets.Socket> 接続キューからその他の接続を受け入れるようにします。 ブロックを呼び出した後に元のスレッドが必要なかどうかは、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを使用して <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>します。 セット メソッドを呼び出す、 <xref:System.Threading.ManualResetEvent> 、元のスレッド実行を継続する場合は、コールバック メソッドにします。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、 <xref:System.IAsyncResult.CompletedSynchronously%2A> プロパティで返された <xref:System.IAsyncResult> ことを示すために設定されます、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に終了しました。  
  
 コールバック メソッドの記述の詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
 保留中の呼び出しをキャンセルする、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッド、閉じる、 <xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出して非同期操作が進行中をコールバックが提供されて、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが呼び出されます。  後続の呼び出しに、 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドをスローする <xref:System.ObjectDisposedException> 操作が取り消されたことを示すためにします。  
  
> [!NOTE]
>  使用することができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ <xref:System.Net.Sockets.Socket> をリモート ホストのネットワーク アドレスとポート番号を識別します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後、に、Windows ソケット バージョン 2 API エラー コード ドキュメントを参照 MSDN エラーの詳細な説明をします。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている <xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 <xref:System.Net.Sockets.Socket> メソッドは、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例は、非同期的に受信接続を受信しようとします。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket\_Async\_Send\_Receive\#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.InvalidOperationException">接続の受け入れ元のソケットがリッスンしていません。 呼び出す必要があります <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> と <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 呼び出す前に <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />します。  
  
 または  
  
 受け入れられたソケットにバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">送信側からそのまま使用するバイト数。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>着信接続の試行をそのまま使用する非同期操作を開始し、クライアント アプリケーションによって送信されたデータの最初のブロックを受信します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期を参照する <see cref="T:System.Net.Sockets.Socket" /> 作成します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向プロトコルを使用して、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを非同期的に受信接続を処理しようとします。 非同期的に接続を受け入れる、単独の実行スレッド内のデータの送受信を行うことができます。 このオーバー ロードでは、初期の転送に同意するバイト数を指定することができます、 `receiveSize` パラメーター。  
  
 呼び出しの前に、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出す必要があります、 <xref:System.Net.Sockets.Socket.Listen%2A> をリッスンし、接続要求をキューのメソッドです。  
  
 実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任し、その名前を渡す、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。 そのためには、極端に言えば、リッスンを渡す必要があります <xref:System.Net.Sockets.Socket> オブジェクトを <xref:System.Net.Sockets.Socket.BeginAccept%2A> を通じて、 `state` パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 <xref:System.Net.Sockets.Socket> およびその他の必要な情報です。 このクラスのインスタンスを渡す、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドです。 アプリケーションを呼び出すと <xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、システムは通常、個別のスレッドを使用して、指定されたコールバック メソッドを実行しでブロック <xref:System.Net.Sockets.Socket.EndAccept%2A> 保留中の接続が取得されるまでです。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 新しい返します <xref:System.Net.Sockets.Socket> リモート ホストとのデータの送受信に使用することできます。 返されるこれを使用することはできません <xref:System.Net.Sockets.Socket> 接続キューからその他の接続を受け入れるようにします。 ブロックを呼び出した後に元のスレッドが必要なかどうかは、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを使用して <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>します。 セット メソッドを呼び出す、 <xref:System.Threading.ManualResetEvent> 、元のスレッド実行を継続する場合は、コールバック メソッドにします。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、 <xref:System.IAsyncResult.CompletedSynchronously%2A> プロパティで返された <xref:System.IAsyncResult> ことを示すために設定されます、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に終了しました。  
  
 コールバック メソッドの記述の詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
 保留中の呼び出しをキャンセルする、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッド、閉じる、 <xref:System.Net.Sockets.Socket>です。  ときに、 <xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出して非同期操作が進行中をコールバックが提供されて、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが呼び出されます。  後続の呼び出しに、 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドをスローする <xref:System.ObjectDisposedException> 操作が取り消されたことを示すためにします。  
  
> [!NOTE]
>  使用を呼び出すことができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ <xref:System.Net.Sockets.Socket> リモート ホストのネットワーク アドレスとポート番号を識別するオブジェクト。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている <xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 <xref:System.Net.Sockets.Socket> メソッドは、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例は、ソケットを開き、非同期の接続を受け入れます。 この例では、ソケットは、最初の 10 バイトのデータを受け入れます。 受信したバイト数と、データは、コールバック デリゲートによって、コンソールに表示されます。 参照してください <xref:System.Net.Sockets.Socket.BeginReceive%2A> 、残りのデータを受信する方法の詳細についてです。  
  
 [!code-cpp[NCLSocketEnhancements\#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements\#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.InvalidOperationException">接続の受け入れ元のソケットがリッスンしていません。 呼び出す必要があります <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> と <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 呼び出す前に <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />します。  
  
 または  
  
 受け入れられたソケットにバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">承諾 <see cref="T:System.Net.Sockets.Socket" /> オブジェクトです。 この値は、 <see langword="null" />です。</param>
        <param name="receiveSize">受信するバイトの最大数。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定したソケットの受信接続の試行をそのまま使用する非同期操作を開始し、クライアント アプリケーションによって送信されたデータの最初のブロックを受信します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期を参照するオブジェクト <see cref="T:System.Net.Sockets.Socket" /> 作成します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向プロトコルを使用して、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを非同期的に受信接続を処理しようとします。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 このオーバー ロードで受け入れられたソケットを指定することができます、 `acceptSocket` パラメーター。 このパラメーターは場合 `null`, 、によって受け入れられたソケットが作成された、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。 初期の転送に同意するバイト数を指定する、 `receiveSize` パラメーター。  
  
 呼び出しの前に、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出す必要があります、 <xref:System.Net.Sockets.Socket.Listen%2A> をリッスンし、接続要求をキューのメソッドです。  
  
 実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任し、その名前を渡す、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。 そのためには、極端に言えば、リッスンを渡す必要があります <xref:System.Net.Sockets.Socket> オブジェクトを <xref:System.Net.Sockets.Socket.BeginAccept%2A> を通じて、 `state` パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 <xref:System.Net.Sockets.Socket> およびその他の必要な情報です。 このクラスのインスタンスを渡す、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドです。 アプリケーションを呼び出すと <xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、システムは通常、個別のスレッドを使用して、指定されたコールバック メソッドを実行しでブロック <xref:System.Net.Sockets.Socket.EndAccept%2A> 保留中の接続が取得されるまでです。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 新しい返します <xref:System.Net.Sockets.Socket> リモート ホストとのデータの送受信に使用できるオブジェクトします。 返されるこれを使用することはできません <xref:System.Net.Sockets.Socket> 接続キューからその他の接続を受け入れるようにします。 ブロックを呼び出した後に元のスレッドが必要なかどうかは、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを使用して <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>します。 セット メソッドを呼び出す、 <xref:System.Threading.ManualResetEvent> 、元のスレッド実行を継続する場合は、コールバック メソッドにします。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、 <xref:System.IAsyncResult.CompletedSynchronously%2A> プロパティで返された <xref:System.IAsyncResult> ことを示すために設定されます、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に終了しました。  
  
 コールバック メソッドの記述に関する詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
 保留中の呼び出しをキャンセルする、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッド、閉じる、 <xref:System.Net.Sockets.Socket>です。 ときに、 <xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出して非同期操作が進行中をコールバックが提供されて、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが呼び出されます。  後続の呼び出しに、 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドをスローする <xref:System.ObjectDisposedException> 操作が取り消されたことを示すためにします。  
  
> [!NOTE]
>  使用することができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ <xref:System.Net.Sockets.Socket> リモート ホストのネットワーク アドレスとポート番号を識別するオブジェクト。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている <xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 <xref:System.Net.Sockets.Socket> メソッドは、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例は、ソケットを開き、非同期の接続を受け入れます。 この例では、ソケットが最初の 10 バイトのデータを受け入れると `acceptSocket` パラメーターは、 `null`, 、どの力、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> 、受け入れられたソケットを作成する方法です。 受信したバイト数と、データは、コールバック デリゲートによって、コンソールに表示されます。 参照してください <xref:System.Net.Sockets.Socket.BeginReceive%2A> 、残りのデータを受信する方法の詳細についてです。  
  
 [!code-cpp[NCLSocketEnhancements\#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements\#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.InvalidOperationException">接続の受け入れ元のソケットがリッスンしていません。 呼び出す必要があります <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> と <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 呼び出す前に <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />します。  
  
 または  
  
 受け入れられたソケットにバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="end_point">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドへの接続への非同期要求を開始する、 `remoteEP` パラメーター。 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 既定のリモート ホストを確立します。 接続するか、既定のリモート ホストの設定を非同期的に個別の実行スレッド内でデータを送受信する機能を提供します。  
  
 実装するコールバック メソッドを作成する、 <xref:System.AsyncCallback> を委任し、その名前を渡す、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドです。 最低限に渡す必要があります、 <xref:System.Net.Sockets.Socket> に <xref:System.Net.Sockets.Socket.BeginConnect%2A> を通じて、 `state` パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 <xref:System.Net.Sockets.Socket>, 、およびその他の必要な情報です。 このクラスのインスタンスを渡す、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドです。 アプリケーションを呼び出すと <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してブロックされます <xref:System.Net.Sockets.Socket.EndConnect%2A> まで、 <xref:System.Net.Sockets.Socket> 正常に接続するか、例外をスローします。 ブロックを呼び出した後に元のスレッドが必要なかどうかは、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを使用して <xref:System.Threading.WaitHandle.WaitOne%2A>します。 セット メソッドを呼び出す、 <xref:System.Threading.ManualResetEvent> 、元のスレッド実行を継続する場合は、コールバック メソッドにします。 コールバック メソッドの記述の詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出す必要はありません <xref:System.Net.Sockets.Socket.BeginConnect%2A> データを送受信する前にします。 使用することができます <xref:System.Net.Sockets.Socket.BeginSendTo%2A> と <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> リモート ホストと通信します。 呼び出す場合 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、指定した既定以外のアドレスから到着する任意のデータグラムが破棄されます。 ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります <xref:System.Net.Sockets.Socket.SetSocketOption%2A> に `true`します。 できない場合は、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> をスローする <xref:System.Net.Sockets.SocketException>です。  
  
 接続指向のプロトコルを使用しているし、呼び出さないかどうか <xref:System.Net.Sockets.Socket.Bind%2A> 呼び出す前に <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号が呼び出されるまで、 <xref:System.Net.Sockets.Socket.BeginSend%2A> または <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。 リモート ホストの既定値を変更する場合を呼び出す、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 、目的のエンドポイントを使用してメソッドです。  
  
 保留中の呼び出しをキャンセルする、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッド、閉じる、 <xref:System.Net.Sockets.Socket>です。 ときに、 <xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出して非同期操作が進行中をコールバックが提供されて、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドが呼び出されます。  後続の呼び出しに、 <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドをスローする <xref:System.ObjectDisposedException> 操作が取り消されたことを示すためにします。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作が完了するまで終了しないスレッドで呼び出される必要があります。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている <xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 <xref:System.Net.Sockets.Socket> メソッドは、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket\_Async\_Send\_Receive\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> しています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="callback">To be added.</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <c>requestCallback</c> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストは <see cref="T:System.Net.IPAddress" /> とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期の <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出して操作を完了する必要があります、 <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドです。 通常、このメソッドはによって、 `requestCallback` を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、 <xref:System.Net.Sockets.Socket.Connect%2A> メソッドのオーバー ロードまたは <xref:System.Net.Sockets.Socket.EndConnect%2A>です。  
  
 保留中の呼び出しをキャンセルする、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッド、閉じる、 <xref:System.Net.Sockets.Socket>です。 ときに、 <xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出して非同期操作が進行中をコールバックが提供されて、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドが呼び出されます。  後続の呼び出しに、 <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドをスローする <xref:System.ObjectDisposedException> 操作が取り消されたことを示すためにします。  
  
 非同期プログラミング モデルの使用に関する詳細については、次を参照してください。 [Asynchronous Programming Overview](http://msdn.microsoft.com/ja-jp/41972034-92ed-450a-9664-ab93fcc6f1fb)  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作が完了するまで終了しないスレッドで呼び出される必要があります。 これは、基になるプロバイダーの制限です。 また、 <xref:System.Net.EndPoint> は異なっていなければならないために使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている <xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 <xref:System.Net.Sockets.Socket> メソッドは、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect\#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect\#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Sockets.Socket" /> はソケット ファミリに含まれません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が正しくありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> しています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストを指定する、少なくとも 1 つの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="callback">To be added.</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <c>requestCallback</c> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストは、<see cref="T:System.Net.IPAddress" /> 配列とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期の [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出して操作を完了する必要があります、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドです。 通常、このメソッドはによって、 `requestCallback` を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドのオーバー ロードします。  
  
 保留中の呼び出しをキャンセルする、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッド、閉じる、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket>です。 ときに、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出して非同期操作が進行中をコールバックが提供されて、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドが呼び出されます。  後続の呼び出しに、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドをスローする [BeginConnect メソッド \(IPAddress\<xref:System.ObjectDisposedException> 操作が取り消されたことを示すためにします。  
  
 非同期プログラミング モデルの使用に関する詳細については、次を参照してください。 [Asynchronous Programming Overview](http://msdn.microsoft.com/ja-jp/41972034-92ed-450a-9664-ab93fcc6f1fb)します。  
  
> [!NOTE]
>  表示された場合、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.SocketException>, を使用して、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作が完了するまで終了しないスレッドで呼び出される必要があります。 これは、基になるプロバイダーの制限です。 また、 [BeginConnect メソッド \(IPAddress\<xref:System.Net.EndPoint> は異なっていなければならないために使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket> メソッドは、特定の [BeginConnect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> を使用するソケットで有効です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> しています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="callback">To be added.</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <c>requestCallback</c> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストはホスト名とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期の <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出して操作を完了する必要があります、 <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドです。 通常、このメソッドはによって、 `requestCallback` を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、 <xref:System.Net.Sockets.Socket.Connect%2A> メソッドのオーバー ロードします。  
  
 保留中の呼び出しをキャンセルする、  <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッド、閉じる、 <xref:System.Net.Sockets.Socket>です。 ときに、 <xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出して非同期操作が進行中をコールバックが提供されて、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドが呼び出されます。  後続の呼び出しに、 <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドをスローする <xref:System.ObjectDisposedException> 操作が取り消されたことを示すためにします。  
  
 非同期プログラミング モデルの使用に関する詳細については、次を参照してください。 [Asynchronous Programming Overview](http://msdn.microsoft.com/ja-jp/41972034-92ed-450a-9664-ab93fcc6f1fb)  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作が完了するまで終了しないスレッドで呼び出される必要があります。 これは、基になるプロバイダーの制限です。 また、 <xref:System.Net.EndPoint> は異なっていなければならないために使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている <xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 <xref:System.Net.Sockets.Socket> メソッドは、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect\#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect\#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリ内のソケットに対して正しいものです。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が正しくありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> しています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" /> このソケットは、接続の終了後に再利用できる場合それ以外の場合、 <see langword="false" />です。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>リモート エンドポイントから切断する非同期要求を開始します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期操作を参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向のプロトコルを使用している場合は、呼び出す、 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> リモート エンドポイントから、切断の要求を送信する方法です。 場合 `reuseSocket` は `true`, 、ソケットを再利用することができます。  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> メソッドでは、別のスレッドを使用して、指定されたコールバック メソッドを呼び出します。<xref:System.Net.Sockets.Socket.EndDisconnect%2A> メソッドは、保留中の接続を解除するまでブロックが完了します。 コールバック メソッドの記述に関する詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException> 例外を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、非同期通信のソケットを作成し、リモート ホストにデータを送信します。 データが送信されると、 <xref:System.Net.Sockets.Socket.Shutdown%2A> を送信を停止し、receive アクティビティが呼び出されます。<xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 切断要求を開始すると呼びます。 要求が完了したら、 <xref:System.Net.Sockets.Socket.Connected%2A> プロパティは、ソケットが切断されているかどうかをテストするクエリを実行します。  
  
 [!code-cpp[Nclsocketenhancements\#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements\#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">オペレーティング システムが Windows 2000 以前のバージョン、およびこのメソッドには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">型の配列 <see cref="T:System.Byte" /> 、受信したデータの格納場所です。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を含むユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>非同期的に、接続グループからデータを受信する開始 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期の <xref:System.Net.Sockets.Socket.BeginReceive%2A> を呼び出して操作を完了する必要があります、 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドです。 通常、このメソッドはによって、 `callback` を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドのオーバー ロードします。  
  
 キャンセルする、保留中 <xref:System.Net.Sockets.Socket.BeginReceive%2A>, を呼び出す、 <xref:System.Net.Sockets.Socket.Close%2A> メソッドです。  
  
 非同期プログラミング モデルの使用に関する詳細については、次を参照してください。 [Asynchronous Programming Overview](http://msdn.microsoft.com/ja-jp/41972034-92ed-450a-9664-ab93fcc6f1fb)します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている <xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 <xref:System.Net.Sockets.Socket> メソッドは、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">型の配列 <see cref="T:System.Byte" /> 、受信したデータの格納場所です。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> ソケット エラーを格納するオブジェクト。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を含むユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>非同期的に、接続グループからデータを受信する開始 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期の <xref:System.Net.Sockets.Socket.BeginReceive%2A> を呼び出して操作を完了する必要があります、 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドです。 通常、このメソッドはによって、 `callback` を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドのオーバー ロードします。  
  
 キャンセルする、保留中 <xref:System.Net.Sockets.Socket.BeginReceive%2A>, を呼び出す、 <xref:System.Net.Sockets.Socket.Close%2A> メソッドです。  
  
 非同期プログラミング モデルの使用に関する詳細については、次を参照してください。 [Asynchronous Programming Overview](http://msdn.microsoft.com/ja-jp/41972034-92ed-450a-9664-ab93fcc6f1fb)します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている <xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 <xref:System.Net.Sockets.Socket> メソッドは、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 、受信したデータの格納場所です。</param>
        <param name="offset">内の 0 から始まる位置、 <c>buffer</c> 受信データを格納するパラメーターです。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を含むユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>非同期的に、接続グループからデータを受信する開始 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期の [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceive%2A> を呼び出して操作を完了する必要があります、 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドです。 通常、このメソッドはによって、 `callback` を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドのオーバー ロードします。  
  
 キャンセルする、保留中 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceive%2A>, を呼び出す、 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Close%2A> メソッドです。  
  
 非同期プログラミング モデルの使用に関する詳細については、次を参照してください。 [Asynchronous Programming Overview](http://msdn.microsoft.com/ja-jp/41972034-92ed-450a-9664-ab93fcc6f1fb)します。  
  
> [!NOTE]
>  表示された場合、 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドは、特定の [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例は、接続グループからデータを非同期的に受信する開始 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket\_Async\_Send\_Receive\#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket\_Async\_Send\_Receive\#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket\_Async\_Send\_Receive\#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さより大きい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" /> の値を差し引いて、 <paramref name="offset" /> パラメーター。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, valuetype System.Net.Sockets.SocketError error, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 、受信したデータの格納場所です。</param>
        <param name="offset">内の場所 <c>buffer</c> を受信したデータを格納します。</param>
        <param name="size">受信するバイト数。</param>
        <param name="flags">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を含むユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>非同期的に、接続グループからデータを受信する開始 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期の [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceive%2A> を呼び出して操作を完了する必要があります、 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドです。 通常、このメソッドはによって、 `callback` を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドのオーバー ロードします。  
  
 キャンセルする、保留中 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceive%2A>, を呼び出す、 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Close%2A> メソッドです。  
  
 非同期プログラミング モデルの使用に関する詳細については、次を参照してください。 [Asynchronous Programming Overview](http://msdn.microsoft.com/ja-jp/41972034-92ed-450a-9664-ab93fcc6f1fb)します。  
  
> [!NOTE]
>  表示された場合、 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドは、特定の [BeginReceive メソッド \(Byte\<xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さより大きい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" /> の値を差し引いて、 <paramref name="offset" /> パラメーター。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 、受信したデータの格納場所です。</param>
        <param name="offset">内の 0 から始まる位置、 <c>buffer</c> データを格納するパラメーターです。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socket_flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定されたネットワーク デバイスからデータを非同期的に受信を開始します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドが、リモート ホストからコネクションレスのデータグラムを非同期的に読み取りを開始します。 呼び出す、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドは、個別の実行スレッド内でデータを受信する機能を提供します。  
  
 実装するコールバック メソッドを作成する、 [BeginReceiveFrom メソッド \(Byte\<xref:System.AsyncCallback> を委任し、その名前を渡す、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドです。 極端に言えば、 `state` パラメーターが接続済みか、既定の必要があります [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> の通信に使用されています。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> およびその他の必要な情報です。 このクラスのインスタンスを渡す、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドです。 アプリケーションを呼び出すと [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, 、システムは指定されたコールバック メソッドを実行する別のスレッドを使用およびを [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> になるまで、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> データを読み取るか、例外をスローします。 ブロックを呼び出した後に元のスレッドが必要なかどうかは、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを使用して [BeginReceiveFrom メソッド \(Byte\<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>します。 元のスレッド実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述に関する詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
> [!NOTE]
>  呼び出しの前に [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, 、明示的にバインドする必要があります、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> を使用して、ローカル エンドポイントに、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> メソッド、または [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> をスロー、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。  
  
 このメソッドにデータを読み込みます、 `buffer` パラメーター、およびデータの送信元となるエンドポイントをホストし、リモート キャプチャします。 このエンドポイントを取得する方法についてを参照してください [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>します。 このメソッドは非同期的に不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。 このような場合は、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> はローカル ネットワーク バッファーに書き込まれる最初のキューに登録されるデータグラムを読み取ります。 受信したデータグラムがのサイズより大きいかどうか `buffer`, 、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドが入力 `buffer` は throw であり、可能なメッセージの多くで、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、超過データは失われます。 信頼性の高いプロトコルを使用するいるし、超過データは、サービス プロバイダーによって保持されるを呼び出して取得することができます、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> のに十分な大きさのバッファーを持つメソッドです。  
  
 リモート ホストのエンドポイントが常に返される、アプリケーションは明示的にバインドする必要があることを保証するために、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> を使用して、ローカル エンドポイントに、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> メソッドと、呼び出し、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを `optionLevel` パラメーターを設定する [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketOptionLevel.IP> または [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketOptionLevel.IPv6> 、必要に応じて、 `optionName` パラメーターを設定する [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketOptionName.PacketInformation>, 、および `optionValue` を呼び出す前にこのオプションを有効にするパラメーター、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドです。 それ以外の場合、可能であれば、受信側が呼び出される前に、送信者のデータグラムの数が送信する場合は、返されていないリモート ホストのエンドポイントの [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドです。  
  
 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> は、コネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、必要があります最初か、リモート ホスト接続を確立するを呼び出して、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> \/ [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して、受信接続要求を受け入れるか、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> または [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。 呼び出した場合、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> 確立するか、接続を受け入れる前にメソッドが表示されます、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドです。 このような場合は、のいずれかで、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドは無視されます、 `remoteEP` パラメーターのみから、接続されているデータや既定のリモート ホストを受信します。  
  
 接続指向のソケットと [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> できるだけ多くのデータを使用して指定されたバイト数を読み取り、 `size` パラメーター。  
  
 キャンセルする、保留中 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, を呼び出す、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Close%2A> メソッドです。  
  
> [!NOTE]
>  表示された場合、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドは、特定の [BeginReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例は、リモート ホストから非同期的にコネクションレスのデータグラムを受信します。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket\_Async\_Send\_Receive\#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さより大きい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" /> の値を差し引いて、 <paramref name="offset" /> パラメーター。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 、受信したデータの格納場所です。</param>
        <param name="offset">内の 0 から始まる位置、 <c>buffer</c> データを格納するパラメーターです。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> データのソースを表します。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定したデータのバイト数を指定して、データ バッファーの指定した場所に非同期的に受信開始 <see cref="T:System.Net.Sockets.SocketFlags" />, 、エンドポイントとパケット情報を保存して.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の読み取りを参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非同期の受信操作呼び出しで完了する必要があります、 [BeginReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> メソッドです。 通常、このメソッドはによって、 `asyncCallback` を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでにブロックするを使用して、 [BeginReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドです。  
  
 キャンセルする、保留中 [BeginReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, を呼び出す、 [BeginReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Close%2A> メソッドです。  
  
 非同期プログラミング モデルの使用に関する詳細については、次を参照してください。 [Asynchronous Programming Overview](http://msdn.microsoft.com/ja-jp/41972034-92ed-450a-9664-ab93fcc6f1fb)  
  
 このメソッドにデータを読み込みます、 `buffer` パラメーター、およびデータの送信元となるエンドポイントをホストし、リモート キャプチャだけでなく、受信したパケットに関する情報。 このエンドポイントを取得する方法についてを参照してください [BeginReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>します。 このメソッドは非同期的に不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
> [!NOTE]
>  表示された場合、 [BeginReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [BeginReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている [BeginReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 [BeginReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドは、特定の [BeginReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さより大きい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" /> の値を差し引いて、 <paramref name="offset" /> パラメーター。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">オペレーティング システムが Windows 2000 以前のバージョン、およびこのメソッドには、Windows XP が必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">型の配列 <see cref="T:System.Byte" /> を送信するデータが含まれています。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されたデータを非同期的に送信 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の送信を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドで確立されたリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>, 、<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、<xref:System.Net.Sockets.Socket.Accept%2A>, 、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。<xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出す必要はない場合、例外がスローされます <xref:System.Net.Sockets.Socket.Accept%2A>, 、<xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、<xref:System.Net.Sockets.Socket.Connect%2A>, 、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成する、 <xref:System.AsyncCallback> を委任し、その名前を渡す、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドです。 極端に言えば、 `state` パラメーターが接続済みか、既定の必要があります <xref:System.Net.Sockets.Socket> の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、 <xref:System.Net.Sockets.Socket> およびその他の必要な情報です。 このクラスのインスタンスを渡す、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 <xref:System.Net.Sockets.Socket.EndSend%2A> メソッドです。 アプリケーションを呼び出すと <xref:System.Net.Sockets.Socket.BeginSend%2A>, 、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してブロックは <xref:System.Net.Sockets.Socket.EndSend%2A> まで、 <xref:System.Net.Sockets.Socket> 要求されたバイト数を送信するか、例外をスローします。 ブロックを呼び出した後に元のスレッドが必要なかどうかは、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを使用して、 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> メソッドです。 元のスレッド実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
 接続指向のプロトコルでは、意図したものが <xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出すことが提供される、コネクションレスのプロトコルに対しても機能、 <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを既定のリモート ホストを確立します。 データを複数の異なるホストに送信するためのコネクションレスのプロトコルと計画を使用している場合を使用する <xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用できる <xref:System.Net.Sockets.Socket.BeginSendTo%2A> で既定のリモート ホストを確立した後でも <xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に既定のリモート ホストを変更することもできます。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 別の呼び出しを行うことによって <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず、 <xref:System.Net.Sockets.Socket.BeginSend%2A> をスロー、 <xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、 <xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketflags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化です。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている <xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 <xref:System.Net.Sockets.Socket> メソッドは、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">型の配列 <see cref="T:System.Byte" /> を送信するデータが含まれています。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> ソケット エラーを格納するオブジェクト。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されたデータを非同期的に送信 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の送信を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドで確立されたリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>, 、<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、<xref:System.Net.Sockets.Socket.Accept%2A>, 、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。<xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出す必要はない場合、例外がスローされます <xref:System.Net.Sockets.Socket.Accept%2A>, 、<xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、<xref:System.Net.Sockets.Socket.Connect%2A>, 、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成する、 <xref:System.AsyncCallback> を委任し、その名前を渡す、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドです。 極端に言えば、 `state` パラメーターが接続済みか、既定の必要があります <xref:System.Net.Sockets.Socket> の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、 <xref:System.Net.Sockets.Socket> およびその他の必要な情報です。 このクラスのインスタンスを渡す、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 <xref:System.Net.Sockets.Socket.EndSend%2A> メソッドです。 アプリケーションを呼び出すと <xref:System.Net.Sockets.Socket.BeginSend%2A>, 、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してブロックは <xref:System.Net.Sockets.Socket.EndSend%2A> まで、 <xref:System.Net.Sockets.Socket> 要求されたバイト数を送信するか、例外をスローします。 ブロックを呼び出した後に元のスレッドが必要なかどうかは、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを使用して、 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> メソッドです。 セット メソッドを呼び出す、 <xref:System.Threading.ManualResetEvent> 、元のスレッド実行を継続する場合は、コールバック メソッドにします。 コールバック メソッドの記述の詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
 接続指向のプロトコルでは、意図したものが <xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出すことが提供される、コネクションレスのプロトコルに対しても機能、 <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを既定のリモート ホストを確立します。 データを複数の異なるホストに送信するためのコネクションレスのプロトコルと計画を使用している場合を使用する <xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用できる <xref:System.Net.Sockets.Socket.BeginSendTo%2A> で既定のリモート ホストを確立した後でも <xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に既定のリモート ホストを変更することもできます。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 別の呼び出しを行うことによって <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず、 <xref:System.Net.Sockets.Socket.BeginSend%2A> をスロー、 <xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、 <xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketflags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化です。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている <xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 <xref:System.Net.Sockets.Socket> メソッドは、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> を送信するデータが含まれています。</param>
        <param name="offset">内の 0 から始まる位置、 <c>buffer</c> データ送信を開始する位置を示すパラメーターです。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されたデータを非同期的に送信 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の送信を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドで確立されたリモート ホストへの非同期送信操作を開始、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>, 、[BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、[BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A>, 、または [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。[BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出す必要はない場合、例外がスローされます [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A>, 、[BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、[BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>, 、または [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成する、 [BeginSend メソッド \(Byte\<xref:System.AsyncCallback> を委任し、その名前を渡す、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドです。 極端に言えば、 `state` パラメーターが接続済みか、既定の必要があります [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> およびその他の必要な情報です。 このクラスのインスタンスを渡す、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドです。 アプリケーションを呼び出すと [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A>, 、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してブロックは [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndSend%2A> まで、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> 要求されたバイト数を送信するか、例外をスローします。 ブロックを呼び出した後に元のスレッドが必要なかどうかは、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを使用して、 [BeginSend メソッド \(Byte\<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> メソッドです。 元のスレッド実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
 接続指向のプロトコルでは、意図したものが [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出すことが提供される、コネクションレスのプロトコルに対しても機能、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを既定のリモート ホストを確立します。 データを複数の異なるホストに送信するためのコネクションレスのプロトコルと計画を使用している場合を使用する [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用できる [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A> で既定のリモート ホストを確立した後でも [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に既定のリモート ホストを変更することもできます。 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> 別の呼び出しを行うことによって [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> をスロー、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketflags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
> [!NOTE]
>  表示された場合、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化です。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドは、特定の [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例では、リモート ホストへのデータを非同期的に送信を開始します。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket\_Async\_Send\_Receive\#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さよりも小さい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" /> の値を差し引いて、 <paramref name="offset" /> パラメーター。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> を送信するデータが含まれています。</param>
        <param name="offset">内の 0 から始まる位置、 <c>buffer</c> データ送信を開始する位置を示すパラメーターです。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> ソケット エラーを格納するオブジェクト。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されたデータを非同期的に送信 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の送信を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドで確立されたリモート ホストへの非同期送信操作を開始、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>, 、[BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、[BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A>, 、または [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。[BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出す必要はない場合、例外がスローされます [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A>, 、[BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、[BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>, 、または [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成する、 [BeginSend メソッド \(Byte\<xref:System.AsyncCallback> を委任し、その名前を渡す、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドです。 そのためには、極端に言えば、 `state` パラメーターが接続済みか、既定の必要があります [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> およびその他の必要な情報です。 このクラスのインスタンスを渡す、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドです。 アプリケーションを呼び出すと [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A>, 、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してブロックは [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndSend%2A> まで、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> 要求されたバイト数を送信するか、例外をスローします。 ブロックを呼び出した後に元のスレッドが必要なかどうかは、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを使用して、 [BeginSend メソッド \(Byte\<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> メソッドです。 元のスレッド実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
 接続指向のプロトコルでは、意図したものが [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出すことが提供される、コネクションレスのプロトコルに対しても機能、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを既定のリモート ホストを確立します。 データを複数の異なるホストに送信するためのコネクションレスのプロトコルと計画を使用している場合を使用する [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用できる [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A> で既定のリモート ホストを確立した後でも [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に既定のリモート ホストを変更することもできます。 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> 別の呼び出しを行うことによって [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> をスロー、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketflags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
> [!NOTE]
>  表示された場合、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化です。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドは、特定の [BeginSend メソッド \(Byte\<xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さよりも小さい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" /> の値を差し引いて、 <paramref name="offset" /> パラメーター。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">送信するファイルの名前とパスを表す文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>ファイル送信 <paramref name="fileName" /> に接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを使用して、 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> フラグ。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の送信を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードは、そのファイルを送信 `fileName` ソケットで接続されています。 場合 `fileName` はそれ、ローカル ディレクトリにファイルの名前だけで識別可能性があります。 それ以外の場合、完全パスとファイルの名前を指定する必要があります。 ワイルドカード \("..\\\\myfile.txt"\) と UNC 共有名 \("\\\\\\shared directory\\\\myfile.txt"\) がサポートされています。 ファイルが見つからない場合、例外 <xref:System.IO.FileNotFoundException> がスローされます。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API の関数が見つかります。 詳細については、 `TransmitFile` 関数とそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドで確立されたリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>,、<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、<xref:System.Net.Sockets.Socket.Accept%2A>, 、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。<xref:System.Net.Sockets.Socket.BeginSendFile%2A> 最初に呼び出す必要はない場合は例外をスロー <xref:System.Net.Sockets.Socket.Accept%2A>, 、<xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、<xref:System.Net.Sockets.Socket.Connect%2A>, 、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドでは、個別の実行スレッド内のファイルを送信することができます。  
  
 によって呼び出されるコールバック メソッドを作成する操作を完了する、 <xref:System.AsyncCallback> パラメーターを委任します。 極端に言えば、 `state` パラメーターを含める必要があります、 <xref:System.Net.Sockets.Socket> の通信に使用されているオブジェクトします。 コールバックは、詳細を必要とする場合は、クラスまたは構造体を作成することができます、 <xref:System.Net.Sockets.Socket> およびその他の必要な情報です。 このカスタム オブジェクトのインスタンスを渡す、 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 <xref:System.Net.Sockets.Socket.EndSendFile%2A> メソッドです。 アプリケーションを呼び出すと <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, 、システムは、別のスレッドを使用して、指定されたコールバック メソッドを実行しでブロック <xref:System.Net.Sockets.Socket.EndSendFile%2A> まで、 <xref:System.Net.Sockets.Socket> ファイル全体を送信するか、例外をスローします。 コールバック メソッドの記述の詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
 接続指向のプロトコルでは、意図したものが <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 最初に呼び出すことが提供される、コネクションレスのプロトコルに対しても機能、 <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを既定のリモート ホストを確立します。 コネクションレスのプロトコルでは、ファイルのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要があります。 データグラムが送信しない場合と <xref:System.Net.Sockets.Socket.BeginSendFile%2A> スロー、 <xref:System.Net.Sockets.SocketException> 例外です。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException> 例外を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている <xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 <xref:System.Net.Sockets.Socket> メソッドは、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例を作成し、非同期通信のソケットを接続します。 最初に、ファイル"text.txt"は、リモート ホストに非同期的に送信されます。 コールバック デリゲート呼び出し <xref:System.Net.Sockets.Socket.EndSendFile%2A> 転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements\#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements\#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルの名前とパスを表す文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">A <see cref="T:System.Byte" /> ファイルが送信される前に送信するデータを含む配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">A <see cref="T:System.Byte" /> ファイルが送信された後に送信されるデータを格納する配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags">ビットごとの組み合わせ <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> この操作が完了したときに呼び出されるデリゲート。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="state">この要求の状態情報を含むユーザー定義のオブジェクト。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary>接続された、ファイルとデータのバッファーを非同期的に送信 <see cref="T:System.Net.Sockets.Socket" /> オブジェクトです。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期操作を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードには、送信するファイルとビットごとの組み合わせの名前が必要です。 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.TransmitFileOptions> 値。`preBuffer` パラメーターには、ファイルの前に、データが含まれています。`postBuffer` ファイルを追跡するデータが含まれています。 場合 `fileName` はそれ、ローカル ディレクトリにファイルの名前だけで識別可能性があります。 それ以外の場合、完全パスとファイルの名前を指定する必要があります。 ワイルドカード \("..\\\\myfile.txt"\) と UNC 共有名 \("\\\\\\shared directory\\\\myfile.txt"\) がサポートされています。 ファイルが見つからない場合、例外 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.IO.FileNotFoundException> がスローされます。  
  
 `flags` パラメーターは、ファイルの転送に関する追加情報\] ウィンドウのソケットのサービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.TransmitFileOptions>します。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API の関数が見つかります。 詳細については、 `TransmitFile` 関数とそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドで確立されたリモート ホストへの非同期送信操作を開始、 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.Connect%2A>, 、[BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、[BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.Accept%2A>, 、または [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。[BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginSendFile%2A> 最初に呼び出す必要はない場合は例外をスロー [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.Accept%2A>, 、[BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、[BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.Connect%2A>, 、または [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドは、個別の実行スレッド内のファイルを送信する機能を提供します。  
  
 によって呼び出されるコールバック メソッドを作成する操作を完了する、 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.AsyncCallback> パラメーターを委任します。 極端に言えば、 `state` パラメーターを含める必要があります、 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket> の通信に使用されているオブジェクトします。 コールバックは、詳細を必要とする場合は、クラスまたは構造体を作成することができます、 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket> およびその他の必要な情報です。 このカスタム オブジェクトのインスタンスを渡す、[BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.EndSendFile%2A> メソッドです。 アプリケーションを呼び出すと [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginSendFile%2A>, 、システムは、別のスレッドを使用して、指定されたコールバック メソッドを実行しでブロック [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.EndSendFile%2A> まで、 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket> ファイル全体を送信するか、例外をスローします。 コールバック メソッドの記述の詳細については、次を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
 接続指向のプロトコルでは、意図したものが [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginSendFile%2A> 最初に呼び出すことが提供される、コネクションレスのプロトコルに対しても機能、 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを既定のリモート ホストを確立します。 コネクションレスのプロトコルを使用している場合は、ファイルのサイズが基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 データグラムが送信しない場合と [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.BeginSendFile%2A> スロー、 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.SocketException> 例外です。  
  
> [!NOTE]
>  表示された場合、 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.SocketException> 例外を使用して、 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket> メソッドは、特定の [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例を作成し、非同期通信のソケットを接続し、リモート ホストに、ファイルの"text.txt"を非同期的に送信を開始します。 この例では、 `preBuffer` と `postBuffer` ファイルとその既定値を送信するデータが作成された [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.TransmitFileOptions> 値を使用します。 コールバック デリゲート呼び出し [BeginSendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.EndSendFile%2A> 転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements\#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements\#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.NotSupportedException">オペレーティング システムが Windows NT 以降です。  
  
 または  
  
 ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> を送信するデータが含まれています。</param>
        <param name="offset">内の 0 から始まる位置 <c>buffer</c> データ送信を開始する位置を示す。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socket_flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 非同期の送信を参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドで指定されたリモート ホストへの非同期送信操作を開始、 `remoteEP` パラメーター。 呼び出す、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。 コネクションレス プロトコルは、意図したものが [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A> コネクションレス型との接続指向の両方のプロトコルで動作します。  
  
 実装するコールバック メソッドを作成する、 [BeginSendTo メソッド \(Byte\<xref:System.AsyncCallback> を委任し、その名前を渡す、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドです。 極端に言えば、 `state` パラメーターが接続済みか、既定の必要があります [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket> の通信に使用されています。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket>, 、およびその他の必要な情報です。 このクラスのインスタンスを渡す、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドによって、 `state` パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndSendTo%2A> メソッドです。 アプリケーションを呼び出すと [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A>, 、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してブロックは [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndSendTo%2A> まで、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket> 要求されたバイト数を送信するか、例外をスローします。 ブロックを呼び出した後に元のスレッドが必要なかどうかは、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドを使用して、 [BeginSendTo メソッド \(Byte\<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> メソッドです。 元のスレッド実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述に関する追加情報を参照してください。 [&#91;\<topic:\/\/cpconcallbacksample\>&#93;](http://msdn.microsoft.com/ja-jp/6ddd7866-9804-4571-84de-83f5cc017a5a)します。  
  
 接続指向のプロトコルを使用している場合は、最初に呼び出す必要があります、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>, 、[BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、[BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A>, 、または [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッド、または [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A> をスロー、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。[BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSendTo%2A> 無視、 `remoteEP` パラメーターと送信のデータを [BeginSendTo メソッド \(Byte\<xref:System.Net.EndPoint> で定められている、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>, 、[BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、[BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A>, 、または [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出す前に [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>します。 呼び出そうとする場合に実行しなければ、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドです。 呼び出す場合、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出す前に [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>, 、 `remoteEP` パラメーターは、操作のみを送信するために、指定された既定のリモート ホストにオーバーライドされます。 また必要はありませんを呼び出して、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> メソッドです。 この場合は、基になるサービス プロバイダーは最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。 基になるサービス プロバイダーは、無料のポートを選択する場合は、ゼロのポート番号を使用します。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 後プロパティ、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndSendTo%2A> メソッドが正常に完了します。  
  
 最初に呼び出す必要がありますが、ブロードキャスト アドレスにデータを送信する場合、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドと、ソケット オプションを [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=fullName>します。 のバッファーのサイズが基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndSendTo%2A> をスロー、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketflags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
> [!NOTE]
>  表示された場合、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  非同期の実行コンテキスト \(セキュリティ コンテキスト、権限を借用したユーザーおよび呼び出し元のコンテキスト\) がキャッシュされている [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドです。 特定のコンテキストの最初の使用後に \(特定の非同期 [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket> メソッドは、特定の [BeginSendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック\)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## 例  
 次のコード例は、指定されたリモート ホストにデータを非同期的に送信します。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket\_Async\_Send\_Receive\#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さより大きい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" /> の値を差し引いて、 <paramref name="offset" /> パラメーター。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">ローカル <see cref="T:System.Net.EndPoint" /> に関連付ける、 <see cref="T:System.Net.Sockets.Socket" />です。</param>
        <summary>関連付けます、 <see cref="T:System.Net.Sockets.Socket" /> 、ローカル エンドポイントを使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Net.Sockets.Socket.Bind%2A> メソッドの特定のローカル エンドポイントを使用する必要がある場合。 呼び出す必要があります <xref:System.Net.Sockets.Socket.Bind%2A> できますを呼び出す前に、 <xref:System.Net.Sockets.Socket.Listen%2A> メソッドです。 呼び出す必要はありません <xref:System.Net.Sockets.Socket.Bind%2A> 使用する前に、 <xref:System.Net.Sockets.Socket.Connect%2A> メソッド、特定のローカル エンドポイントを使用する必要があります。 使用することができます、 <xref:System.Net.Sockets.Socket.Bind%2A> コネクションレス型との接続指向の両方のプロトコルのメソッドです。  
  
 呼び出しの前に <xref:System.Net.Sockets.Socket.Bind%2A>, 、ローカルを作成する必要があります <xref:System.Net.IPEndPoint> データをやり取りするからです。 ローカル アドレスが割り当てられているを限定しない場合は、作成、 <xref:System.Net.IPEndPoint> を使用して <xref:System.Net.IPAddress.Any?displayProperty=fullName> アドレス パラメータと基になるサービス プロバイダーは、最も適切なネットワーク アドレスを割り当てます。 これにより、複数のネットワーク インターフェイスがある場合に、アプリケーションを単純化のに役立ちます。 使用されているローカル ポートを限定しない場合は、作成、 <xref:System.Net.IPEndPoint> 0 ポート番号を使用しています。 この場合、サービス プロバイダーは、1024年 ~ 5000 で、使用可能なポート番号を割り当てます。  
  
 呼び出すことによってどのようなローカル ネットワーク アドレスとポート番号が割り当てられてを検出するには、上記の方法を使用する場合、 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>です。 接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> への呼び出しを行った後、までローカルで割り当てられているネットワーク アドレスを返しませんが、 <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドです。 コネクションレスのプロトコルを使用している場合はありませんこの情報にアクセスする送信を完了したかが表示されるまでです。  
  
 UDP ソケットで受信したパケットのインターフェイスの情報を受け取りたい場合、 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドに設定するソケット オプションで明示的に呼び出す必要があります <xref:System.Net.Sockets.SocketOptionName.PacketInformation> 呼び出し直後後、 <xref:System.Net.Sockets.Socket.Bind%2A> メソッドです。  
  
> [!NOTE]
>  マルチキャスト データグラムを受信する場合は、呼び出す必要があります、 <xref:System.Net.Sockets.Socket.Bind%2A> マルチキャストのポート番号を持つメソッドです。  
  
> [!NOTE]
>  呼び出す必要があります、 <xref:System.Net.Sockets.Socket.Bind%2A> メソッド コネクションレスのデータグラムを使用して受信する場合、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException> を呼び出すときに、 <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例のバインド、 <xref:System.Net.Sockets.Socket> 指定したローカル エンドポイントを使用します。  
  
 [!code-cpp[Classic Socket.Bind Example\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the host defined by **parameterReference tag is not supported!!!!**  
. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を示す値かどうか、 <see cref="T:System.Net.Sockets.Socket" /> ブロック モードにします。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Net.Sockets.Socket" /> がブロックされます。 それ以外の場合、 <see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを示すかどうか、 <xref:System.Net.Sockets.Socket> ブロック モードにします。  
  
 ブロッキング モードでは、すると、メソッドがすぐに完了しない場合、アプリケーションは、要求された操作が完了するまで実行をブロックします。 要求された操作が完了しない場合でもを続行して変更するには、実行する場合、 <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false`します。<xref:System.Net.Sockets.Socket.Blocking%2A> プロパティが非同期メソッドに対して影響を与えません。 使用している場合を送信し、データを非同期的に受信の実行をブロックする、 <xref:System.Threading.ManualResetEvent> クラスです。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> のいずれかを呼び出すことによってリモート ホストへの接続を要求するために使用するオブジェクト、 <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドです。</param>
        <summary>リモート ホスト接続への非同期要求をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> メソッドは、リモート ホスト接続への非同期要求をキャンセルします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> パラメーターを null にすることはできませんと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> null にすることはできません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>閉じる、 <see cref="T:System.Net.Sockets.Socket" /> 接続とリソースを関連付けられているすべて解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.Close%2A> メソッドは、リモート ホスト接続を閉じると、リリースのすべてのマネージしアンマネージ リソースに関連付けられている、 <xref:System.Net.Sockets.Socket>です。 終了時に、 <xref:System.Net.Sockets.Socket.Connected%2A> にプロパティが設定されている `false`します。  
  
 接続指向のプロトコルは勧めを呼び出すこと <xref:System.Net.Sockets.Socket.Shutdown%2A> 呼び出す前に、 <xref:System.Net.Sockets.Socket.Close%2A> メソッドです。 これにより、すべてのデータが送信されが閉じられるまで、接続されたソケットで受信したことです。  
  
 呼び出す必要がある場合 <xref:System.Net.Sockets.Socket.Close%2A> 最初に呼び出さず <xref:System.Net.Sockets.Socket.Shutdown%2A>, 、キュー データを設定して送信される出力方向の送信のことを確認できる、 <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> オプションを `false` 0 以外のタイムアウト間隔を指定するとします。<xref:System.Net.Sockets.Socket.Close%2A> このデータが送信されるまで、または指定したタイムアウトの期限が切れるまで、ブロックされます。 設定した場合 <xref:System.Net.Sockets.SocketOptionName.DontLinger> に `false` 0 のタイムアウト間隔を指定して <xref:System.Net.Sockets.Socket.Close%2A> の接続を解放し、送信キューに置かれたデータを自動的に破棄します。  
  
> [!NOTE]
>  設定する、 <xref:System.Net.Sockets.SocketOptionName.DontLinger> ソケット オプションに `false`, 、作成、 <xref:System.Net.Sockets.LingerOption>, に有効なプロパティを設定 `true`, 、設定と、 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> プロパティを目的のタイムアウト期間。 これを使用して <xref:System.Net.Sockets.LingerOption> と共に、 <xref:System.Net.Sockets.SocketOptionName.DontLinger> ソケット オプションを呼び出して、 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例が閉じ、 <xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Classic Socket.Close Example\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">最大 <c>timeout</c> 秒まで待ってから残りのデータを送信し、ソケットを閉じます。</param>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、すべての関連付けられているリソースを指定したタイムアウトで解放して、キューに置かれたデータの送信を許可します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>. Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to **languageKeyword tag is not supported!!!!**  
.  
  
 For connection\-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>. This ensures that all data is sent and received on the connected socket before it is closed.  
  
 If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to **languageKeyword tag is not supported!!!!**  
 and specifying a non\-zero time\-out interval. <xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time\-out expires. If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to **languageKeyword tag is not supported!!!!**  
 and specify a zero time\-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.  
  
> [!NOTE]
>  To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to **languageKeyword tag is not supported!!!!**  
> , create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to **languageKeyword tag is not supported!!!!**  
> , and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time\-out period. Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.  
  
> [!NOTE]
>  This member outputs trace information when you enable network tracing in your application. For more information, see [&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## 例  
 The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> リモート デバイスを表します。</param>
        <summary>リモート ホストへの接続を確立します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 TCP などの接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Connect%2A> メソッドは同期的に間のネットワーク接続を確立 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.Connect%2A> 既定のリモート ホストを確立します。 呼び出した後 <xref:System.Net.Sockets.Socket.Connect%2A>, のリモート デバイスにデータを送信することができます、 <xref:System.Net.Sockets.Socket.Send%2A> メソッド、またはリモート デバイスからデータを受信、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出す必要はありません <xref:System.Net.Sockets.Socket.Connect%2A> データを送受信する前にします。 使用する <xref:System.Net.Sockets.Socket.SendTo%2A> と <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> リモート ホストと同期通信します。 呼び出す場合 <xref:System.Net.Sockets.Socket.Connect%2A>, 、指定した既定以外のアドレスから到着するデータグラムは破棄されます。 ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります、 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドと、ソケット オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=fullName>, 、または <xref:System.Net.Sockets.Socket.Connect%2A> をスローする <xref:System.Net.Sockets.SocketException>です。 表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 具体的に設定していない場合、メソッドはブロック、 <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` 呼び出しの前に <xref:System.Net.Sockets.Socket.Connect%2A>します。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.Connect%2A> をスロー、 <xref:System.Net.Sockets.SocketException> 接続するために時間が必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用する <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーがときに返される場合は <xref:System.Net.Sockets.Socket>, 、まだ完了していませんが正常にします。 使用して、 <xref:System.Net.Sockets.Socket.Poll%2A> タイミングを決定するメソッド、 <xref:System.Net.Sockets.Socket> が終了した接続します。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか <xref:System.Net.Sockets.Socket.Bind%2A> 呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A>, 、基になるサービス プロバイダーがローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまで。 リモート ホストの既定値を変更する場合は、呼び出す <xref:System.Net.Sockets.Socket.Connect%2A> 、目的のエンドポイントを使用しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかの <xref:System.Net.Sockets.Socket.BeginConnect%2A> 再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[Classic Socket.Connect Example\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> しています。</exception>
        <permission cref="T:System.Net.SocketPermission">for connecting to the remote host. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの IP アドレス。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスとポート番号で指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 TCP などの接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Connect%2A> メソッドは同期的に間のネットワーク接続を確立 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.Connect%2A> 既定のリモート ホストを確立します。 呼び出した後 <xref:System.Net.Sockets.Socket.Connect%2A> のリモート デバイスにデータを送信することができます、 <xref:System.Net.Sockets.Socket.Send%2A> メソッド、またはリモート デバイスからデータを受信、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出す必要はありません <xref:System.Net.Sockets.Socket.Connect%2A> データを送受信する前にします。 使用する <xref:System.Net.Sockets.Socket.SendTo%2A> と <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> リモート ホストと同期通信します。 呼び出す場合 <xref:System.Net.Sockets.Socket.Connect%2A> 指定した既定以外のアドレスから到着する任意のデータグラムが破棄されます。 ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります、 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドと、ソケット オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=fullName>, 、または <xref:System.Net.Sockets.Socket.Connect%2A> をスローする <xref:System.Net.Sockets.SocketException>です。 表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 具体的に設定していない場合、メソッドはブロック、 <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` 呼び出しの前に <xref:System.Net.Sockets.Socket.Connect%2A>します。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.Connect%2A> をスロー、 <xref:System.Net.Sockets.SocketException> 接続するために時間が必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用する <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーがときに返される場合は <xref:System.Net.Sockets.Socket>, 、まだ完了していませんが正常にします。 使用して、 <xref:System.Net.Sockets.Socket.Poll%2A> タイミングを決定するメソッド、 <xref:System.Net.Sockets.Socket> が終了した接続します。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか <xref:System.Net.Sockets.Socket.Bind%2A> 呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A>, 、基になるサービス プロバイダーがローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまで。 リモート ホストの既定値を変更する場合は、呼び出す <xref:System.Net.Sockets.Socket.Connect%2A> 、目的のエンドポイントを使用しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかの <xref:System.Net.Sockets.Socket.BeginConnect%2A> 再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect\#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリ内のソケットに対して正しいものです。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストの IP アドレスです。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスの配列とポート番号で指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドへの呼び出しの直後に通常使用 [Connect メソッド \(IPAddress\<xref:System.Net.Dns.GetHostAddresses%2A>, 、1 つのホストの複数の IP アドレスを返すことができます。 TCP などの接続指向のプロトコルを使用している場合、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドは同期的に間のネットワーク接続を確立 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A> 既定のリモート ホストを確立します。 呼び出した後 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A> のリモート デバイスにデータを送信することができます、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Send%2A> メソッド、またはリモート デバイスからデータを受信、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出す必要はありません [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A> データを送受信する前にします。 使用する [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.SendTo%2A> と [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> リモート ホストと同期通信します。 呼び出す場合 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A> 指定した既定以外のアドレスから到着する任意のデータグラムが破棄されます。 ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドと、ソケット オプションを [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=fullName>, 、または [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A> をスローする [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.SocketException>です。 表示された場合、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.SocketException>, を使用して、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A> 具体的に設定していない場合、メソッドはブロック、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` 呼び出しの前に [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A>します。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A> をスロー、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.SocketException> 接続するために時間が必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用する [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーがときに返される場合は [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket>, 、まだ完了していませんが正常にします。 使用して、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Poll%2A> タイミングを決定するメソッド、 [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket> が終了した接続します。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Bind%2A> 呼び出す前に [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A>, 、基になるサービス プロバイダーがローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまで。 リモート ホストの既定値を変更する場合は、呼び出す [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.Connect%2A> 、目的のエンドポイントを使用しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかの [Connect メソッド \(IPAddress\<xref:System.Net.Sockets.Socket.BeginConnect%2A> 再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect\#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect\#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリ内のソケットに対して正しいものです。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストはホスト名とポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 TCP などの接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Connect%2A> メソッドは同期的に間のネットワーク接続を確立 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定したリモート ホストします。 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.Connect%2A> 既定のリモート ホストを確立します。 呼び出した後 <xref:System.Net.Sockets.Socket.Connect%2A> のリモート デバイスにデータを送信することができます、 <xref:System.Net.Sockets.Socket.Send%2A> メソッド、またはリモート デバイスからデータを受信、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出す必要はありません <xref:System.Net.Sockets.Socket.Connect%2A> データを送受信する前にします。 使用する <xref:System.Net.Sockets.Socket.SendTo%2A> と <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> リモート ホストと同期通信します。 呼び出す場合 <xref:System.Net.Sockets.Socket.Connect%2A> 、データグラム、指定された既定以外のアドレスから到着したが破棄されます。 ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります、 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドと、ソケット オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=fullName>, 、または <xref:System.Net.Sockets.Socket.Connect%2A> をスローする <xref:System.Net.Sockets.SocketException>です。 表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 具体的に設定していない場合、メソッドはブロック、 <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` 呼び出しの前に <xref:System.Net.Sockets.Socket.Connect%2A>します。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.Connect%2A> をスロー、 <xref:System.Net.Sockets.SocketException> 接続するために時間が必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用する <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 、特定のエラー コードを取得します。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーがときに返される場合は <xref:System.Net.Sockets.Socket>, 、まだ完了していませんが正常にします。 使用して、 <xref:System.Net.Sockets.Socket.Poll%2A> タイミングを決定するメソッド、 <xref:System.Net.Sockets.Socket> が終了した接続します。  
  
 IPv6 が有効になっている場合、 <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> メソッドが呼び出され、IPv6 の両方に解決されるホストに接続し、IPv4 アドレス、IPv6 のアドレスへの接続を IPv4 アドレスの前に最初の試行します。 これには、ホストが IPv6 アドレスでリッスンしていない場合は、接続を確立するために時間が遅延の影響があります。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか <xref:System.Net.Sockets.Socket.Bind%2A> 呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A>, 、基になるサービス プロバイダーがローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまで。 リモート ホストの既定値を変更する場合は、呼び出す <xref:System.Net.Sockets.Socket.Connect%2A> 、目的のエンドポイントを使用しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかの <xref:System.Net.Sockets.Socket.BeginConnect%2A> 再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect\#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect\#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリ内のソケットに対して正しいものです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>リモート ホストに接続するための非同期要求を開始します。</summary>
        <returns>返します。 <see langword="true" /> I\/O 操作が保留中の場合。<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターが操作の完了時に発生します。  
  
 返します。 <see langword="false" /> 場合は、I\/O 操作が同期的に完了します。 ここで、 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターは発生しません、 <paramref name="e" /> 操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドは、リモート ホストに接続するための非同期要求を開始します。 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 既定のリモート ホストを確立します。  
  
 完了の通知を受信する、実装 EventHandler \< SocketAsyncEventArgs \> は委任し、アタッチするためのコールバックは、コールバック メソッドを作成する必要があります、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> イベントです。  
  
 呼び出し元を設定する必要があります、 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> プロパティを <xref:System.Net.IPEndPoint> リモート ホストに接続するのです。  
  
 呼び出し元の設定、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> プロパティを呼び出す前に必要なユーザーの状態オブジェクト、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出す必要はありません <xref:System.Net.Sockets.Socket.ConnectAsync%2A> データを送受信する前にします。 使用することができます <xref:System.Net.Sockets.Socket.SendToAsync%2A> と <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> リモート ホストと通信します。 呼び出す場合 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 、指定した既定以外のアドレスから到着する任意のデータグラムが破棄されます。 リモート ホストの既定値を変更する場合を呼び出す、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 、目的のエンドポイントを使用してメソッドです。  
  
 ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります <xref:System.Net.Sockets.Socket.SetSocketOption%2A> に `true`します。 処理を行わない場合、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドをスローする <xref:System.Net.Sockets.SocketException>です。  
  
 次のプロパティおよびイベントに、 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> オブジェクトが必要。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  
  
 必要に応じて、バッファー提供することが後に、ソケットにアトミックに送信されます、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドが成功しました。 ここで、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> プロパティを送信するデータを含むバッファーに設定する必要があり、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> プロパティは、バッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向のプロトコルを使用しているし、呼び出さないかどうか <xref:System.Net.Sockets.Socket.Bind%2A> 呼び出す前に <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。  
  
 コネクションレスのプロトコルを使用しているサービス プロバイダーを割り当てませんがローカル ネットワークの IP アドレスとポート番号が呼び出されるまで、 <xref:System.Net.Sockets.Socket.SendAsync%2A> または <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドです。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドでのスロー <xref:System.NotSupportedException> 場合のアドレス ファミリ、 <xref:System.Net.Sockets.Socket> と <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> 同じアドレス ファミリではありません。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException> このメソッドを呼び出すときに使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 複数のバッファーを指定する場合、この例外が発生した、 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null でないです。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> パラメーターを null にすることはできませんと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> null にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は進行状況を使用してリッスンまたはソケット操作が既に、 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> で指定されたオブジェクト、 <paramref name="e" /> パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降がこのメソッドに必要です。 場合にもこの例外が発生したローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 同じアドレス ファミリではありません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</param>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>リモート ホストに接続するための非同期要求を開始します。</summary>
        <returns>返します。 <see langword="true" /> I\/O 操作が保留中の場合。<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターが操作の完了時に発生します。  
  
 返します。 <see langword="false" /> 場合は、I\/O 操作が同期的に完了します。 ここで、 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターは発生しません、 <paramref name="e" /> 操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向のプロトコルを使用している場合、M:System.Net.Sockets.Socket.ConnectAsync\(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs\) メソッドは、リモート ホストに接続するための非同期要求を開始します。 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> で指定された既定のリモート ホストの確立、 `socketType` と `protocolType` パラメーター。  
  
 完了の通知を受信する、実装 EventHandler \< SocketAsyncEventArgs \> は委任し、アタッチするためのコールバックは、コールバック メソッドを作成する必要があります、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> イベントです。  
  
 呼び出し元を設定する必要があります、 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> プロパティを <xref:System.Net.IPEndPoint> リモート ホストに接続するのです。  
  
 呼び出し元の設定、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> プロパティを呼び出す前に必要なユーザーの状態オブジェクト、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出す必要はありません <xref:System.Net.Sockets.Socket.ConnectAsync%2A> データを送受信する前にします。 使用することができます <xref:System.Net.Sockets.Socket.SendToAsync%2A> と <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> リモート ホストと通信します。 呼び出す場合 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 、指定した既定以外のアドレスから到着するデータグラムは破棄されます。 リモート ホストの既定値を変更する場合を呼び出す、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> 、目的のエンドポイントを使用してメソッドです。  
  
 ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります <xref:System.Net.Sockets.Socket.SetSocketOption%2A> に `true`します。 処理を行わない場合、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドをスローする <xref:System.Net.Sockets.SocketException>です。  
  
 次のプロパティおよびイベントに、 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> オブジェクトが必要。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  
  
 必要に応じて、バッファー提供することが後に、ソケットにアトミックに送信されます、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドが成功しました。 ここで、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> プロパティを送信するデータを含むバッファーに設定する必要があり、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> プロパティは、バッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向のプロトコルを使用しているし、呼び出さないかどうか <xref:System.Net.Sockets.Socket.Bind%2A> 呼び出す前に <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。  
  
 コネクションレスのプロトコルを使用しているサービス プロバイダーを割り当てませんがローカル ネットワークの IP アドレスとポート番号が呼び出されるまで、 <xref:System.Net.Sockets.Socket.SendAsync%2A> または <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドです。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドでのスロー <xref:System.NotSupportedException> 場合のアドレス ファミリ、 <xref:System.Net.Sockets.Socket> と <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> 同じアドレス ファミリではありません。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException> このメソッドを呼び出すときに使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 複数のバッファーを指定する場合、この例外が発生した、 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null でないです。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> パラメーターを null にすることはできませんと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> null にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は進行状況を使用してリッスンまたはソケット操作が既に、 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> で指定されたオブジェクト、 <paramref name="e" /> パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降がこのメソッドに必要です。 場合にもこの例外が発生したローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 同じアドレス ファミリではありません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Net.Sockets.Socket" /> 最後の時点でのリモート ホストに接続されている <see cref="Overload:System.Net.Sockets.Socket.Send" /> または <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 操作します。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Net.Sockets.Socket" /> が最新の操作の時点でのリモート リソースに接続されているそれ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `Connected` プロパティの接続状態の取得、 <xref:System.Net.Sockets.Socket> 最後の I\/O 操作の時点でします。 返す場合 `false`, 、 <xref:System.Net.Sockets.Socket> が未接続か、または接続されていません。  
  
 値、 <xref:System.Net.Sockets.Socket.Connected%2A> プロパティには、最新の操作の時点で接続の状態が反映されます。 接続の現在の状態を確認する必要がある場合は、非ブロッキングを持つ 0 バイトの Send 呼び出しを作成します。 呼び出しが正常に終了または WAEWOULDBLOCK エラー コード \(10035\) をスロー、ソケットが接続されているまだ;それ以外の場合、ソケットが接続していません。  
  
 呼び出す場合 <xref:System.Net.Sockets.Socket.Connect%2A> ユーザー データグラム プロトコル \(UDP\) のソケットに対して、 <xref:System.Net.Sockets.Socket.Connected%2A> プロパティは常に返します `true`。 ただし、この操作には、UDP のコネクションレス性質は変わりません。  
  
   
  
## 例  
 次のコード例は、チェックをリモート エンドポイントに接続する、 <xref:System.Net.Sockets.Socket.Connected%2A> プロパティとの接続の現在の状態をチェックします。  
  
 [!code-cpp[Classic Socket.Connect Example\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" /> このソケットは、後に再利用できる場合、現在の接続は閉じられます。それ以外の場合、 <see langword="false" />です。</param>
        <summary>ソケット接続を閉じます、ソケットの再利用できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向のプロトコルを使用している場合は、ソケットを閉じるにこのメソッドを使用できます。 接続やセットは、このメソッドが、 <xref:System.Net.Sockets.Socket.Connected%2A> プロパティを `false`します。 ただし場合、 `reuseSocket` は `true`, 、ソケットを再利用することができます。  
  
 すべてのデータが送信され、ソケットが閉じられる前に受信したことを確認を呼び出す必要があります <xref:System.Net.Sockets.Socket.Shutdown%2A> 呼び出す前に、 <xref:System.Net.Sockets.Socket.Disconnect%2A> メソッドです。  
  
 呼び出す必要がある場合 <xref:System.Net.Sockets.Socket.Disconnect%2A> 最初に呼び出さず <xref:System.Net.Sockets.Socket.Shutdown%2A>, 、設定することができます、 <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> オプションを `false` キュー データを出力方向の送信が送信されるを確認する 0 以外のタイムアウト間隔を指定します。<xref:System.Net.Sockets.Socket.Disconnect%2A> データが送信されるまで、または指定されたタイムアウトが経過するまでブロックします。 設定した場合 <xref:System.Net.Sockets.SocketOptionName.DontLinger> に `false` 0 のタイムアウト間隔を指定して <xref:System.Net.Sockets.Socket.Close%2A> の接続を解放し、送信キューに置かれたデータを自動的に破棄します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、同期通信のソケットを作成し、リモート ホストにデータを送信します。 順に呼び出して <xref:System.Net.Sockets.Socket.Shutdown%2A>, を送信を停止し、receive アクティビティ、および <xref:System.Net.Sockets.Socket.Disconnect%2A>, 、ソケット接続を閉じる。  
  
 [!code-cpp[Nclsocketenhancements\#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements\#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 2000 またはそれ以前、または、例外がスローされます。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>リモート エンドポイントから切断する非同期要求を開始します。</summary>
        <returns>返します。 <see langword="true" /> I\/O 操作が保留中の場合。<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターが操作の完了時に発生します。  
  
 返します。 <see langword="false" /> 場合は、I\/O 操作が同期的に完了します。 ここで、 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターは発生しません、 <paramref name="e" /> 操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向のプロトコルを使用する場合の呼び出し、 <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> メソッドがリモート エンドポイントからの接続が切断を要求します。 設定した場合 <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=fullName> に `true` で、 `e` パラメーター、ソケットを再利用できます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> パラメーターを null にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> で指定されたオブジェクト、 <paramref name="e" /> パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降がこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Call **languageKeyword tag is not supported!!!!**  
 when you are finished using the <xref:System.Net.Sockets.Socket>. The **languageKeyword tag is not supported!!!!**  
 method leaves the <xref:System.Net.Sockets.Socket> in an unusable state. After calling **languageKeyword tag is not supported!!!!**  
, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.  
  
 For more information, see [Cleaning Up Unmanaged Resources](http://msdn.microsoft.com/ja-jp/a17b0066-71c2-4ba4-9822-8e19332fc213) and [Implementing a Dispose Method](http://msdn.microsoft.com/ja-jp/eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9).  
  
> [!NOTE]
>  Always call **languageKeyword tag is not supported!!!!**  
>  before you release your last reference to the <xref:System.Net.Sockets.Socket>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's **languageKeyword tag is not supported!!!!**  
>  method.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> が使用しているアンマネージ リソースを解放します。オプションでマネージ リソースも破棄します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is called by the public **languageKeyword tag is not supported!!!!**  
 method and the <xref:System.Object.Finalize%2A> method. **languageKeyword tag is not supported!!!!**  
 invokes the protected **languageKeyword tag is not supported!!!!**  
 method with the **parameterReference tag is not supported!!!!**  
 parameter set to **languageKeyword tag is not supported!!!!**  
. <xref:System.Object.Finalize%2A> invokes **languageKeyword tag is not supported!!!!**  
 with **parameterReference tag is not supported!!!!**  
 set to **languageKeyword tag is not supported!!!!**  
.  
  
 When the **parameterReference tag is not supported!!!!**  
 parameter is **languageKeyword tag is not supported!!!!**  
, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references. This method invokes the **languageKeyword tag is not supported!!!!**  
 method of each referenced object.  
  
> [!NOTE]
>  This member outputs trace information when you enable network tracing in your application. For more information, see [&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> can be called multiple times by other objects. When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />. For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 <see cref="T:System.Boolean" /> 値を指定するかどうか、 <see cref="T:System.Net.Sockets.Socket" /> により、インターネット プロトコル \(IP\) データグラムを断片化をします。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Net.Sockets.Socket" /> データグラム フラグメントを許可しない場合は、 <see langword="false" />です。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 データグラムは、そのサイズを超える、最大転送単位 \(MTU\) 伝送媒体の場合、断片化を求められます。 データグラムは、送信元ホスト \(すべてのインターネット プロトコル バージョン\) または中間ルーター \(インターネット プロトコル バージョン 4 だけ\) によって断片化している可能性があります。 データグラムを断片化しなければならない場合、 <xref:System.Net.Sockets.Socket.DontFragment%2A> オプションが設定されている、データグラムを破棄すると、およびデータグラムの送信者に送り返すインターネット制御メッセージ プロトコル \(ICMP\) のエラー メッセージを送信します。  
  
 伝送制御プロトコル \(TCP\) ソケットにこのプロパティを設定しても影響します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.DontFragment%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">内のソケットに対してのみこのプロパティを設定することができます、 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリです。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> が IPv4 と IPv6 の両方に使用されるデュアル モード ソケットであるかどうか指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> がデュアル モード ソケットの場合、<see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">ソケットの参照の複製が作成された対象プロセスの ID。</param>
        <summary>ターゲット プロセスでは、ソケットの参照を複製し、このプロセスのソケットを閉じます。</summary>
        <returns>ターゲット プロセスに渡されるソケット参照します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ターゲット プロセスを使用する必要があります <xref:System.Net.Sockets.Socket.%23ctor%2A> 重複するソケットのインスタンスを作成します。  
  
 呼び出した場合、 <xref:System.Net.Sockets.Socket.%23ctor%2A> 複数回の各呼び出しの引数と同じバイト配列を持つコンス トラクターは、複数の管理を作成、 <xref:System.Net.Sockets.Socket> と基になるソケットの同じインスタンスです。 この方法はお勧めします。  
  
 ソケットを作成するプロセスは、非同期メソッドを使用している場合 \(<xref:System.Net.Sockets.Socket.BeginReceive%2A> または <xref:System.Net.Sockets.Socket.BeginSend%2A>\)、プロセスは、まず設定、 <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> プロパティをソケットを引き起こす可能性のある作成プロセスの完了ポートにバインド true。 それ以外の場合、、 <xref:System.ArgumentNullException> ターゲット プロセスでスローされます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="targetProcessID" /> 有効なプロセス id ではありません。  
  
 または  
  
 ソケットの参照の複製に失敗しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 <see cref="T:System.Boolean" /> 値を指定するかどうか、 <see cref="T:System.Net.Sockets.Socket" /> 送信したり、ブロードキャスト パケットを受信します。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Net.Sockets.Socket" /> ブロードキャスト パケットを許可しない場合は、 <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ブロードキャストは、特定のサブネットに制限されており、ユーザー データグラム プロトコル \(UDP\) を使用する必要があります。 255.255.255.255; にパケットを送信してインターネット プロトコル バージョン 4 では、ローカル サブネットにブロードキャストできます。または、ホスト部分で設定のすべてのビットで、インターネット プロトコル \(IP\) アドレスのネットワーク部分は、有向ブロードキャスト アドレスを使用することができます。 たとえば、IP アドレスが 192.168.1.40 \(255.255.255.0 のネットマスク付きのクラス C アドレスはネットワーク部分が最初の 3 オクテットは、ホスト部分は、最後のオクテット、\)、有向ブロードキャスト アドレスは 192.168.1.255 です。  
  
 伝送制御プロトコル \(TCP\) ソケットにこのプロパティを設定しても影響します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">このオプションは、データグラム ソケットのみ有効です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>非同期的に受信接続の試行を受け入れるし、新たに作成 <see cref="T:System.Net.Sockets.Socket" /> リモート ホストの通信を処理します。</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> をリモート ホストとの通信を処理します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 呼び出しが完了すると <xref:System.Net.Sockets.Socket.BeginAccept%2A>です。 呼び出しの前に <xref:System.Net.Sockets.Socket.BeginAccept%2A>, を実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを返します。`asyncResult` パラメーターから返される、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。  
  
 コールバック メソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 `asyncResult` を取得するパラメーター、 <xref:System.Net.Sockets.Socket> で、接続試行が行わします。 取得した後、 <xref:System.Net.Sockets.Socket>, 、呼び出すことができます、 <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを接続試行を正常に完了します。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、受信接続を許可し、新しい返します <xref:System.Net.Sockets.Socket> データを送信して、リモート ホストからのデータの受信に使用できます。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例は、非同期要求を終了し、新たに作成 <xref:System.Net.Sockets.Socket> 受信接続要求を受け入れるようにします。 完全な例には、ソケットを使用して非同期通信については、次を参照してください。 [&#91;\<topic:\/\/cpconSocketCodeExamples\>&#93;](http://msdn.microsoft.com/ja-jp/f3fc7533-6956-42c6-bbc3-73e5a221027d)します。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket\_Async\_Send\_Receive\#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって作成されていない <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />します。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドが呼び出されたとします。</exception>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(unsigned int8[] buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 転送されたバイト数を格納しています。</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> この非同期操作だけでなくすべてのユーザーの状態情報を格納するオブジェクトがデータを定義します。</param>
        <summary>非同期的に受信接続の試行を受け入れるし、新たに作成 <see cref="T:System.Net.Sockets.Socket" /> リモート ホストの通信を処理するオブジェクト。 このメソッドは、転送される初期データを格納しているバッファーを返します。</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> リモート ホストとの通信を処理するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndAccept%2A> 呼び出しが完了すると [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A>です。 呼び出しの前に [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、によって呼び出されるコールバック メソッドを作成する必要があります、 [EndAccept メソッド \(Byte\<xref:System.AsyncCallback> を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを返します。  
  
 コールバック メソッド内で、 [EndAccept メソッド \(Byte\<xref:System.IAsyncResult.AsyncState%2A> のメソッド、 `asyncResult` を取得するパラメーター、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket> で、接続試行が行わします。 取得した後、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket>, 、呼び出すことができます、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを接続試行を正常に完了します。`buffer` このオーバー ロードのパラメーターには、呼び出しで受信されたデータが含まれています。 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> と `bytesTransferred` パラメーターには、の呼び出しで転送されたバイト数が含まれています。  
  
 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。[EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、受信接続を許可し、新しい返します [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket> データを送信して、リモート ホストからのデータの受信に使用できます。  
  
> [!NOTE]
>  表示された場合、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> を作成およびソケットを接続し、最初の 10 バイトのデータをそのまま使用します。 コールバック デリゲート呼び出し [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndAccept%2A> 非同期要求を終了します。 転送されるバイト数と、データが返される、 `buffer` と `bytesTransferred` このメソッドのパラメーター、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements\#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements\#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって作成されていない <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />します。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドが呼び出されたとします。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">アクセスするときにエラーが発生しました、 <see cref="T:System.Net.Sockets.Socket" /> 詳細については「解説」セクションを参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(unsigned int8[] buffer, int32 bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 転送されたバイト数を格納しています。</param>
        <param name="bytesTransferred">転送されたバイト数。</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> この非同期操作だけでなくすべてのユーザーの状態情報を格納するオブジェクトがデータを定義します。</param>
        <summary>非同期的に受信接続の試行を受け入れるし、新たに作成 <see cref="T:System.Net.Sockets.Socket" /> リモート ホストの通信を処理するオブジェクト。 このメソッドは、初期のデータと転送されたバイト数を含むバッファーを返します。</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> リモート ホストとの通信を処理するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndAccept%2A> 呼び出しが完了すると [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A>です。 呼び出しの前に [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、によって呼び出されるコールバック メソッドを作成する必要があります、 [EndAccept メソッド \(Byte\<xref:System.AsyncCallback> を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを返します。`asyncResult` パラメーターから返される、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドです。  
  
 コールバック メソッド内で、 [EndAccept メソッド \(Byte\<xref:System.IAsyncResult.AsyncState%2A> のメソッド、 `asyncResult` を取得するパラメーター、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket> で、接続試行が行わします。 取得した後、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket>, 、呼び出すことができます、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを接続試行を正常に完了します。`buffer` このオーバー ロードのパラメーターには、呼び出しで受信されたデータが含まれています。 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> と `bytesTransferred` パラメーターには、の呼び出しで転送されたバイト数が含まれています。  
  
 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。[EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、受信接続を許可し、新しい返します [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket> データを送信して、リモート ホストからのデータの受信に使用できます。  
  
> [!NOTE]
>  表示された場合、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.BeginAccept%2A> を作成およびソケットを接続し、最初の 10 バイトのデータをそのまま使用します。 コールバック デリゲート呼び出し [EndAccept メソッド \(Byte\<xref:System.Net.Sockets.Socket.EndAccept%2A> 非同期要求を終了します。 転送されるバイト数と、データが返される、 `buffer` と `bytesTransferred` このメソッドのパラメーター、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements\#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements\#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって作成されていない <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />します。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドが呼び出されたとします。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">アクセスするときにエラーが発生しました、 <see cref="T:System.Net.Sockets.Socket" />です。 詳細については、「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>要求の保留中の非同期接続を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> 非同期リモート ホスト接続要求を完了したブロッキング メソッド開始、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドです。  
  
 呼び出しの前に <xref:System.Net.Sockets.Socket.BeginConnect%2A>, を実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される <xref:System.Net.Sockets.Socket.BeginConnect%2A> を返します。 コールバック メソッド、 <xref:System.IAsyncResult> によって返される、 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドをパラメーターとして。  
  
 コールバック メソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 <xref:System.IAsyncResult> を取得するパラメーター、 <xref:System.Net.Sockets.Socket> で、接続試行が行わします。 取得した後、 <xref:System.Net.Sockets.Socket>, 、呼び出すことができます、 <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを接続試行を正常に完了します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、非同期接続の試行を終了します。 完全な例には、ソケットを使用して非同期通信については、次を参照してください。 [&#91;\<topic:\/\/cpconSocketCodeExamples\>&#93;](http://msdn.microsoft.com/ja-jp/f3fc7533-6956-42c6-bbc3-73e5a221027d)します。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket\_Async\_Send\_Receive\#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって返されませんでした、 <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> 非同期の接続が呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 状態情報との非同期操作がこのユーザー定義データを格納するオブジェクト。</param>
        <summary>保留中の非同期の切断要求を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 呼び出しが完了すると <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>です。<xref:System.Net.Sockets.Socket.EndDisconnect%2A> メソッドが完了すると、切断するまでブロックします。 非同期操作については、MSDN ライブラリの非同期プログラミングの概要トピックを参照してください。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、非同期通信のソケットを作成し、リモート ホストにデータを送信します。 データが送信されると、 <xref:System.Net.Sockets.Socket.Shutdown%2A> を送信を停止し、receive アクティビティが呼び出されます。<xref:System.Net.Sockets.Socket.BeginDisconnect%2A> 切断要求を開始すると呼びます。 コールバック デリゲート呼び出し <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 非同期要求を終了します。 要求が完了したら、 <xref:System.Net.Sockets.Socket.Connected%2A> プロパティは、ソケットが切断されているかどうかをテストするクエリを実行します。  
  
 [!code-cpp[Nclsocketenhancements\#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements\#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">オペレーティング システムが Windows 2000 以前のバージョン、およびこのメソッドには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって返されませんでした、 <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> 非同期の接続が呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.Net.WebException">接続解除要求がタイムアウトしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッド開始される非同期の読み取り操作が完了すると、 <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドです。  
  
 呼び出しの前に <xref:System.Net.Sockets.Socket.BeginReceive%2A>, を実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される <xref:System.Net.Sockets.Socket.BeginReceive%2A> を返します。 コールバック メソッド、 <xref:System.IAsyncResult> によって返される、 <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドをパラメーターとして。  
  
 コールバック メソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 <xref:System.IAsyncResult> に渡される状態オブジェクトを取得し、 <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドです。 受信側の抽出 <xref:System.Net.Sockets.Socket> この状態オブジェクトから。 取得した後、 <xref:System.Net.Sockets.Socket>, 、呼び出すことができます、 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを正常に読み取り操作を完了し、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドはデータが使用可能になるまでブロックします。 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.EndReceive%2A> は着信ネットワーク バッファで使用できる最初のキューに登録されるデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドはバイトで指定した数まで使用量のデータを読み取る、 `size` のパラメーター、 <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドです。 リモート ホストがシャット ダウンした場合、 <xref:System.Net.Sockets.Socket> との接続、 <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
 受信したデータを取得する呼び出し、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 <xref:System.IAsyncResult>, 、し、結果の状態オブジェクトに含まれているバッファーを抽出します。  
  
 キャンセルする、保留中 <xref:System.Net.Sockets.Socket.BeginReceive%2A>, を呼び出す、 <xref:System.Net.Sockets.Socket.Close%2A> メソッドです。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、保留中の非同期読み取りを終了します。 完全な例には、ソケットを使用して非同期通信については、次を参照してください。 [&#91;\<topic:\/\/cpconSocketCodeExamples\>&#93;](http://msdn.microsoft.com/ja-jp/f3fc7533-6956-42c6-bbc3-73e5a221027d)します。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket\_Async\_Send\_Receive\#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって返されませんでした、 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 非同期読み取りが呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketError errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 状態情報との非同期操作がこのユーザー定義データを格納します。</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> ソケット エラーを格納するオブジェクト。</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッド開始される非同期の読み取り操作が完了すると、 <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドです。  
  
 呼び出しの前に <xref:System.Net.Sockets.Socket.BeginReceive%2A>, を実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される <xref:System.Net.Sockets.Socket.BeginReceive%2A> を返します。 コールバック メソッド、 <xref:System.IAsyncResult> によって返される、 <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドをパラメーターとして。  
  
 コールバック メソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 <xref:System.IAsyncResult> に渡される状態オブジェクトを取得し、 <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドです。 受信側の抽出 <xref:System.Net.Sockets.Socket> この状態オブジェクトから。 取得した後、 <xref:System.Net.Sockets.Socket>, 、呼び出すことができます、 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドを正常に読み取り操作を完了し、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドはデータが使用可能になるまでブロックします。 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.EndReceive%2A> は着信ネットワーク バッファで使用できる最初のキューに登録されるデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドはバイトで指定した数まで使用量のデータを読み取る、 `size` のパラメーター、 <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドです。 リモート ホストがシャット ダウンした場合、 <xref:System.Net.Sockets.Socket> との接続、 <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
 受信したデータを取得する呼び出し、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 <xref:System.IAsyncResult>, 、し、結果の状態オブジェクトに含まれているバッファーを抽出します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって返されませんでした、 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 非同期読み取りが呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint end_point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary>特定のエンドポイントから、保留中の非同期読み取りを終了します。</summary>
        <returns>成功した場合、バイト数を受信します。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッド開始される非同期の読み取り操作が完了すると、 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドです。  
  
 呼び出しの前に <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, を実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> を返します。 コールバック メソッド、 <xref:System.IAsyncResult> によって返される、 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドをパラメーターとして。  
  
 コールバック メソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 <xref:System.IAsyncResult> に渡される状態オブジェクトを取得し、 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドです。 受信側の抽出 <xref:System.Net.Sockets.Socket> この状態オブジェクトから。 取得した後、 <xref:System.Net.Sockets.Socket>, 、呼び出すことができます、 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドを正常に読み取り操作を完了し、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドはデータが使用可能になるまでブロックします。 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> は着信ネットワーク バッファで使用できる最初のキューに登録されるデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドはバイトで指定した数まで使用量のデータを読み取る、 `size` のパラメーター、 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドです。 リモート ホストがシャット ダウンした場合、 <xref:System.Net.Sockets.Socket> との接続、 <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドはすぐに完了し、0 バイトを返します。 受信したデータを取得する呼び出し、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 <xref:System.IAsyncResult> オブジェクト、および結果の状態オブジェクトに含まれているバッファーを抽出します。 元のホストを識別するのには、抽出、 <xref:System.Net.EndPoint> にキャストし、 <xref:System.Net.IPEndPoint>です。 使用して、 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> IP アドレスを取得するメソッドと <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> ポート番号を取得します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例は、特定の保留中の非同期読み取りを終了 <xref:System.Net.EndPoint>します。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket\_Async\_Send\_Receive\#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって返されませんでした、 <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> 非同期読み取りが呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint endPoint, valuetype System.Net.Sockets.IPPacketInformation ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 状態情報との非同期操作がこのユーザー定義データを格納します。</param>
        <param name="socketFlags">ビットごとの組み合わせ、 <see cref="T:System.Net.Sockets.SocketFlags" /> 受信パケットの値。</param>
        <param name="endPoint">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">
          <see cref="T:System.Net.IPAddress" /> と受信パケットのインターフェイスです。</param>
        <summary>特定のエンドポイントから、保留中の非同期読み取りを終了します。 このメソッドはの詳細については、パケットよりも表れて <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />します。</summary>
        <returns>成功した場合、バイト数を受信します。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 操作が完了していない場合、このメソッドは、これはまでブロックします。  
  
 この操作を同期的に実行するを使用して、 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドです。  
  
 調べる `ipPacketInformation` かどうかは、ユニキャスト、マルチキャストまたはブロードキャスト アドレスを使用して、データグラムが送信されたかを把握する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> します。 <see langword="null" />  
  
 または  
  
 <paramref name="endPoint" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって返されませんでした、 <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> 非同期読み取りが呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>かどうかは成功すると、バイト数に送信、 <see cref="T:System.Net.Sockets.Socket" />。 そうしないと、無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 開始された非同期送信操作が完了すると <xref:System.Net.Sockets.Socket.BeginSend%2A>です。  
  
 呼び出しの前に <xref:System.Net.Sockets.Socket.BeginSend%2A>, を実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される <xref:System.Net.Sockets.Socket.BeginSend%2A> を返します。 コールバック メソッド、 <xref:System.IAsyncResult> によって返される、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドをパラメーターとして。  
  
 コールバック メソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 <xref:System.IAsyncResult> 送信を取得するパラメーター <xref:System.Net.Sockets.Socket>します。 取得した後、 <xref:System.Net.Sockets.Socket>, 、呼び出すことができます、 <xref:System.Net.Sockets.Socket.EndSend%2A> を正常に送信操作を完了して送信されたバイト数を返します。  
  
 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.EndSend%2A> データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.EndSend%2A> バッファーの一部が送信するまでブロックされます。 戻り値の場合 <xref:System.Net.Sockets.Socket.EndSend%2A> バッファーができなかったことを示します呼び出す完全に送信される、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを再度、未送信のデータを保持するバッファーを変更します。  
  
 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、保留中の非同期送信を終了します。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket\_Async\_Send\_Receive\#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって返されませんでした、 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> 非同期の送信が呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketError errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> この非同期操作の状態情報を格納します。</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> ソケット エラーを格納するオブジェクト。</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>かどうかは成功すると、バイト数に送信、 <see cref="T:System.Net.Sockets.Socket" />。 そうしないと、無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 開始された非同期送信操作が完了すると <xref:System.Net.Sockets.Socket.BeginSend%2A>です。  
  
 呼び出しの前に <xref:System.Net.Sockets.Socket.BeginSend%2A>, を実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される <xref:System.Net.Sockets.Socket.BeginSend%2A> を返します。 コールバック メソッド、 <xref:System.IAsyncResult> によって返される、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドをパラメーターとして。  
  
 コールバック メソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 <xref:System.IAsyncResult> 送信を取得するパラメーター <xref:System.Net.Sockets.Socket>します。 取得した後、 <xref:System.Net.Sockets.Socket>, 、呼び出すことができます、 <xref:System.Net.Sockets.Socket.EndSend%2A> を正常に送信操作を完了して送信されたバイト数を返します。  
  
 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.EndSend%2A> データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.EndSend%2A> バッファーの一部が送信するまでブロックされます。 戻り値の場合 <xref:System.Net.Sockets.Socket.EndSend%2A> バッファーができなかったことを示します呼び出す完全に送信される、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを再度、未送信のデータを保持するバッファーを変更します。  
  
 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I\/O が取り消されました。 保留中の非同期操作は、スレッドの終了操作が完了していなかった場合に失敗します。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって返されませんでした、 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> 非同期の送信が呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> この非同期操作の状態情報を格納するオブジェクト。</param>
        <summary>ファイルの保留中の非同期送信を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 開始された非同期送信操作が完了すると <xref:System.Net.Sockets.Socket.BeginSendFile%2A>です。  
  
 呼び出しの前に <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, を実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される <xref:System.Net.Sockets.Socket.BeginSendFile%2A> を返します。 コールバック メソッド、 <xref:System.IAsyncResult> によって返されるオブジェクト、 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドをパラメーターとして。  
  
 コールバック メソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 <xref:System.IAsyncResult> 送信を取得するパラメーター <xref:System.Net.Sockets.Socket>します。 取得した後、 <xref:System.Net.Sockets.Socket>, 、呼び出すことができます、 <xref:System.Net.Sockets.Socket.EndSendFile%2A> メソッドを正常に送信操作を完了します。  
  
 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 、データグラムを送信するまでブロックします。 接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.EndSendFile%2A> ファイル全体を送信するまでブロックします。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例を作成し、非同期通信のソケットを接続し、リモート ホストに、ファイルの"text.txt"を非同期的に送信を開始します。 コールバック デリゲート呼び出し <xref:System.Net.Sockets.Socket.EndSendFile%2A> 転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements\#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements\#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT は、このメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって返されませんでした、 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> 非同期が呼び出された <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>特定の場所に保留中の非同期送信を終了します。</summary>
        <returns>成功すると、バイト数送信します。それ以外の場合、無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 開始された非同期送信操作が完了すると <xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。  
  
 呼び出しの前に <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, を実装するコールバック メソッドを作成する必要があります、 <xref:System.AsyncCallback> を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される <xref:System.Net.Sockets.Socket.BeginReceive%2A> を返します。 コールバック メソッド、 <xref:System.IAsyncResult> によって返される、 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドをパラメーターとして。  
  
 コールバック メソッド内で、 <xref:System.IAsyncResult.AsyncState%2A> のメソッド、 <xref:System.IAsyncResult> 送信を取得するパラメーター <xref:System.Net.Sockets.Socket>します。 取得した後、 <xref:System.Net.Sockets.Socket>, 、呼び出すことができます、 <xref:System.Net.Sockets.Socket.EndSendTo%2A> を正常に送信操作を完了して送信されたバイト数を返します。  
  
 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.EndSendTo%2A> データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 要求されたバイト数が送信されるまでブロックされます。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、特定の場所への非同期送信を終了します。  
  
 [!code-cpp[Socket\_Async\_Send\_Receive\#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket\_Async\_Send\_Receive\#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket\_Async\_Send\_Receive\#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 呼び出しによって返されませんでした、 <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドです。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> 非同期の送信が呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 <see cref="T:System.Boolean" /> 値を指定するかどうか、 <see cref="T:System.Net.Sockets.Socket" /> により、ポートにバインドするプロセスは 1 つだけです。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Net.Sockets.Socket" /> 、特定のポートにバインドする 1 つだけのソケットは、それ以外の場合、 <see langword="false" />です。 既定値は <see langword="true" /> の Windows Server 2003 および Windows XP Service Pack 2、および <see langword="false" /> 他のすべてのバージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> は `false`, 、複数のソケットを使用して、 <xref:System.Net.Sockets.Socket.Bind%2A> 特定のポートにバインドするメソッドは、ソケットの 1 つただしのみが、ポートに送信されるネットワーク トラフィックに対して操作を実行できます。 1 つ以上のソケットを使用するしようとすると、 <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> より特定の IP アドレスを持つ 1 つはそのポートに送信されるネットワーク トラフィックを処理し、特定のポートにバインドするメソッドです。  
  
 場合 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> は `true`, 、最初に使用する、 <xref:System.Net.Sockets.Socket.Bind%2A> インターネット プロトコル \(IP\) アドレスに関係なく、特定のポートにバインドしようとするメソッドは成功しています。 の後続のすべての使用、 <xref:System.Net.Sockets.Socket.Bind%2A> 元は、ソケットをバインドするまでのポートが失敗するようにバインドしようとするメソッドが破棄されます。  
  
 前にこのプロパティを設定する必要があります <xref:System.Net.Sockets.Socket.Bind%2A> と呼ばれる以外の場合は、 <xref:System.InvalidOperationException> がスローされます。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> これが呼び出された <see cref="T:System.Net.Sockets.Socket" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> クラスによって使用されていたリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket> クラスのファイナライザーの呼び出し、 <xref:System.Net.Sockets.Socket.Close%2A> を終了するメソッド、 <xref:System.Net.Sockets.Socket> に関連付けられているリソースを解放し、 <xref:System.Net.Sockets.Socket>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <summary>指定した値を返す <see cref="T:System.Net.Sockets.Socket" /> オプションをオブジェクトとして表されます。</summary>
        <returns>オプションの値を表すオブジェクト。 ときに、 <paramref name="optionName" /> にパラメーターが設定されている <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> 、戻り値のインスタンスは、 <see cref="T:System.Net.Sockets.LingerOption" /> クラスです。<paramref name="optionName" /> に設定されている <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> または <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, 、戻り値は、のインスタンス、 <see cref="T:System.Net.Sockets.MulticastOption" /> クラスです。 ときに <paramref name="optionName" /> その他の値は、戻り値は整数です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定 <xref:System.Net.Sockets.Socket>します。 このオーバー ロードを使用して取得する、 <xref:System.Net.Sockets.SocketOptionName.Linger>, 、<xref:System.Net.Sockets.SocketOptionName.AddMembership>, 、および <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> オプション。<xref:System.Net.Sockets.SocketOptionName.Linger> オプションを使用して <xref:System.Net.Sockets.Socket> の `optionLevel` パラメーター。<xref:System.Net.Sockets.SocketOptionName.AddMembership> と <xref:System.Net.Sockets.SocketOptionName.DropMembership>, を使用して <xref:System.Net.Sockets.SocketOptionLevel.IP>します。 上記のオプションのいずれかの値の設定を使用する場合、 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドです。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例の取得、 <xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> タイムアウト値し、コンソールに表示します。  
  
 [!code-cpp[Socket\_Socket\_Options\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket\_Socket\_Options\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket\_Socket\_Options\#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、次の「解説」を参照してください。  
  
 または  
  
 <paramref name="optionName" /> サポートされていない値に設定された <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />します。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">型の配列 <see cref="T:System.Byte" /> ことでは、オプションの設定を受信します。</param>
        <summary>指定 <see cref="T:System.Net.Sockets.Socket" /> オプションの設定、バイト配列として表されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定 <xref:System.Net.Sockets.Socket>します。 このメソッドを正常に完了するで指定された配列、 `optionValue` パラメーターには、指定した値が含まれています。 <xref:System.Net.Sockets.Socket> オプション。  
  
 ときの長さ、 `optionValue` 配列が指定した値を格納するために必要なバイト数より小さい <xref:System.Net.Sockets.Socket> オプション、 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> をスロー、 <xref:System.Net.Sockets.SocketException>です。 表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。 このオーバー ロードを使用して、すべてのソケットのブール値または整数値で表されます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例の取得、 <xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> タイムアウト値し、コンソールに表示します。  
  
 [!code-cpp[Socket\_Socket\_Options\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket\_Socket\_Options\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket\_Socket\_Options\#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、次の「解説」を参照してください。  
  
 または  
  
 .NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32,768 バイトに設定されます。 変更することができます、呼び出すことによって、ソケット バッファー領域あたり <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionLength">想定される戻り値の長さ、\(バイト単位\)。</param>
        <summary>指定した値を返す <see cref="T:System.Net.Sockets.Socket" /> 配列内のオプションです。</summary>
        <returns>型の配列 <see cref="T:System.Byte" /> ソケット オプションの値を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `optionLength` パラメーターが返されたバイト配列の最大サイズを設定します。 オプションの値には、以下のバイトが必要とする場合、配列にはそれだけでバイト数。 オプションの値には、多くのバイト数が必要な場合 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> をスローする <xref:System.Net.Sockets.SocketException>です。 このオーバー ロードを使用して、すべてのソケットのブール値または整数値で表されます。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例の取得、 <xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> タイムアウト値し、コンソールに表示します。  
  
 [!code-cpp[Socket\_Socket\_Options\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket\_Socket\_Options\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket\_Socket\_Options\#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、次の「解説」を参照してください。  
  
 または  
  
 .NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32,768 バイトに設定されます。 変更することができます、呼び出すことによって、ソケット バッファー領域あたり <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オペレーティング システム ハンドルを取得、 <see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value>
          <see cref="T:System.IntPtr" /> のオペレーティング システム ハンドルを表す、 <see cref="T:System.Net.Sockets.Socket" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">
          <see cref="T:System.Int32" /> 操作を実行するコントロールのコードを指定します。</param>
        <param name="optionInValue">A <see cref="T:System.Byte" /> 、操作に必要な入力データを格納する配列。</param>
        <param name="optionOutValue">A <see cref="T:System.Byte" /> 操作によって返される出力データを格納する配列。</param>
        <summary>動作モードは低レベルの設定、 <see cref="T:System.Net.Sockets.Socket" /> 数値制御コードを使用します。</summary>
        <returns>バイト数、 <paramref name="optionOutValue" /> パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [IOControl メソッド \(Int32, Byte\<xref:System.Net.Sockets.Socket.IOControl%2A> メソッドは、オペレーティング システムへの低レベルのアクセスを提供 [IOControl メソッド \(Int32, Byte\<xref:System.Net.Sockets.Socket> の現在のインスタンスの基になる、 [IOControl メソッド \(Int32, Byte\<xref:System.Net.Sockets.Socket> クラスです。 詳細については、MSDN ライブラリの WSAIoctl ドキュメントを参照してください。  
  
> [!NOTE]
>  表示された場合、 [IOControl メソッド \(Int32, Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [IOControl メソッド \(Int32, Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、FIONREAD と利用可能なプロパティの結果を比較します。  
  
 [!code-cpp[NCLSocketIoControl\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">使用せずにブロッキング モードを変更しようとした、 <see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティです。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックに呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to execute unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">A <see cref="T:System.Net.Sockets.IOControlCode" /> 実行する操作のコントロールのコードを指定します。</param>
        <param name="optionInValue">型の配列 <see cref="T:System.Byte" /> 、操作に必要な入力データが含まれています。</param>
        <param name="optionOutValue">型の配列 <see cref="T:System.Byte" /> 操作によって返される出力データが含まれています。</param>
        <summary>動作モードは低レベルの設定、 <see cref="T:System.Net.Sockets.Socket" /> を使用して、 <see cref="T:System.Net.Sockets.IOControlCode" /> 制御コードを指定する列挙体です。</summary>
        <returns>バイト数、 <paramref name="optionOutValue" /> パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、オペレーティング システムへの低レベルのアクセスを提供 [IOControl メソッド \(IOControlCode, Byte\<xref:System.Net.Sockets.Socket> の現在のインスタンスの基になる、 [IOControl メソッド \(IOControlCode, Byte\<xref:System.Net.Sockets.Socket> クラスです。 詳細については、MSDN ライブラリの WSAIoctl ドキュメントを参照してください。  
  
> [!NOTE]
>  表示された場合、 [IOControl メソッド \(IOControlCode, Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [IOControl メソッド \(IOControlCode, Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例は、通話の結果を比較 [IOControl メソッド \(IOControlCode, Byte\<xref:System.Net.Sockets.Socket.IOControl%2A> と [IOControl メソッド \(IOControlCode, Byte\<xref:System.Net.Sockets.IOControlCode.DataToRead> と [IOControl メソッド \(IOControlCode, Byte\<xref:System.Net.Sockets.Socket.Available%2A> プロパティです。  
  
 [!code-cpp[NCLSocketIoControl1\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">使用せずにブロッキング モードを変更しようとした、 <see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティです。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to execute unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Net.Sockets.Socket" /> は特定のローカル ポートにバインドします。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Net.Sockets.Socket" /> はローカル ポートにバインドされている以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出して明示的にバインドされている場合、ソケットはローカル ポートにバインドされたと見なされる、 <xref:System.Net.Sockets.Socket.Bind%2A> メソッド、またはのようなメンバーを呼び出すことによって暗黙的にバインドされた <xref:System.Net.Sockets.Socket.Connect%2A>, 、<xref:System.Net.Sockets.Socket.SendTo%2A>, 、または <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, 、一時的なローカル ポート \(空きポート オペレーティング システムで選択された 1024年を超えています\) を使用する。 サーバーを使用して、 <xref:System.Net.Sockets.Socket.Bind%2A> にクライアントが接続できるように、既知のポートにバインドするメソッドです。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.IsBound%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定を指定する値かどうか、 <see cref="T:System.Net.Sockets.Socket" /> を保留中のすべてのデータを送信するために、ソケットを閉じる、遅延されます。</summary>
        <value>A <see cref="T:System.Net.Sockets.LingerOption" /> ソケットを閉じるときの待機をする方法を指定します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.LingerState%2A> プロパティの変更方法 <xref:System.Net.Sockets.Socket.Close%2A> メソッドは動作します。 このプロパティ セットを接続をリセットして Winsock によって条件を変更する場合。 接続のリセットにも IP プロトコルの動作に基づいて発生します。  
  
 このプロパティは、接続指向の接続は開いたままへの呼び出し後の時間の長さを制御 <xref:System.Net.Sockets.Socket.Close%2A> 送信されるデータが残っている場合。  
  
 データをピアに送信するためのメソッドを呼び出すと、このデータは送信のネットワーク バッファーに配置されます。 このプロパティを使用する前にリモート ホストにこのデータが送信されるように、 <xref:System.Net.Sockets.TcpClient.Close%2A> メソッドは、接続を切断します。  
  
 接続を維持できるように、作成、 <xref:System.Net.Sockets.LingerOption> 、目的の値を含むをインスタンス化し、設定、 <xref:System.Net.Sockets.Socket.LingerState%2A> プロパティをこのインスタンスにします。  
  
 次の表の動作、 <xref:System.Net.Sockets.Socket.Close%2A> メソッドの有効な値を <xref:System.Net.Sockets.LingerOption.Enabled%2A> プロパティおよび <xref:System.Net.Sockets.LingerOption.LingerTime%2A> にプロパティが格納されている、 <xref:System.Net.Sockets.Socket.LingerState%2A> プロパティです。  
  
|LingerState.Enabled|LingerState.LingerTime|動作|  
|-------------------------|----------------------------|--------|  
|`false` \(無効\)、既定値|タイムアウトは、必要に応じて、されません \(既定値\)。|既定の IP プロトコル タイムアウトの期限が切れるまで、保留中のデータ送信を試みます。|  
|`true` \(有効\)|0 以外のタイムアウト|指定されたタイムアウトに達すると、試行が失敗した場合は、Winsock 接続がリセットされるまで、保留中のデータ送信を試みます。|  
|`true` \(有効\)|0 のタイムアウト|保留中のデータを破棄します。 接続志向ソケット \(TCP など\) の場合は、Winsock は接続をリセットします。|  
  
 IP スタックは、接続の往復時間に基づいて使用する既定の IP プロトコルのタイムアウト期間を計算します。 ほとんどの場合、スタックによって計算されたタイムアウトは、アプリケーションで定義された 1 つ以上に大きな意味です。 これは、ソケットの既定の動作と、 <xref:System.Net.Sockets.Socket.LingerState%2A> プロパティが設定されていません。  
  
 ときに、 <xref:System.Net.Sockets.LingerOption.LingerTime%2A> にプロパティが格納されている、 <xref:System.Net.Sockets.Socket.LingerState%2A> プロパティは、既定の IP プロトコル タイムアウトよりも大きい設定も、既定の IP プロトコル タイムアウトはまだ適用してオーバーライドできます。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.LingerState%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">保留中の接続のキューの最大長。</param>
        <summary>場所、 <see cref="T:System.Net.Sockets.Socket" /> リッスン状態にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.Listen%2A> により、接続指向 <xref:System.Net.Sockets.Socket> 受信試行の接続をリッスンするようにします。`backlog` パラメーターへの同意キューに置くことの受信接続の数を指定します。 指定する接続の最大数を確認するのには、取得、 <xref:System.Net.Sockets.SocketOptionName.MaxConnections> 値。<xref:System.Net.Sockets.Socket.Listen%2A> ブロックされません。  
  
 表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。 使用 <xref:System.Net.Sockets.Socket.Accept%2A> または <xref:System.Net.Sockets.Socket.BeginAccept%2A> キューからの接続を受け入れます。  
  
> [!NOTE]
>  呼び出す必要があります、 <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Listen%2A>, 、または <xref:System.Net.Sockets.Socket.Listen%2A> をスローする <xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
> [!NOTE]
>  バックログのパラメーターは、オペレーティング システムに応じて異なる値に制限されます。 高い値を指定することがありますが、バックログは限られたオペレーティング システムに基づくです。  
  
   
  
## 例  
 次のコード例では <xref:System.Net.Sockets.Socket> 着信接続をリッスンします。  
  
 [!code-cpp[Classic Socket.Listen Example\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル エンドポイントを取得します。</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> を <see cref="T:System.Net.Sockets.Socket" /> 通信に使用します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを取得、 <xref:System.Net.EndPoint> するローカル IP アドレスとポート番号を含む、 <xref:System.Net.Sockets.Socket> がバインドされています。 これをキャストする必要があります <xref:System.Net.EndPoint> に、 <xref:System.Net.IPEndPoint> すべての情報を取得する前にします。 呼び出すことができます、 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> ローカルを取得するメソッドを <xref:System.Net.IPAddress>, 、および <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> ローカル ポート番号を取得します。  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティが通常設定への呼び出しを行った後、 <xref:System.Net.Sockets.Socket.Bind%2A> メソッドです。 ソケットのローカル IP アドレスとポート番号を割り当てるシステムを許可する場合、 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティは、最初の I\/O 操作の後に設定されます。 接続指向のプロトコルでは、最初の I\/O 操作の呼び出しになります、 <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 コネクションレスのプロトコルの最初の I\/O 操作は送信のいずれかを指定または、呼び出しを受信します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例を取得し、ローカルおよびリモートのエンドポイントを表示します。  
  
 [!code-cpp[Socket\_Socket\_Options\#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket\_Socket\_Options\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket\_Socket\_Options\#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または発信マルチキャスト パケットが送信元アプリケーションに配信されるかどうかを指定する値を設定します。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Net.Sockets.Socket" /> 発信マルチキャスト パケットを受信します。 それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マルチキャストは、インターネットでの多対多の通信に拡張性の高い方法です。 マルチキャスト アドレスをサブスクライブしているプロセス次に、サブスクライブしているプロセスが送信したすべてのパケットは、マルチキャスト アドレスをサブスクライブしている他のすべてのプロセスによって受信されます。  
  
 伝送制御プロトコル \(TCP\) ソケットにこのプロパティを設定しても影響します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、 <see cref="T:System.Boolean" /> を指定する値かどうか、ストリーム <see cref="T:System.Net.Sockets.Socket" /> Nagle アルゴリズムを使用しています。</summary>
        <value>
          <see langword="false" /> 場合、 <see cref="T:System.Net.Sockets.Socket" /> Nagle アルゴリズムを使用しない場合は、 <see langword="true" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Nagle アルゴリズムは、小さなパケットのバッファーを結合し、特定の状況で 1 つのパケットで送信したりするソケットを発生させることによってネットワーク トラフィックの削減に設計されています。 TCP パケットは、header、および送信されるデータの 40 バイトで構成されます。 TCP では、小さなデータ パケットが送信される、TCP ヘッダーに起因するオーバーヘッドにネットワーク トラフィックの大部分になります。負荷の高いネットワークでこのオーバーヘッドに起因輻輳失われたデータグラムと再伝送、輻輳による過剰な伝達時間になります。 Nagle アルゴリズムは、送信側の新しい TCP segmentswhen 新しい、previouslytransmitted 上のデータ接続が、受信確認されていない場合、ユーザーから到着するデータを送信を禁止します。  
  
 ネットワーク アプリケーションの大部分は、Nagle アルゴリズムを使用する必要があります。  
  
 ユーザー データグラム プロトコル \(UDP\) ソケットにこのプロパティを設定しても影響します。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.NoDelay%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">アクセスするときにエラーが発生しました、 <see cref="T:System.Net.Sockets.Socket" />です。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 4 \(IPv4\) をサポートするかどうかを示します。</summary>
        <value>
          <see langword="true" /> オペレーティング システムおよびネットワーク アダプター、IPv4 プロトコルをサポートしている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 6 \(IPv6\) をサポートするかどうかを示します。</summary>
        <value>
          <see langword="true" /> オペレーティング システムおよびネットワーク アダプターの IPv6 プロトコルをサポートしている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">マイクロ秒単位で応答を待機する時間。</param>
        <param name="mode">
          <see cref="T:System.Net.Sockets.SelectMode" /> 値のいずれか。</param>
        <summary>状態を判断、 <see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <returns>状態、 <see cref="T:System.Net.Sockets.Socket" /> に渡されたポーリング モード値に基づいて、 <paramref name="mode" /> パラメーター。  
  
 <list type="table">  
<listheader>  
<term> モード  
  
 </term>  
<description> 戻り値  
  
 </description>  
</listheader>  
<item>  
<term> <see cref="F:System.Net.Sockets.SelectMode.SelectRead" />  
  
 </term>  
<description> <see langword="true" /> 場合 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> が呼び出されて、接続が保留中です。  
  
 または  
  
 <see langword="true" /> データを読み取ることがある場合  
  
 または  
  
 <see langword="true" /> 接続が閉じ、リセット、または終了する場合  
  
 それ以外の場合、返す <see langword="false" />します。  
  
 </description>  
</item>  
<item>  
<term> <see cref="F:System.Net.Sockets.SelectMode.SelectWrite" />  
  
 </term>  
<description> <see langword="true" />, を処理している場合、 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, 、との接続が成功したとします。  
  
 または  
  
 <see langword="true" /> データを送信する場合  
  
 それ以外の場合、返す <see langword="false" />します。  
  
 </description>  
</item>  
<item>  
<term> <see cref="F:System.Net.Sockets.SelectMode.SelectError" />  
  
 </term>  
<description> <see langword="true" /> 処理している場合、 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> をでブロックしないと、接続が失敗しました。  
  
 または  
  
 <see langword="true" /> 場合 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> がセットと帯域外のデータがあります。  
  
 それ以外の場合、返す <see langword="false" />します。  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.Poll%2A> メソッドの状態を確認、 <xref:System.Net.Sockets.Socket>です。 指定 <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=fullName> の `selectMode` パラメーターかどうかを <xref:System.Net.Sockets.Socket> を読み取ることができます。 指定 <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=fullName> かどうかを <xref:System.Net.Sockets.Socket> が書き込み可能です。 使用 <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=fullName> エラー状態を検出します。<xref:System.Net.Sockets.Socket.Poll%2A> 単位で指定された期間までの実行をブロック `microseconds`, が経過するとします。 設定、 `microSeconds` の応答を無期限に待機するには負の値のパラメーターです。 使用する複数のソケットの状態を確認する場合をお勧めします <xref:System.Net.Sockets.Socket.Select%2A> メソッドです。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメソッドは、切断されたネットワーク ケーブルなどの接続に関する問題の特定の種類を検出できないこと、またはリモート ホスト不意にシャット ダウンします。 このようなエラーを検出するためにデータ送信または受信しようとする必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例は、ソケットを作成しは、サーバーに接続を使用して <xref:System.Net.Sockets.Socket.Poll%2A> 、ソケットの状態を確認します。  
  
 [!code-cpp[SelectModeExample\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="mode" /> パラメーターは、のいずれかではない、 <see cref="T:System.Net.Sockets.SelectMode" /> 値。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 以下の「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロトコルの種類を取得、 <see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value>
          <see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A> 場合、プロパティが設定、 <xref:System.Net.Sockets.Socket> が作成されを使用するプロトコルを指定 <xref:System.Net.Sockets.Socket>します。  
  
   
  
## 例  
 次のコード例を表示、 <xref:System.Net.Sockets.AddressFamily>, 、<xref:System.Net.Sockets.SocketType>, 、および <xref:System.Net.Sockets.ProtocolType> コンソールにします。  
  
 [!code-cpp[Socket\_Socket\_Options\#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket\_Socket\_Options\#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket\_Socket\_Options\#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 、受信したデータの格納場所です。</param>
        <summary>バインドされたデータを受け取る <see cref="T:System.Net.Sockets.Socket" /> 受信バッファーにします。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドに buffer パラメータ データを読み取ります、正常に読み取られたバイト数を返します。 呼び出すことができます <xref:System.Net.Sockets.Socket.Receive%2A> 接続指向とコネクションレス ソケットの両方からです。  
  
 このオーバー ロードでは、受信バッファーを提供するだけです。 バッファーのオフセットの既定値は 0、サイズの既定値はバッファー パラメーターの長さと <xref:System.Net.Sockets.SocketFlags> 値の既定値は <xref:System.Net.Sockets.SocketFlags.None>です。  
  
 呼び出すか接続指向のプロトコルを使用している場合は <xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するために、または <xref:System.Net.Sockets.Socket.Accept%2A> を呼び出す前に着信接続を受け入れるように <xref:System.Net.Sockets.Socket.Receive%2A>します。<xref:System.Net.Sockets.Socket.Receive%2A> メソッドで定められているリモート ホストから受信するデータを読み取るだけが、 <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> により、すべてのホストから着信するデータを受信できます。  
  
 読み取り、可能なデータがない場合、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドがタイムアウト値を使用して設定されたデータが使用可能になるまでにブロック <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 <xref:System.Net.Sockets.Socket.Receive%2A> を <xref:System.Net.Sockets.SocketException>です。 非ブロッキング モードで使用可能なデータがない場合、プロトコル スタック バッファー、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、スロー、 <xref:System.Net.Sockets.SocketException>です。 使用することができます、 <xref:System.Net.Sockets.Socket.Available%2A> プロパティ データが読み取り可能かを判断します。<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合は、 <xref:System.Net.Sockets.Socket>, 、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、 <xref:System.Net.Sockets.Socket> との接続、 <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合は、 <xref:System.Net.Sockets.Socket>, 、<xref:System.Net.Sockets.Socket.Receive%2A> で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、 <xref:System.Net.Sockets.Socket.Connect%2A> メソッドです。 受信したデータグラムがのサイズより大きいかどうか、 `buffer` パラメーター、 `buffer` 設定します。 メッセージの最初の部分には余分なデータが失われると <xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例は、接続上のデータを受け取る <xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックに呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の <see cref="T:System.ArraySegment`1" />型の s <see cref="T:System.Byte" /> 、受信したデータを格納しています。</param>
        <summary>バインドされたデータを受け取る <see cref="T:System.Net.Sockets.Socket" /> 受信バッファーの一覧にします。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、バッファー パラメーターにデータを読み取りますを正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、どちらかを指定する必要がありますか、以上の受信バッファー。  
  
 呼び出すか接続指向のプロトコルを使用している場合は <xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するために、または <xref:System.Net.Sockets.Socket.Accept%2A> を呼び出す前に着信接続を受け入れるように <xref:System.Net.Sockets.Socket.Receive%2A>します。<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、リモート ホストでの接続確立から到着したデータを読み取るだけ、 <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> により、すべてのホストから着信するデータを受信できます。  
  
 読み取り、可能なデータがない場合、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドがタイムアウト値を使用して設定されたデータが使用可能になるまでにブロック <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 <xref:System.Net.Sockets.Socket.Receive%2A> を <xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるしで使用可能なデータがない場合、プロトコル スタック バッファー、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、スロー、 <xref:System.Net.Sockets.SocketException>です。 使用することができます、 <xref:System.Net.Sockets.Socket.Available%2A> プロパティ データが読み取り可能かを判断します。<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合は、 <xref:System.Net.Sockets.Socket>, 、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、 <xref:System.Net.Sockets.Socket> との接続、 <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合は、 <xref:System.Net.Sockets.Socket>, 、<xref:System.Net.Sockets.Socket.Receive%2A> で指定した宛先アドレスの最初のキューに登録されるデータグラムを読み取り、 <xref:System.Net.Sockets.Socket.Connect%2A> メソッドです。 受信したデータグラムがのサイズより大きいかどうか、 `buffers` パラメーター、 `buffers` 設定します。 メッセージの最初の部分には余分なデータが失われると <xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
 **注** このメンバーは、アプリケーションでネットワーク トレースを有効にした場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 、受信したデータの格納場所です。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>バインドされたデータを受け取る <see cref="T:System.Net.Sockets.Socket" /> 受信バッファーに指定して <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドに buffer パラメータ データを読み取ります、正常に読み取られたバイト数を返します。 呼び出すことができます [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> 接続指向とコネクションレス ソケットの両方からです。  
  
 このオーバー ロードだけ指定する必要が受信バッファーと、必要な [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags>です。 バッファーの既定値は 0、オフセット、サイズの既定値はバイト パラメーターの長さ。  
  
 呼び出すか接続指向のプロトコルを使用している場合は [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するために、または [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> を呼び出す前に着信接続を受け入れるように [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A>します。[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドで定められているリモート ホストから受信するデータを読み取るだけが、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> により、すべてのホストから着信するデータを受信できます。  
  
 読み取り、可能なデータがない場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。 非ブロッキング モードでは、プロトコル スタック バッファーできるデータがない場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 使用することができます、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> プロパティ データが読み取り可能かを判断します。[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、再試行、受信操作します。  
  
 接続指向を使用している場合は、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket>, 、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズの最大使用量のデータを読み取る。 リモート ホストがシャット ダウンした場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket> との接続、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合は、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket>, 、[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> で指定した宛先アドレスの最初のキューに登録されるデータグラムを読み取り、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドです。 受信したデータグラムがのサイズより大きいかどうか、 `buffer` パラメーター、 `buffer` 設定します。 メッセージの最初の部分には余分なデータが失われると [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  表示された場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例は、データ バッファーを指定し、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags> 接続上のデータを受信するため [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックに呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の <see cref="T:System.ArraySegment`1" />型の s <see cref="T:System.Byte" /> 、受信したデータを格納しています。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>バインドされたデータを受け取る <see cref="T:System.Net.Sockets.Socket" /> 受信バッファーのリストに指定して <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドにデータを読み込みます、 `buffers` パラメーターと正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、どちらかを指定する必要がありますか、以上の受信バッファー。<xref:System.Net.Sockets.SocketFlags> 値の既定値は <xref:System.Net.Sockets.SocketFlags.None>です。  
  
 呼び出すか接続指向のプロトコルを使用している場合は <xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するために、または <xref:System.Net.Sockets.Socket.Accept%2A> を呼び出す前に着信接続を受け入れるように <xref:System.Net.Sockets.Socket.Receive%2A>します。<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、リモート ホストでの接続確立から到着したデータを読み取るだけ、 <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> により、すべてのホストから着信するデータを受信できます。  
  
 読み取り、可能なデータがない場合、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドがタイムアウト値を使用して設定されたデータが使用可能になるまでにブロック <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 <xref:System.Net.Sockets.Socket.Receive%2A> スローされます、 <xref:System.Net.Sockets.SocketException>です。 非ブロッキング モードで使用可能なデータがない場合、プロトコル スタック バッファー、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、スロー、 <xref:System.Net.Sockets.SocketException>です。 使用することができます、 <xref:System.Net.Sockets.Socket.Available%2A> プロパティ データが読み取り可能かを判断します。<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合は、 <xref:System.Net.Sockets.Socket>, 、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、 <xref:System.Net.Sockets.Socket> との接続、 <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合は、 <xref:System.Net.Sockets.Socket>, 、<xref:System.Net.Sockets.Socket.Receive%2A> で指定した宛先アドレスの最初のキューに登録されるデータグラムを読み取り、 <xref:System.Net.Sockets.Socket.Connect%2A> メソッドです。 受信したデータグラムがのサイズより大きいかどうか、 `buffers` パラメーター、 `buffers` 設定します。 メッセージの最初の部分には余分なデータが失われると <xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、接続に関するデータを受け取る <xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="buffers" />.カウントは 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 、受信したデータの格納場所です。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したデータのバイト数をバインドから受け取る <see cref="T:System.Net.Sockets.Socket" /> 受信バッファーに指定して <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドにデータを読み込みます、 `buffer` パラメーターと正常に読み取られたバイト数を返します。 呼び出すことができます [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> 接続指向とコネクションレス ソケットの両方からです。  
  
 このオーバー ロードのみを必要とすると、受信バッファー、数バイトを受信して、必要な情報を提供 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags>します。  
  
 呼び出すか接続指向のプロトコルを使用している場合は [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するために、または [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> を呼び出す前に着信接続を受け入れるように [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A>します。[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドで定められているリモート ホストから受信するデータを読み取るだけが、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> により、すべてのホストから着信するデータを受信できます。  
  
 読み取り、可能なデータがない場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドがタイムアウト値を使用して設定されたデータが使用可能になるまでにブロック [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> を [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるしで使用可能なデータがない場合、プロトコル スタック バッファー、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、スロー、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 使用することができます、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> プロパティ データが読み取り可能かを判断します。[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、再試行、受信操作します。  
  
 接続指向を使用している場合は、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket>, 、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはバイト単位で指定された数まで使用可能な多くのデータを読み取る、 `size` パラメーター。 リモート ホストがシャット ダウンした場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket> との接続、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合は、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket>, 、[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドです。 受信したデータグラムがのサイズより大きいかどうか、 `buffer` パラメーター、 `buffer` 設定します。 メッセージの最初の部分には余分なデータが失われると [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  表示された場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次に検出されたデータを受信する `buffer`, を指定して [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.None> の [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags>です。  
  
 [!code-cpp[Socket\_Send\_Recieve\#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket\_Send\_Recieve\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket\_Send\_Recieve\#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> サイズを超える <paramref name="buffer" />します。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックに呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の <see cref="T:System.ArraySegment`1" />型の s <see cref="T:System.Byte" /> 、受信したデータを格納しています。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> ソケット エラーを格納するオブジェクト。</param>
        <summary>バインドされたデータを受け取る <see cref="T:System.Net.Sockets.Socket" /> 受信バッファーのリストに指定して <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドにデータを読み込みます、 `buffers` パラメーターと正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、どちらかを指定する必要がありますか、以上の受信バッファー。<xref:System.Net.Sockets.SocketFlags> 値の既定値は <xref:System.Net.Sockets.SocketFlags.None>です。  
  
 呼び出すか接続指向のプロトコルを使用している場合は <xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するために、または <xref:System.Net.Sockets.Socket.Accept%2A> を呼び出す前に着信接続を受け入れるように <xref:System.Net.Sockets.Socket.Receive%2A>します。<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、リモート ホストでの接続確立から到着したデータを読み取るだけ、 <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> により、すべてのホストから着信するデータを受信できます。  
  
 読み取り、可能なデータがない場合、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドがタイムアウト値を使用して設定されたデータが使用可能になるまでにブロック <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 <xref:System.Net.Sockets.Socket.Receive%2A> スローされます、 <xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるしで使用可能なデータがない場合、プロトコル スタック バッファー、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、スロー、 <xref:System.Net.Sockets.SocketException>です。 使用することができます、 <xref:System.Net.Sockets.Socket.Available%2A> プロパティ データが読み取り可能かを判断します。<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合は、 <xref:System.Net.Sockets.Socket>, 、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、 <xref:System.Net.Sockets.Socket> との接続、 <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合は、 <xref:System.Net.Sockets.Socket>,、<xref:System.Net.Sockets.Socket.Receive%2A> で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、 <xref:System.Net.Sockets.Socket.Connect%2A> メソッドです。 受信したデータグラムがのサイズより大きいかどうか、 `buffers` パラメーター、 `buffers` 設定します。 メッセージの最初の部分には余分なデータが失われると <xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。  
  
 または  
  
 <paramref name="buffers" />.カウントは 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセス中にエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 受信したデータの格納場所です。</param>
        <param name="offset">内の場所 <c>buffer</c> を受信したデータを格納します。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したバイト数をバインドから受信 <see cref="T:System.Net.Sockets.Socket" /> 受信バッファーの指定したオフセット位置に指定して <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドに buffer パラメータ データを読み取ります、正常に読み取られたバイト数を返します。 呼び出すことができます [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> 接続指向とコネクションレス ソケットの両方からです。  
  
 呼び出すか接続指向のプロトコルを使用している場合は [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するために、または [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> を呼び出す前に着信接続を受け入れるように [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A>します。[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドで定められているリモート ホストから受信するデータを読み取るだけが、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> により、すべてのホストから着信するデータを受信できます。  
  
 読み取り、可能なデータがない場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドがタイムアウト値を使用して設定されたデータが使用可能になるまでにブロック [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> を [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 非ブロッキング モードで使用可能なデータがない場合、プロトコル スタック バッファー、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、スロー、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 ソケットにアクセスしようとして、エラーが発生しました。 以下の「解説」を参照してください。 使用することができます、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> プロパティ データが読み取り可能かを判断します。[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合は、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket>, 、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドがサイズ パラメーターで指定したバイトの数までの使用可能な量のデータを読み取る。 リモート ホストがシャット ダウンした場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket> との接続、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合は、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket>, 、[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドです。 受信したデータグラムがのサイズより大きいかどうか、 `buffer` パラメーター、 `buffer` 設定します。 メッセージの最初の部分には余分なデータが失われると [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  表示された場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では接続上のデータを受信する前にデータ バッファー、オフセット、サイズ、およびソケット フラグが指定 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さより大きい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" /> の値を差し引いて、 <paramref name="offset" /> パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 有効値の組み合わせではありません。  
  
 または  
  
 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティは設定されませんでした。  
  
 または  
  
 アクセス中には、オペレーティング システム エラーが発生した、 <see cref="T:System.Net.Sockets.Socket" />です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックに呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 、受信したデータの格納場所です。</param>
        <param name="offset">内の位置、 <c>buffer</c> を受信したデータを格納します。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> ソケット エラーを格納するオブジェクト。</param>
        <summary>バインドされたデータを受け取る <see cref="T:System.Net.Sockets.Socket" /> 受信バッファーに指定して <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドに buffer パラメータ データを読み取ります、正常に読み取られたバイト数を返します。 呼び出すことができます [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> 接続指向とコネクションレス ソケットの両方からです。  
  
 呼び出すか接続指向のプロトコルを使用している場合は [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するために、または [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> を呼び出す前に着信接続を受け入れるように [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A>、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドで定められているリモート ホストから受信するデータを読み取るだけが、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> により、すべてのホストから着信するデータを受信できます。  
  
 読み取り、可能なデータがない場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドがタイムアウト値を使用して設定されたデータが使用可能になるまでにブロック [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> を [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 非ブロッキング モードで使用可能なデータがない場合、プロトコル スタック バッファー、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、スロー、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 ソケットにアクセスしようとして、エラーが発生しました。 以下の「解説」を参照してください。 使用することができます、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> プロパティ データが読み取り可能かを判断します。[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合は、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket>, 、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドがサイズ パラメーターで指定したバイトの数までの使用可能な量のデータを読み取る。 リモート ホストがシャット ダウンした場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket> との接続、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合は、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket>, 、[Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Receive%2A> で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドです。 受信したデータグラムがのサイズより大きいかどうか、 `buffer` パラメーター、 `buffer` 設定します。 メッセージの最初の部分には余分なデータが失われると [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  表示された場合、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [Receive メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さより大きい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" /> の値を差し引いて、 <paramref name="offset" /> パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 有効値の組み合わせではありません。  
  
 または  
  
 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていません。  
  
 または  
  
 アクセス中には、オペレーティング システム エラーが発生した、 <see cref="T:System.Net.Sockets.Socket" />です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックに呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>接続からデータを受信する非同期要求を開始 <see cref="T:System.Net.Sockets.Socket" /> オブジェクトです。</summary>
        <returns>返します。 <see langword="true" /> I\/O 操作が保留中の場合。<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターが操作の完了時に発生します。  
  
 返します。 <see langword="false" /> 場合は、I\/O 操作が同期的に完了します。 ここで、 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターは発生しません、 <paramref name="e" /> 操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドが使用されるソケットまたはバインドされたコネクションレス型のソケット接続し、着信データを読み取るために使用します。 ソケットのローカル アドレスが認識されている必要があります。  
  
 コネクションレス型ソケットのバインドされている場合は、この関数は、受信したメッセージは受け入れ元となるアドレスを制限します。 関数には、接続で指定されたリモート アドレスからのメッセージのみを返します。 その他のアドレスからのメッセージが自動的に破棄されます。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> プロパティを `e` パラメーターが読み取り要求に関する追加情報\] ウィンドウのソケットのサービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。 <xref:System.Net.Sockets.SocketFlags?displayProperty=fullName>します。  
  
 次のプロパティおよびイベントに、 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> オブジェクトがこのメソッドを呼び出すことが必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> 場合 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> 設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> 場合 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> 設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  
  
 呼び出し元の設定、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> プロパティを呼び出す前に必要なユーザーの状態オブジェクト、 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 バイト ストリーム スタイルのソケットの受信データは、バッファーが満杯に、接続を終了すると、または内部バッファー内のデータがなくなるまで、バッファーに配置されます。  
  
 受信メッセージの配置に関連付けられているバッファーの合計サイズの最大のバッファーにメッセージ指向のソケット、 `e` パラメーター。 メッセージがバッファーよりも大きい場合は、バッファーには、メッセージの最初の部分が格納されます。  
  
 接続指向のソケット、 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドは、ソケットは、バイト ストリームまたはメッセージ指向かどうかに依存する 2 つの方法のいずれかで仮想回線の正常終了を示すことができます。 バイト ストリームでは、既読 0 バイトは、正常に閉じられたあり、以上のバイトを読むことを示します。 ここで、ゼロ バイトのメッセージでは、多くの場合、使用、メッセージ指向のソケットの場合、 <xref:System.Net.Sockets.SocketException> で、 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> ネイティブ Winsock WSAEDISCON エラー コード \(10101\) に設定が正常に閉じられたを示すために使用します。 いずれの場合、 <xref:System.Net.Sockets.SocketException> で、 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> ネイティブ Winsock WSAECONNRESET に設定エラー コード \(10054\) を示す異常終了が発生しました。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が無効です。<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> または <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティを <paramref name="e" /> パラメーターが有効なバッファーを参照する必要があります。 セットが、同時に両方のいずれか、またはこれらのプロパティの他の可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> で指定されたオブジェクト、 <paramref name="e" /> パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降がこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の受信バッファーのサイズを指定する値、 <see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value>
          <see cref="T:System.Int32" /> 受信バッファーのバイト単位のサイズを格納します。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 可能性のあるより大きなバッファー サイズは、空の受信確認 \(データ部分を持たないと TCP パケット\) の数が減るは、接続に関する問題を認識を遅らせるも可能性があります。 サイズの大きなファイルを転送するか、高帯域幅、衛星ブロード バンド プロバイダーです。\) などの高待機時間の接続を使用している場合は、バッファー サイズを増やすことを検討してください。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">セット操作に指定された値は、0 より小さい値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 受信したデータの格納場所です。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, 、リモート サーバーを表す参照によって渡されます。</param>
        <summary>データ バッファーにデータグラムを受信し、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドにデータを読み込みます、 `buffer` パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバー ロードだけ指定する必要が受信 `buffer`, 、および [ReceiveFrom メソッド \(Byte\<xref:System.Net.EndPoint> リモート ホストを表します。 バッファーのオフセットの既定値は 0 です。 サイズの既定値の長さ、 `buffer` パラメーターおよび `socketFlags` 値の既定値は [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.None>です。  
  
> [!NOTE]
>  呼び出しの前に [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, 、明示的にバインドする必要があります、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> を使用して、ローカル エンドポイントに、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> メソッドです。 そうしない場合 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> をスローする [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。  
  
 コネクションレスのプロトコルで [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> はローカル ネットワーク バッファーに書き込まれる最初のキューに登録されるデータグラムを読み取ります。 受信したデータグラムがのサイズより大きいかどうか `buffer`, 、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが入力 `buffer` は throw であり、可能なメッセージの多くで、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、超過データは失われます。 信頼性の高いプロトコルを使用するいるし、超過データは、サービス プロバイダーによって保持されるを呼び出して取得することができます、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> のに十分な大きさのバッファーを持つメソッドです。  
  
 読み取り、可能なデータがない場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはデータが使用可能になるまでブロックします。 モードの非ブロッキングであるしで使用可能なデータがない場合、プロトコル スタック バッファー、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはすぐに完了し、スロー、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 使用することができます、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> プロパティ データが読み取り可能かを判断します。[ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行してください。  
  
 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、コネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、必要があります最初か、リモート ホスト接続を確立するを呼び出して、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドか着信リモートをそのまま使用を呼び出して接続をホスト、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 確立したり、呼び出しの前に接続を許可しない場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 取得は、メソッド、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。 このような場合は、のいずれかで、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは無視されます、 `remoteEP` パラメーターのみから、接続されているデータや既定のリモート ホストを受信します。  
  
 接続指向のソケットと [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> のサイズの最大使用量のデータを読み取る `buffer`します。 リモート ホストがシャット ダウンした場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> との接続、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  表示された場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.AddressFamily> の [ReceiveFrom メソッド \(Byte\<xref:System.Net.EndPoint> で使用される [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> と一致する必要がある、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.AddressFamily> の [ReceiveFrom メソッド \(Byte\<xref:System.Net.EndPoint> で使用される [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、リモート ホストからコネクションレスのデータグラムを受信します。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックに呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 、受信したデータの格納場所です。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, 、リモート サーバーを表す参照によって渡されます。</param>
        <summary>指定して、データ バッファーのデータグラムを受信 <see cref="T:System.Net.Sockets.SocketFlags" />, 、し、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドにデータを読み込みます、 `buffer` パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバー ロードだけ指定する必要が受信バッファーで、必要な [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags>, 、および [ReceiveFrom メソッド \(Byte\<xref:System.Net.EndPoint> リモート ホストを表します。 オフセットの既定値 0、サイズの既定値はバッファー パラメーターの長さ。  
  
> [!NOTE]
>  呼び出しの前に [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, 、明示的にバインドする必要があります、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> を使用して、ローカル エンドポイントに、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> メソッドです。 そうしない場合 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> をスローする [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。  
  
 コネクションレスのプロトコルで [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> はローカル ネットワーク バッファーに書き込まれる最初のキューに登録されるデータグラムを読み取ります。 受信したデータグラムがのサイズより大きいかどうか `buffer`, 、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが入力 `buffer` は throw であり、可能なメッセージの多くで、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、超過データは失われます。 信頼性の高いプロトコルを使用するいるし、超過データは、サービス プロバイダーによって保持されるを呼び出して取得することができます、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> のに十分な大きさのバッファーを持つメソッドです。  
  
 読み取り、可能なデータがない場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはデータが使用可能になるまでブロックします。 モードの非ブロッキングであるしで使用可能なデータがない場合、プロトコル スタック バッファー、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはすぐに完了し、スロー、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 使用することができます、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> プロパティ データが読み取り可能かを判断します。[ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行してください。  
  
 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、コネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、必要があります最初か、リモート ホスト接続を確立するを呼び出して、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドか着信リモートをそのまま使用を呼び出して接続をホスト、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 確立したり、呼び出しの前に接続を許可しない場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 取得は、メソッド、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。 このような場合は、のいずれかで、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは無視されます、 `remoteEP` パラメーターのみから、接続されているデータや既定のリモート ホストを受信します。  
  
 接続指向のソケットと [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> のサイズの最大使用量のデータを読み取る `buffer`します。 リモート ホストがシャット ダウンした場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> との接続、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  表示された場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.AddressFamily> の [ReceiveFrom メソッド \(Byte\<xref:System.Net.EndPoint> で使用される [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> と一致する必要がある、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.AddressFamily> の [ReceiveFrom メソッド \(Byte\<xref:System.Net.EndPoint> で使用される [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、リモート ホストからコネクションレスのデータグラムを受信します。[ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags> 渡される、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックに呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 受信したデータの格納場所です。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, 、リモート サーバーを表す参照によって渡されます。</param>
        <summary>指定したバイト数を指定して、データ バッファーに受け取る <see cref="T:System.Net.Sockets.SocketFlags" />, 、し、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドにデータを読み込みます、 `buffer` パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバー ロードだけ指定する必要が必要なを受信するバイト数、受信バッファー [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags>, 、および [ReceiveFrom メソッド \(Byte\<xref:System.Net.EndPoint> リモート ホストを表します。 バッファーのオフセットの既定値は 0 です。  
  
 コネクションレスのプロトコルで [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> はローカル ネットワーク バッファーに書き込まれる最初のキューに登録されるデータグラムを読み取ります。 受信したデータグラムがのサイズより大きいかどうか `buffer`, 、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが入力 `buffer` は throw であり、可能なメッセージの多くで、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、超過データは失われます。 信頼性の高いプロトコルを使用するいるし、超過データは、サービス プロバイダーによって保持されるを呼び出して取得することができます、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> のに十分な大きさのバッファーを持つメソッドです。  
  
 読み取り、可能なデータがない場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはデータが使用可能になるまでブロックします。 モードの非ブロッキングであるしで使用可能なデータがない場合、プロトコル スタック バッファー、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはすぐに完了し、スロー、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 使用することができます、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> プロパティ データが読み取り可能かを判断します。[ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> 0 以外の場合は、受信操作を再試行してください。  
  
 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、コネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、必要があります最初か、リモート ホスト接続を確立するを呼び出して、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドか着信リモートをそのまま使用を呼び出して接続をホスト、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 確立したり、呼び出しの前に接続を許可しない場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 取得は、メソッド、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。 このような場合は、のいずれかで、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは無視されます、 `remoteEP` パラメーターのみから、接続されているデータや既定のリモート ホストを受信します。  
  
 接続指向のソケットと [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> できるだけ多くのデータを使用して指定されたバイト数を読み取り、 `size` パラメーター。 リモート ホストがシャット ダウンした場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> との接続、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Shutdown%2A> メソッド、および使用可能なすべてのデータを受信、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  呼び出しの前に [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, 、明示的にバインドする必要があります、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> を使用して、ローカル エンドポイントに、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> メソッドです。 そうしない場合 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> をスローする [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 表示された場合、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.AddressFamily> の [ReceiveFrom メソッド \(Byte\<xref:System.Net.EndPoint> で使用される [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> と一致する必要がある、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.AddressFamily> の [ReceiveFrom メソッド \(Byte\<xref:System.Net.EndPoint> で使用される [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、リモート ホストからコネクションレスのデータグラムを受信します。 バッファー サイズと [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags> に渡される、 [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドです。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" />します。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 有効値の組み合わせではありません。  
  
 または  
  
 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティは設定されませんでした。  
  
 または  
  
 アクセス中には、オペレーティング システム エラーが発生した、 <see cref="T:System.Net.Sockets.Socket" />です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックに呼び出し元には、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<c>buffer</c> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを受信して、データ バッファー内の指定した位置に格納します。またエンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the **parameterReference tag is not supported!!!!**  
 parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.  
  
 With connectionless protocols, [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of **parameterReference tag is not supported!!!!**  
, the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill **parameterReference tag is not supported!!!!**  
 with as much of the message as is possible, and throw a [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.  
  
 If no data is available for reading, the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non\-blocking mode, and there is no data available in the in the protocol stack buffer, the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>. You can use the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Available%2A> is non\-zero, retry the receive operation.  
  
 Although [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection\-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the **parameterReference tag is not supported!!!!**  
 parameter and only receive data from the connected or default remote host.  
  
 With connection\-oriented sockets, [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the **parameterReference tag is not supported!!!!**  
 parameter. If the remote host shuts down the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> connection with the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.  
  
> [!NOTE]
>  Before calling [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket> to a local endpoint using the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>. If you receive a [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, use the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  
  
> [!NOTE]
>  The [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.AddressFamily> of the [ReceiveFrom メソッド \(Byte\<xref:System.Net.EndPoint> used in [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the[ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.AddressFamily> of the [ReceiveFrom メソッド \(Byte\<xref:System.Net.EndPoint> used in [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  This member outputs trace information when you enable network tracing in your application. For more information, see [&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## 例  
 The following code example receives a connectionless datagram from a remote host. The offset, buffer size, and [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags> are passed to the [ReceiveFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> が、<paramref name="buffer" /> の長さからオフセット パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
 または  
  
 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されませんでした。  
  
 または  
  
 ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>指定されたネットワーク デバイスからデータを非同期的に受信を開始します。</summary>
        <returns>返します。 <see langword="true" /> I\/O 操作が保留中の場合。<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターが操作の完了時に発生します。  
  
 返します。 <see langword="false" /> 場合は、I\/O 操作が同期的に完了します。 ここで、 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターは発生しません、 <paramref name="e" /> 操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> コネクションレス型のソケット上のデータを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスが認識されている必要があります。  
  
 呼び出し元を設定する必要があります、 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> プロパティを <xref:System.Net.IPEndPoint> データの受信元となるリモート ホストのです。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> プロパティを `e` パラメーターが読み取り要求に関する追加情報\] ウィンドウのソケットのサービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。 <xref:System.Net.Sockets.SocketFlags?displayProperty=fullName>します。  
  
 次のプロパティおよびイベントに、 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> オブジェクトがこのメソッドを呼び出すことが必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  
  
 呼び出し元の設定、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> プロパティを呼び出す前に必要なユーザーの状態オブジェクト、 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 メッセージ指向のソケットでは、受信メッセージは、バッファーの合計サイズの最大のバッファーに置かれます。<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> と <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> プロパティは、バッファー内のデータが配置されていると、データの量を決定します。  
  
 バイト ストリーム – スタイルのソケットの受信データは、バッファーが満杯に、接続を終了すると、または内部バッファー内のデータがなくなるまで、バッファーに配置されます。<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> と <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> プロパティは、バッファー内のデータが配置されていると、データの量を決定します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Null にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> で指定されたオブジェクト、 <paramref name="e" /> パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降がこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, valuetype System.Net.Sockets.IPPacketInformation ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 受信したデータの格納場所です。</param>
        <param name="offset">内の位置、 <c>buffer</c> を受信したデータを格納します。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />, 、リモート サーバーを表す参照によって渡されます。</param>
        <param name="ipPacketInformation">
          <see cref="T:System.Net.Sockets.IPPacketInformation" /> アドレスとインターフェイスの情報を保持します。</param>
        <summary>指定したデータのバイト数を指定して、データ バッファーの指定した場所に受信 <see cref="T:System.Net.Sockets.SocketFlags" />, 、エンドポイントとパケット情報を保存しています。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドにデータを読み込みます、 `buffer` パラメーターが正常に読み取られたバイト数を返し、データの送信元、受信したパケットに関する情報に加えて、リモート ホストのエンドポイントをキャプチャします。  
  
 [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> コネクションレス ソケットでのメッセージ データを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスが認識されている必要があります。 このメソッドは、データグラム チャネルと raw ソケットでのみ使用できます。 ソケットの初期化、ソケットの種類に設定してください [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketType.Dgram> または [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketType.Raw> このメソッドを呼び出す前にします。 これを使用して、ソケットを作成するとき [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.%23ctor%2A>します。  
  
 メッセージ指向のソケットでは、受信メッセージに配置、 `buffer` パラメーターで指定された合計サイズに達するまで、 `size` パラメーター。`offset` パラメーター内の場所を決定する、 `buffer` データが配置されます。 実際のデータ量が実、 `buffer` によって返される、 [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドです。  
  
 [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドに自動的にメソッドを設定、 [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketOptionName.PacketInformation> ソケット オプションに `true` で呼び出された最初に、指定された [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket>します。 ただし、返された [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.IPPacketInformation> オブジェクトのみ有効になりますパケットのソケット オプションが設定された後に、ローカル コンピューターに到達します。 ローカル エンドポイントにバインドされているときに、ソケットの間でパケットが送信する場合 \(によって明示的に、 [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> メソッドまたはのいずれかで暗黙的に、 [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>, 、[ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 、[ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>, 、または [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッド\) と、最初の呼び出し、 [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドの呼び出しに [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドは無効な [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.IPPacketInformation> これらのパケットのオブジェクト。  
  
 確実にすべて [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.IPPacketInformation> オブジェクトが有効で、アプリケーションを設定する必要があります、 [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.SocketOptionName.PacketInformation> ソケット オプションに `true` を使用して、ローカル エンドポイントにバインドされる前に、 [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> メソッドです。  
  
 アプリケーションを調べることが、 `ipPacketInformation` パラメーターの場合は、ユニキャスト、マルチキャストまたはブロードキャスト アドレスを使用して、データグラムが送信されたかを知る必要があります。  
  
> [!NOTE]
>  [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.AddressFamily> の [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.EndPoint> で使用される [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> と一致する必要がある、 [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.AddressFamily> の [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.EndPoint> で使用される [ReceiveMessageFrom メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \- または \-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さより大きい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい、 <paramref name="buffer" /> オフセット パラメーターの値を減算します。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 有効値の組み合わせではありません。  
  
 または  
  
 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティは設定されませんでした。  
  
 または  
  
 .NET Framework は、AMD 64 ビット プロセッサで実行されています。  
  
 または  
  
 ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">オペレーティング システムが Windows 2000 以前のバージョン、およびこのメソッドには、Windows XP が必要です。</exception>
        <permission cref="T:System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>指定したデータのバイト数を指定して、データ バッファー内の指定した場所に非同期的に受信開始 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, 、し、エンドポイントとパケット情報を格納します。</summary>
        <returns>返します。 <see langword="true" /> I\/O 操作が保留中の場合。<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターが操作の完了時に発生します。  
  
 返します。 <see langword="false" /> 場合は、I\/O 操作が同期的に完了します。 ここで、 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターは発生しません、 <paramref name="e" /> 操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> コネクションレス ソケットでのメッセージ データを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスが認識されている必要があります。 このメソッドは、データグラム チャネルと raw ソケットでのみ使用できます。 ソケットの初期化、ソケットの種類に設定してください <xref:System.Net.Sockets.SocketType.Dgram> または <xref:System.Net.Sockets.SocketType.Raw> このメソッドを呼び出す前にします。 これを使用して、ソケットを作成するとき <xref:System.Net.Sockets.Socket.%23ctor%2A>します。  
  
 呼び出し元を設定する必要があります、 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> プロパティを <xref:System.Net.IPEndPoint> データの受信元となるリモート ホストのです。  
  
 次のプロパティおよびイベントに、 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> オブジェクトがこのメソッドを呼び出すことが必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  
  
 呼び出し元の設定、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> プロパティを呼び出す前に必要なユーザーの状態オブジェクト、 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 メッセージ指向のソケットでは、受信メッセージは、バッファーの合計サイズの最大のバッファーに置かれます。<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> と <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> プロパティは、バッファー内のデータが配置されていると、データの量を決定します。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドが自動的に設定、 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> ソケット オプションに `true` で呼び出された最初に、指定された <xref:System.Net.Sockets.Socket>します。 ただし、 <xref:System.Net.Sockets.IPPacketInformation> オブジェクトのみ有効になりますパケットのソケット オプションが設定された後に、ローカル コンピューターに到達します。 ソケットがローカル エンドポイントにバインドされている場合、ソケットの間でパケットが送信する場合 \(によって明示的に、 <xref:System.Net.Sockets.Socket.Bind%2A> メソッドまたはのいずれかで暗黙的に、 <xref:System.Net.Sockets.Socket.Connect%2A>, 、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>, 、<xref:System.Net.Sockets.Socket.SendTo%2A>, 、または <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッド\) と最初の呼び出し、 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドの呼び出しに <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドと、無効な <xref:System.Net.Sockets.IPPacketInformation> これらのパケットのオブジェクト。  
  
 確実にすべて <xref:System.Net.Sockets.IPPacketInformation> オブジェクトが有効で、アプリケーションを設定する必要があります、 <xref:System.Net.Sockets.SocketOptionName.PacketInformation> ソケット オプションに`true` を使用して、ローカル エンドポイントにバインドされる前に、 <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> メソッドです。  
  
 アプリケーションは、その結果を調べることができます <xref:System.Net.Sockets.IPPacketInformation> ユニキャスト、マルチキャストまたはブロードキャスト アドレスを使用して、データグラムが送信されたかの情報が必要なかどうかのオブジェクトします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Null にすることはできません。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降がこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得するまでの時間を指定する値を設定または同期 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 呼び出しがタイムアウトになります。</summary>
        <value>タイムアウト値 \(ミリ秒\)。 既定値は、タイムアウト期間が無限を示す 0 です。 \-1 を指定するには、タイムアウト期間が無限も示されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオプションを適用する同期 <xref:System.Net.Sockets.Socket.Receive%2A> 呼び出しのみです。 タイムアウト期間を超えた場合、 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドをスロー、 <xref:System.Net.Sockets.SocketException>です。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">セット操作に指定された値は、\-1 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモートのエンドポイントを取得します。</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> いる、 <see cref="T:System.Net.Sockets.Socket" /> が通信しています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> プロパティを取得、 <xref:System.Net.EndPoint> するリモート IP アドレスとポート番号が含まれる、 <xref:System.Net.Sockets.Socket> が接続されています。 コネクションレスのプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> が既定のリモート IP アドレスとポート番号が含まれています、 <xref:System.Net.Sockets.Socket> と通信します。 これをキャストする必要があります <xref:System.Net.EndPoint> に、 <xref:System.Net.IPEndPoint> すべての情報を取得する前にします。 呼び出すことができます、 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> リモコンを取得するメソッドを <xref:System.Net.IPAddress>, 、および <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> リモート ポート番号を取得します。  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> いずれかを呼び出した後に設定されている <xref:System.Net.Sockets.Socket.Accept%2A> または <xref:System.Net.Sockets.Socket.Connect%2A>です。 前の手順では、このプロパティにアクセスしようとする場合 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> をスローする <xref:System.Net.Sockets.SocketException>です。 表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例を取得し、ローカルおよびリモートのエンドポイントを表示します。  
  
 [!code-cpp[Socket\_Socket\_Options\#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket\_Socket\_Options\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket\_Socket\_Options\#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">読みやすさを確認する <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite">書きやすさを確認する <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="checkError">エラーを確認する <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="microSeconds">タイムアウト値 \(ミリ秒\)。 値が \-1 の場合は、タイムアウトが無限であることを示します。</param>
        <summary>1 つまたは複数のソケットのステータスを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.Select%2A>1 つまたは複数のステータスを決定する静的メソッドは、<xref:System.Net.Sockets.Socket>インスタンス。 1 つまたは複数のソケットを配置する必要があります、<xref:System.Collections.IList>使用する前に、<xref:System.Net.Sockets.Socket.Select%2A>メソッドです。 読みやすさを呼び出して確認<xref:System.Net.Sockets.Socket.Select%2A>で、<xref:System.Collections.IList>として、`checkRead`パラメーター。 確認するには、どうを使用して、`checkWrite`のパラメーターです。 エラー条件を検出するため使用`checkError`です。 呼び出した後<xref:System.Net.Sockets.Socket.Select%2A>、<xref:System.Collections.IList>の条件を満たすソケットのみが格納されます。  
  
 リッスン状態の場合は、読みやすくすることを意味する呼び出し<xref:System.Net.Sockets.Socket.Accept%2A>ブロックすることがなくは成功します。 接続を受け入れている場合読みやすさはデータの読み取りに使用されます。 このような場合は、すべての受信操作はブロックすることがなく成功します。 読みやすくすることもあるかどうか、リモート<xref:System.Net.Sockets.Socket>がシャット ダウン接続以外の場合はそのケースへの呼び出し<xref:System.Net.Sockets.Socket.Receive%2A>は返されたゼロのバイト数で、すぐに戻ります。  
  
 <xref:System.Net.Sockets.Socket.Select%2A>ときに返されます関心のあるソケットの少なくとも 1 つ \(におけるソケット、 `checkRead`、 `checkWrite`、および`checkError`一覧表示\)、指定した条件を満たすまたは`microSeconds`パラメーターを超過すると、どちらか早い方です。 設定`microSeconds`を\-1 に無限のタイムアウトを指定します。  
  
 非ブロッキング呼び出しを行う場合<xref:System.Net.Sockets.Socket.Connect%2A>、書き込みの許可が正常に接続していることを意味します。 確立された接続がある場合、書き込みの許可は、すべての送信操作はブロックすることがなく成功を意味します。  
  
 非ブロッキング呼び出しを行ったかどうか<xref:System.Net.Sockets.Socket.Connect%2A>、`checkerror`パラメーターが正常に接続されていないソケットを識別します。  
  
> [!NOTE]
>  使用して、<xref:System.Net.Sockets.Socket.Poll%2A>メソッドの場合は、1 つの状態を判別する<xref:System.Net.Sockets.Socket>です。  
  
> [!NOTE]
>  このメソッドは、切断されたネットワーク ケーブルなどの接続に関する問題の特定の種類を検出できないか、リモート ホストが異常停止しました。 このようなエラーを検出するためにデータの送受信を送信しようとする必要があります。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョンに 2 API エラー コードのドキュメント、MSDN ライブラリについて参照エラーの詳細な説明。  
  
   
  
## 例  
 次のコード例では<xref:System.Net.Sockets.Socket.Select%2A>接続要求をリッスンしているソケットを決定します。  
  
 [!code-cpp[Socket\_Select\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket\_Select\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket\_Select\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="checkRead" /> パラメーターは <see langword="null" /> または空です。  
  
 および  
  
 <paramref name="checkWrite" /> パラメーターは <see langword="null" /> または空です。  
  
 および  
  
 <paramref name="checkError" /> パラメーターは <see langword="null" /> または空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 送信されるデータが含まれています。</param>
        <summary>接続されたデータを送信 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
        <returns>送信されたバイト数、 <see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.Send%2A> 指定されたリモート ホストにデータを同期的に送信、 <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドと正常に送信されたバイトの数を返します。<xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 このオーバー ロードには、送信するデータを格納しているバッファーが必要です。<xref:System.Net.Sockets.SocketFlags> を 0 に既定値として、バッファーのオフセットの既定値は 0、およびバッファーのサイズを既定値を送信するバイト数。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります <xref:System.Net.Sockets.Socket.Connect%2A> このメソッドを呼び出す前に、または <xref:System.Net.Sockets.Socket.Send%2A> をスロー、 <xref:System.Net.Sockets.SocketException>です。 接続指向のプロトコルを使用している場合を使用する必要があります <xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するかを使用して <xref:System.Net.Sockets.Socket.Accept%2A> 着信接続を受け入れるようにします。  
  
 使用する必要がありますデータを複数の異なるホストに送信するためのコネクションレスのプロトコルと計画を使用している場合、 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。 使用しない場合、 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す必要は <xref:System.Net.Sockets.Socket.Connect%2A> への各呼び出しの前に <xref:System.Net.Sockets.Socket.Send%2A>します。 使用する <xref:System.Net.Sockets.Socket.SendTo%2A> で既定のリモート ホストを確立した後でも <xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に既定のリモート ホストを変更することもできます。 <xref:System.Net.Sockets.Socket.Send%2A> 別の呼び出しを行うことによって <xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.Send%2A> を使用して、タイムアウトが設定されたしない限り、すべてのバッファー内のバイトが送信されるまでブロックされます <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 <xref:System.Net.Sockets.Socket.Send%2A> を <xref:System.Net.Sockets.SocketException>です。 非ブロッキング モードで <xref:System.Net.Sockets.Socket.Send%2A> バッファーの送信バイト数よりも少ない場合でも正常に完了可能性があります。 送信されたバイト数を追跡して、アプリケーションは、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 <xref:System.Net.Sockets.Socket.Send%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets のバージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例に示しますに接続されたデータの送信 <xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の <see cref="T:System.ArraySegment`1" />型の s <see cref="T:System.Byte" /> 送信されるデータを格納しています。</param>
        <summary>接続された一連のバッファーは、リストに <see cref="T:System.Net.Sockets.Socket" />します。</summary>
        <returns>送信されたバイト数、 <see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります <xref:System.Net.Sockets.Socket.Connect%2A> このメソッドを呼び出す前に、または <xref:System.Net.Sockets.Socket.Send%2A> をスロー、 <xref:System.Net.Sockets.SocketException>です。 接続指向のプロトコルを使用している場合を使用する必要があります <xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するかを使用して <xref:System.Net.Sockets.Socket.Accept%2A> 着信接続を受け入れるようにします。  
  
 使用する必要がありますデータを複数の異なるホストに送信するためのコネクションレスのプロトコルと計画を使用している場合、 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。 使用しない場合、 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す必要は <xref:System.Net.Sockets.Socket.Connect%2A> への各呼び出しの前に <xref:System.Net.Sockets.Socket.Send%2A>します。 使用する <xref:System.Net.Sockets.Socket.SendTo%2A> で既定のリモート ホストを確立した後でも <xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に既定のリモート ホストを変更することもできます。 <xref:System.Net.Sockets.Socket.Send%2A> 別の呼び出しを行うことによって <xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.Send%2A> を使用して、タイムアウトが設定されたしない限り、すべてのバッファー内のバイトが送信されるまでブロックされます <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 <xref:System.Net.Sockets.Socket.Send%2A> を <xref:System.Net.Sockets.SocketException>です。 非ブロッキング モードで <xref:System.Net.Sockets.Socket.Send%2A> バッファーの送信バイト数よりも少ない場合でも正常に完了可能性があります。 送信されたバイト数を追跡して、アプリケーションは、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 <xref:System.Net.Sockets.Socket.Send%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets のバージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 送信されるデータが含まれています。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>接続されたデータを送信 <see cref="T:System.Net.Sockets.Socket" /> 指定して <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>送信されたバイト数、 <see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> 定められているリモート ホストにデータを同期的に送信、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドと正常に送信されたバイトの数を返します。[Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス プロトコルの両方のメソッドを使用できます。  
  
 このオーバー ロードは、送信するデータを含むバッファーとビットごとの組み合わせが必要です。 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags>します。 バッファーは、既定値は 0、およびバッファーのサイズを既定値を送信するバイト数をオフセットします。 指定した場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketflags` パラメーターの値、ルーティングされなくなるを送信するデータを取得します。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> このメソッドを呼び出す前に、または [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> をスロー、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 接続指向のプロトコルを使用している場合を使用する必要があります [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するかを使用して [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> 着信接続を受け入れるようにします。  
  
 使用する必要がありますデータを複数の異なるホストに送信するためのコネクションレスのプロトコルと計画を使用している場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。 使用しない場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す必要は、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドに対する各呼び出しの前に [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A>します。 使用する [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> で既定のリモート ホストを確立した後でも [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に既定のリモート ホストを変更することもできます。 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> 別の呼び出しを行うことによって [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向のプロトコルを使用している場合 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> を使用して、タイムアウトが設定されたしない限り、すべてのバッファー内のバイトが送信されるまでブロックされます [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> を [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 非ブロッキング モードで [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> バッファーの送信バイト数よりも少ない場合でも正常に完了可能性があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  バッファーのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要があります。 場合は、データグラムが送信されず、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> をスロー、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 表示された場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets のバージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)します。  
  
   
  
## 例  
 次のコード例に示しますに接続されたデータの送信 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の <see cref="T:System.ArraySegment`1" />型の s <see cref="T:System.Byte" /> 送信されるデータを格納しています。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>接続された一連のバッファーは、リストに <see cref="T:System.Net.Sockets.Socket" />, を指定して <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>送信されたバイト数、 <see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。<xref:System.Net.Sockets.SocketFlags> 値の既定値は 0 です。 指定した場合、 <xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketFlags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります <xref:System.Net.Sockets.Socket.Connect%2A> このメソッドを呼び出す前に、または <xref:System.Net.Sockets.Socket.Send%2A> をスロー、 <xref:System.Net.Sockets.SocketException>です。 接続指向のプロトコルを使用している場合を使用する必要があります <xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するかを使用して <xref:System.Net.Sockets.Socket.Accept%2A> 着信接続を受け入れるようにします。  
  
 使用する必要がありますデータを複数の異なるホストに送信するためのコネクションレスのプロトコルと計画を使用している場合、 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。 使用しない場合、 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す必要は <xref:System.Net.Sockets.Socket.Connect%2A> への各呼び出しの前に <xref:System.Net.Sockets.Socket.Send%2A>します。 使用する <xref:System.Net.Sockets.Socket.SendTo%2A> で既定のリモート ホストを確立した後でも <xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に既定のリモート ホストを変更することもできます。 <xref:System.Net.Sockets.Socket.Send%2A> 別の呼び出しを行うことによって <xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.Send%2A> を使用して、タイムアウトが設定されたしない限り、すべてのバッファー内のバイトが送信されるまでブロックされます <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 <xref:System.Net.Sockets.Socket.Send%2A> を <xref:System.Net.Sockets.SocketException>です。 非ブロッキング モードで <xref:System.Net.Sockets.Socket.Send%2A> バッファーの送信バイト数よりも少ない場合でも正常に完了可能性があります。 送信されたバイト数を追跡して、アプリケーションは、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 <xref:System.Net.Sockets.Socket.Send%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets のバージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 送信されるデータが含まれています。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したデータのバイト数に、接続されている送信 <see cref="T:System.Net.Sockets.Socket" />, を指定して <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>送信されたバイト数、 <see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> 定められているリモート ホストにデータを同期的に送信、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドと正常に送信されたバイトの数を返します。[Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 このオーバー ロードには、送信するバイト数とのいずれかのビットごとの組み合わせを送信するデータを格納するバッファーが必要です。 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags>します。 指定した場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketflags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> このメソッドを呼び出す前に、または [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> をスロー、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 接続指向のプロトコルを使用している場合を使用する必要があります [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するかを使用して [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> 着信接続を受け入れるようにします。  
  
 使用する必要がありますデータを複数の異なるホストに送信するためのコネクションレスのプロトコルと計画を使用している場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。 使用しない場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す必要は、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドに対する各呼び出しの前に、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> メソッドです。 使用する [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> で既定のリモート ホストを確立した後でも [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に既定のリモート ホストを変更することもできます。 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> 別の呼び出しを行うことによって [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向プロトコルが [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> を使用して、タイムアウトが設定されたしない限り、要求されたバイト数が送信されるまでブロックされます [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> を [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 非ブロッキング モードで [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> 送信を要求したバイト数よりも少ない場合でも正常に完了可能性があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  サイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要があります。 場合は、データグラムが送信されず、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> をスロー、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 表示された場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets のバージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例は、バッファーに含まれるデータを送信しを指定 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.None> の [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags>です。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> 0 未満か、バッファーのサイズを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 有効値の組み合わせではありません。  
  
 または  
  
 オペレーティング システムのエラーは、ソケットへのアクセス中に発生します。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">一連の <see cref="T:System.ArraySegment`1" />型の s <see cref="T:System.Byte" /> 送信されるデータを格納しています。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> ソケット エラーを格納するオブジェクト。</param>
        <summary>接続された一連のバッファーは、リストに <see cref="T:System.Net.Sockets.Socket" />, を指定して <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>送信されたバイト数、 <see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。<xref:System.Net.Sockets.SocketFlags> 値の既定値は 0 です。 指定した場合、 <xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketFlags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります <xref:System.Net.Sockets.Socket.Connect%2A> このメソッドを呼び出す前に、または <xref:System.Net.Sockets.Socket.Send%2A> をスロー、 <xref:System.Net.Sockets.SocketException>です。 接続指向のプロトコルを使用している場合を使用する必要があります <xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するかを使用して <xref:System.Net.Sockets.Socket.Accept%2A> 着信接続を受け入れるようにします。  
  
 使用する必要がありますデータを複数の異なるホストに送信するためのコネクションレスのプロトコルと計画を使用している場合、 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。 使用しない場合、 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す必要は <xref:System.Net.Sockets.Socket.Connect%2A> への各呼び出しの前に <xref:System.Net.Sockets.Socket.Send%2A>します。 使用する <xref:System.Net.Sockets.Socket.SendTo%2A> で既定のリモート ホストを確立した後でも <xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に既定のリモート ホストを変更することもできます。 <xref:System.Net.Sockets.Socket.Send%2A> 別の呼び出しを行うことによって <xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.Send%2A> を使用して、タイムアウトが設定されたしない限り、すべてのバッファー内のバイトが送信されるまでブロックされます <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 <xref:System.Net.Sockets.Socket.Send%2A> を <xref:System.Net.Sockets.SocketException>です。 非ブロッキング モードで <xref:System.Net.Sockets.Socket.Send%2A> バッファーの送信バイト数よりも少ない場合でも正常に完了可能性があります。 送信されたバイト数を追跡して、アプリケーションは、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 <xref:System.Net.Sockets.Socket.Send%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets のバージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> or [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection\-oriented and connectionless protocols.  
  
 In this overload, if you specify the [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the **parameterReference tag is not supported!!!!**  
 parameter, the data you are sending will not be routed.  
  
 If you are using a connectionless protocol, you must call [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> will throw a [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>. If you are using a connection\-oriented protocol, you must either use [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  
  
 If you are using a connectionless protocol and plan to send data to several different hosts, you should use [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>. If you do not use [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> before each call to [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A>. It is okay to use [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> by making another call to [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> will throw a [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>.  
  
 If you are using a connection\-oriented protocol, [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time\-out was set by using [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time\-out value was exceeded, the [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> call will throw a [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>. In nonblocking mode, [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  
  
> [!NOTE]
>  If you receive a [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, use the [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  
  
> [!NOTE]
>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  
  
> [!NOTE]
>  This member outputs trace information when you enable network tracing in your application. For more information, see [&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## 例  
 The following code example specifies the data buffer, an offset, a size, and [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags> for sending data to a connected [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
 または  
  
 <see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 送信されるデータが含まれています。</param>
        <param name="offset">データの送信を開始する位置を示すデータ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> ソケット エラーを格納するオブジェクト。</param>
        <summary>指定したデータのバイト数に、接続されている送信 <see cref="T:System.Net.Sockets.Socket" />, 、指定されたオフセットから開始し、指定して、 <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>送信されたバイト数、 <see cref="T:System.Net.Sockets.Socket" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> 指定されたリモート ホストにデータを同期的に送信、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> または [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドと正常に送信されたバイトの数を返します。[Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 指定した場合、オーバー ロードでは、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketflags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> このメソッドを呼び出す前に、または [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> をスロー、[Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 接続指向のプロトコルを使用している場合を使用する必要があります [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するかを使用して [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> 着信接続を受け入れるようにします。  
  
 データを複数の異なるホストに送信するためのコネクションレスのプロトコルと計画を使用している場合を使用する [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>です。 使用しない場合 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>, を呼び出す必要は [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> への各呼び出しの前に [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A>します。 使用できる [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> で既定のリモート ホストを確立した後でも [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に既定のリモート ホストを変更することもできます。 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> 別の呼び出しを行うことによって [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 サイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> をスロー、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。  
  
 接続指向のプロトコルを使用している場合 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> を使用して、タイムアウトが設定されたしない限り、要求されたバイト数が送信されるまでブロックされます [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>します。 タイムアウト値を超えている場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> を [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 非ブロッキング モードで [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> 送信を要求したバイト数よりも少ない場合でも正常に完了可能性があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets のバージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了では、データが正常に送信されたことは示されません。 転送するデータを保持するために、トランスポート システム内で使用できるバッファ領域がない場合は、送信は、ソケットが非ブロッキング モードで配置されている場合を除き、ブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)します。  
  
   
  
## 例  
 次のコード例は、データ バッファー、オフセット、サイズを指定し、 [Send メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags> に接続されたデータを送信するため [Send メソッド \(Byte\<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さより大きい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" /> の値を差し引いて、 <paramref name="offset" /> パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 有効値の組み合わせではありません。  
  
 または  
  
 アクセス中には、オペレーティング システム エラーが発生した、 <see cref="T:System.Net.Sockets.Socket" />です。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>接続されたデータを非同期的に送信 <see cref="T:System.Net.Sockets.Socket" /> オブジェクトです。</summary>
        <returns>返します。 <see langword="true" /> I\/O 操作が保留中の場合。<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターが操作の完了時に発生します。  
  
 返します。 <see langword="false" /> 場合は、I\/O 操作が同期的に完了します。 ここで、 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターは発生しません、 <paramref name="e" /> 操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドを使用して、接続指向のソケットで 1 つまたは複数のバッファーの送信データを書き込みます。 このメソッドこともできます、ただし、コネクションレス型のソケット接続操作で、リモート ホストを指定します。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドで確立されたリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Accept%2A>, 、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>, 、<xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、<xref:System.Net.Sockets.Socket.Connect%2A>, 、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドです。  
  
 次のプロパティおよびイベントに、 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> オブジェクトがこのメソッドを呼び出すことが必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> 場合 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> 設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> 場合 <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> 設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  
  
 呼び出し元の設定、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> プロパティを呼び出す前に必要なユーザーの状態オブジェクト、 <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> 最初に呼び出す必要はない場合にメソッドが例外をスロー <xref:System.Net.Sockets.Socket.Accept%2A>, 、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>, 、<xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、<xref:System.Net.Sockets.Socket.Connect%2A>, 、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A>です。  
  
 呼び出す、 <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 メッセージ指向のソケットでは、基になる Windows sockets サービス プロバイダーのメッセージの最大サイズを超えないようにしないでください。 データが長すぎて、基になるサービス プロバイダーの場合は、データは送信されず <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドでのスロー、 <xref:System.Net.Sockets.SocketException> で、 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> ネイティブ Winsock WSAEMSGSIZE エラー コード \(10040\) に設定します。  
  
 注意を正常に完了、 <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドは、データが正常に送信されたことを指定していません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> または <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティを <paramref name="e" /> パラメーターが有効なバッファーを参照する必要があります。 セットが、同時に両方のいずれか、またはこれらのプロパティの他の可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> で指定されたオブジェクト、 <paramref name="e" /> パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降がこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <see cref="T:System.Net.Sockets.Socket" /> まだ接続されていないかを使用して取得されませんでした、 <see cref="M:System.Net.Sockets.Socket.Accept" />, 、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,、または <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, 、メソッドです。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の送信バッファーのサイズを指定する値、 <see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value>
          <see cref="T:System.Int32" /> 送信バッファーのバイト単位のサイズを格納します。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 大きなバッファー サイズは、接続に関する問題を認識を遅らせることができます。 サイズの大きなファイルを転送するか、高帯域幅、衛星ブロード バンド プロバイダーです。\) などの高待機時間の接続を使用している場合は、バッファー サイズを増やすことを検討してください。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.SendBufferSize%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">セット操作に指定された値は、0 より小さい値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> 送信されるファイルの名前とパスを含みます。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary>ファイル送信 <paramref name="fileName" /> に接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> フラグを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードは、そのファイルを送信 `fileName` ソケットで接続されています。`flags` パラメーターの既定値 <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> \(0\) および `preBuffer` と `postBuffer` パラメーターに既定の `null`です。 場合 `fileName` はそれ、ローカル ディレクトリにファイルの名前だけで識別可能性があります。 それ以外の場合、完全パスとファイルの名前を指定する必要があります。 ワイルドカード \("..\\\\myfile.txt"\) と UNC 共有名 \("\\\\\\shared directory\\\\myfile.txt"\) がサポートされています。 ファイルが見つからない場合、例外 <xref:System.IO.FileNotFoundException> がスローされます。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API の関数が見つかります。 詳細については、 `TransmitFile` 関数とそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 指定されたリモート ホストにファイルを同期的に送信、 <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。<xref:System.Net.Sockets.Socket.SendFile%2A> コネクションレスのプロトコル、接続指向の両方に使用できます。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります <xref:System.Net.Sockets.Socket.Connect%2A> それ以外の場合、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.SendFile%2A> スロー、 <xref:System.Net.Sockets.SocketException> 例外です。 接続指向のプロトコルを使用している場合を使用する必要があります <xref:System.Net.Sockets.Socket.Connect%2A> リモート ホスト接続を確立するかを使用して <xref:System.Net.Sockets.Socket.Accept%2A> 着信接続を受け入れるようにします。  
  
 接続指向のプロトコルを使用している場合 <xref:System.Net.Sockets.Socket.SendFile%2A> ファイルを送信するまでブロックします。 非ブロッキング モードで <xref:System.Net.Sockets.Socket.SendFile%2A> ファイル全体が送信される前に正常に完了可能性があります。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 <xref:System.Net.Sockets.Socket.SendFile%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例を作成し、ソケットを接続し、リモート ホストにファイルを送信します。 ファイル「test.txt」は、ローカル コンピューターのルート ディレクトリにあります。  
  
 [!code-cpp[NCLSocketEnhancements\#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements\#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは、ブロックしているモードではないと、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、次の「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">ファイル送信の前に送信されるデータを含む <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">ファイル送信の後に送信されるデータを含む <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags">1 つ以上の <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> およびデータのバッファーを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This overload requires the name of the file you want to send and a bitwise combination of [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.TransmitFileOptions> values. The **parameterReference tag is not supported!!!!**  
 parameter contains any data you want to precede the file. **parameterReference tag is not supported!!!!**  
 contains data you want to follow the file. If **parameterReference tag is not supported!!!!**  
 is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards \("..\\\\myfile.txt"\) and UNC share names \("\\\\\\\\shared directory\\\\myfile.txt"\) are supported.  
  
 The **parameterReference tag is not supported!!!!**  
 parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.TransmitFileOptions>.  
  
 This method uses the **languageKeyword tag is not supported!!!!**  
 function found in the Windows Sockets 2 API. For more information about the **languageKeyword tag is not supported!!!!**  
 function and its flags, see the Windows Sockets documentation in the MSDN Library.  
  
 [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.Connect%2A> or [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.Accept%2A> method. [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection\-oriented and for connectionless protocols.  
  
 If you are using a connectionless protocol, you must call [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.SendFile%2A> throws a [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.SocketException>. If you are using a connection\-oriented protocol, you must either use [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  
  
 If you are using a connection\-oriented protocol, [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent. In nonblocking mode, [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.  
  
> [!NOTE]
>  If you receive a [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.SocketException>, use the [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  
  
> [!NOTE]
>  This member outputs trace information when you enable network tracing in your application. For more information, see [&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## 例  
 The following code example creates and connects a socket. The file "test.txt" is located in the root directory of the local machine. In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file. The default [SendFile メソッド \(String, Byte\[\], Byte\<xref:System.Net.Sockets.TransmitFileOptions> are used.  
  
 [!code-cpp[NCLSocketEnhancements\#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements\#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">オペレーティング システムは Windows NT 以降ではありません。  
  
 または  
  
 ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>接続されたをメモリ内、またはファイルのコレクションのデータ バッファーを非同期的に送信 <see cref="T:System.Net.Sockets.Socket" /> オブジェクトです。</summary>
        <returns>返します。 <see langword="true" /> I\/O 操作が保留中の場合。<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターが操作の完了時に発生します。  
  
 返します。 <see langword="false" /> 場合は、I\/O 操作が同期的に完了します。 ここで、 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターは発生しません、 <paramref name="e" /> 操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> リモート ホストにデータ バッファーをメモリ内、またはファイルのコレクションに送信するメソッドを使用します。<xref:System.Net.Sockets.Socket> リモート ホストに既に接続している必要があります。  
  
 場合、 <xref:System.Net.Sockets.SendPacketsElement?displayProperty=fullName> 作業ディレクトリでファイルを参照、ファイルの名前だけでそれを識別できる可能性があります。 それ以外の場合、完全パスとファイルの名前を指定する必要があります。 ワイルドカードと UNC 共有名がサポートされています。 ファイルが見つからない場合 <xref:System.IO.FileNotFoundException> がスローされます。  
  
 完了の通知を受信する、実装 EventHandler \< SocketAsyncEventArgs \> は委任し、アタッチするためのコールバックは、コールバック メソッドを作成する必要があります、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> イベントです。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName> プロパティを `e` パラメーターは、ファイルの転送に関する追加情報\] ウィンドウのソケットのサービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。 <xref:System.Net.Sockets.TransmitFileOptions>します。  
  
 次のプロパティおよびイベントに、 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> オブジェクトがこのメソッドを呼び出すことが必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  
  
 呼び出し元の設定、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> プロパティを呼び出す前に必要なユーザーの状態オブジェクト、 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 このメソッドは、Windows Sockets 2 API で見つかった TransmitPackets 関数を使用します。 TransmitPackets 関数およびそのフラグの詳細については、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 接続指向のプロトコルでは、意図したものが、 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッドに対しても機能コネクションレスのプロトコルを最初に呼び出すことが提供される、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、<xref:System.Net.Sockets.Socket.Connect%2A>, 、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> を既定のリモート ホストを確立する方法です。 コネクションレスのプロトコルを使用している場合は、ファイルのサイズが基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 データグラムが送信しない場合と <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> スロー、 <xref:System.Net.Sockets.SocketException> 例外です。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッドが使用される、オペレーティング システムによって最適化します。 Windows server のエディションで、 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッドは高パフォーマンスの最適化します。  
  
 Windows クライアントのエディションで、 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッドが最低限のメモリとリソース使用率に適しています。  
  
 使用、 <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=fullName> フラグ、 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName> プロパティを `e` パラメーターは、大幅なパフォーマンス上の利点を提供できます。 場合は、スレッドを開始する、 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 大量の計算には、メソッドの呼び出しを使用しているが可能であれば、見込みのない、Apc が起動できない可能性があることもできます。 Apc のカーネルとユーザー モードの違いがあることに注意してください。 スレッドが待機状態には、カーネル Apc が起動します。 スレッドは、アラートを通知の待機状態で、ユーザー モードの Apc が起動します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">指定されたファイル、 <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> プロパティが見つかりません。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> で指定されたオブジェクト、 <paramref name="e" /> パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降がこのメソッドに必要です。 場合にもこの例外が発生した、 <see cref="T:System.Net.Sockets.Socket" /> リモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">コネクションレス <see cref="T:System.Net.Sockets.Socket" /> が使用されていると、ファイル送信される、基になるトランスポートのパケットの最大サイズを超えています。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得するまでの時間を指定する値を設定または同期 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 呼び出しがタイムアウトになります。</summary>
        <value>タイムアウト値 \(ミリ秒\)。 1 ~ 499 の値を持つプロパティを設定した場合、値は 500 に変更されます。 既定値は、タイムアウト期間が無限を示す 0 です。 \-1 を指定するには、タイムアウト期間が無限も示されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオプションを適用する同期 <xref:System.Net.Sockets.Socket.Send%2A> 呼び出しのみです。 タイムアウト期間を超えた場合、 <xref:System.Net.Sockets.Socket.Send%2A> メソッドをスロー、 <xref:System.Net.Sockets.SocketException>です。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.SendTimeout%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">セット操作に指定された値は、\-1 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 送信されるデータが含まれています。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> を表すデータのシリアル化先。</param>
        <summary>指定されたエンドポイントにデータを送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードで、バッファーのオフセットの既定値は 0 のサイズを既定値を送信するバイト数、 `buffer` パラメーター、および [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags> 値の既定値は 0 です。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す前に [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>します。 呼び出そうとする場合に実行しなければ、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> メソッドです。 呼び出す場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す前に [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>, 、 `remoteEP` パラメーターは、操作のみを送信するために、指定された既定のリモート ホストにオーバーライドされます。 必要はありませんを呼び出して、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> メソッドでは、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 後プロパティ、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了します。  
  
 意図したものが [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> でも、接続指向のプロトコルを使用します。 最初に呼び出すことによってリモート ホスト接続を確立する必要があります接続指向のプロトコルを使用している場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッド、着信接続を使用して要求を受け入れるか、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 確立したり、リモート ホスト接続をそのまま使用しない場合 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> をスローする [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。 このような場合は、のいずれかで [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> は無視、 `remoteEP` パラメーターとのみデータを送信する、接続またはリモート ホストの既定値です。  
  
 ソケットのブロッキングは、すべてのバッファーのバイトが送信されるまでブロックします。 以降、非ブロッキング[SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket> が完了すると、すぐにもが送信されてすべてのバイト数の `buffer`です。 送信されたバイト数を追跡して、アプリケーションでは、すべてのバイトを送信するまで、操作を再試行する、アプリケーションの役目です、 `buffer`です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の送信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードでのコネクションレスのプロトコルを使用している場合 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> データグラムが送信されるまでブロックされます。 最初に呼び出す必要がありますが、ブロードキャスト アドレスにデータを送信する場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドと、ソケット オプションを [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=fullName>します。 送信されたバイト数が、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> をスロー、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、指定したリモート ホストをコネクションレスのデータグラムを送信します。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 送信されるデータが含まれています。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> データの保存場所を表します。</param>
        <summary>データを指定して特定のエンドポイントに送信 <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードで、バッファーのオフセットの既定値は 0 でのサイズを既定値を送信するバイト数、 `buffer`です。 指定した場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketflags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す前に [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>します。 呼び出そうとする場合に実行しなければ、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> メソッドです。 呼び出す場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す前に [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>, 、 `remoteEP` パラメーターは、操作のみを送信するために、指定された既定のリモート ホストにオーバーライドされます。 必要はありませんを呼び出して、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> メソッドでは、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 後プロパティ、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了します。  
  
 意図したものが [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> でも、接続指向のプロトコルを使用します。 最初に呼び出すことによってリモート ホスト接続を確立する必要があります接続指向のプロトコルを使用している場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッド、着信接続を使用して要求を受け入れるか、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 確立したり、リモート ホスト接続をそのまま使用しない場合 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> をスローする [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。 このような場合は、のいずれかで [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> は無視、 `remoteEP` パラメーターとのみデータを送信する、接続またはリモート ホストの既定値です。  
  
 ブロッキング ソケットは、ブロックされるまで、要求されたすべてのバイト数の `buffer` 送信されます。 以降、非ブロッキング[SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket> が完了すると、すぐにもが送信されてすべてのバイト数の `buffer`です。 送信されたバイト数を追跡して、アプリケーションでは、すべてのバイトを送信するまで、操作を再試行する、アプリケーションの役目です、 `buffer`です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の発信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードでのコネクションレスのプロトコルを使用している場合 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> データグラムが送信されるまでブロックされます。 最初に呼び出す必要がありますが、ブロードキャスト アドレスにデータを送信する場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドと、ソケット オプションを [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=fullName>します。 送信されたバイト数が、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> をスロー、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、指定したリモート ホストをコネクションレスのデータグラムを送信します。[SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags> 渡される、[SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 送信されるデータが含まれています。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> データの保存場所を表します。</param>
        <summary>指定したデータのバイト数を指定して、指定されたエンドポイントに送信 <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このオーバー ロードでは、バッファーは、既定値は 0 をオフセットです。 指定した場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketflags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す前に [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>します。 呼び出そうとする場合に実行しなければ、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> メソッドです。 呼び出す場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す前に [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>, 、 `remoteEP` パラメーターは、操作のみを送信するために、指定された既定のリモート ホストにオーバーライドされます。 必要はありませんを呼び出して、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> メソッドでは、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 後プロパティ、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了します。  
  
 意図したものが [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> でも、接続指向のプロトコルを使用します。 最初に呼び出すことによってリモート ホスト接続を確立する必要があります接続指向のプロトコルを使用している場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッド、着信接続を使用して要求を受け入れるか、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 確立したり、リモート ホスト接続をそのまま使用しない場合 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> をスローする [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。 このような場合は、のいずれかで [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> は無視、 `remoteEP` パラメーターとのみデータを送信する、接続またはリモート ホストの既定値です。  
  
 ソケットのブロッキングは、要求されたバイト数が送信されるまでブロックします。 非ブロッキング[SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket> が完了すると、すぐにも可能性があります送信されてすべての単一の操作で要求されたバイト数。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の発信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードでのコネクションレスのプロトコルを使用している場合 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> データグラムが送信されるまでブロックされます。 最初に呼び出す必要がありますが、ブロードキャスト アドレスにデータを送信する場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドと、ソケット オプションを [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=fullName>します。 送信されたバイト数が、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> をスロー、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、指定したリモート ホストをコネクションレスのデータグラムを送信します。 サイズと [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags> に渡される、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定した <paramref name="size" /> のサイズを超える <paramref name="buffer" />します。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">型の配列 <see cref="T:System.Byte" /> 送信されるデータが含まれています。</param>
        <param name="offset">データの送信を開始する位置を示すデータ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" /> データの保存場所を表します。</param>
        <summary>指定したデータのバイト数をバッファー内の指定位置から開始し、指定して、指定されたエンドポイントに送信 <see cref="T:System.Net.Sockets.SocketFlags" />します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定した場合、オーバー ロードでは、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags.DontRoute> としてフラグを設定、 `socketflags` パラメーターには、ルーティングされなくなるを送信するデータ。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す前に [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>します。 呼び出そうとする場合に実行しなければ、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Send%2A> メソッドです。 呼び出す場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す前に [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A>, 、 `remoteEP` パラメーターは、操作のみを送信するために、指定された既定のリモート ホストにオーバーライドされます。 必要はありませんを呼び出して、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Bind%2A> メソッドでは、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 後プロパティ、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了します。  
  
 意図したものが [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> でも、接続指向のプロトコルを使用します。 最初に呼び出すことによってリモート ホスト接続を確立する必要があります接続指向のプロトコルを使用している場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Connect%2A> メソッド、着信接続を使用して要求を受け入れるか、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.Accept%2A> メソッドです。 確立したり、リモート ホスト接続をそのまま使用しない場合 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> をスローする [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。 このような場合は、のいずれかで [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> は無視、 `remoteEP` パラメーターとのみデータを送信する、接続またはリモート ホストの既定値です。  
  
 ソケットのブロッキングは、要求されたバイト数が送信されるまでブロックします。 非ブロッキング以降 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket> が完了すると、すぐにも可能性があります送信されてすべての単一の操作で要求されたバイト数。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行するユーザー アプリケーションの責任においてすることをお勧めします。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに大量の発信データが収集されるまで、基になるシステムは送信を遅延する可能性があります。 正常に完了する、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドでは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードでのコネクションレスのプロトコルを使用している場合 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> データグラムが送信されるまでブロックされます。 最初に呼び出す必要がありますが、ブロードキャスト アドレスにデータを送信する場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドと、ソケット オプションを [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=fullName>します。 サイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> をスロー、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException>, を使用して、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では、指定したリモート ホストをコネクションレスのデータグラムを送信します。 オフセット、サイズ、および [SendTo メソッド \(Byte\<xref:System.Net.Sockets.SocketFlags> に渡される、 [SendTo メソッド \(Byte\<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドです。  
  
 [!code-cpp[Socket\_Sync\_Send\_Receive\#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket\_Sync\_Send\_Receive\#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket\_Sync\_Send\_Receive\#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。  
  
 \-または\-  
  
 <paramref name="remoteEP" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  
  
 または  
  
 <paramref name="offset" /> 長さより大きい <paramref name="buffer" />します。  
  
 または  
  
 <paramref name="size" /> が 0 未満です。  
  
 または  
  
 <paramref name="size" /> 長さより大きい <paramref name="buffer" /> の値を差し引いて、 <paramref name="offset" /> パラメーター。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 有効値の組み合わせではありません。  
  
 または  
  
 アクセス中には、オペレーティング システム エラーが発生した、 <see cref="T:System.Net.Sockets.Socket" />です。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックに呼び出し元には、必要なアクセス許可がありません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> この非同期ソケット操作に使用するオブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns>返します。 <see langword="true" /> I\/O 操作が保留中の場合。<see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターが操作の完了時に発生します。  
  
 返します。 <see langword="false" /> 場合は、I\/O 操作が同期的に完了します。 ここで、 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> でイベントを <paramref name="e" /> パラメーターは発生しません、 <paramref name="e" /> 操作の結果を取得するメソッドの呼び出しが戻った後にすぐに、パラメーターを調べることがありますとして渡されたオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドで指定されたリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> のプロパティ、 `e` パラメーター。 呼び出す、 <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。 このメソッドは、コネクションレスのプロトコルを <xref:System.Net.Sockets.Socket.SendToAsync%2A> コネクションレス型との接続指向の両方のプロトコルで動作します。  
  
 完了の通知を受信する、実装 EventHandler \< SocketAsyncEventArgs \> は委任し、アタッチするためのコールバックは、コールバック メソッドを作成する必要があります、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> イベントです。  
  
 次のプロパティおよびイベントに、 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> オブジェクトがこのメソッドを呼び出すことが必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  
  
 呼び出し元の設定、 <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> プロパティを呼び出す前に必要なユーザーの状態オブジェクト、 <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 接続指向のプロトコルを使用している場合は、最初に呼び出す必要があります、 <xref:System.Net.Sockets.Socket.Accept%2A>, 、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>, 、<xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、<xref:System.Net.Sockets.Socket.Connect%2A>, 、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドです。 それ以外の場合 <xref:System.Net.Sockets.Socket.SendToAsync%2A> をスローする <xref:System.Net.Sockets.SocketException>です。 接続指向のプロトコルを使用する場合、 <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドは無視、 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> プロパティと送信のデータを <xref:System.Net.EndPoint?displayProperty=fullName> で定められている、 <xref:System.Net.Sockets.Socket.Accept%2A>, 、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>, 、<xref:System.Net.Sockets.Socket.BeginAccept%2A>, 、<xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、<xref:System.Net.Sockets.Socket.Connect%2A>, 、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドです。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、<xref:System.Net.Sockets.Socket.Connect%2A>, 、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出す前に <xref:System.Net.Sockets.Socket.SendToAsync%2A>します。 呼び出そうとする場合に実行しなければ、 <xref:System.Net.Sockets.Socket.BeginSend%2A> または <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドです。 呼び出す場合、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>, 、<xref:System.Net.Sockets.Socket.Connect%2A>, 、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出す前に <xref:System.Net.Sockets.Socket.SendToAsync%2A>, 、 <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> プロパティは、操作のみを送信する、指定された既定のリモート ホストは無効です。 また必要はありませんを呼び出して、 <xref:System.Net.Sockets.Socket.Bind%2A> メソッドです。 この場合は、基になるサービス プロバイダーは最も適切なローカル ネットワーク IP アドレスとポート番号を割り当てます。 基になるサービス プロバイダーは、無料のポートを選択する場合は、ゼロのポート番号を使用します。 使用することができます、割り当てられているローカル ネットワークの IP アドレスとポート番号を識別する必要がある場合、 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> 後プロパティ、 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> イベントがシグナル状態になるし、関連付けられているデリゲートが呼び出されます。  
  
 最初に呼び出す必要がありますが、ブロードキャスト アドレスにデータを送信する場合、 <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドと、ソケット オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=fullName> を true にします。 バッファーのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず、 <xref:System.Net.Sockets.Socket.SendToAsync%2A> をスロー、 <xref:System.Net.Sockets.SocketException>です。  
  
 DontRoute フラグを指定する場合、 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> プロパティ、ルーティングされなくなるを送信するデータを取得します。  
  
 メッセージ指向のソケットでは、基になるトランスポートのメッセージの最大サイズを超えないように注意する必要があります。 バッファーのサイズは、基になるサービス プロバイダーの最大パケット サイズを超えている場合、データグラムが送信されず、 <xref:System.Net.Sockets.Socket.SendToAsync%2A> がスローされます、 <xref:System.Net.Sockets.SocketException>です。 正常に完了、 <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドは、データが正常に送信されたことを指定していません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> Null にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException">ソケット操作が既に進行中の使用中、 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> で指定されたオブジェクト、 <paramref name="e" /> パラメーター。</exception>
        <exception cref="T:System.NotSupportedException">Windows XP 以降がこのメソッドに必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定されたプロトコルは、接続指向しますが、 <see cref="T:System.Net.Sockets.Socket" /> はまだ接続されていません。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">このソケットで設定する IP 保護レベル。</param>
        <summary>ソケットでは、IP 保護レベルを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> メソッドの使用を制限する、リンク ローカルまたはサイト ローカル プレフィックスを持つ同じアドレスなど、特定のスコープをリッスンするように、IPv6、または IP ソケットです。 このソケット オプションにより、IPv6、または IP ソケットでアクセス制限を設定できます。 この制限により、プライベート LAN で実行されるアプリケーションを外部からの攻撃に対して簡単かつ堅牢に強化できます。 このソケット オプションは、アクセス制限を削除する場合にも使用できます、 `level` にパラメーターが設定されている <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>します。 このソケット オプションで待機中のソケットのスコープを変更して、適切な場合はパブリック ユーザーおよびプライベート ユーザーからの無制限のアクセスを許可したり、必要に応じて同じサイトへのアクセスのみに制限したりできます。  
  
 このソケット オプションには、<xref:System.Net.Sockets.IPProtectionLevel> 列挙型で指定されている定義済みの保護レベルが設定されています。  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> メソッドを使用を有効または無効のネットワーク アドレス トラバーサル \(NAT\) を <xref:System.Net.Sockets.Socket> インスタンス。 Teredo、6to4、または ISATAP トンネルを使用して、NAT トラバーサルを指定することがあります。  
  
 ときに、 `level` にパラメーターが設定されている <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, 、または <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, 、NAT トラバーサルが明示的に無効になります、 <xref:System.Net.Sockets.Socket> インスタンス。  
  
 ときに、 `level` にパラメーターが設定されている <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, 、NAT トラバーサルこのことができます、 <xref:System.Net.Sockets.Socket> によっては、システム上の場所でのファイアウォール ルール。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="level" /> パラメーターを <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /> にすることはできません。 IP 保護レベルは、指定されていないに設定することはできません。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Sockets.AddressFamily" /> ソケットのいずれかでなければなりません <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />です。</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">として表される、オプションの値、 <see cref="T:System.Boolean" />です。</param>
        <summary>指定した設定 <see cref="T:System.Net.Sockets.Socket" /> を指定されたオプション <see cref="T:System.Boolean" /> 値。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定 <xref:System.Net.Sockets.Socket>します。 設定 `optionValue` に `true` オプションを有効にまたは `false` オプションを無効にします。  
  
 <xref:System.Net.Sockets.Socket> オプションは、プロトコルのサポートのレベルでグループ化されます。  
  
 次のとおり、さまざまな <xref:System.Net.Sockets.Socket> オプションをこのオーバー ロードを使用して設定できます。 これらのオプションが適切にグループ化された <xref:System.Net.Sockets.SocketOptionLevel> 値。 これらのオプションのいずれかを設定する場合は、必ず使用して、適切な <xref:System.Net.Sockets.SocketOptionLevel> の値として、 `optionLevel` パラメーター。 設定を選択したオプションを指定する必要があります、 `optionName` パラメーター。 表示されたオプションのいずれかの現在の値を取得、使用する場合、 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドです。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=fullName> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=fullName> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=fullName> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=fullName> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 これらのオプションの詳細についてを参照してください、 <xref:System.Net.Sockets.SocketOptionName> 列挙します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException> 例外を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets のバージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
   
  
## 例  
 ソケットを開き、により、次のコード例、 `DontLinger` と `OutOfBandInline` ソケット オプション。  
  
 [!code-cpp[NCLSocketEnhancements\#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements\#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトが閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、「解説」を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">型の配列 <see cref="T:System.Byte" /> オプションの値を表します。</param>
        <summary>指定した設定 <see cref="T:System.Net.Sockets.Socket" /> オプションをバイト配列として表される、指定した値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定 <xref:System.Net.Sockets.Socket>します。 このオーバー ロードを使用して、それらを設定する <xref:System.Net.Sockets.Socket> オプションの値として、バイト配列を必要とするオプションです。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例、 <xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> タイムアウト値。  
  
 [!code-cpp[Socket\_Socket\_Options\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket\_Socket\_Options\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket\_Socket\_Options\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプションの値。</param>
        <summary>指定した設定 <see cref="T:System.Net.Sockets.Socket" /> オプションを指定した整数値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定 <xref:System.Net.Sockets.Socket>します。<xref:System.Boolean> オプションを有効に 0 以外の値とオプションを無効にゼロ値を指定するデータ型します。 整数データ型のオプションでは、適切な値を指定します。<xref:System.Net.Sockets.Socket> オプションは、プロトコルのサポートのレベルでグループ化されます。  
  
 次のとおり、さまざまな <xref:System.Net.Sockets.Socket> オプションをこのオーバー ロードを使用して設定できます。 これらのオプションが適切にグループ化された <xref:System.Net.Sockets.SocketOptionLevel>します。 これらのオプションのいずれかを設定する場合は、必ず使用して、適切な <xref:System.Net.Sockets.SocketOptionLevel> の `optionLevel` パラメーター。 設定を選択したオプションを指定する必要があります、 `optionName` パラメーター。 表示されたオプションのいずれかの現在の値を取得、使用する場合、 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドです。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=fullName> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=fullName> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=fullName> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=fullName> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=fullName> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 これらのオプションの詳細についてを参照してください、 <xref:System.Net.Sockets.SocketOptionName> 列挙します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例、 <xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> タイムアウト値。  
  
 [!code-cpp[Socket\_Socket\_Options\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket\_Socket\_Options\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket\_Socket\_Options\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">A <see cref="T:System.Net.Sockets.LingerOption" /> または <see cref="T:System.Net.Sockets.MulticastOption" /> オプションの値を格納します。</param>
        <summary>指定した設定 <see cref="T:System.Net.Sockets.Socket" /> オプションをオブジェクトとして表される、指定した値にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定 <xref:System.Net.Sockets.Socket>します。 このオーバー ロードを使用して、設定、 <xref:System.Net.Sockets.SocketOptionName.Linger>, 、<xref:System.Net.Sockets.SocketOptionName.AddMembership>, 、および <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> オプション。<xref:System.Net.Sockets.SocketOptionName.Linger> オプションを使用して <xref:System.Net.Sockets.Socket> の `optionLevel` パラメーター。<xref:System.Net.Sockets.SocketOptionName.AddMembership> と <xref:System.Net.Sockets.SocketOptionName.DropMembership>, を使用して <xref:System.Net.Sockets.SocketOptionLevel.IP>します。 上記のオプションのいずれかの現在の値を取得、使用する場合、 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドです。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
   
  
## 例  
 次のコード例、 <xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> タイムアウトの値。  
  
 [!code-cpp[Socket\_Socket\_Options\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket\_Socket\_Options\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket\_Socket\_Options\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">いずれか、 <see cref="T:System.Net.Sockets.SocketShutdown" /> が不要になった許可される操作を指定する値。</param>
        <summary>送信を無効にしでの受信は、 <see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 接続指向を使用する場合 <xref:System.Net.Sockets.Socket>, 、常を呼び出して、 <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッドを終了する前に、 <xref:System.Net.Sockets.Socket>です。 これにより、すべてのデータが送信されが閉じられるまで、接続されたソケットで受信したことです。  
  
 呼び出す、 <xref:System.Net.Sockets.Socket.Close%2A> すべてを解放するためのメソッドが管理され、アンマネージ リソースに関連付けられている、 <xref:System.Net.Sockets.Socket>です。 再利用しないように、 <xref:System.Net.Sockets.Socket> 終了タグの後です。  
  
 次の表に、 <xref:System.Net.Sockets.SocketShutdown> に対して有効な列挙値、 `how` パラメーター。  
  
|値|説明|  
|-------|--------|  
|送信|これで送信を無効にする <xref:System.Net.Sockets.Socket>です。|  
|Receive|これで受信を無効にする <xref:System.Net.Sockets.Socket>です。|  
|両方|送受信両方にこれを無効にする <xref:System.Net.Sockets.Socket>です。|  
  
 設定 `how` に <xref:System.Net.Sockets.SocketShutdown.Send> の後続を指定するために呼び出す <xref:System.Net.Sockets.Socket.Send%2A> は許可されません。 コネクションレス型を使用している場合は、 <xref:System.Net.Sockets.Socket>, を指定して <xref:System.Net.Sockets.SocketShutdown.Send> 効果はありません。  
  
 設定 `how` に <xref:System.Net.Sockets.SocketShutdown.Receive> の後続を指定するために呼び出す <xref:System.Net.Sockets.Socket.Receive%2A> は許可されません。 下位のプロトコル層への影響はありません。 呼び出した後、次の条件のいずれかが存在する場合接続指向のプロトコルを使用している場合、接続は終了 <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   データは、受信を待機している受信ネットワーク バッファーです。  
  
-   多くのデータが到着しました。  
  
 コネクションレスのプロトコルを使用している場合データグラムが受け入れられるし、キューに登録します。 ただし、追加の受信データグラムの利用可能なバッファー領域がない場合は破棄され、送信者にエラーが返されません。 使用して <xref:System.Net.Sockets.Socket.Shutdown%2A> 、コネクションレスで <xref:System.Net.Sockets.Socket> はお勧めしません。  
  
 設定 `how` に <xref:System.Net.Sockets.SocketShutdown.Both> 両方の送信を無効にし、上記で説明したときに受信します。  
  
> [!NOTE]
>  表示された場合、 <xref:System.Net.Sockets.SocketException> を呼び出すときに、 <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッドを使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「[&#91;\<topic:\/\/conUsingNetworkTracing\>&#93;](http://msdn.microsoft.com/ja-jp/e993b7c3-087f-45d8-9c02-9dded936d804)」を参照してください。  
  
   
  
## 例  
 次のコード例では <xref:System.Net.Sockets.Socket.Shutdown%2A> を無効にする、 <xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Classic Socket.Close Example\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example\#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットにアクセスしようとして、エラーが発生しました。 詳細については、「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> の型を取得します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Net.Sockets.Socket.SocketType%2A> is read\-only and is set when the <xref:System.Net.Sockets.Socket> is created.  
  
   
  
## 例  
 The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.  
  
 [!code-cpp[Socket\_Socket\_Options\#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket\_Socket\_Options\#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket\_Socket\_Options\#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>IPv4 のサポートが利用できると、現在のホストで有効になっているかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 現在のホストには、IPv4 プロトコルがサポートされている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フレームワークが廃止された特定の IPv6 をサポートするかどうかを示す値を取得 <see cref="T:System.Net.Dns" /> メンバーです。</summary>
        <value>
          <see langword="true" /> 特定のフレームワークに IPv6 がサポートされている場合は、古い <see cref="T:System.Net.Dns" /> メソッド以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定によって送信されるインターネット プロトコル \(IP\) パケットの Time To Live \(TTL\) 値を指定する値、 <see cref="T:System.Net.Sockets.Socket" />です。</summary>
        <value>TTL の値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 TTL の値は、ルーターはパケットとインターネット制御メッセージ プロトコル \(ICMP\) の"TTL を超えています"を破棄する前に、パケットが走査できるルーターの最大数を示すエラー メッセージが送信者に返されます。  
  
 TTL の値は、0 ~ 255 の値に設定可能性があります。 このプロパティが設定されていない場合、ソケットの既定の TTL 値は 32 です。  
  
 伝送制御プロトコル \(TCP\) ソケットでこのプロパティの設定は、TCP\/IP スタックによって、このソケットを使用して成功した接続が確立された場合無視されます。  
  
 表示された場合、 <xref:System.Net.Sockets.SocketException>, を使用して、 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> 固有のエラー コードを取得するプロパティです。 このコードを入手した場合は後を参照して Windows Sockets バージョン 2 API エラー コードのドキュメント、MSDN ライブラリでエラーの詳細な説明。  
  
   
  
## 例  
 次のコード例では、使用、 <xref:System.Net.Sockets.Socket.Ttl%2A> プロパティです。  
  
 [!code-cpp[SocketPropertyTester\#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester\#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL の値は、負の数を設定できません。</exception>
        <exception cref="T:System.NotSupportedException">内のソケットに対してのみこのプロパティを設定することができます、 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリです。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 このエラーは、TTL を 255 より大きい値に設定しようとしたときにも返されます。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソケットでのみ重複 I\/O モードを使用するかどうかを指定します。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Net.Sockets.Socket" /> 重複した I\/O のみを使用しない場合は、 <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを設定 `true` の <xref:System.Net.Sockets.Socket> を呼び出そうと <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>です。 それ以外の場合、フレームワークは、ソケットでは、使用を禁止する、完了ポートを割り当てることが <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ソケットは、完了ポートにバインドされました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保留中の非同期送信を終了します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続されたデータを非同期的に送信 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>着信接続の試行をそのまま使用する非同期操作を開始します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>セット、 <see cref="T:System.Net.Sockets.Socket" /> オプション。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>動作モードは低レベルの設定、 <see cref="T:System.Net.Sockets.Socket" />です。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>データを特定のエンドポイントに送信します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>閉じる、 <see cref="T:System.Net.Sockets.Socket" /> 接続とリソースを関連付けられているすべて解放します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホストに接続するための非同期要求を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値を返す、 <see cref="T:System.Net.Sockets.Socket" /> オプション。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同期的に、接続グループからデータを受信する開始 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保留中の非同期読み取りを終了します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホストへの接続を確立します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ファイルを接続を非同期的に送信 <see cref="T:System.Net.Sockets.Socket" /> オブジェクトです。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>着信接続の試行を非同期的に受け付けます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バインドされたデータを受け取る <see cref="T:System.Net.Sockets.Socket" />します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ファイルと省略可能なデータを同期的に接続する送信 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続されたデータを送信 <see cref="T:System.Net.Sockets.Socket" />します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>データグラムを受信し、元のエンドポイントを格納します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>