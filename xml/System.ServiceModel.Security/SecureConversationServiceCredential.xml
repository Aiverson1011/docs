<Type Name="SecureConversationServiceCredential" FullName="System.ServiceModel.Security.SecureConversationServiceCredential">
  <TypeSignature Language="C#" Value="public sealed class SecureConversationServiceCredential" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SecureConversationServiceCredential extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Security.SecureConversationServiceCredential" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>セキュリティで保護されたメッセージ交換サービスの資格情報の設定を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 安全な対話を行うには、複数のメッセージを交換し、セキュリティ コンテキスト トークン \(SCT\) を使用してセキュリティを保証する必要があります。 SCT は、通信セッションが存続している期間中、すべての通信参加者の間で共有されます。 サービスは 2 種類の SCT を発行できます。  
  
-   最初の SCT は一意の ID を含むセッション ベースの SCT です。 メッセージにはこの ID だけが含まれ、SCT ID と内容 \(クレーム、セキュリティ キーなど\) をマップする状態マッピング キャッシュがサービスで保持されます。 適切に動作するクライアントは SCT キャンセルを送信して、サービスでキャッシュ リソースを最適化できるようにする必要があります。<xref:System.ServiceModel.Channels.SecurityBindingElement.CreateSecureConversationBindingElement%2A> パラメーターを `requireCancellation` に設定した `true` を呼び出すことでこのクラスをインスタンス化すると、SCT はこの方法で発行されます。  
  
-   2 番目の SCT は、クライアントのクッキーに存在する独立した SCT です。 この SCT は完全な状態情報を格納しているため、サービスからの状態管理もクライアントからの SCT キャンセルも必要ありません。 これを "クッキー モード" SCT と呼ぶこともあります。 SCT は完全な状態情報を格納しているため、SCT のサイズはセッション ベースの場合より大きくなります。 セッション ベースの SCT により、サービスは状態情報のほとんどを格納します。 ただし、この SCT は独立しているため、サービスの有効期間にわたって使用でき、サービスの停止と再起動の間も持続します。  
  
   
  
## 例  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="SecurityContextClaimTypes">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;Type&gt; SecurityContextClaimTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Type&gt; SecurityContextClaimTypes" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.SecureConversationServiceCredential.SecurityContextClaimTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クッキー シリアル化のための <see cref="T:System.Type" /> クレームのコレクションを取得します。</summary>
        <value>クッキー シリアル化のための <see cref="T:System.Type" /> クレームのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 クレームを SCT クッキーにシリアル化するため、[!INCLUDE[indigo1](~/includes/indigo1-md.md)] は既定で <xref:System.Runtime.Serialization.DataContractSerializer> を使用します。 クレーム リソースは拡張可能であるため、[!INCLUDE[indigo2](~/includes/indigo2-md.md)] では既知のリソース型のリストを提供できます。 これはクッキー内のクレームの逆シリアル化時に <xref:System.Runtime.Serialization.DataContractSerializer> を支援し、元の厳密に型指定されたオブジェクトを返すことができるようになります。  
  
   
  
## 例  
 このプロパティを取得する方法を次のコードに示します。  
  
 [!code-csharp[S\_UE\_SecureConversationServiceCredential\#2](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_secureconversationservicecredential/cs/source.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityStateEncoder">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Security.SecurityStateEncoder SecurityStateEncoder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Security.SecurityStateEncoder SecurityStateEncoder" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.SecureConversationServiceCredential.SecurityStateEncoder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Security.SecurityStateEncoder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クッキー シリアル化をエンコードおよびデコードするためのカスタマイズした <see cref="T:System.ServiceModel.Security.SecurityStateEncoder" /> を取得または設定します。</summary>
        <value>
          <see cref="T:System.ServiceModel.Security.SecurityStateEncoder" /> オブジェクト。これはカスタマイズされた <see cref="T:System.ServiceModel.Security.DataProtectionSecurityStateEncoder" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 "クッキー モード" では、サービスがクッキー形式でセキュリティ コンテキスト トークン \(SCT\) をクライアントに発行するため、セキュリティ状態を維持する必要がありません。 クライアントは要求メッセージでクッキーを送り返して、サービスに要求メッセージの保護を解除して検証する方法を伝達します。 SCT はセキュリティで保護されていないネットワーク経由で転送されることが多いため、保護する必要があります。  
  
 既定では、[!INCLUDE[indigo1](~/includes/indigo1-md.md)] は <xref:System.ServiceModel.Security.DataProtectionSecurityStateEncoder> クラスを使用して、データ保護 API \(DPAPI\) によりクッキーを保護します。 DPAPI が Web ファーム環境で機能するようにするには、すべてのバックエンド サービスが同じドメイン ユーザー アカウントとして実行されている必要があります。 言い換えると、サービスが Web ホストである場合は、インターネット インフォメーション サービス \(IIS\) ワーカー プロセスをドメイン ユーザーとして実行するよう構成する必要があります。  
  
 このプロパティにより、DPAPI を使用せずに、カスタマイズされた <xref:System.ServiceModel.Security.SecurityStateEncoder> を使用してクッキーを暗号化および復号化することができます。  
  
   
  
## 例  
 次のコードに、このプロパティを設定する方法を示します。  
  
 [!code-csharp[S\_UE\_SecureConversationServiceCredential\#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_secureconversationservicecredential/cs/source.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>