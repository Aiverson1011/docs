<Type Name="WindowsClientCredential" FullName="System.ServiceModel.Security.WindowsClientCredential">
  <TypeSignature Language="C#" Value="public sealed class WindowsClientCredential" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WindowsClientCredential extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Security.WindowsClientCredential" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>クライアントを表すために使用される Windows 資格情報に関連するプロパティを指定できます。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.ServiceModel.Security.WindowsClientCredential> を使用して、サービスと通信するときに使用する Windows クライアントのプロパティを設定できます。<xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> は、クライアントを偽装するときにサービスが利用できる偽装のレベルを設定します。<xref:System.ServiceModel.Security.WindowsClientCredential.ClientCredential%2A> は、クライアントがユーザー名とパスワードを使用してサービスから認証を受けられるようにします。<xref:System.ServiceModel.Security.WindowsClientCredential.AllowNtlm%2A> は、Kerberos が使用されていない場合にクライアントの認証に NTLM を使用できるかどうかを決定します。  
  
   
  
## 例  
 クライアントを作成し、<xref:System.ServiceModel.Security.WindowsClientCredential> への参照を取得する例を次に示します。 コードでは、その後、<xref:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel%2A> を新しい値に変更します。  
  
 [!code-csharp[WindowsClientCredential\#1](~/samples/snippets/csharp/VS_Snippets_CFX/windowsclientcredential/cs/source.cs#1)]
 [!code-vb[WindowsClientCredential\#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/windowsclientcredential/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AllowedImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel AllowedImpersonationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel AllowedImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.WindowsClientCredential.AllowedImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>許可される偽装レベルを取得または設定します。</summary>
        <value>
          <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、Windows SSPI ネゴシエート認証の使用時にクライアントがサーバーに付与する偽装レベルを指定します。 サーバーがクライアント トークンを偽装するときに取得する偽装レベルは、この設定だけに依存するわけではありません。 サービスが実行されているアカウントの関連付けられている特権やドメインの設定にも依存します。  
  
 クライアントは、このプロパティを使って、許可される偽装レベルを明示的に設定する必要があります。  
  
 クライアントが匿名偽装レベルを指定した場合、サービスで偽装が実行されなくても、クライアントは常に匿名ユーザーとしてサービスから認証されます。 これは、基になる Windows オペレーティング システムの動作によるものです。  
  
 [!INCLUDE[crabout](~/includes/crabout-md.md)] 移動して、偽装 Windows [Impersonating and Reverting](http://go.microsoft.com/fwlink/?LinkId=96178)します。[!INCLUDE[crabout](~/includes/crabout-md.md)] を使用した偽装[!INCLUDE[indigo1](~/includes/indigo1-md.md)]、「[Delegation and Impersonation with WCF](http://msdn.microsoft.com/ja-jp/110e60f7-5b03-4b69-b667-31721b8e3152)」を参照してください。  
  
   
  
## 例  
 このプロパティを設定する方法を次の例に示します。  
  
 [!code-csharp[WindowsClientCredential\#1](~/samples/snippets/csharp/VS_Snippets_CFX/windowsclientcredential/cs/source.cs#1)]
 [!code-vb[WindowsClientCredential\#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/windowsclientcredential/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowNtlm">
      <MemberSignature Language="C#" Value="public bool AllowNtlm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowNtlm" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.WindowsClientCredential.AllowNtlm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Windows SSPI ネゴシエート認証時に NTLM 認証を許可するかどうかを示す値を取得または設定します。</summary>
        <value>Windows SSPI ネゴシエート認証時に NTLM 認証を許可する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを `true` に設定すると、Kerberos 認証を利用できない場合、NTLM 認証にダウングレードできます。  
  
 このプロパティを `false` に設定すると、NTLM が使用されている場合、[!INCLUDE[indigo1](~/includes/indigo1-md.md)] はベスト エフォートで例外をスローします。 ただし、このプロパティを `false` に設定しても、ネットワーク経由で NTLM 資格情報が送信されなくなるとは限りません。  
  
 ワークグループやローカル アカウントなどの一部の展開では NTLM 認証が必要です。 そのような展開でこのフラグを `false` に設定すると、[!INCLUDE[indigo2](~/includes/indigo2-md.md)] の使用時に認証が失敗します。 相互認証 \(Kerberos のみでサポート\) を必要とする展開では、このフラグを `false` に設定します。  
  
 NTLM \(Windows NT LAN Manager\) は、Windows NT オペレーティング システムを実行するシステムで構成されるネットワーク上、およびスタンドアロン システム上で使用される認証プロトコルです。  
  
 Microsoft Kerberos セキュリティ パッケージを使用すると、NTLM と比較してネットワーク上のシステムのセキュリティを大幅に強化できます。 推奨されるプロトコルは Microsoft Kerberos ですが、NTLM も依然としてサポートされており、ネットワーク上に Windows NT 4.0 かそれ以前のバージョンを実行しているシステムが配置されている場合およびスタンドアロン システムでは、ネットワーク認証に NTLM プロトコルを使用する必要があります。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCredential">
      <MemberSignature Language="C#" Value="public System.Net.NetworkCredential ClientCredential { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.NetworkCredential ClientCredential" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Security.WindowsClientCredential.ClientCredential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.NetworkCredential</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Windows クライアント資格情報を取得または設定します。</summary>
        <value>クライアントの <see cref="T:System.Net.NetworkCredential" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 By default, the current thread's credentials are used by [!INCLUDE[indigo2](~/includes/indigo2-md.md)] for doing Windows SSPI Negotiate authentication.  
  
 To authenticate the client as another principal, change the properties of the instance of the <xref:System.Net.NetworkCredential> class that is returned by this property. Alternatively, create a new instance of the <xref:System.Net.NetworkCredential> class and assign it to this property.  
  
   
  
## 例  
 The following code examples show how to authenticate the client as a different principal.  
  
 This is how to change the properties of the instance of the <xref:System.Net.NetworkCredential> class that is returned by this property.  
  
 [!code-csharp[WindowsClientCredential\#2](~/samples/snippets/csharp/VS_Snippets_CFX/windowsclientcredential/cs/source.cs#2)]  
  
 This is how to create a new instance of the <xref:System.Net.NetworkCredential> class and assign it to this property.  
  
 [!code-csharp[WindowsClientCredential\#3](~/samples/snippets/csharp/VS_Snippets_CFX/windowsclientcredential/cs/source.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>