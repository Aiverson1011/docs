<Type Name="ResourceManager" FullName="System.Resources.ResourceManager">
  <TypeSignature Language="C#" Value="public class ResourceManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ResourceManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceManager" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>実行時にカルチャ固有のリソースにアクセスする便利な手段を提供するリソース マネージャーを表します。  
  
 **セキュリティに関するメモ**: このクラスのメソッドを信頼できないデータを指定して呼び出すことには、セキュリティ上のリスクが伴います。 このクラスのメソッドの呼び出しは、信頼されたデータだけを指定して実行してください。 詳細については、「[信頼されていないデータのセキュリティ リスク](https://docs.com/rick-anderson-1/8710/untrusted-data-security-risks)」を参照してください。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Resources.ResourceManager> class retrieves resources from a binary .resources file that is embedded in an assembly or from a standalone .resources file. If an app has been localized and localized resources have been deployed in [satellite assemblies](http://msdn.microsoft.com/ja-jp/8d5c6044-2919-41d2-8321-274706b295ac), it looks up culture\-specific resources, provides resource fallback when a localized resource does not exist, and supports resource serialization.  
  
 For more information about creating and managing resources in desktop apps and [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps, see the following sections:  
  
-   [Desktop Apps](#desktop)  
  
    -   [Creating Resources](#creating_resources)  
  
    -   [Instantiating a ResourceManager Object](#instantiating)  
  
    -   [ResourceManager and Culture\-Specific Resources](#CultureSpecific)  
  
    -   [Retrieving Resources](#retrieving)  
  
    -   [Handling MissingManifestResourceException and MissingSatelliteAssemblyException Exceptions](#exception)  
  
    -   [Resource Versioning](#versioning)  
  
    -   [\<satelliteassemblies\> Configuration File Node](#config)  
  
-   [Windows Store Apps](#ws)  
  
<a name="desktop"></a>   
## Desktop Apps  
 For desktop apps, the<xref:System.Resources.ResourceManager> class retrieves resources from binary resource \(.resources\) files. Typically, a language compiler or the  [Assembly Linker \(AL.exe\)](http://msdn.microsoft.com/ja-jp/b5382965-0053-47cf-b92f-862860275a01) embeds these resource files in an assembly. You can also use a <xref:System.Resources.ResourceManager> object to retrieve resources directly from a .resources file that is not embedded in an assembly, by calling the <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> method.  
  
> [!CAUTION]
>  Using standalone .resources files in an ASP.NET app will break XCOPY deployment, because the resources remain locked until they are explicitly released by the <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> method. If you want to deploy resources with your ASP.NET apps, you should compile your .resources files into satellite assemblies.  
  
 In a resource\-based app, one .resources file contains the resources of the default culture whose resources are used if no culture\-specific resources can be found. For example, if an app's default culture is English \(en\), the English language resources are used whenever localized resources cannot be found for a specific culture, such as English \(United States\) \(en\-US\) or French \(France\) \(fr\-FR\). Typically, the resources for the default culture are embedded in the main app assembly, and resources for other localized cultures are embedded in satellite assemblies. Satellite assemblies contain only resources. They have the same root file name as the main assembly and an extension of .resources.dll. For apps whose assemblies are not registered in the global assembly cache, satellite assemblies are stored in an app subdirectory whose name corresponds to the assembly's culture.  
  
<a name="creating_resources"></a>   
### Creating Resources  
 When you develop a resource\-based app, you store resource information in text files \(files that have a .txt or .restext extension\) or XML files \(files that have a .resx extension\). You then compile the text or XML files with the  [Resource File Generator \(Resgen.exe\)](http://msdn.microsoft.com/ja-jp/8ef159de-b660-4bec-9213-c3fbc4d1c6f4) to create a binary .resources file. You can then embed the resulting .resources file in an executable or library by using a compiler option such as **languageKeyword tag is not supported!!!!**  
 for the C\# and Visual Basic compilers, or you can embed it in a satellite assembly by using the . If you include a .resx file in your Visual Studio project, Visual Studio handles the compilation and embedding of default and localized resources automatically as part of the build process.  
  
 Ideally, you should create resources for every language your app supports, or at least for a meaningful subset of each language. The binary .resources file names follow the naming convention **placeholder tag is not supported!!!!**  
.**placeholder tag is not supported!!!!**  
.resources, where **placeholder tag is not supported!!!!**  
 is the name of the app or the name of a class, depending on the level of detail you want. The <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=fullName> property is used to determine **placeholder tag is not supported!!!!**  
. A resource for the app's default culture should be named **placeholder tag is not supported!!!!**  
.resources.  
  
 For example, suppose that an assembly has several resources in a resource file that has the base name MyResources. These resource files should have names such as MyResources.ja\-JP.resources for the Japan \(Japanese\) culture, MyResources.de.resources for the German culture, MyResources.zh\-CHS.resources for the simplified Chinese culture, and MyResources.fr\-BE.resources for the French \(Belgium\) culture. The default resource file should be named MyResources.resources. The culture\-specific resource files are commonly packaged in satellite assemblies for each culture. The default resource file should be embedded in the app's main assembly.  
  
 Note that  allows resources to be marked as private, but you should always mark them as public so they can be accessed by other assemblies. \(Because a satellite assembly contains no code, resources that are marked as private are unavailable to your app through any mechanism.\)  
  
 For more information about creating, packaging, and deploying resources, see the articles [Creating Resource Files](http://msdn.microsoft.com/ja-jp/6c5ad891-66a0-4e7a-adcf-f41863ba6d8d), [Creating Satellite Assemblies](http://msdn.microsoft.com/ja-jp/8d5c6044-2919-41d2-8321-274706b295ac), and [Packaging and Deploying Resources](http://msdn.microsoft.com/ja-jp/b224d7c0-35f8-4e82-a705-dd76795e8d16).  
  
<a name="instantiating"></a>   
### Instantiating a ResourceManager Object  
 You instantiate a <xref:System.Resources.ResourceManager> object that retrieves resources from an embedded .resources file by calling one of its class constructor overloads. This tightly couples a <xref:System.Resources.ResourceManager> object with a particular .resources file and with any associated localized .resources files in satellite assemblies.  
  
 The two most commonly called constructors are:  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> looks up resources based on two pieces of information that you supply: the base name of the .resources file, and the assembly in which the default .resources file resides. The base name includes the namespace and root name of the .resources file, without its culture or extension. Note that .resources files that are compiled from the command line typically do not include a namespace name, whereas .resources files that are created in the Visual Studio environment do. For example, if a resource file is named MyCompany.StringResources.resources and the <xref:System.Resources.ResourceManager> constructor is called from a static method named `Example.Main`, the following code instantiates a <xref:System.Resources.ResourceManager> object that can retrieve resources from the .resources file:  
  
     [!code-csharp[Conceptual.Resources.Retrieving\#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#1)]
     [!code-vb[Conceptual.Resources.Retrieving\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#1)]  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> looks up resources in satellite assemblies based on information from a type object. The type's fully qualified name corresponds to the base name of the .resources file without its file name extension. In desktop apps that are created by using the Visual Studio Resource Designer, Visual Studio creates a wrapper class whose fully qualified name is the same as the root name of the .resources file. For example, if a resource file is named MyCompany.StringResources.resources and there is a wrapper class named `MyCompany.StringResources`, the following code instantiates a <xref:System.Resources.ResourceManager> object that can retrieve resources from the .resources file:  
  
     [!code-csharp[Conceptual.Resources.Retrieving\#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#2)]
     [!code-vb[Conceptual.Resources.Retrieving\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#2)]  
  
 If the appropriate resources cannot be found, the constructor call creates a valid <xref:System.Resources.ResourceManager> object. However, the attempt to retrieve a resource throws a <xref:System.Resources.MissingManifestResourceException> exception. For information about dealing with the exception, see the [Handling MissingManifestResourceException and MissingSatelliteAssembly Exceptions](#exception) section later in this article.  
  
 The following example shows how to instantiate a <xref:System.Resources.ResourceManager> object. It contains the source code for an executable named ShowTime.exe. It also includes the following text file named Strings.txt that contains a single string resource, `TimeHeader`:  
  
```  
TimeHeader=The current time is  
```  
  
 You can use a batch file to generate the resource file and embed it into the executable. Here's the batch file to generate an executable by using the C\# compiler:  
  
```  
  
resgen strings.txt  
csc ShowTime.cs /resource:strings.resources  
  
```  
  
 For the Visual Basic compiler, you can use the following batch file:  
  
```  
  
resgen strings.txt  
vbc ShowTime.vb /resource:strings.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.Class\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showtime.cs#1)]
 [!code-vb[System.Resources.ResourceManager.Class\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showtime.vb#1)]  
  
<a name="CultureSpecific"></a>   
### ResourceManager and Culture\-Specific Resources  
 A localized app requires resources to be deployed, as discussed in the article [Packaging and Deploying Resources](http://msdn.microsoft.com/ja-jp/b224d7c0-35f8-4e82-a705-dd76795e8d16). If the assemblies are properly configured, the resource manager determines which resources to retrieve based on the current thread's <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=fullName> property. \(That property also returns the current thread's UI culture.\) For example, if an app is compiled with default English language resources in the main assembly and with French and Russian language resources in two satellite assemblies, and the <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=fullName> property is set to fr\-FR, the resource manager retrieves the French resources.  
  
 You can set the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> property explicitly or implicitly. The way you set it determines how the <xref:System.Resources.ResourceManager> object retrieves resources based on culture:  
  
-   If you explicitly set the <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=fullName> property to a specific culture, the resource manager always retrieves the resources for that culture, regardless of the user's browser or operating system language. Consider an app that is compiled with default English language resources and three satellite assemblies that contain resources for English \(United States\), French \(France\), and Russian \(Russia\). If the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> property is set to fr\-FR, the <xref:System.Resources.ResourceManager> object always retrieves the French \(France\) resources, even if the user's operating system language is not French. Make sure that this is the desired behavior before you set the property explicitly.  
  
     In ASP.NET apps, you must set the <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=fullName> property explicitly, because it is unlikely that the setting on the server will match incoming client requests. An ASP.NET app can set the <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=fullName> property explicitly to the user's browser accept language.  
  
     Explicitly setting the <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=fullName> property defines the current UI culture for that thread. It does not affect the current UI culture of any other threads in an app.  
  
-   You can set the UI culture of all threads in an app domain by assigning a <xref:System.Globalization.CultureInfo> object that represents that culture to the static <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName> property.  
  
-   If you do not explicitly set the current UI culture and you do not define a default culture for the current app domain, the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property is set implicitly by the Windows **languageKeyword tag is not supported!!!!**  
     function. This function is provided by the Multilingual User Interface \(MUI\), which enables the user to set the default language. If the UI language is not set by the user, it defaults to the system\-installed language, which is the language of operating system resources.  
  
 The following simple "Hello world" example sets the current UI culture explicitly. It contains resources for three cultures: English \(United States\) or en\-US, French \(France\) or fr\-FR, and Russian \(Russia\) or ru\-RU. The en\-US resources are contained in a text file named Greetings.txt:  
  
```  
HelloString=Hello world!  
```  
  
 The fr\-FR resources are contained in a text file named Greetings.fr\-FR.txt:  
  
```  
HelloString=Salut tout le monde!  
```  
  
 The ru\-RU resources are contained in a text file named Greetings.ru\-RU.txt:  
  
```  
HelloString=Всем привет!  
```  
  
 Here's the source code for the example \(Example.vb for the Visual Basic version or Example.cs for the C\# version\):  
  
 [!code-csharp[Conceptual.Resources.CurrentCulture\#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.currentculture/cs/example.cs#1)]
 [!code-vb[Conceptual.Resources.CurrentCulture\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.currentculture/vb/example.vb#1)]  
  
 To compile this example, create a batch \(.bat\) file that contains the following commands and run it from the command prompt. If you're using C\#, specify `csc` instead of `vbc` and `Example.cs` instead of `Example.vb`.  
  
```  
resgen Greetings.txt   
vbc Example.vb /resource:Greetings.resources  
  
resgen Greetings.fr-FR.txt  
Md fr-FR  
al /embed:Greetings.fr-FR.resources /culture:fr-FR /out:fr-FR\Example.resources.dll  
  
resgen Greetings.ru-RU.txt  
Md ru-RU  
al /embed:Greetings.ru-RU.resources /culture:ru-RU /out:ru-RU\Example.resources.dll  
```  
  
<a name="retrieving"></a>   
### Retrieving Resources  
 You call the <xref:System.Resources.ResourceManager.GetObject%28System.String%29> and <xref:System.Resources.ResourceManager.GetString%28System.String%29> methods to access a specific resource. You can also call the <xref:System.Resources.ResourceManager.GetStream%28System.String%29> method to retrieve non\-string resources as a byte array. By default, in an app that has localized resources, these methods return the resource for the culture determined by the current UI culture of the thread that made the call. See the previous section, [ResourceManager and Culture\-Specific Resources](#CultureSpecific), for more information about how the current UI culture of a thread is defined. If the resource manager cannot find the resource for the current thread's UI culture, it uses a fallback process to retrieve the specified resource. If the resource manager cannot find any localized resources, it uses the resources of the default culture. For more information about resource fallback rules, see the "Resource Fallback Process" section of the article [Packaging and Deploying Resources](http://msdn.microsoft.com/ja-jp/b224d7c0-35f8-4e82-a705-dd76795e8d16).  
  
> [!NOTE]
>  If the .resources file specified in the <xref:System.Resources.ResourceManager> class constructor cannot be found, the attempt to retrieve a resource throws a <xref:System.Resources.MissingManifestResourceException> or <xref:System.Resources.MissingSatelliteAssemblyException> exception. For information about dealing with the exception, see the [Handling  MissingManifestResourceException and MissingSatelliteAssemblyException Exceptions](#exception) section later in this topic.  
  
 The following example uses the <xref:System.Resources.ResourceManager.GetString%2A> method to retrieve culture\-specific resources. It consists of resources compiled from .txt files for the English \(en\), French \(France\) \(fr\-FR\), and Russian \(Russia\) \(ru\-RU\) cultures. The example changes the current culture and current UI culture to English \(United States\), French \(France\), Russian \(Russia\), and Swedish \(Sweden\). It then calls the <xref:System.Resources.ResourceManager.GetString%2A> method to retrieve the localized string, which it displays along with the current day and month. Notice that the output displays the appropriate localized string except when the current UI culture is Swedish \(Sweden\). Because Swedish language resources are unavailable, the app instead uses the resources of the default culture, which is English.  
  
 The example requires the text\-based resource files listed in following table. Each has a single string resource named `DateStart`.  
  
|Culture|File name|Resource name|Resource value|  
|-------------|---------------|-------------------|--------------------|  
|en\-US|DateStrings.txt|`DateStart`|Today is|  
|fr\-FR|DateStrings.fr\-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru\-RU|DateStrings.ru\-RU.txt|`DateStart`|Сегодня|  
  
 Here's the source code for the example \(ShowDate.vb for the Visual Basic version or ShowDate.cs for the C\# version of the code\).  
  
 [!code-csharp[System.Resources.ResourceManager.Class\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 To compile this example, create a batch file that contains the following commands and run it from the command prompt. If you're using C\#, specify `csc` instead of `vbc` and `showdate.cs` instead of `showdate.vb`.  
  
```  
  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
  
```  
  
 There are two ways to retrieve the resources of a specific culture other than the current UI culture:  
  
-   You can call the <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>,  <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>, or <xref:System.Resources.ResourceManager.GetStream%28System.String%2CSystem.Globalization.CultureInfo%29> method to retrieve a resource for a specific culture. If a localized resource cannot be found, the resource manager uses the resource fallback process to locate an appropriate resource.  
  
-   You can call the <xref:System.Resources.ResourceManager.GetResourceSet%2A> method to obtain a <xref:System.Resources.ResourceSet> object that represents the resources for a particular culture. In the method call, you can determine whether the resource manager probes for parent cultures if it is unable to find localized resources, or whether it simply falls back to the resources of the default culture. You can then use the <xref:System.Resources.ResourceSet> methods to access the resources \(localized for that culture\) by name, or to enumerate the resources in the set.  
  
<a name="exception"></a>   
### Handling MissingManifestResourceException and MissingSatelliteAssemblyException Exceptions  
 If you try to retrieve a specific resource, but the resource manager cannot find that resource and either no default culture has been defined or the resources of the default culture cannot be located, the resource manager throws a <xref:System.Resources.MissingManifestResourceException> exception if it expects to find the resources in the main assembly or a <xref:System.Resources.MissingSatelliteAssemblyException> if it expects to find the resources in a satellite assembly. Note that the exception is thrown when you call a resource retrieval method such as <xref:System.Resources.ResourceManager.GetString%2A> or <xref:System.Resources.ResourceManager.GetObject%2A>, and not when you instantiate a <xref:System.Resources.ResourceManager> object.  
  
 The exception is typically thrown under the following conditions:  
  
-   The appropriate resource file or satellite assembly does not exist. If the resource manager expects the app's default resources to be embedded in the main app assembly, they are absent. If the <xref:System.Resources.NeutralResourcesLanguageAttribute> attribute indicates that the app's default resources reside in a satellite assembly, that assembly cannot be found. When you compile your app, make sure that resources are embedded in the main assembly or that the necessary satellite assembly is generated and is named appropriately. Its name should take the form **placeholder tag is not supported!!!!**  
    .resources.dll, and it should be located in a directory named after the culture whose resources it contains.  
  
-   Your app doesn't have a default or neutral culture defined. Add the <xref:System.Resources.NeutralResourcesLanguageAttribute> attribute to a source code file or to the project information file \(AssemblyInfo.vb for a Visual Basic app or AssemblyInfo.cs for a C\# app\) file.  
  
-   The **parameterReference tag is not supported!!!!**  
     parameter in the <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> constructor does not specify the name of a .resources file. The name should include the resource file's fully qualified namespace but not its file name extension. Typically, resource files that are created in Visual Studio include namespace names, but resource files that are created and compiled at the command prompt do not. You can determine the names of embedded .resources files by compiling and running the following utility. This is a console app that accepts the name of a main assembly or satellite assembly as a command\-line parameter. It displays the strings that should be provided as the **parameterReference tag is not supported!!!!**  
     parameter so that the resource manager can correctly identify the resource.  
  
     [!code-csharp[System.Resources.ResourceManager.Class\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
     [!code-vb[System.Resources.ResourceManager.Class\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 If you are changing the current culture of your application explicitly, you should also remember that the resource manager retrieves a resource set based on the value of the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property, and not the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName> property. Typically, if you change one value, you should also change the other.  
  
<a name="versioning"></a>   
### Resource Versioning  
 Because the main assembly that contains an app's default resources is separate from the app's satellite assemblies, you can release a new version of your main assembly without redeploying the satellite assemblies. You use the <xref:System.Resources.SatelliteContractVersionAttribute> attribute to use existing satellite assemblies and instruct the resource manager not to redeploy them with a new version of your main assembly,  
  
 For more information about versioning support for satellite assemblies, see the article [Retrieving Resources](http://msdn.microsoft.com/ja-jp/eca16922-1c46-4f68-aefe-e7a12283641f).  
  
<a name="config"></a>   
### \<satelliteassemblies\> Configuration File Node  
 For executables that are deployed and run from a website \(HREF .exe files\), the <xref:System.Resources.ResourceManager> object may probe for satellite assemblies over the web, which can hurt your app's performance. To eliminate the performance problem, you can limit this probing to the satellite assemblies that you have deployed with your app. To do this, you create a `<satelliteassemblies>` node in your app's configuration file to specify that you have deployed a specific set of cultures for your app, and that the <xref:System.Resources.ResourceManager> object should not try to probe for any culture that is not listed in that node.  
  
> [!NOTE]
>  The preferred alternative to creating a `<satelliteassemblies>` node is to use the [ClickOnce Deployment Manifest](http://msdn.microsoft.com/ja-jp/8457e615-e3b6-4990-8dcf-11bc590e4e9b) feature.  
  
 In your app's configuration file, create a section similar to the following:  
  
```  
<?xml version ="1.0"?>  
<configuration>  
    <satelliteassemblies>  
        <assembly name="MainAssemblyName, Version=versionNumber, Culture=neutral, PublicKeyToken=null|yourPublicKeyToken">  
            <culture>cultureName1</culture>  
            <culture>cultureName2</culture>  
            <culture>cultureName3</culture>  
        </assembly>  
    </satelliteassemblies>  
</configuration>  
```  
  
 Edit this configuration information as follows:  
  
-   Specify one or more `<assembly>` nodes for each main assembly that you deploy, where each node specifies a fully qualified assembly name. Specify the name of your main assembly in place of **placeholder tag is not supported!!!!**  
    , and specify the `Version`, `PublicKeyToken`, and `Culture` attribute values that correspond to your main assembly.  
  
     For the `Version` attribute, specify the version number of your assembly. For example, the first release of your assembly might be version number 1.0.0.0.  
  
     For the `PublicKeyToken` attribute, specify the keyword `null` if you have not signed your assembly with a strong name, or specify your public key token if you have signed your assembly.  
  
     For the `Culture` attribute, specify the keyword `neutral` to designate the main assembly and cause the <xref:System.Resources.ResourceManager> class to probe only for the cultures listed in the `<culture>` nodes.  
  
     For more information about fully qualified assembly names, see the article [Assembly Names](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e). For more information about strong\-named assemblies, see the article [Creating and Using Strong\-Named Assemblies](http://msdn.microsoft.com/ja-jp/ffbf6d9e-4a88-4a8a-9645-4ce0ee1ee5f9).  
  
-   Specify one or more `<culture>` nodes with a specific culture name, such as "fr\-FR", or a neutral culture name, such as "fr".  
  
 If resources are needed for any assembly not listed under the `<satelliteassemblies>` node, the <xref:System.Resources.ResourceManager> class probes for cultures using standard probing rules.  
  
<a name="ws"></a>   
## [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] Apps  
  
> [!IMPORTANT]
>  Although the <xref:System.Resources.ResourceManager> class is supported in [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps, we do not recommend its use. Use this class only when you develop [!INCLUDE[net_portable](~/includes/net-portable-md.md)] projects that can be used with [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps. To retrieve resources from [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps, use the [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182) class instead.  
  
 For [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps, the<xref:System.Resources.ResourceManager> class retrieves resources from package resource index \(PRI\) files. A single PRI file \(the application package PRI file\) contains the resources for both the default culture and any localized cultures. You use the MakePRI utility to create a PRI file from one or more resource files that are in XML resource \(.resw\) format. For resources that are included in a Visual Studio project, Visual Studio handles the process of creating and packaging the PRI file automatically. You can then use the .NET Framework <xref:System.Resources.ResourceManager> class to access the app's or library's resources.  
  
 You can instantiate a <xref:System.Resources.ResourceManager> object for a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app in the same way that you do for a desktop app.  
  
 You can then access the resources for a particular culture by passing the name of the resource to be retrieved to the <xref:System.Resources.ResourceManager.GetString%28System.String%29> method. By default, this method returns the resource for the culture determined by the current UI culture of the thread that made the call. You can also retrieve the resources for a specific culture by passing the name of the resource and a <xref:System.Globalization.CultureInfo> object that represents the culture whose resource is to be retrieved to the <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> method. If the resource for the current UI culture or the specified culture cannot be found, the resource manager uses a UI language fallback list to locate a suitable resource.  
  
   
  
## 例  
 The following example demonstrates how to use an explicit culture and the implicit current UI culture to obtain string resources from a main assembly and a satellite assembly. For more information, see the "Directory Locations for Satellite Assemblies Not Installed in the Global Assembly Cache" section of the [Creating Satellite Assemblies](http://msdn.microsoft.com/ja-jp/8d5c6044-2919-41d2-8321-274706b295ac) topic.  
  
 To run this example:  
  
1.  In the app directory, create a file named rmc.txt that contains the following resource strings:  
  
    ```  
  
    day=Friday  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
2.  Use the  [Resource File Generator](http://msdn.microsoft.com/ja-jp/8ef159de-b660-4bec-9213-c3fbc4d1c6f4) to generate the rmc.resources resource file from the rmc.txt input file as follows:  
  
    ```  
    resgen rmc.txt  
    ```  
  
3.  Create a subdirectory of the app directory and name it "es\-MX". This is the culture name of the satellite assembly that you will create in the next three steps.  
  
4.  Create a file named rmc.es\-MX.txt in the es\-MX directory that contains the following resource strings:  
  
    ```  
  
    day=Viernes  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
5.  Use the  [Resource File Generator](http://msdn.microsoft.com/ja-jp/8ef159de-b660-4bec-9213-c3fbc4d1c6f4) to generate the rmc.es\-MX.resources resource file from the rmc.es\-MX.txt input file as follows:  
  
    ```  
    resgen rmc.es-MX.txt  
    ```  
  
6.  Assume that the filename for this example is rmc.vb or rmc.cs. Copy the following source code into a file. Then compile it and embed the main assembly resource file, rmc.resources, in the executable assembly. If you are using the Visual Basic compiler, the syntax is:  
  
    ```  
    vbc rmc.vb /resource:rmc.resources  
    ```  
  
     The corresponding syntax for the C\# compiler is:  
  
    ```  
    csc /resource:rmc.resources rmc.cs  
    ```  
  
7.  Use the  [Assembly Linker](http://msdn.microsoft.com/ja-jp/b5382965-0053-47cf-b92f-862860275a01) to create a satellite assembly. If the base name of the app is rmc, the satellite assembly name must be rmc.resources.dll. The satellite assembly should be created in the es\-MX directory. If es\-MX is the current directory, use this command:  
  
    ```  
    al /embed:rmc.es-MX.resources /c:es-MX /out:rmc.resources.dll   
    ```  
  
8.  Run rmc.exe to obtain and display the embedded resource strings.  
  
 [!code-csharp[ResourceManager\_Class\#1](~/samples/snippets/csharp/VS_Snippets_CLR/ResourceManager_Class/cs/rmc.cs#1)]
 [!code-vb[ResourceManager\_Class\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ResourceManager_Class/vb/rmc.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>This type is thread safe.</threadsafe>
    <altmember cref="T:System.Globalization.CultureInfo" />
    <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
    <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ResourceManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを既定値で初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターはから派生するクラスを記述する場合にのみ役立ちます、 <xref:System.Resources.ResourceManager> クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (Type resourceSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type resourceSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.Type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resourceSource" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="resourceSource">リソース マネージャーが .resources ファイルを検索するために必要なすべての情報を取得する元となる種類。</param>
        <summary>指定した型オブジェクトの情報に基づいて、サテライト アセンブリでリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
## デスクトップ アプリ  
 リソース マネージャーを使用してデスクトップ アプリケーションでは、 `resourceSource` パラメーターは次のように特定のリソース ファイルを読み込めません。  
  
-   場合、 <xref:System.Resources.NeutralResourcesLanguageAttribute> 属性が既定のカルチャのリソースがサテライト アセンブリに存在することは、リソース マネージャーで指定された型と同じアセンブリで、既定のカルチャ リソース ファイルで見つかったことを想定していますを示すために使用されない、 `resourceSource` パラメーター。  
  
-   リソース マネージャーでは、既定のリソース ファイルが、基本と同じ名前で指定された型であると想定しています、 `resourceSource` パラメーター。  
  
-   リソース マネージャーは、既定値を使用して <xref:System.Resources.ResourceSet> リソース ファイルを操作するクラス。  
  
 たとえば、MyCompany.MyProduct.MyType という名前の型を指定するには、リソース マネージャーを探します MyType を定義するアセンブリで MyCompany.MyProduct.MyType.resources をという名前の .resources ファイルです。  
  
 Visual Studio で、リソース デザイナーを自動的に生成コードを定義する、 `internal` \(C\# の場合\) または `Friend` \(Visual Basic\) では、クラスの名前は既定のカルチャの .resources ファイルのベース名と同じです。 インスタンスを作成できるようになります、 <xref:System.Resources.ResourceManager> オブジェクトし、クラスがコンパイラに表示されている限り、リソースにもする必要がありますので、リソースの名前に対応する名前、型のオブジェクトを取得することによって、特定のリソースのセットを結合します。 たとえば、.resources ファイルが \[Resource1 をという名前の場合、次のステートメントをインスタンス化、 <xref:System.Resources.ResourceManager> \[Resource1 をという名前の .resources ファイルを管理するオブジェクト。  
  
 [!code-csharp[System.Resources.ResourceManager.ctor\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/ctor1.cs#2)]  
  
 Visual Studio を使用していない場合は、メンバーを持たないが名前空間と名前は、既定の .resources ファイルのと同じクラスを作成することができます。 具体的な例を次に示します。  
  
## [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  ですが、 <xref:System.Resources.ResourceManager> クラスではサポートされて [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ、お勧めしません使用します。 このクラスを使用して開発する場合のみ [!INCLUDE[net_portable](~/includes/net-portable-md.md)] で使用できるプロジェクト [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリです。 リソースを取得する [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 、アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182) クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ、 <xref:System.Resources.ResourceManager> を使用して、 `resourceSource` パラメーター、アセンブリ、基本名、およびリソース項目をアプリのパッケージ リソース インデックス \(PRI\) ファイル内に配置できる場所の名前空間を推論します。 たとえばで定義されている MyCompany.MyProduct.MyType という名前の型を指定 `MyAssembly`, 、リソース マネージャーがリソース MyAssembly という名前の識別子のセットを検索し、MyCompany.MyProduct.MyType そのリソース セット内のスコープを探します。 リソース マネージャーは、このスコープ内での既定のコンテキスト \(現在のカルチャや現在のハイ コントラスト設定\) の下にあるリソース項目を検索します。  
  
   
  
## 例  
 次の例では、 <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> インスタンスを作成するコンス トラクター、 <xref:System.Resources.ResourceManager> オブジェクトです。 構成は次の英語 \(en\)、フランス語 \(フランス\) \(FR\-FR\)、およびロシア語 \(ロシア\) \(RU\-RU\) .txt ファイルからコンパイルされたリソースのカルチャ。 例は、英語 \(米国\)、フランス語 \(フランス\)、ロシア語 \(ロシア\)、およびスウェーデン語 \(スウェーデン\) を現在のカルチャと現在の UI カルチャを変更します。 呼び出して、 <xref:System.Resources.ResourceManager.GetString%28System.String%29> 時間帯に依存している応答メッセージを表示するローカライズされた文字列を取得します。  
  
 例では、次の表に記載されている、3 つのテキスト ベースのリソース ファイルが必要です。 各ファイルには、という名前の文字列リソースが含まれています。 `Morning`, 、`Afternoon`, 、および `Evening`です。  
  
|カルチャ|ファイル名|リソース名|リソースの値|  
|----------|-----------|-----------|------------|  
|en\-US|GreetingResources.txt|`Morning`|おはようございます|  
|en\-US|GreetingResources.txt|`Afternoon`|こんにちは|  
|en\-US|GreetingResources.txt|`Evening`|こんばんは|  
|fr\-FR|GreetingResources.fr FR.txt|`Morning`|Bonjour|  
|fr\-FR|GreetingResources.fr FR.txt|`Afternoon`|Bonjour|  
|fr\-FR|GreetingResources.fr FR.txt|`Evening`|Bonsoir|  
|ru\-RU|GreetingResources.ru RU.txt|`Morning`|ДОБРОЕ УТРО|  
|ru\-RU|GreetingResources.ru RU.txt|`Afternoon`|ДОБРЫЙ ДЕНЬ|  
|ru\-RU|GreetingResources.ru RU.txt|`Evening`|ДОБРЫЙ ВЕЧЕР|  
  
 次のバッチ ファイルを使用して、Visual Basic の例をコンパイルし、Greet.exe を名前付き実行可能ファイルを作成することができます。 C\# でコンパイルからコンパイラ名を変更します。 `vbc` に `csc` とファイル拡張子を `.vb` に `.cs`します。  
  
```  
  
resgen GreetingResources.txt  
vbc Greet.vb /resource: GreetingResources.resources  
  
md fr-FR  
resgen GreetingResources.fr-FR.txt  
al /out:fr-FR\Greet.resources.dll /culture:fr-FR /embed: GreetingResources.fr-FR.resources   
  
md ru-RU  
resgen GreetingResources.ru-RU.txt  
al /out:ru-RU\Greet.resources.dll /culture:ru-RU /embed: GreetingResources.ru-RU.resources  
  
```  
  
 \(Visual Basic バージョン ShowDate.vb\) または ShowDate.cs c\# バージョンのコードの例のソース コードを次に示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Ctor\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/greet.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Ctor\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/greet.vb#3)]  
  
 In addition to defining an app class named `Example`, the source code defines an internal class whose name, `GreetingResources`, is the same as the base name of the resource files. This makes it possible to successfully instantiate a <xref:System.Resources.ResourceManager> object by calling the <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> constructor.  
  
 Notice that the output displays the appropriate localized string except when the current UI culture is Swedish \(Sweden\), in which case it uses English language resources. Because Swedish language resources are unavailable, the app uses the resources of the default culture, as defined by the <xref:System.Resources.NeutralResourcesLanguageAttribute> attribute, instead.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceSource" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="baseName">拡張子はないが、完全修飾名前空間名を含んだ、リソース ファイルのルート名。 たとえば、"MyApplication.MyResource.en\-US.resources" というリソース ファイルのルート名は "MyApplication.MyResource" です。</param>
        <param name="assembly">リソースのメイン アセンブリ。</param>
        <summary>指定したアセンブリ内で指定したルート名を持つファイルに含まれているリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
## デスクトップ アプリ  
 デスクトップ アプリでカルチャに固有の個々 のリソース ファイルは、サテライト アセンブリに含まれている必要があり、既定のカルチャのリソース ファイルは、メインのアセンブリに含まれている必要があります。 サテライト アセンブリでは、そのアセンブリのマニフェストに指定された 1 つのカルチャのリソースを含んでいると想定され、必要に応じて読み込まれます。  
  
> [!NOTE]
>  リソースを取得するアセンブリから取得するのではなく、直接 .resources ファイルから、呼び出す必要があります、 <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> メソッド代わりにインスタンス化する、 <xref:System.Resources.ResourceManager> オブジェクトです。  
  
 リソース ファイルがで識別される場合 `baseName` で見つからない `assembly`, 、メソッドをインスタンス化、 <xref:System.Resources.ResourceManager> オブジェクトで、かつ特定のリソースを取得しようとすると、通常、例外がスロー <xref:System.Resources.MissingManifestResourceException>します。 例外の原因を診断する方法については、「the MissingManifestResourceException 例外を処理する」を参照してください、 <xref:System.Resources.ResourceManager> クラスに関するトピック。  
  
## [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  ですが、 <xref:System.Resources.ResourceManager> クラスではサポートされて [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ、お勧めしません使用します。 このクラスを使用して開発する場合のみ [!INCLUDE[net_portable](~/includes/net-portable-md.md)] で使用できるプロジェクト [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリです。 リソースを取得する [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 、アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182) クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ、リソース マネージャーの簡易名を使用して、 `assembly` アプリのパッケージ リソース インデックス \(PRI\) ファイルで一致するリソースを検索するパラメーターを設定します。`baseName` リソース セット内のリソース項目を検索するパラメーターを使用します。 たとえば、PortableLibrary1.Resource1.de DE.resources のルート名は PortableLibrary1.Resource1 です。  
  
   
  
## 例  
 次の例を示すために、単純なローカライズされていない"Hello World"アプリケーションを使用して、 <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> コンス トラクターです。 ExampleResources.txt をという名前のテキスト ファイルの内容を次に示します。 アプリケーションのコンパイル時に、リソースがメイン アプリケーション アセンブリに埋め込まれます。  
  
```  
Greeting=Hello  
```  
  
 使用してバイナリ リソース ファイルをテキスト ファイルを変換できる、コマンド プロンプトで、次のようにします。  
  
```  
resgen ExampleResources.txt  
```  
  
 次の例は、実行可能コードをインスタンス化する、 <xref:System.Resources.ResourceManager> オブジェクトの名前を入力するように求めるし、あいさつ文が表示されます。  
  
 [!code-csharp[System.Resources.ResourceManager.ctor\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/example.cs#1)]
 [!code-vb[System.Resources.ResourceManager.ctor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/example.vb#1)]  
  
 Visual Basic では、次のコマンドを使用してコンパイルしておくことができます。  
  
```  
vbc Example.vb /resource:ExampleResources.resources  
```  
  
 または、次を使用して c\# ではコマンドします。  
  
```  
csc Example.cs /resource:ExampleResources.resources  
```  
  
 いる例では、取得するには、そのアセンブリで定義された型を渡すことによって、リソース ファイルを含むアセンブリへの参照、 `typeof` \(c\#\) の関数または `GetType` \(Visual Basic\) で機能し、値を取得するその <xref:System.Type.Assembly%2A?displayProperty=fullName> プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> パラメーターまたは <paramref name="assembly" /> パラメーターが <see langword="null" /> です。</exception>
        <block subset="none" type="overrides">
          <para>This constructor uses the system-provided <see cref="T:System.Resources.ResourceSet" /> implementation. To use a custom resource file format, you should derive from the <see cref="T:System.Resources.ResourceSet" /> class, override the <see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> and <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> methods, and pass that type to the <see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" /> constructor. Using a custom <see cref="T:System.Resources.ResourceSet" /> can be useful for controlling resource caching policy or supporting your own resource file format, but is generally not necessary.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">拡張子はないが、完全修飾名前空間名を含んだ、リソース ファイルのルート名。 たとえば、"MyApplication.MyResource.en\-US.resources" というリソース ファイルのルート名は "MyApplication.MyResource" です。</param>
        <param name="assembly">リソースのメイン アセンブリ。</param>
        <param name="usingResourceSet">使用するカスタム <see cref="T:System.Resources.ResourceSet" /> の種類。<see langword="null" /> の場合は、既定のランタイム <see cref="T:System.Resources.ResourceSet" /> オブジェクトが使用されます。</param>
        <summary>指定した <see cref="T:System.Resources.ResourceSet" /> クラスを使用して、指定したアセンブリ内で指定したルート名を持つファイルに含まれるリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 カルチャに固有の個々 のリソース ファイルは、サテライト アセンブリに含まれている必要があり、既定のカルチャのリソース ファイルは、メインのアセンブリに含まれている必要があります。 サテライト アセンブリでは、そのアセンブリのマニフェストに指定された 1 つのカルチャのリソースを含んでいると想定され、必要に応じて読み込まれます。  
  
> [!NOTE]
>  リソースを取得するアセンブリから取得するのではなく、直接 .resources ファイルから、呼び出す必要があります、 <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> メソッド代わりにインスタンス化する、 <xref:System.Resources.ResourceManager> オブジェクトです。  
  
 リソース ファイルがで識別される場合 `baseName` で見つからない `assembly`, 、メソッドをインスタンス化、 <xref:System.Resources.ResourceManager> オブジェクトで、かつ特定のリソースを取得しようとすると、通常、例外がスロー <xref:System.Resources.MissingManifestResourceException>します。 例外の原因を診断する方法については、「the MissingManifestResourceException 例外を処理する」を参照してください、 <xref:System.Resources.ResourceManager> クラスに関するトピック。  
  
> [!NOTE]
>  `usingResourceSet` パラメーターは、独自のリソース形式をサポートするために使用され、多くの場合、 `null`です。 受け取るコンス トラクターとは異なる、 <xref:System.Type> のみです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="usingResourceset" /> 派生クラスではない <see cref="T:System.Resources.ResourceSet" />します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> パラメーターまたは <paramref name="assembly" /> パラメーターが <see langword="null" /> です。</exception>
        <block subset="none" type="usage">
          <para>This constructor lets you specify a <see cref="T:System.Resources.ResourceSet" /> implementation. If you do not want a specific <see cref="T:System.Resources.ResourceSet" /> implementation but would like to use a custom resource file format, you should derive from the <see cref="T:System.Resources.ResourceSet" /> class, override the <see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> and <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> methods, and pass that type to this constructor.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="BaseName">
      <MemberSignature Language="C#" Value="public virtual string BaseName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseName" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.BaseName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名を取得します。</summary>
        <value>
          <see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Resources.ResourceManager.BaseName%2A> プロパティには、完全修飾名前空間の名前とカルチャまたはファイル名拡張子の付かないのリソース ファイルのルート リソース名が反映されます。 たとえば、アプリの既定のリソース ファイルの名前は `SampleApps.StringResources.resources`, の値、 <xref:System.Resources.ResourceManager.BaseName%2A> プロパティは、"SampleApps.StringResources"です。 アプリの既定のリソース ファイルの名前を付けて場合 `SampleApps.StringResources.en-US.resources` しの値、サテライト アセンブリに組み込まれて、 <xref:System.Resources.ResourceManager.BaseName%2A> プロパティが"SampleApps.StringResources"ではまだです。  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager.BaseName%2A> を含めない限り、明示的にいずれかのファイルをコンパイルするときに、コンパイルされ、コマンドラインから埋め込みリソース ファイルのプロパティの値で名前空間の名前が含まれません。 一方で、 <xref:System.Resources.ResourceManager.BaseName%2A> コンパイルされ、通常の Visual Studio 環境に埋め込まれたリソース ファイルのプロパティの値では既定の名前空間の名前。  
  
 <xref:System.Resources.ResourceManager.BaseName%2A> に渡される文字列と同じプロパティ値が、 <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> または <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> コンス トラクターのインスタンス化するとき、 <xref:System.Resources.ResourceManager> インスタンス。  
  
   
  
## 例  
 コンパイルし、次のユーティリティを実行して、埋め込みの .resources ファイルの名前を確認できます。 これは、メイン アセンブリまたはコマンド ライン パラメーターとしてのサテライト アセンブリの名前を受け入れ、コンソール アプリケーションです。 として提供される文字列を表示、 `baseName` のパラメーター、 <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> または <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> コンス トラクター、リソース マネージャーでは、リソースを正しく特定できるようにします。  
  
 [!code-csharp[System.Resources.ResourceManager.Class\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
 [!code-vb[System.Resources.ResourceManager.Class\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseNameField">
      <MemberSignature Language="C#" Value="protected string BaseNameField;" />
      <MemberSignature Language="ILAsm" Value=".field family string BaseNameField" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.BaseNameField" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Resources.ResourceManager.BaseNameField> フィールドにから派生するクラスを記述する場合にのみ役立ちますが、 <xref:System.Resources.ResourceManager> クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFileBasedResourceManager">
      <MemberSignature Language="C#" Value="public static System.Resources.ResourceManager CreateFileBasedResourceManager (string baseName, string resourceDir, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.CreateFileBasedResourceManager(System.String,System.String,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="resourceDir" Type="System.String" />
        <Parameter Name="usingResourceSet" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="baseName">リソースのルート名。 たとえば、"MyResource.en\-US.resources" というリソース ファイルのルート名は "MyResource" です。</param>
        <param name="resourceDir">リソースを検索するディレクトリの名前。<c>resourceDir</c> には、アプリケーション ディレクトリを基準とした相対パス、または絶対パスを指定できます。</param>
        <param name="usingResourceSet">使用するカスタム <see cref="T:System.Resources.ResourceSet" /> の種類。<see langword="null" /> の場合は、既定のランタイム <see cref="T:System.Resources.ResourceSet" /> オブジェクトが使用されます。</param>
        <summary>リソースのアセンブリ マニフェストではなく特定のディレクトリを検索する <see cref="T:System.Resources.ResourceManager" /> オブジェクトを返します。</summary>
        <returns>リソースのアセンブリ マニフェストの代わりに指定されたディレクトリを検索する、リソース マネージャーの新しいインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アセンブリに埋め込まれていない .resources ファイルからリソースを取得するリソース マネージャーを返します。 これを行うこともできます <xref:System.Resources.ResourceManager> ASP.NET ページのリソースを読み込むかをテストするオブジェクト、 <xref:System.Resources.ResourceSet> 実装します。  スタンドアロンの .resources ファイルからリソースを取得する例については、 [Retrieving Resources in Desktop Apps](http://msdn.microsoft.com/ja-jp/eca16922-1c46-4f68-aefe-e7a12283641f) 記事です。  
  
 このメソッドを指定できます、 <xref:System.Resources.ResourceSet> 実装します。 特定したくない場合 <xref:System.Resources.ResourceSet> 実装がカスタム リソース ファイル形式を使用するようから派生しなければならない、 <xref:System.Resources.ResourceSet> クラスでオーバーライド、 <xref:System.Resources.ResourceSet.GetDefaultReader%2A> と <xref:System.Resources.ResourceSet.GetDefaultWriter%2A> メソッド、およびこのコンス トラクターにパスを入力します。  
  
> [!CAUTION]
>  ASP.NET アプリケーションでスタンドアロンの .resources ファイルを使用しなく xcopy による配置で明示的にリリースされるまで、リソースがロックされるため、 <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> メソッドです。 ASP.NET アプリを使用してリソースをデプロイする場合は、.resources ファイルをサテライト アセンブリにコンパイルします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseName" /> パラメーターまたは <paramref name="resourceDir" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FallbackLocation">
      <MemberSignature Language="C#" Value="protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Resources.UltimateResourceFallbackLocation FallbackLocation" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.FallbackLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.UltimateResourceFallbackLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のフォールバック リソースの取得元の場所を取得または設定します。</summary>
        <value>リソース マネージャーがフォールバック リソースを検索できる場所を指定する列挙値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Resources.ResourceManager.FallbackLocation%2A> プロパティから派生するクラスを記述する場合にのみ役立ちます、 <xref:System.Resources.ResourceManager> クラスです。  
  
 使用することができます、 <xref:System.Resources.NeutralResourcesLanguageAttribute> リソース マネージャーのアプリケーションの既定のカルチャを検索する場所を通知する属性: \(既定値\) のメイン アセンブリまたはサテライト アセンブリ。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Resources.UltimateResourceFallbackLocation" />
        <altmember cref="T:System.Resources.NeutralResourcesLanguageAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetNeutralResourcesLanguage">
      <MemberSignature Language="C#" Value="protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Globalization.CultureInfo GetNeutralResourcesLanguage(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetNeutralResourcesLanguage(System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">カルチャ固有の情報を返すアセンブリ。</param>
        <summary>指定したアセンブリで <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 属性の値を取得して、メイン アセンブリの既定のリソースのカルチャ固有の情報を返します。</summary>
        <returns>見つかった場合は <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 属性のカルチャ、それ以外の場合は、インバリアント カルチャ。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <summary>指定した文字列以外のリソースの値を返します。</summary>
        <returns>呼び出し元の現在のカルチャ用にローカライズされているリソースの値。 適切なリソース セットが存在するが、<paramref name="name" /> が見つからない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Resources.ResourceManager.GetObject%2A> メソッドを使用して、文字列以外のリソースを取得します。 などのプリミティブ データ型に属している値が含まれます <xref:System.Int32> または <xref:System.Double>, 、ビットマップ \(など、 <xref:System.Drawing.Bitmap?displayProperty=fullName> オブジェクト\)、またはカスタム オブジェクトをシリアル化します。 通常、返されたオブジェクトにキャスト \(c\#\) または \(Visual Basic\) で適切な型のオブジェクトに変換する必要があります。  
  
 定義されている現在のスレッドの UI カルチャのため、返されたリソースをローカライズ、 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> プロパティです。 リソースは、そのカルチャにローカライズされていない、リソース マネージャーはフォールバック規則を使用して適切なリソースを読み込みます。 ローカライズされたリソースの使用可能なセットが見つからない場合、 <xref:System.Resources.ResourceManager> 既定のカルチャのリソースに頼ることにします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスロー、 <xref:System.Resources.MissingManifestResourceException> 例外や、サテライト アセンブリに存在するリソース セットが予想される場合、 <xref:System.Resources.MissingSatelliteAssemblyException> 例外です。 適切なリソースが設定が、という名前のリソースを見つけられない場合は、リソース マネージャーが読み込むことができます `name`, 、メソッドが返す `null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティを決定するかどうかの比較 `name` リソースの名前で大文字と小文字は \(既定値\) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、 <xref:System.IO.FileLoadException> の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされます <xref:System.Runtime.Serialization.SerializationException> 型が逆シリアル化されるときに、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性がします。  
  
## パフォーマンスに関する考慮事項  
 呼び出した場合、 <xref:System.Resources.ResourceManager.GetObject%2A> メソッドで複数回同じ `name` パラメーター、呼び出しごとに同じオブジェクトへの参照を返すメソッドに依存しません。 これは、 <xref:System.Resources.ResourceManager.GetObject%2A> メソッドは、キャッシュで既存のリソース オブジェクトへの参照を返すことができますか、リソースを再読み込みして新しいリソース オブジェクトへの参照を返します。  
  
   
  
## 例  
 次の例では、 <xref:System.Resources.ResourceManager.GetObject%28System.String%29> メソッドをカスタム オブジェクトを逆シリアル化します。 この例では UIElements.cs \(UIElements.vb Visual Basic を使用している場合\) という名前のソース コード ファイルという名前の次の構造を定義する `PersonTable`です。 この構造体は、テーブルの列のローカライズされた名前を表示する一般的なテーブル表示ルーチンが使用する対象としています。 なお、 `PersonTable` 構造が付いて、 <xref:System.SerializableAttribute> 属性です。  
  
 [!code-csharp[Conceptual.Resources.Retrieving\#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example.cs#6)]
 [!code-vb[Conceptual.Resources.Retrieving\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#6)]  
  
 という名前のファイルから次のコード CreateResources.cs \(Visual basic の CreateResources.vb\) という UIResources.resx テーブルのタイトルを格納する XML リソース ファイルを作成して、 `PersonTable` 英語の言語にローカライズされているアプリの情報を含むオブジェクト。  
  
 [!code-csharp[Conceptual.Resources.Retrieving\#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example1.cs#7)]
 [!code-vb[Conceptual.Resources.Retrieving\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#7)]  
  
 ソース コード ファイルで次のコードは GetObject.cs \(GetObject.vb\) という名前のリソースを取得し、それらをコンソールに表示します。  
  
 [!code-csharp[Conceptual.Resources.Retrieving\#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example2.cs#8)]
 [!code-vb[Conceptual.Resources.Retrieving\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example2.vb#8)]  
  
 必要なリソース ファイルとアセンブリを構築し、次のバッチ ファイルを実行して、アプリケーションを実行できます。 使用する必要があります、 `/r` UIElements.dll への参照で Resgen.exe を指定して、に関する情報にアクセスできるようにするにはオプション、 `PersonTable` 構造体。 C\# を使用している場合は、置換、 `vbc` コンパイラの名前を `csc`, と置換、 `.vb` を持つ拡張機能 `.cs`です。  
  
```  
  
vbc /t:library UIElements.vb  
vbc CreateResources.vb /r:UIElements.dll  
CreateResources  
  
resgen UIResources.resx  /r:UIElements.dll  
vbc GetObject.vb /r:UIElements.dll /resource:UIResources.resources  
  
GetObject.exe  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">ローカライズされたリソースの使用可能なセットが見つからず、かつ、既定のカルチャのリソースはありません。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは見つかりませんでした、サテライト アセンブリに存在します。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <param name="culture">リソースのローカライズ対象のカルチャ。 リソースがこのカルチャにローカライズされていない場合、リソース マネージャーはフォールバック規則を使用して適切なリソースを探します。  
  
 この値が <see langword="null" /> の場合、<see cref="P:System.Globalization.CultureInfo.CurrentUICulture" /> プロパティを使用して <see cref="T:System.Globalization.CultureInfo" /> オブジェクトが取得されます。</param>
        <summary>指定されたカルチャ用にローカライズされている指定された文字列以外のリソースの値を取得します。</summary>
        <returns>指定されたカルチャに合わせてローカライズされているリソースの値。 適切なリソース セットが存在するが、<paramref name="name" /> が見つからない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドを使用して、文字列以外のリソースを取得します。 などのプリミティブ データ型に属している値が含まれます <xref:System.Int32> または <xref:System.Double>, 、ビットマップ \(など、 <xref:System.Drawing.Bitmap?displayProperty=fullName> オブジェクト\)、またはカスタム オブジェクトをシリアル化します。 通常、返されたオブジェクトにキャスト \(c\#\) または \(Visual Basic\) で適切な型のオブジェクトに変換する必要があります。  
  
 指定されたカルチャ用に、返されたリソースをローカライズ `culture`, 、またはカルチャで指定されている、 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> プロパティ場合 `culture` は `null`です。 リソースは、そのカルチャにローカライズされていない、リソース マネージャーはフォールバック規則を使用して適切なリソースを読み込みます。 ローカライズされたリソースの使用可能なセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスロー、 <xref:System.Resources.MissingManifestResourceException> 例外や、サテライト アセンブリに存在するリソース セットが予想される場合、 <xref:System.Resources.MissingSatelliteAssemblyException> 例外です。 適切なリソースが設定が、という名前のリソースを見つけられない場合は、リソース マネージャーが読み込むことができます `name`, 、メソッドが返す `null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティを決定するかどうかの比較 `name` リソースの名前で大文字と小文字は \(既定値\) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、 <xref:System.IO.FileLoadException> の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされます <xref:System.Runtime.Serialization.SerializationException> 型が逆シリアル化されるときに、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性がします。  
  
## パフォーマンスに関する考慮事項  
 呼び出した場合、 <xref:System.Resources.ResourceManager.GetObject%2A> メソッドで複数回同じ `name` パラメーター、呼び出しごとに同じオブジェクトへの参照を返すメソッドに依存しません。 これは、 <xref:System.Resources.ResourceManager.GetObject%2A> メソッドは、キャッシュで既存のリソース オブジェクトへの参照を返すことができますか、リソースを再読み込みして新しいリソース オブジェクトへの参照を返します。  
  
   
  
## 例  
 次の例では、 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドをカスタム オブジェクトを逆シリアル化します。 この例では NumberInfo.cs \(NumberInfo.vb Visual Basic を使用している場合\) という名前のソース コード ファイルという名前の次の構造を定義する `Numbers`です。 この構造体は英語で 10 までをカウントする英語以外の話し方生徒をについて説明する簡単な教育アプリによって使用されるものです。 なお、 `Numbers` クラスには、 <xref:System.SerializableAttribute> 属性です。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/numberinfo.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetObject\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/numberinfo.vb#1)]  
  
 次のソース コードをファイルから名前付き CreateResources.cs \(Visual basic の CreateResources.vb\) は、既定の英語とフランス語、ポルトガル語、ロシア語の言語の XML リソース ファイルを作成します。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/createresources.cs#2)]
 [!code-vb[System.Resources.ResourceManager.GetObject\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/createresources.vb#2)]  
  
 リソースは、現在の UI カルチャをフランス語 \(フランス\)、ポルトガル語 \(ブラジル\)、またはロシア語 \(ロシア\) に設定を次のようなアプリによって使用されます。 呼び出す、 <xref:System.Resources.ResourceManager.GetObject%28System.String%29> を取得します、 `Numbers` ローカライズされた数値を含むオブジェクトと <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> を取得します、 `Numbers` 英語の言語の数値を含むオブジェクト。 現在の UI カルチャと英語の言語を使用して、奇数の番号が表示されます。 ソース コード ファイルを ShowNumbers.cs \(ShowNumbers.vb\) と呼びます。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/shownumbers.cs#3)]
 [!code-vb[System.Resources.ResourceManager.GetObject\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/shownumbers.vb#3)]  
  
 ビルドおよび Visual Basic バージョンの例を実行するのには、次のバッチ ファイルを使用できます。 C\# を使用している場合は置き換えます `vbc` と `csc`, と置換、 `.vb` 拡張子 `.cs`します。  
  
```  
  
vbc /t:library NumberInfo.vb  
  
vbc CreateResources.vb /r:NumberInfo.dll  
CreateResources  
  
resgen NumberResources.resx /r:NumberInfo.dll  
  
resgen NumberResources.fr.resx /r:Numberinfo.dll  
Md fr  
al /embed:NumberResources.fr.resources /culture:fr /t:lib /out:fr\ShowNumbers.resources.dll  
  
resgen NumberResources.pt.resx  /r:Numberinfo.dll  
Md pt  
al /embed:NumberResources.pt.resources /culture:pt /t:lib /out:pt\ShowNumbers.resources.dll  
  
resgen NumberResources.ru.resx /r:Numberinfo.dll  
Md ru  
al /embed:NumberResources.ru.resources /culture:ru /t:lib /out:ru\ShowNumbers.resources.dll  
  
vbc ShowNumbers.vb /r:NumberInfo.dll /resource:NumberResources.resources  
ShowNumbers.exe  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つかりませんでした、および既定のカルチャのリソースはありません。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは見つかりませんでした、サテライト アセンブリに存在します。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" /> メソッドはスレッド セーフであります。</threadsafe>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceFileName">
      <MemberSignature Language="C#" Value="protected virtual string GetResourceFileName (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetResourceFileName(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">リソース ファイル名を構築する対象のカルチャ オブジェクト。</param>
        <summary>指定した <see cref="T:System.Globalization.CultureInfo" /> オブジェクトのリソース ファイルの名前を生成します。</summary>
        <returns>指定した <see cref="T:System.Globalization.CultureInfo" /> オブジェクトのリソース ファイルに使用できる名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Resources.ResourceManager.GetResourceFileName%2A> メソッドは、独自のクラスから派生したを記述する場合にのみ、 <xref:System.Resources.ResourceManager> クラスです。  
  
 このメソッドを使用して、 <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=fullName> インバリアント カルチャ以外のすべてのカルチャのファイル名の一部としてのプロパティです。 このメソッドは、アセンブリのマニフェストまたはタッチ、ディスクを検索しませんし、リソース ファイル名を作成する場合にのみ使用されます \(に渡すのために適した、 <xref:System.Resources.ResourceReader> コンス トラクター\) またはマニフェスト リソース blob の名前。  
  
 派生クラスが別の拡張機能など、検索するには、このメソッドをオーバーライドできます"です。ResX"、またはリソース ファイルの名前を付けるためのまったく異なるスキームです。 サテライト アセンブリ内のリソース ファイルの名前をカスタマイズし、サテライト アセンブリ自体の名前をカスタマイズするには、いないメソッドを使用できることに注意してください。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceSet">
      <MemberSignature Language="C#" Value="public virtual System.Resources.ResourceSet GetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Resources.ResourceSet GetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">リソースが取得されるカルチャ。</param>
        <param name="createIfNotExists">リソース セットがまだ読み込まれていなければ読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="tryParents">リソース セットが見つからないときに、適切なリソースを読み込むためにリソース フォールバックを使用する場合は <see langword="true" />。リソース フォールバック プロセスをバイパスする場合は <see langword="false" />。 「解説」を参照してください。</param>
        <summary>特定のカルチャのリソース セットを取得します。</summary>
        <returns>指定されたカルチャに設定されたリソース。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるリソース セットは、指定したカルチャにローカライズされたリソースを表します。 リソースがそのカルチャにローカライズされていない場合と `tryParents` は `true`, 、<xref:System.Resources.ResourceManager.GetResourceSet%2A> 適切なリソースの読み込みにリソース フォールバック規則を使用します。 場合 `tryParents` は `false` 、カルチャに固有のリソース セットが見つからない、メソッドは返します `null`します。 リソース フォールバックの詳細については、「リソース フォールバック プロセス」セクションを参照して、 [Packaging and Deploying Resources](http://msdn.microsoft.com/ja-jp/b224d7c0-35f8-4e82-a705-dd76795e8d16) 記事です。  
  
   
  
## 例  
 次の例では、 <xref:System.Resources.ResourceManager.GetResourceSet%2A> フランス語 \(フランス\) カルチャのカルチャに固有のリソースを取得します。 すべてのリソース セットでリソースを列挙します。 実行可能ファイル ShowNumbers.exe という名前のソース コードが含まれています。 数値の名前を格納する次の 2 つのテキスト ファイルも含まれています。 1 つ目 NumberResources.txt にはには、1 から 10 まで英語での数値の名前が含まれています。  
  
```  
  
one=one  
two=two  
three=three  
four=four  
five=five  
six=six  
seven=seven  
eight=eight  
nine=nine  
ten=ten  
  
```  
  
 2 つ目 NumberResources.fr FR.txt にはには、1 ~ 4 個の in、フランス語の番号の名前が含まれています。  
  
```  
  
one=un  
two=deux  
three=trois  
four=quatre  
  
```  
  
 バッチ ファイルを使用して、リソース ファイルの生成、英語の言語リソース ファイル、実行可能ファイルに埋め込むか、およびフランス語の言語リソースのサテライト アセンブリを作成することができます。 Visual Baisc コンパイラを使用して、実行可能ファイルを生成するバッチ ファイルを次に示します。  
  
```  
  
resgen NumberResources.txt  
vbc shownumbers.vb /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
```  
  
 C\# コンパイラでは、次のバッチ ファイルを使用できます。  
  
```  
  
resgen NumberResources.txt  
csc shownumbers.cs /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.GetResourceSet\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/cs/shownumbers.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetResourceSet\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/vb/shownumbers.vb#1)]  
  
 Note that if you change the value of the **parameterReference tag is not supported!!!!**  
 argument to **languageKeyword tag is not supported!!!!**  
, the method call returns **languageKeyword tag is not supported!!!!**  
, since Resource Manager has not already loaded the French language resources.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">
          <paramref name="tryParents" /> <see langword="true" />, 、使用できるリソースのセットが見つからず、かつ、既定のカルチャのリソースはありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteContractVersion">
      <MemberSignature Language="C#" Value="protected static Version GetSatelliteContractVersion (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Version GetSatelliteContractVersion(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetSatelliteContractVersion(System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="a">
          <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 属性を確認する対象のアセンブリ。</param>
        <summary>指定したアセンブリの <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 属性で指定されたバージョンを返します。</summary>
        <returns>指定したアセンブリのサテライト コントラクト バージョン。バージョンが見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サテライト アセンブリのバージョン管理の詳細については、次を参照してください。、 <xref:System.Resources.SatelliteContractVersionAttribute> リファレンス トピックです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Version" /> 、アセンブリ内にある <paramref name="a" /> が無効です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="a" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。</param>
        <summary>指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
        <returns>リソースを表すアンマネージ メモリ ストリーム オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Resources.ResourceManager.GetStream%2A> メソッドとして格納されているリソースの名前には、 <xref:System.IO.MemoryStream> オブジェクトの値を取得、 <xref:System.Object> リソース、および返す、 <xref:System.IO.UnmanagedMemoryStream> オブジェクトです。 オブジェクトに変換し、バイトのストリームを直接操作することが必要です。 このメソッドは、主にパフォーマンス上の理由: リソースを取得するように明示的なオブジェクトではなくバイト ストリームは、パフォーマンスを向上させることができます。  
  
 定義されている現在のスレッドの UI カルチャのため、返されたリソースをローカライズ、 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> プロパティです。 リソースは、そのカルチャにローカライズされていない、リソース マネージャーはフォールバック規則を使用して適切なリソースを読み込みます。 ローカライズされたリソースの使用可能なセットが見つからない場合、 <xref:System.Resources.ResourceManager> 既定のカルチャのリソースに頼ることにします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスロー、 <xref:System.Resources.MissingManifestResourceException> 例外や、サテライト アセンブリに存在するリソース セットが予想される場合、 <xref:System.Resources.MissingSatelliteAssemblyException> 例外です。 適切なリソースが設定が、という名前のリソースを見つけられない場合は、リソース マネージャーが読み込むことができます `name`, 、メソッドが返す `null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティを決定するかどうかの比較 `name` リソースの名前で大文字と小文字は \(既定値\) または大文字小文字を区別します。  
  
   
  
## 例  
 次の例では、 <xref:System.Resources.ResourceManager.GetStream%28System.String%29> アプリで使用されているビットマップを取得するメソッドのスプラッシュ ウィンドウを開始します。 次のソース コードをという名前のファイルから CreateResources.cs \(の C\# の場合\) または CreateResources.vb \(Visual Basic の場合\) のシリアル化されたイメージが含まれる AppResources.resx をという名前の .resx ファイルが生成されます。 この場合、イメージが SplashScreen.jpg; という名前のファイルから読み込まれる独自のイメージの代わりにファイル名を変更することができます。  
  
 [!code-csharp[Conceptual.Resources.Retrieving\#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/createresources.cs#4)]
 [!code-vb[Conceptual.Resources.Retrieving\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/createresources.vb#4)]  
  
 次のコード \(C\# の場合\) GetStream.cs という名前のファイルまたは GetStream.vb \(Visual Basic の場合\) のリソースを取得しで画像を表示します、 <xref:System.Windows.Forms.PictureBox?displayProperty=fullName> コントロールです。  
  
 [!code-csharp[Conceptual.Resources.Retrieving\#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/getstream.cs#5)]
 [!code-vb[Conceptual.Resources.Retrieving\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/getstream.vb#5)]  
  
 次のバッチ ファイルを使用すると、c\# の例をビルドします。 Visual basic では、次のように変更します `csc` に `vbc`, 、からソース コード ファイルの拡張子を変更および `.cs` に `.vb`.。  
  
```  
  
csc CreateResources.cs  
CreateResources  
  
resgen AppResources.resx  
  
csc GetStream.cs /resource:AppResources.resources  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したリソースの値は、 <see cref="T:System.IO.MemoryStream" /> オブジェクトです。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからないし、既定のリソースはありません。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは見つかりませんでした、サテライト アセンブリに存在します。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。</param>
        <param name="culture">リソース検索に使用するカルチャを指定するオブジェクト。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドのカルチャが使用されます。</param>
        <summary>指定したカルチャを使用し、指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
        <returns>リソースを表すアンマネージ メモリ ストリーム オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Resources.ResourceManager.GetStream%2A> メソッドとして格納されているリソースの名前には、 <xref:System.IO.MemoryStream> オブジェクトの値を取得、 <xref:System.Object> リソース、および返す、 <xref:System.IO.UnmanagedMemoryStream> オブジェクトです。 オブジェクトに変換し、バイトのストリームを直接操作することが必要です。 このメソッドは、主にパフォーマンス上の理由: リソースを取得するように明示的なオブジェクトではなくバイト ストリームは、パフォーマンスを向上させることができます。  
  
 指定されたカルチャ用に、返されたリソースをローカライズ `culture`, 、またはカルチャで指定されている、 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> プロパティ場合 `culture` は `null`です。 リソースは、そのカルチャにローカライズされていない、リソース マネージャーはフォールバック規則を使用して適切なリソースを読み込みます。 ローカライズされたリソースの使用可能なセットが見つからない場合、 <xref:System.Resources.ResourceManager> 既定のカルチャのリソースに頼ることにします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスロー、 <xref:System.Resources.MissingManifestResourceException> 例外や、サテライト アセンブリに存在するリソース セットが予想される場合、 <xref:System.Resources.MissingSatelliteAssemblyException> 例外です。 適切なリソースが設定が、という名前のリソースを見つけられない場合は、リソース マネージャーが読み込むことができます `name`, 、メソッドが返す `null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティを決定するかどうかの比較 `name` リソースの名前で大文字と小文字は \(既定値\) または大文字小文字を区別します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定したリソースの値は、 <see cref="T:System.IO.MemoryStream" /> オブジェクトです。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからないし、既定のリソースはありません。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは見つかりませんでした、サテライト アセンブリに存在します。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <summary>指定されている文字列リソースの値を返します。</summary>
        <returns>呼び出し元の現在の UI カルチャのためにローカライズされたリソースの値、または、リソース セットで <paramref name="name" /> が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
## デスクトップ アプリ  
 デスクトップ アプリで返されるリソースが現在のスレッドの UI カルチャのローカライズで定義されている、 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> プロパティです。 次の「リソース フォールバック プロセス」のセクションで説明されている手順に従って、リソース マネージャーがリソースのプローブ場合は、リソースがそのカルチャにローカライズされておらず、 [Packaging and Deploying Resources](http://msdn.microsoft.com/ja-jp/b224d7c0-35f8-4e82-a705-dd76795e8d16) 記事です。 ローカライズされたリソースの使用可能なセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 メソッドがスローする場合は、リソース マネージャーでは、既定のカルチャのリソース セットを読み込むことができません、 <xref:System.Resources.MissingManifestResourceException> 例外や、サテライト アセンブリに存在するリソース セットが予想される場合、 <xref:System.Resources.MissingSatelliteAssemblyException> 例外です。 適切なリソースが設定が、という名前のリソースを見つけられない場合は、リソース マネージャーが読み込むことができます `name`, 、メソッドが返す `null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティを決定するかどうかの比較 `name` リソースの名前で大文字と小文字は \(既定値\) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、 <xref:System.IO.FileLoadException> の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされます <xref:System.Runtime.Serialization.SerializationException> 型が逆シリアル化されるときに、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性がします。  
  
## [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  ですが、 <xref:System.Resources.ResourceManager> クラスではサポートされて [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ、お勧めしません使用します。 このクラスを使用して開発する場合のみ [!INCLUDE[net_portable](~/includes/net-portable-md.md)] で使用できるプロジェクト [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリです。 リソースを取得する [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 、アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182) クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリの場合、 <xref:System.Resources.ResourceManager.GetString%28System.String%29> メソッドの値を返す、 `name` の呼び出し元の現在の UI カルチャ設定にローカライズされたリソースの文字列です。 カルチャの一覧については、オペレーティング システムの推奨される UI 言語の一覧から派生します。 リソース マネージャーが一致しない場合 `name`, 、メソッドが返す `null`します。  
  
   
  
## 例  
 次の例では、 <xref:System.Resources.ResourceManager.GetString%2A> カルチャに固有のリソースを取得します。 構成は次の英語 \(en\)、フランス語 \(フランス\) \(FR\-FR\)、およびロシア語 \(ロシア\) \(RU\-RU\) .txt ファイルからコンパイルされたリソースのカルチャ。 例は、英語 \(米国\)、フランス語 \(フランス\)、ロシア語 \(ロシア\)、およびスウェーデン語 \(スウェーデン\) を現在のカルチャと現在の UI カルチャを変更します。 呼び出して、 <xref:System.Resources.ResourceManager.GetString%2A> および現在の日と月を表示するローカライズされた文字列を取得します。 現在の UI カルチャがスウェーデン語 \(スウェーデン\) 場合を除いて、適切なローカライズされた文字列が表示に注意してください。 スウェーデン語の言語リソースが利用できないため、アプリは代わりに既定のカルチャが英語のリソースを使用します。 この例では、次の表に示されているテキスト ベースのリソース ファイルが必要です。 という名前の 1 つの文字列リソースを持つ各 `DateStart`します。  
  
|カルチャ|ファイル名|リソース名|リソースの値|  
|----------|-----------|-----------|------------|  
|en\-US|DateStrings.txt|`DateStart`|今日の日付します。|  
|fr\-FR|DateStrings.fr FR.txt|`DateStart`|Aujourd'hui c'est le|  
|ru\-RU|DateStrings.ru RU.txt|`DateStart`|СЕГОДНЯ|  
  
 次のバッチ ファイルを使用して、c\# の例をコンパイルすることができます。 Visual basic では、次のように変更します。 `csc` に `vbc`, 、からソース コード ファイルの拡張子を変更および `.cs` に `.vb`します。  
  
```  
resgen DateStrings.txt  
csc showdate.cs /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 次の例では、\(Visual Basic バージョン ShowDate.vb\) または ShowDate.cs c\# バージョンのソース コードに示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Class\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したリソースの値は、文字列ではありません。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、かつ、既定のカルチャのリソースはありません。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは見つかりませんでした、サテライト アセンブリに存在します。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> メソッドはスレッド セーフであります。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <param name="culture">リソースのローカライズ先のカルチャを表すオブジェクト。</param>
        <summary>指定したカルチャにローカライズされている文字列リソースの値を返します。</summary>
        <returns>指定されたカルチャのためにローカライズされたリソースの値、または、リソース セットで <paramref name="name" /> が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
## デスクトップ アプリ  
 デスクトップ アプリで場合 `culture` は `null`, 、 <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドから取得した現在の UI カルチャを使用して、 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> プロパティです。  
  
 返されるリソースがで指定されたカルチャに合わせてローカライズ、 `culture` パラメーター。 リソースがローカライズされていない場合 `culture`, 、リソース マネージャーが次の「リソース フォールバック プロセス」のセクションで説明されている手順に従ってリソースのプローブ、 [Packaging and Deploying Resources](http://msdn.microsoft.com/ja-jp/b224d7c0-35f8-4e82-a705-dd76795e8d16) トピックです。 使用できるリソースのセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 メソッドがスローする場合は、リソース マネージャーでは、既定のカルチャのリソース セットを読み込むことができません、 <xref:System.Resources.MissingManifestResourceException> 例外や、サテライト アセンブリに存在するリソース セットが予想される場合、 <xref:System.Resources.MissingSatelliteAssemblyException> 例外です。 適切なリソースが設定が、という名前のリソースを見つけられない場合は、リソース マネージャーが読み込むことができます `name`, 、メソッドが返す `null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティを決定するかどうかの比較 `name` リソースの名前で大文字と小文字は \(既定値\) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、 <xref:System.IO.FileLoadException> の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされます <xref:System.Runtime.Serialization.SerializationException> 型が逆シリアル化されるときに、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性がします。  
  
## [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  ですが、 <xref:System.Resources.ResourceManager>クラスではサポートされて [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ、お勧めしません使用します。 このクラスを使用して開発する場合のみ [!INCLUDE[net_portable](~/includes/net-portable-md.md)] で使用できるプロジェクト [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリです。 リソースを取得する [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 、アプリを使用して、 [Windows.ApplicationModel.Resources.ResourceLoader](http://go.microsoft.com/fwlink/p/?LinkId=238182) クラスの代わりにします。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリの場合、 <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドの値を返す、 `name` 文字列で指定したカルチャにローカライズされたリソース、 `culture` パラメーター。 リソースがローカライズされていない場合、 `culture` 全体を使用するカルチャでは、ルックアップ [!INCLUDE[win8](~/includes/win8-md.md)] 言語フォールバック リスト、および既定のカルチャで検索して停止します。 リソース マネージャーが一致しない場合 `name`, 、メソッドが返す `null`します。  
  
   
  
## 例  
 次の例では、 <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> カルチャに固有のリソースを取得します。 この例の既定のカルチャが英語 \(en\) とフランス語 \(フランス\) \(FR\-FR\)、ロシア語 \(ロシア\) \(RU\-RU\) のサテライト アセンブリが含まれていますカルチャ。 例では、変更、現在のカルチャと現在の UI カルチャ ロシア語 \(ロシア\) を呼び出す前に <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>します。 呼び出して、 <xref:System.Resources.ResourceManager.GetString%2A> メソッドおよび <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> メソッドを呼び出し <xref:System.Globalization.CultureInfo> 各メソッドには、フランス語 \(フランス\) とスウェーデン語 \(スウェーデン\) カルチャを表すオブジェクト。 出力では、月と日の月だけでなく、文字列の前にフランス語で表示、ため、 <xref:System.Resources.ResourceManager.GetString%2A> メソッドは、フランス語のリソースを取得することができます。 ただし、スウェーデン語 \(スウェーデン\) カルチャを使用すると月と日、月の表示スウェーデン語では英語で表示する前に表示される文字列が。 これは、代わりに既定の英語のカルチャのリソースを返すように、リソース マネージャーが、スウェーデン語のローカライズされたリソースを検出できないためです。  
  
 この例では、次の表に示されているテキスト ベースのリソース ファイルが必要です。 という名前の 1 つの文字列リソースを持つ各 `DateStart`します。  
  
|カルチャ|ファイル名|リソース名|リソースの値|  
|----------|-----------|-----------|------------|  
|en\-US|DateStrings.txt|`DateStart`|今日の日付します。|  
|fr\-FR|DateStrings.fr FR.txt|`DateStart`|Aujourd'hui c'est le|  
|ru\-RU|DateStrings.ru RU.txt|`DateStart`|СЕГОДНЯ|  
  
 次のバッチ ファイルを使用して、Visual Basic の例をコンパイルすることができます。 C\# でコンパイルする `vbc` に `csc`, からソース コード ファイルの拡張子を変更および `.vb` に `.cs`します。  
  
```  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 次の例では、\(Visual Basic バージョン ShowDate.vb\) または ShowDate.cs c\# バージョンのソース コードに示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Class\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate2.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Class\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定したリソースの値は、文字列ではありません。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、かつ、既定のカルチャのリソースはありません。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースは見つかりませんでした、サテライト アセンブリに存在します。 この例外を処理する方法については、「MissingManifestResourceException と MissingSatelliteAssemblyException の例外を処理する」」セクションを参照してください、 <see cref="T:System.Resources.ResourceManager" /> クラスに関するトピック。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <threadsafe>
          <see cref="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" /> メソッドはスレッド セーフであります。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="HeaderVersionNumber">
      <MemberSignature Language="C#" Value="public static readonly int HeaderVersionNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 HeaderVersionNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceManager" /> の現在の実装が解釈および作成できるリソース ファイル ヘッダーのバージョンを指定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreCase">
      <MemberSignature Language="C#" Value="public virtual bool IgnoreCase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.IgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソース マネージャーが <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> メソッドと <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> メソッドで大文字と小文字を区別しないリソースの検索を許可しているかどうかを示す値を取得または設定します。</summary>
        <value>リソースの検索時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合の値、 <xref:System.Resources.ResourceManager.IgnoreCase%2A> プロパティは、 `false`, 、「リソース」という名前のリソースが「リソース」という名前を使用してリソースに相当します。 場合 <xref:System.Resources.ResourceManager.IgnoreCase%2A> は `true`, 、「リソース」という名前のリソースは「リソース」という名前を使用してリソースに相当します。 ただし、時に <xref:System.Resources.ResourceManager.IgnoreCase%2A> は `true`, 、 <xref:System.Resources.ResourceManager.GetString%2A?displayProperty=fullName> と <xref:System.Resources.ResourceManager.GetObject%2A?displayProperty=fullName> メソッドは、インバリアント カルチャを使用して文字列の小文字を区別しない比較を実行します。 利点は、これらのメソッドによって実行される小文字を区別しない文字列比較の結果がカルチャに関係なくすべてのコンピューターで同じであります。 欠点は、結果は、すべてのカルチャの大文字小文字の規則と一致しません。  
  
 たとえば、ドット付きの I の文字の 2 つのバージョンとドットなしのいずれかに、トルコ語のアルファベットがあります。 トルコ語では、文字 I \(Unicode 0049\) と見なされます ı \(Unicode 0131\) 別の文字の大文字バージョン。 文字 i \(Unicode 0069\) は、さらに別の文字 İ \(Unicode 0130\) の小文字版と見なされます。 小文字を区別しない文字列比較、これらの大文字と小文字規則に従って文字 \(Unicode 0069\) の i と I \(Unicode 0049\) が"TR\-TR"\(七面鳥のトルコ語\) のカルチャの失敗する必要があります。 ただし、比較を実行する場合は、インバリアント カルチャの大文字小文字の規則を使用しているため <xref:System.Resources.ResourceManager.IgnoreCase%2A> は `true`, 、この比較は成功します。  
  
> [!NOTE]
>  パフォーマンス向上のため、常にリソース名の大文字小文字を正しくを指定することをお勧めします。 設定 <xref:System.Resources.ResourceManager.IgnoreCase%2A> に `true` ワーキング セットとパフォーマンスの大幅な低下の大幅な増加が発生することができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalGetResourceSet">
      <MemberSignature Language="C#" Value="protected virtual System.Resources.ResourceSet InternalGetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Resources.ResourceSet InternalGetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" />
        <Parameter Name="tryParents" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="culture">検索対象のカルチャ オブジェクト。</param>
        <param name="createIfNotExists">リソース セットがまだ読み込まれていなければ読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="tryParents">リソース セットを読み込むことができないときに、親 <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを確認する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース セットを検索するための実装を提供します。</summary>
        <returns>指定されたリソース セット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">メインのアセンブリでは、リソースを検索するために必要 .resources ファイルは含まれません。</exception>
        <exception cref="T:System.ExecutionEngineException">ランタイムの内部エラーが発生しました。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">サテライト アセンブリに関連付けられている <paramref name="culture" /> に見つかりませんでした。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <block subset="none" type="overrides">
          <para>This method completes all the work necessary to find a resource set, and can be recursive and reentrant. In other words, this method might load an assembly and trigger an <see cref="E:System.AppDomain.AssemblyLoad" /> event, which then calls back into a <see cref="T:System.Resources.ResourceManager" /> object that has not been completely initialized. To avoid taking extra locks, this method is not thread safe. The <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />, <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />, and <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> methods do all the necessary synchronization.</para>
        </block>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="MagicNumber">
      <MemberSignature Language="C#" Value="public static readonly int MagicNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MagicNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MagicNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソース ファイルを識別するために使用する番号を保持します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値は、0xBEEFCACE に設定されます。 システム既定のファイル形式の最初の 4 バイトを含むリトル エンディアン形式の 32 ビット符号付き整数 \(を参照してください <xref:System.Text.Encoding>\)。  
  
 場合、 <xref:System.Resources.ResourceManager.MagicNumber> が見つかると、それに続くバイトのバージョン番号になります、 <xref:System.Resources.ResourceManager> ヘッダーの後にこのヘッダーを通過するバイト数をスキップするかを示す番号。 次の番号がのバージョンを示す、 <xref:System.Resources.ResourceManager> バージョンについては後にヘッダーを作成します。  
  
 現在の実装のバージョン番号は、1 つです。 次のバイトは、固定長の文字列の名前を含む、 <xref:System.Resources.IResourceReader>, 、このファイルを読み取ることができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainAssembly">
      <MemberSignature Language="C#" Value="protected System.Reflection.Assembly MainAssembly;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Reflection.Assembly MainAssembly" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MainAssembly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソースを含むメイン アセンブリを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Resources.ResourceManager.MainAssembly> フィールドにから派生するクラスを記述する場合にのみ役立ちますが、 <xref:System.Resources.ResourceManager> クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllResources">
      <MemberSignature Language="C#" Value="public virtual void ReleaseAllResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseAllResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.ReleaseAllResources" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リソース マネージャーに、すべての <see cref="T:System.Resources.ResourceSet" /> オブジェクトの <see cref="M:System.Resources.ResourceSet.Close" /> メソッドを呼び出し、すべてのリソースを解放するように指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、実行中のアプリのワーキング セットに縮小されます。 これで、将来のリソース検索 <xref:System.Resources.ResourceManager> リソース マネージャーを検索する必要があるために、オブジェクトが最初の参照としてコストが高くなり、リソースを再読み込みします。 これ役に立ちます、複雑なスレッド処理シナリオで、新しい <xref:System.Resources.ResourceManager> オブジェクトが適切な動作です。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 以降で、 <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> メソッドはスレッドを安全ではありません <xref:System.Resources.ResourceManager.GetObject%2A>, 、<xref:System.Resources.ResourceManager.GetString%2A>, 、および <xref:System.Resources.ResourceManager.GetStream%2A> 操作します。 この変更の利点は、リソースにアクセスする複数のスレッドのパフォーマンスが向上します。 ただしを呼び出す場合、 <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> 別のスレッドで同時に、リソースを取得中に 1 つのスレッドで、get 操作メソッド、 <xref:System.ObjectDisposedException> 例外です。  
  
 リソース マネージャーは完全にスコープ外に出るし、ガベージ コレクションを待たずに、確定的に解放される現在のリソース マネージャーによって作成されたリソース用のマネージ インスタンスがある状況でこのメソッドを使用することもできます。  
  
> [!NOTE]
>  このメソッドを呼び出すサテライト アセンブリをアンロードしません。 サテライト アセンブリをアンロードするには、 <xref:System.AppDomain.Unload%2A> メソッドです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ResourceSets">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable ResourceSets;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Hashtable ResourceSets" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.ResourceSets" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("call InternalGetResourceSet instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カルチャから <see cref="T:System.Resources.ResourceSet" /> オブジェクトへの割り当てを返す <see cref="T:System.Collections.Hashtable" /> を格納します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSetType">
      <MemberSignature Language="C#" Value="public virtual Type ResourceSetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ResourceSetType" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.ResourceSetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceSet" /> オブジェクトの構築にリソース マネージャーが使用するリソース セット オブジェクトの型を取得します。</summary>
        <value>
          <see cref="T:System.Resources.ResourceSet" /> オブジェクトの構築にリソース マネージャーが使用するリソース セット オブジェクトの型。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のカルチャの文字列以外の指定したリソースの値を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したカルチャまたは現在の UI カルチャの指定した文字列リソースを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>