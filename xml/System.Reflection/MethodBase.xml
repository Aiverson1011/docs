<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>メソッドとコンストラクターについての情報を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 `MethodBase` 基本クラスは、 <xref:System.Reflection.MethodInfo> と <xref:System.Reflection.ConstructorInfo>です。  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">for full trust for inheritors. This class cannot be inherited by partially trusted code.</permission>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <block subset="none" type="overrides">
      <para>When you inherit from <see langword="MethodBase" />, you must override the following members: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Reflection.MethodBase" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメソッドに関連付けられている属性を取得します。</summary>
        <value>
          <see cref="T:System.Reflection.MethodAttributes" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 すべてのメンバーには、メンバーの特定の種類に応じて定義されている属性のセットがあります。  
  
 取得する、 <xref:System.Reflection.MethodAttributes>, 、まず、型を取得します。 型からメソッドを取得します。 メソッドから取得、 <xref:System.Reflection.MethodAttributes>です。  
  
   
  
## 例  
 次のコード例では、ユーザー定義メソッド Mymethod の属性が表示されます。  
  
 [!code-cpp[Classic MethodBase.Attributes Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 このコードを実行すると、次の出力が生成されます。  
  
 Reflection.MethodBase.Attributes サンプル  
  
 Mymethodbase \= Void Mymethod \(Int32、System.String ByRef System.String ByRef\)  
  
 プライベート スコープ  
  
 ファミリとアセンブリ  
  
 ファミリ  
  
 パブリック  
  
 HideBySig  
  
 ReuseSlot  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Use the <see cref="P:System.Reflection.MethodBase.Attributes" /> property to determine whether a method is <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, and so on.</para>
        </block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメソッドの呼び出し規約を示す値を取得します。</summary>
        <value>
          <see cref="T:System.Reflection.CallingConventions" /> このメソッドにします。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ジェネリック メソッドに未割り当てのジェネリック型パラメーターが含まれるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 場合は、現在 <see cref="T:System.Reflection.MethodBase" /> オブジェクトは、未割り当てのジェネリック型パラメーターを含むジェネリック メソッドを表します。 それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ジェネリック型定義またはオープンの構築型、メソッド自体の型引数または外側の型がない場合にのみ、ジェネリック メソッドを呼び出すことができます。 型指定できますが、任意の複雑なために、この再帰的な決定を行うは困難です。 便宜上、およびエラーの可能性を低く、 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> プロパティは、呼び出すことが閉じたの構築のメソッドを区別する標準的な方法を提供し、オープン構築メソッドで、このことはできません。 場合、 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> プロパティを返します。 `true`, 、メソッドを呼び出すことができません。  
  
 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> プロパティは、再帰的に、型パラメーターを検索します。 たとえば、返されます `true` オープン型のすべてのメソッドで `A<T>` \(`A(Of T)` Visual Basic で\) メソッド自体がジェネリックでないにもかかわらず、します。 動作と比較してみて、 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> を返すプロパティ `false` これらのメソッドです。  
  
 同様に、 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property パラメーターを返します `true` オープン型の任意のコンス トラクターをたとえコンス トラクターしていてはなりません、独自の型パラメーターです。  
  
 ジェネリック メソッドに固有の用語に対するインバリアント条件の一覧は、次を参照してください。、 <xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName> プロパティです。 一般的なリフレクションで使用されるその他の用語に対するインバリアント条件の一覧は、次を参照してください。、 <xref:System.Type.IsGenericType%2A?displayProperty=fullName> プロパティです。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">対象のインスタンスと比較する対象のオブジェクト、または <see langword="null" />。</param>
        <summary>このインスタンスが、指定されたオブジェクトと等価であるかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> がこのインスタンスの型および値に等しい場合は <paramref name="obj" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在実行中のメソッドを表す <see langword="MethodBase" /> オブジェクトを返します。</summary>
        <returns>
          <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> は、実行中のメソッド内から呼び出され、そのメソッドに関する情報を返す、静的メソッドです。  
  
 現在実行中のメソッドを表す <see langword="MethodBase" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 現在実行中のメソッドがジェネリック型で定義されている場合、<xref:System.Reflection.MethodInfo>によって返される<xref:System.Reflection.MethodBase.GetCurrentMethod%2A>、ジェネリック型定義から取得されます \(つまり、<xref:System.Reflection.MethodInfo.ContainsGenericParameters%2A?displayProperty=fullName>を返します`true`\)。 したがって、メソッドが呼び出されたときに使用された型引数は反映されません。 場合、メソッドなど、`M()`ジェネリック型で定義された`C<T>`\(`C(Of T)` Visual Basic で\)、および<xref:System.Reflection.MethodBase.GetCurrentMethod%2A>から呼び出されます`C<string>.M()`、し<xref:System.Reflection.MethodBase.GetCurrentMethod%2A>を返します`C<T>.M()`\(`C(Of T).M()` Visual Basic で\)。  
  
 現在実行中のメソッドがジェネリック メソッドの場合<xref:System.Reflection.MethodBase.GetCurrentMethod%2A>ジェネリック メソッド定義を返します。 ジェネリック メソッドがジェネリック型で定義されている場合、<xref:System.Reflection.MethodInfo>はジェネリック型定義から取得します。  
  
   
  
## 例  
 次の例では、2 つの型を定義します。 1 つは、非ジェネリックのクラス`TestClass`、という名前のメソッド、コンス トラクターが含まれています`GetValue`、およびという名前の読み取り\/書き込みプロパティ`GetValue`です。 2 番目は、という名前のジェネリック クラス`TestClass<T>`、コンス トラクターが含まれている、`GetValue`メソッド、およびジェネリック メソッドでは、`ConvertValue<Y>`です。 各コンス トラクター、メソッド、およびプロパティのアクセサーへの呼び出しが含まれています、<xref:System.Reflection.MethodBase.GetCurrentMethod%2A>メソッドです。  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">このメンバーは、遅延バインディング メカニズムで呼び出されました。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ジェネリック メソッドの型引数、またはジェネリック メソッドの定義の型パラメーターを表す <see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>ジェネリック メソッドの型引数またはジェネリック メソッド定義の型パラメーターを表す <see cref="T:System.Type" /> オブジェクトの配列。 現在のメソッドがジェネリック メソッドではない場合は、空の配列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返される配列の要素は、ジェネリック メソッドの型パラメーターの一覧に表示される順です。  
  
-   場合は、現在のメソッドはクローズ構築メソッド \(つまり、 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> プロパティを返します。 `false`\)、によって返される配列、 <xref:System.Reflection.MethodBase.GetGenericArguments%2A> メソッドには、ジェネリック メソッド定義のジェネリック型パラメーターに割り当てられている型が含まれています。  
  
-   現在のメソッドがジェネリック メソッド定義である場合、配列には、型パラメーターが含まれています。  
  
-   場合は、現在のメソッドは、オープン構築メソッド \(つまり、 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> プロパティを返します。 `true`\) を特定の種類は、いくつかの型パラメーターに割り当てられていると外側のジェネリック型の型パラメーターは、他の型パラメーターに割り当てられている、配列には、型と型の両方が含まれています。 パラメーター。 使用して、 <xref:System.Type.IsGenericParameter%2A> を見分けるプロパティです。 このシナリオのデモについては、コード例を参照してください、 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> プロパティです。  
  
 ジェネリック コンス トラクターは、.NET Framework version 2.0 ではサポートされません。 このプロパティをスロー <xref:System.NotSupportedException> 派生クラスでオーバーライドされていないため、例外がスローされます、現在のインスタンスが型の場合 <xref:System.Reflection.ConstructorInfo>します。  
  
 ジェネリック メソッドに固有の用語に対するインバリアント条件の一覧は、次を参照してください。、 <xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName> プロパティです。 一般的なリフレクションで使用されるその他の用語に対するインバリアント条件の一覧は、次を参照してください。、 <xref:System.Type.IsGenericType%2A?displayProperty=fullName> プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在のオブジェクトが、 <see cref="T:System.Reflection.ConstructorInfo" />です。 ジェネリック コンス トラクターは、.NET Framework version 2.0 ではサポートされません。 この例外は、このメソッドは派生クラスでオーバーライドされていない場合の既定の動作です。</exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodInfo.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、 <see cref="T:System.Reflection.MethodBody" /> を現在のメソッドの MSIL ストリーム、ローカル変数、および例外へのアクセスを提供するオブジェクト。</summary>
        <returns>A <see cref="T:System.Reflection.MethodBody" /> を現在のメソッドの MSIL ストリーム、ローカル変数、および例外へのアクセスを提供するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバーライドする必要はありません、 <xref:System.Reflection.MethodBase.GetMethodBody%2A> が使用します。 呼び出すことができます、 <xref:System.Reflection.MethodBase.GetMethodBody%2A> メソッドを <xref:System.Reflection.MethodInfo> と <xref:System.Reflection.ConstructorInfo> オブジェクト、メソッドがこれらのクラスのランタイムのバージョンで上書きされるためです。 ランタイムのバージョンなど、 <xref:System.Reflection.MethodInfo> クラスから派生する、 <xref:System.Reflection.MethodInfo> から派生するクラス、 <xref:System.Reflection.MethodBase> クラスです。  
  
   
  
## 例  
 次のコード例は、という名前のテスト メソッドを定義 `MethodBodyExample` し、そのローカル変数の情報と例外処理句を表示します。<xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=fullName> メソッドを使用して取得する、 <xref:System.Reflection.MethodBody> テスト メソッドのオブジェクト。  
  
 <xref:System.Reflection.MethodBody.LocalVariables%2A> の一覧を取得するプロパティが使用される <xref:System.Reflection.LocalVariableInfo> オブジェクトしその型が表示され、注文のインデックスを作成します。<xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> 例外処理句の一覧を取得するプロパティを使用します。  
  
> [!NOTE]
>  すべてのコンピューター言語を生成できます <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=fullName> 句。 Visual Basic の例は、Visual Basic を使用して、フィルター句を示しています。 `When` 式で、その他の言語の例から省略するとします。  
  
 [!code-cpp[MethodBody\#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody\#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">このメソッドは、派生クラスでオーバーライドされない限り有効ではありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">for the access to metadata for members. Permission value: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle">メソッドのハンドル。</param>
        <summary>メソッドの内部メタデータ表現 \(ハンドル\) を使用して、メソッドの情報を取得します。</summary>
        <returns>A <see langword="MethodBase" /> メソッドに関する情報を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ハンドルは、取得されたアプリケーション ドメインでのみ有効です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> が無効です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">コンス トラクターまたはメソッドの内部メタデータ表現へのハンドル。</param>
        <param name="declaringType">コンス トラクターまたはメソッドを定義するジェネリック型へのハンドル。</param>
        <summary>取得、 <see cref="T:System.Reflection.MethodBase" /> のコンス トラクターまたはメソッドの指定したジェネリック型の指定したハンドルによって表されるオブジェクト。</summary>
        <returns>A <see cref="T:System.Reflection.MethodBase" /> メソッドまたはコンス トラクターで指定されたを表すオブジェクトを <paramref name="handle" />, で指定されたジェネリック型に <paramref name="declaringType" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ハンドルは、取得されたアプリケーション ドメインでのみ有効です。  
  
 A <xref:System.RuntimeMethodHandle> コンス トラクターまたはメソッドのジェネリック型の構造を別に表すことができる <xref:System.Reflection.MethodBase> に応じて、ジェネリック型のパラメーターを型指定された型のオブジェクト。 たとえば場合、 `class G<T>` \(`class G(Of T)` Visual basic で `generic <T> ref class G` C\+\+ では\) 型を返すメソッドを持つ `T`, 、 <xref:System.Reflection.MethodBase> 、構築されたクラスでは、そのメソッドのなどのオブジェクト `G<int>` とは異なる、 <xref:System.Reflection.MethodBase> 、ジェネリック型定義内のオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> が無効です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、新しい <see cref="T:System.Reflection.MethodImplAttributes" /> フラグを返します。</summary>
        <returns>
          <see langword="MethodImplAttributes" /> フラグ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例は、動的アセンブリでコンス トラクターを定義しを使用して、<xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A>既定で設定されているメソッドの実装フラグを表示するメソッド。  
  
 [!code-cpp[ConstructorBuilder\_GetModule\_4\#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder\_GetModule\_4\#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder\_GetModule\_4\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合は、指定されたメソッドまたはコンス トラクターのパラメーターを取得します。</summary>
        <returns>型の配列 <see langword="ParameterInfo" /> この反映メソッド \(またはコンス トラクター\) のシグネチャと一致する情報を含む <see langword="MethodBase" /> インスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、 <xref:System.Reflection.MethodBase.GetParameters%2A> のパラメーターを取得するメソッドを `Invoke` 、デリゲートのメソッドです。  
  
 例では、という名前のデリゲートを定義する `MyDelegate` という名前のイベントと `ev` 型の `MyDelegate`です。 内のコード、 `Main` メソッド、イベントのデリゲート型を取得することによって、イベント シグネチャの検出を取得する、 `Invoke` 、デリゲート型を取得し、パラメーターの表示のメソッドです。  
  
 [!code-cpp[eventarg\#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg\#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">メソッドまたはコンストラクターを呼び出す対象となるオブジェクト。 メソッドが静的な場合、この引数は無視されます。 コンストラクターが静的な場合、この引数は <see langword="null" />、またはコンストラクターを定義するクラスのインスタンスである必要があります。</param>
        <param name="parameters">呼び出されたメソッドまたはコンストラクターのための引数リスト。 これは、呼び出されるメソッドまたはコンストラクターのパラメーターと同じ数、順序、および型のオブジェクトの配列です。 パラメーターがない場合は、<c>parameters</c> は <see langword="null" /> である必要があります。  
  
 このインスタンスが表すメソッドまたはコンストラクターが <see langword="ref" /> パラメーター \(Visual Basic では <see langword="ByRef" />\) を受け取る場合、このパラメーターには、この関数を使用してメソッドまたはコンストラクターを呼び出すために特別な属性が必要ありません。 値で明示的に初期化されていないこの配列内のすべてのオブジェクトに、オブジェクトの型の既定値が含まれます。 参照型の要素の場合、この値は <see langword="null" /> です。 値型要素では、要素の型によって、この値は 0、0.0、または <see langword="false" /> になります。</param>
        <summary>指定されたパラメーターを使用して、現在のインスタンスが表すメソッドまたはコンストラクターを呼び出します。</summary>
        <returns>呼び出されたメソッド、またはコンストラクターの場合は <see langword="null" /> の戻り値を格納するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This is a convenience method that calls the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> method overload, passing <xref:System.Reflection.BindingFlags.Default> for **parameterReference tag is not supported!!!!**  
 and **languageKeyword tag is not supported!!!!**  
 for **parameterReference tag is not supported!!!!**  
 and **parameterReference tag is not supported!!!!**  
.  
  
 If the invoked method throws an exception, the <xref:System.Exception.GetBaseException%2A?displayProperty=fullName> method returns the exception.  
  
 To invoke a static method using its <xref:System.Reflection.MethodInfo> object, pass **languageKeyword tag is not supported!!!!**  
 for **parameterReference tag is not supported!!!!**  
.  
  
> [!NOTE]
>  If this method overload is used to invoke an instance constructor, the object supplied for **parameterReference tag is not supported!!!!**  
>  is reinitialized; that is, all instance initializers are executed. The return value is **languageKeyword tag is not supported!!!!**  
> . If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed. The return value is **languageKeyword tag is not supported!!!!**  
> .  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non\-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=fullName> flag and if the grant set of the non\-public members is restricted to the caller’s grant set, or a subset thereof. \(See [Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5).\)  
>   
>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.  
  
 If a parameter of the current method is a value type, and the corresponding argument in **parameterReference tag is not supported!!!!**  
 is **languageKeyword tag is not supported!!!!**  
, the runtime passes a zero\-initialized instance of the value type.  
  
   
  
## 例  
 The following code example demonstrates dynamic method lookup using reflection. Note that you cannot use the <xref:System.Reflection.MethodInfo> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">  
<para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または [ポータブル クラス ライブラリ](http://msdn.microsoft.com/ja-jp/c31e1663-c164-4e65-b66d-d3aa8750a154)では、<see cref="T:System.Exception" /> を代わりにキャッチします。  
  
</para>  
</block>  
  
 <paramref name="obj" /> パラメーターは <see langword="null" /> で、メソッドは静的でありません。  
  
 または  
  
 メソッドは <paramref name="obj" /> のクラスで宣言も継承もされていません。  
  
 または  
  
 静的コンストラクターが呼び出されました。<paramref name="obj" /> は <see langword="null" /> でも、コンストラクターを宣言したクラスのインスタンスでもありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameters" /> 配列の要素は、このインスタンスがリフレクトしたメソッドまたはコンストラクターの署名と一致しません。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">呼び出されたメソッドまたはコンストラクターが例外をスローします。  
  
 または  
  
 現在のインスタンスは、検証できないコードを含む <see cref="T:System.Reflection.Emit.DynamicMethod" /> です。<see cref="T:System.Reflection.Emit.DynamicMethod" /> については、「解説」の「検証」セクションを参照してください。</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <paramref name="parameters" /> 配列に正しい数の引数がありません。</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">  
<para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または [ポータブル クラス ライブラリ](http://msdn.microsoft.com/ja-jp/c31e1663-c164-4e65-b66d-d3aa8750a154)では、基本クラスの例外である <see cref="T:System.MemberAccessException" /> を代わりにキャッチします。  
  
</para>  
</block>  
  
 呼び出し元には、現在のインスタンスが表すメソッドまたはコンストラクターを実行するアクセス許可がありません。</exception>
        <exception cref="T:System.InvalidOperationException">メソッドを宣言する型は、オープン ジェネリック型です。 つまり、<see cref="P:System.Type.ContainsGenericParameters" /> プロパティは宣言型に <see langword="true" /> を返します。</exception>
        <exception cref="T:System.NotSupportedException">現在のインスタンスは <see cref="T:System.Reflection.Emit.MethodBuilder" /> です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">メソッドまたはコンス トラクターを呼び出し元となるオブジェクト。 メソッドが静的な場合は、この引数は無視されます。 この引数がある必要があります、コンス トラクターが静的な場合は、 <see langword="null" /> またはコンス トラクターを定義するクラスのインスタンス。</param>
        <param name="invokeAttr">0 個以上のビット フラグの組み合わせは、ビットマスク <see cref="T:System.Reflection.BindingFlags" />します。 場合 <c>binder</c> は <see langword="null" />, 、このパラメーターには、値が割り当てられた <see cref="F:System.Reflection.BindingFlags.Default" />。 このため、渡すは無視されます。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションによる <see langword="MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。<c>binder</c> が <see langword="null" /> の場合は、既定のバインダーが使用されます。</param>
        <param name="parameters">呼び出されたメソッドまたはコンス トラクターの引数リスト。 これは、メソッドまたは呼び出されるコンス トラクターのパラメーターと同じ数、順序、および型を持つオブジェクトの配列です。 パラメーターがない場合、これこと <see langword="null" />します。  
  
 メソッドまたはコンス トラクターのこのインスタンスで表されるで ByRef パラメーターを受け取る場合、そのパラメーターにメソッドまたはコンス トラクターを呼び出すために必要な特別な属性はありません。 この値を明示的に初期化されていない配列内のオブジェクトには、そのオブジェクトの種類の既定値が含まれます。 この値は、参照型の要素の <see langword="null" />です。 値型要素は、この値は 0、0.0、または <see langword="false" />, の特定の要素の種類によって異なります。</param>
        <param name="culture">型の強制変換を制御するために使用する <see langword="CultureInfo" /> のインスタンス。<see langword="null" /> の場合は、現在のスレッドの <see langword="CultureInfo" /> が使用されます。 \(これは、たとえば、1000 を表す <see langword="String" /> を <see langword="Double" /> 値に変換する場合に必要です。これは、カルチャによって 1000 の表記が異なるためです。\)</param>
        <summary>派生クラスでオーバーライドされた場合は、リフレクションされたメソッドまたは指定したパラメーターを持つコンス トラクターを呼び出します。</summary>
        <returns>
          <see langword="Object" /> 呼び出されたメソッドの戻り値を含むまたは <see langword="null" /> 、コンス トラクターの場合、または <see langword="null" /> メソッドの戻り値の型が <see langword="void" />です。 メソッドまたはコンス トラクターを呼び出す前に <see langword="Invoke" /> を確認、ユーザーがアクセス許可を持つパラメーターが有効であることを確認し、かどうか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このインスタンスがリフレクション メソッドを動的に呼び出します `obj`, を指定されたパラメーターを渡します。 メソッドが静的である場合、 `obj` パラメーターは無視されます。 非静的メソッドの `obj` 継承またはメソッドを宣言し、このクラスと同じ型である必要がありますクラスのインスタンスである必要があります。 メソッドは、パラメーターの値を持たない場合 `parameters` べき `null`します。 それ以外の場合、数、種類、および内の要素の順序 `parameters` 数や型のこのインスタンスがリフレクション メソッド パラメーターの順序と同一である必要があります。  
  
 呼び出しで省略可能なパラメーターを省略できません `Invoke`します。 省略可能なパラメーターを省略するメソッドを呼び出すを呼び出す必要があります `Type.InvokeMember` 代わりにします。  
  
> [!NOTE]
>  オブジェクトが指定した場合、このメソッドのオーバー ロードは、インスタンス コンス トラクターの呼び出しに使用される、 `obj` は再初期化されます。 つまり、すべてのインスタンスの初期化子を実行します。 戻り値は `null`です。 クラスのコンス トラクターが呼び出されると、クラスが再初期化されます。つまり、すべてのクラス初期化子が実行されます。 戻り値は `null`です。  
  
 通常の拡張の実行プリミティブ パラメーターの値渡し \(Int16 \-\> Int32 など\)。 値渡しの参照パラメーターの場合は、通常の参照拡張が許可されます \(派生クラスを基本クラスおよびインターフェイス型の基本クラス\)。 ただし、参照渡しのプリミティブ パラメーターの型が正確に一致する必要があります。 参照渡しの参照パラメーターの場合は、通常の拡張も適用されます。  
  
 たとえば、メソッドがリフレクションしている場合は、このインスタンスとして宣言されて `public boolean Compare(String a, String b)`, 、し `parameters` の配列である必要があります `Objects` 長が 2 ように `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`します。  
  
 現在のメソッドのパラメーターの値の型と、対応する引数の場合 `parameters` は `null`, 、ランタイムは、値型のゼロ初期化のインスタンスを渡します。  
  
 リフレクションは、仮想メソッドを呼び出すときに、動的メソッドの参照を使用します。 たとえば、クラス B がクラス A から継承され、どちらも M という仮想メソッドを実装するとします。これであると仮定する `MethodInfo` クラス A に M を表すオブジェクト使用する場合、 `Invoke` B. クラスで指定された実装はリフレクションを使用して、タイプ B のオブジェクトに対して M を呼び出すメソッドをクラス B で指定された実装が使用される場合でも、タイプ B のオブジェクトを A にキャスト \(以下のコード サンプルを参照してください\)。  
  
 その一方で、メソッドが仮想でない場合、リフレクションは使用元となる型で指定された実装、 `MethodInfo` 対象として渡されるオブジェクトの種類に関係なく、取得しました。  
  
 アクセスの制限には、完全に信頼されたコードは無視されます。 つまり、private のコンス トラクター、メソッド、フィールド、およびプロパティにアクセスしてコードが完全に信頼されていると、リフレクションを使用して起動します。  
  
 呼び出されたメソッドが、例外をスローした場合 `TargetInvocationException.GetException` の例外を返します。 この実装は、 `NotSupportedException`です。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], 、このメソッドは、呼び出し元が許可されている場合は、非パブリック メンバーをアクセスに使用できます [Invoke メソッド \(Object, BindingFlags, Binder, Object\<xref:System.Security.Permissions.ReflectionPermission> で、 [Invoke メソッド \(Object, BindingFlags, Binder, Object\<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=fullName> フラグを設定し、非パブリック メンバーの許可セットが、呼び出し元に制限されている場合は、セット、またはそのサブセットを付与します。 \(「[Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5)」を参照\)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## 例  
 次の例では、すべてのメンバー、 [Invoke メソッド \(Object, BindingFlags, Binder, Object\<xref:System.Reflection.Binder?displayProperty=fullName> クラスのオーバー ロードを使用して [Invoke メソッド \(Object, BindingFlags, Binder, Object\<xref:System.Type.InvokeMember%2A?displayProperty=fullName>します。 プライベート メソッド `CanConvertFrom` 、指定された型の互換性のある型を検索します。 カスタム バインディングのシナリオでメンバーを呼び出す別の例を参照してください。 [&#91;\<topic:\/\/cpcondynamicallyloadingusingtypes\>&#93;](http://msdn.microsoft.com/ja-jp/db985bec-5942-40ec-b13a-771ae98623dc)します。  
  
 [!code-cpp[Binder\_1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder\_1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder\_1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <paramref name="obj" /> パラメーターは <see langword="null" /> メソッドは static ではないとします。  
  
 または  
  
 メソッドの宣言またはのクラスによって継承されていない <paramref name="obj" />します。  
  
 または  
  
 静的コンス トラクターが呼び出されると、および <paramref name="obj" /> も <see langword="null" /> もをコンス トラクターを宣言したクラスのインスタンス。</exception>
        <exception cref="T:System.ArgumentException">種類、 <paramref name="parameters" /> パラメーターがメソッドまたはこのインスタンスがリフレクション コンス トラクターのシグネチャと一致しません。</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <paramref name="parameters" /> 配列に正しい数の引数がありません。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">呼び出されたメソッドまたはコンス トラクターは、例外をスローします。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、メソッドまたは現在のインスタンスによって表されるコンス トラクターを実行する権限がありません。</exception>
        <exception cref="T:System.InvalidOperationException">メソッドを宣言する型は、オープン ジェネリック型です。 つまり、 <see cref="P:System.Type.ContainsGenericParameters" /> プロパティを返します。 <see langword="true" /> 宣言型のです。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメソッドが抽象であるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> メソッドが抽象である場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 抽象メンバーは基本クラスで宣言され、実装が指定されていません。  
  
 取得する、 <xref:System.Reflection.MethodBase>, 、まず、型を取得します。 型からメソッドを取得します。 メソッドから取得、 `MethodBase`です。 場合、 `MethodBase` またはコンス トラクターがパブリック以外、それが保護されており、すぐにアクセスすることはできません。 非パブリック メソッドにアクセスするには、設定、 <xref:System.Reflection.BindingFlags> マスクを `NonPublic` で `GetMethod`します。  
  
   
  
## 例  
 次の例では、このメソッドは abstract であり、結果が表示されますが指定されているかどうかを決定します。  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメソッドまたはコンス トラクターの潜在的な可視性がで説明されているかどうかを示す値を取得 <see cref="F:System.Reflection.MethodAttributes.Assembly" />; は、メソッドまたはコンス トラクターは表示されている多くても、同じアセンブリ内の他の型へとに非表示の派生、アセンブリ外で型です。</summary>
        <value>
          <see langword="true" /> このメソッドまたはコンス トラクターの可視性がによって正確に説明されているかどうかは <see cref="F:System.Reflection.MethodAttributes.Assembly" />。 そうしないと、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッドの実際の可視性は、その型の可視性によって制限されます。<xref:System.Reflection.MethodBase.IsAssembly%2A> プロパティがあります `true` メソッドの場合は、メソッドは、包含する型の外部で参照することはありませんし、プライベートの入れ子にされた型のメソッドである場合。  
  
 メソッドまたはコンス トラクターの可視性が正確に説明されている <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=fullName> 場合は唯一の可視性修飾子 `internal` \(`Friend` Visual Basic で\)。 このプロパティは、 `false` あるメソッドの `protected internal` C\# の場合 \(`Protected Friend` Visual basic で `protected public` C\+\+ では\); を使用して、 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> このようなメソッドを識別するプロパティです。  
  
   
  
## 例  
 次のコード例はさまざまなレベルの可視性を持つメソッドを定義しの値を表示、 <xref:System.Reflection.MethodBase.IsAssembly%2A>, 、<xref:System.Reflection.MethodBase.IsFamily%2A>, 、<xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 、および <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> プロパティです。  
  
> [!NOTE]
>  Visual Basic および c\# 言語でのメソッドは定義できません <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=fullName> 可視性\]; \[アクセス レベルは、C\+\+ の例でのみが表示されます。  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メソッドが、コンス トラクターであるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> このメソッドは、コンス トラクターによって表される場合、 <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト \(は、「解説」注を参照してください <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> オブジェクト\)。 そうしないと、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  <xref:System.Reflection.MethodBase.IsConstructor%2A> プロパティを返します。 `false` の、 <xref:System.Reflection.Emit.ConstructorBuilder> しない限り、動的な型のオブジェクト、 <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=fullName> にフラグが含まれていた、 `attributes` コンス トラクターが定義したときにパラメーター。 省略すると、 <xref:System.Reflection.MethodAttributes.RTSpecialName> フラグでは、出力されたコンス トラクターの正確さには影響しません。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメソッドまたはコンス トラクターの可視性がで説明されているかどうかを示す値を取得 <see cref="F:System.Reflection.MethodAttributes.Family" />;、メソッドまたはコンス トラクターは、クラスと派生クラス内でのみ表示します。</summary>
        <value>
          <see langword="true" /> 場合はこのメソッドへのアクセスまたはコンス トラクターは <see cref="F:System.Reflection.MethodAttributes.Family" />。 そうしないと、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッドまたはコンス トラクターの可視性が正確に説明されている <xref:System.Reflection.MethodAttributes.Family?displayProperty=fullName> 場合は唯一の可視性修飾子 `protected`します。 このプロパティは、 `false` あるメソッドの `protected internal` C\# の場合 \(`Protected Friend` Visual basic で `protected public` C\+\+ では\); を使用して、 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> このようなメソッドを識別するプロパティです。  
  
   
  
## 例  
 次のコード例はさまざまなレベルの可視性を持つメソッドを定義しの値を表示、 <xref:System.Reflection.MethodBase.IsAssembly%2A>, 、<xref:System.Reflection.MethodBase.IsFamily%2A>, 、<xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 、および <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> プロパティです。  
  
> [!NOTE]
>  Visual Basic および c\# 言語でのメソッドは定義できません <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=fullName> 可視性\]; \[アクセス レベルは、C\+\+ の例でのみが表示されます。  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメソッドまたはコンス トラクターの可視性がで説明されているかどうかを示す値を取得 <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; は、メソッドまたはコンス トラクターから呼び出せる派生クラスの場合のみ、同じアセンブリ内にある場合。</summary>
        <value>
          <see langword="true" /> 場合はこのメソッドへのアクセスまたはコンス トラクターは <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />。 そうしないと、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メソッドまたはコンス トラクターの可視性が正確に説明されている <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=fullName> 場合は、可視性修飾子 `protected private` C\+\+ では。 この可視性を持つメソッドは、Visual Basic または c\# で定義することはできません。  
  
   
  
## 例  
 次のコード例はさまざまなレベルの可視性を持つメソッドを定義しの値を表示、 <xref:System.Reflection.MethodBase.IsAssembly%2A>, 、<xref:System.Reflection.MethodBase.IsFamily%2A>, 、<xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 、および <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> プロパティです。  
  
> [!NOTE]
>  Visual Basic および c\# 言語でのメソッドは定義できません <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=fullName> 可視性\]; \[アクセス レベルは、C\+\+ の例でのみが表示されます。  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメソッドまたはコンス トラクターの潜在的な可視性がで説明されているかどうかを示す値を取得 <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; は、メソッドまたはコンス トラクター呼び出せる派生クラスによって任意の場所であると、同じアセンブリ内のクラスによってです。</summary>
        <value>
          <see langword="true" /> 場合はこのメソッドへのアクセスまたはコンス トラクターは <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />。 そうしないと、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型のメンバーがある場合 <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=fullName>可視性、呼び出せるから同じアセンブリ内のメンバーまたは派生クラスでの任意のメンバーからはないその他の種類。  
  
 メソッドの実際の可視性は、その型の可視性によって制限されます。<xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> プロパティがあります `true` メソッドの場合は、メソッドは、包含する型の外部で参照することはありませんし、プライベートの入れ子にされた型のメソッドである場合。  
  
 メソッドまたはコンス トラクターの可視性が正確に説明されている <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=fullName> 可視性修飾子がある場合 `protected internal` C\# の場合 \(`Protected Friend` Visual basic で `protected public` C\+\+ で\)。  
  
   
  
## 例  
 次のコード例はさまざまなレベルの可視性を持つメソッドを定義しの値を表示、 <xref:System.Reflection.MethodBase.IsAssembly%2A>, 、<xref:System.Reflection.MethodBase.IsFamily%2A>, 、<xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 、および <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> プロパティです。  
  
> [!NOTE]
>  Visual Basic および c\# 言語でのメソッドは定義できません <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=fullName> 可視性\]; \[アクセス レベルは、C\+\+ の例でのみが表示されます。  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメソッドは、あるかどうかを示す値を取得 <see langword="final" />します。</summary>
        <value>
          <see langword="true" /> このメソッドは場合 <see langword="final" />。 そうしないと、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ないことを確認するための十分なメソッドがオーバーライド可能な場合を判断する <xref:System.Reflection.MethodBase.IsVirtual%2A> は `true`です。 メソッドのオーバーライドに `IsVirtual` する必要があります `true` と `IsFinal` する必要があります `false`します。 たとえば、メソッドは仮想マシンにありますが、インターフェイス メソッドを実装します。 共通言語ランタイムでは、インターフェイスのメンバーを実装するすべてのメソッドは、としてマークする必要がありますが必要です `virtual`。 したがって、コンパイラがメソッドをマーク `virtual final`します。 メソッドとしてマークされている場合があるように `virtual` がオーバーライドできません。  
  
 メソッドがオーバーライドできるかどうかを確実に確立するには、このようなコードを使用します。  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 場合 `IsVirtual` は `false` または `IsFinal` は `true`, 、メソッドをオーバーライドすることはできませんし、します。  
  
   
  
## 例  
 次の例を表示 `false` の `IsFinal`, を実行すると考えがちになるする可能性があります。 コードの出力を `false` MyMethod がマークされていない場合でも `virtual` ため、オーバーライドできません。  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメソッドがジェネリックかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 場合は、現在 <see cref="T:System.Reflection.MethodBase" /> ジェネリック メソッドを表します。 そうしないと、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> を確認するにするかどうか、現在 <xref:System.Reflection.MethodBase> オブジェクトがジェネリック メソッドを表します。 使用、 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> を確認するにするかどうか、現在 <xref:System.Reflection.MethodBase> オブジェクトは、オープン構築メソッドまたはクローズ構築メソッドを表します。  
  
> [!NOTE]
>  既定ではジェネリックはサポートされていませんこのプロパティを返します `false` 派生クラスでオーバーライドされていない場合。 ジェネリック コンス トラクターは、.NET Framework version 2.0 でサポートされないため、このプロパティを返します `false` 現在のインスタンスが型の場合 <xref:System.Reflection.ConstructorInfo>します。  
  
 ジェネリック メソッドに固有の用語に対するインバリアント条件の一覧は、次を参照してください。、 <xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName> プロパティです。 一般的なリフレクションで使用されるその他の用語に対するインバリアント条件の一覧は、次を参照してください。、 <xref:System.Type.IsGenericType%2A?displayProperty=fullName> プロパティです。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodInfo.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メソッドがジェネリック メソッド定義であるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 場合は、現在 <see cref="T:System.Reflection.MethodBase" /> オブジェクトがジェネリック メソッドの定義を表します。 そうしないと、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合は、現在 <xref:System.Reflection.MethodBase> し、ジェネリック メソッド定義を表します。  
  
-   <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> プロパティが `true` です。  
  
-   各 <xref:System.Type> によって返される配列内のオブジェクト、 <xref:System.Reflection.MethodBase.GetGenericArguments%2A> メソッド。  
  
    -   <xref:System.Type.IsGenericParameter%2A?displayProperty=fullName> プロパティが `true` です。  
  
    -   <xref:System.Type.DeclaringMethod%2A?displayProperty=fullName> プロパティは、現在のインスタンスを返します。  
  
    -   <xref:System.Type.GenericParameterPosition%2A?displayProperty=fullName> プロパティは、の位置と同じ、 <xref:System.Type> 、配列内のオブジェクト。  
  
> [!NOTE]
>  既定ではジェネリックはサポートされていませんこのプロパティを返します `false` 派生クラスでオーバーライドされていない場合。 ジェネリック コンス トラクターは、.NET Framework version 2.0 でサポートされないため、このプロパティを返します `false` 現在のインスタンスが型の場合 <xref:System.Reflection.ConstructorInfo>します。  
  
 ジェネリック メソッドに固有の用語に対するインバリアント条件の一覧は、次を参照してください。、 <xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName> プロパティです。 一般的なリフレクションで使用されるその他の用語に対するインバリアント条件の一覧は、次を参照してください。、 <xref:System.Type.IsGenericType%2A?displayProperty=fullName> プロパティです。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodInfo.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスで正確に同じシグネチャを持つ同じ種類のメンバーだけが非表示かどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> シグネチャでメンバーが表示されていない場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生クラスでメンバーが、c\# で宣言されている場合 `new` 修飾子または Visual Basic `Shadows` 修飾子は、基本クラスに同じ名前のメンバーを非表示にできます。 C\# シグネチャで基本クラスのメンバーを非表示にします。 基本クラスのメンバーに複数のオーバー ロードがある場合は、非表示には、1 つだけには、同じシグネチャを持つ 1 つです。 これに対し、Visual Basic では、すべての基本クラスのオーバー ロードを非表示にします。 したがって、 <xref:System.Reflection.MethodBase.IsHideBySig%2A> を返します `false` Visual Basic で宣言されたメンバーに `Shadows` 修飾子と `true` 、c\# で宣言されたメンバーに `new` 修飾子です。  
  
> [!WARNING]
>  このプロパティは、メソッドがあるかどうかを決定しません、 <xref:System.Reflection.MethodAttributes.NewSlot> 属性です。 いずれかで宣言されているメソッド、 `new` または `Shadows` 修飾子がある、 <xref:System.Reflection.MethodAttributes.NewSlot> 属性がで宣言されたメソッドのみ `new` \(つまり、c\# メソッドのみ\) が、 <xref:System.Reflection.MethodBase.IsHideBySig%2A> プロパティに設定 `true`します。  メソッドがあるかどうかを確認する、 <xref:System.Reflection.MethodAttributes.NewSlot> 属性を次のようなコードを使用して: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` C\# の場合、または `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` Visual Basic でします。 ただしをで宣言されたすべてのメソッドが `new` または `Shadows` が、 <xref:System.Reflection.MethodAttributes.NewSlot> 属性を持つすべてのメソッド、 <xref:System.Reflection.MethodAttributes.NewSlot> で属性が宣言された `new` または `Shadows`です。  
  
   
  
## 例  
 次のコード例には、オーバー ロードされたメソッドを持つ基本クラスと、オーバー ロードのいずれかの操作を非表示にする派生クラスが含まれています。 コード例の Visual Basic バージョンで、 <xref:System.Reflection.MethodBase.IsHideBySig%2A> プロパティを返します。 `false` 派生クラス内のメンバーです。 コード サンプルの c\# バージョンでは、プロパティを返します `true` 派生クラス内のメンバーです。  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーはプライベートであるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> このメソッドへのアクセスはクラス自体の他のメンバーに制限されている場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 型のメンバーがある場合 `Private` レベルの可視性、呼び出せるすべて、同じクラスとその他のメンバーからです。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>パブリック メソッドであるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> このメソッドがパブリックの場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 取得する、 <xref:System.Reflection.MethodBase>, 、まず、型を取得します。 型からメソッドを取得します。 メソッドから取得、 `MethodBase`です。 場合、 `MethodBase` またはコンス トラクターがパブリック以外、それが保護されており、すぐにアクセスすることはできません。 非パブリック メソッドにアクセスするには、設定、 <xref:System.Reflection.BindingFlags> マスクを `NonPublic` で `GetMethod`します。  
  
   
  
## 例  
 次の例では、 <xref:System.Reflection.MethodBase.IsPublic%2A> プロパティに指定されたメソッドがパブリックであるかどうかを示すメッセージが表示されます。  
  
 [!code-cpp[Classic MethodBase.IsPublic Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドまたはコンス トラクターが現在の信頼レベルが、セキュリティ クリティカルまたはセキュリティ セーフ クリティカルであり、重要な操作を実行できるかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> 現在のメソッドまたはコンス トラクターがセキュリティ クリティカルまたはセキュリティ セーフ クリティカルにある場合、現在の信頼レベルです。 <see langword="false" /> が透過的な場合です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, 、<xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, 、および <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> プロパティは、メソッドまたはコンス トラクターに共通言語ランタイム \(CLR\) によって決定される、現在の信頼レベルの透過度をレポートします。 次の表では、これらのプロパティの組み合わせを示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|----------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|セーフ クリティカル|`true`|`true`|`false`|  
|透過的|`false`|`false`|`true`|  
  
 これらのプロパティを使用すると、アセンブリとその型およびメンバーのセキュリティの注釈を調べることを確認したり、現在の信頼レベルをランタイムの規則を複製するよりも単純です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション \(たとえば、サンド ボックス アプリケーション ドメイン\) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。 アセンブリとそのすべての型を透過的に処理されます。 ランタイムは、そのアセンブリが \(たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン\) に完全に信頼されたアプリケーション ドメインに読み込まれる場合にのみ部分的に信頼されたアセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ \(つまり、厳密な名前付きアセンブリがグローバル アセンブリ キャッシュにインストールされている\) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは常に完全に信頼されました。 使用してアセンブリおよびアプリケーション ドメインの現在の信頼レベルを指定できます、 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> プロパティです。  
  
 リフレクションと透過性の詳細については、次を参照してください。 [Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5)します。 透過性の詳細については、次を参照してください。 [Security Changes in the .NET Framework Version 4.0](http://msdn.microsoft.com/ja-jp/5e87881c-9c13-4b52-8ad1-e34bb46e8aaa)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>するかどうか、現在のメソッドまたはコンス トラクターが、セキュリティ セーフ クリティカルな現在の信頼レベルを示す値を取得します。つまり、かどうか、重要な操作を実行することができます、透過的なコードからアクセスできます。</summary>
        <value>
          <see langword="true" /> メソッドまたはコンス トラクターは、セキュリティ セーフ クリティカルな現在の信頼レベルにある場合 <see langword="false" /> セキュリティ クリティカルまたは透過的なである場合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, 、<xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, 、および <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> プロパティは、メソッドまたはコンス トラクターに共通言語ランタイム \(CLR\) によって決定される、現在の信頼レベルの透過度をレポートします。 次の表では、これらのプロパティの組み合わせを示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|----------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|セーフ クリティカル|`true`|`true`|`false`|  
|透過的|`false`|`false`|`true`|  
  
 これらのプロパティを使用すると、アセンブリとその型およびメンバーのセキュリティの注釈を調べることを確認したり、現在の信頼レベルをランタイムの規則を複製するよりも単純です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション \(たとえば、サンド ボックス アプリケーション ドメイン\) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。 アセンブリとそのすべての型を透過的に処理されます。 ランタイムは、そのアセンブリが \(たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン\) に完全に信頼されたアプリケーション ドメインに読み込まれる場合にのみ部分的に信頼されたアセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ \(つまり、厳密な名前付きアセンブリがグローバル アセンブリ キャッシュにインストールされている\) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは常に完全に信頼されました。 使用してアセンブリおよびアプリケーション ドメインの現在の信頼レベルを指定できます、 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> プロパティです。  
  
 リフレクションと透過性の詳細については、次を参照してください。 [Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5)します。 透過性の詳細については、次を参照してください。 [Security Changes in the .NET Framework Version 4.0](http://msdn.microsoft.com/ja-jp/5e87881c-9c13-4b52-8ad1-e34bb46e8aaa)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドまたはコンス トラクターが透明かどうか、現在の信頼レベル、および操作を実行できない重要なことを示す値を取得します。</summary>
        <value>
          <see langword="true" /> メソッドまたはコンス トラクターが透過的セキュリティにある場合、現在の信頼レベルです。それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティを返す場合 `true`, 、 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> と <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> プロパティの戻り値 `false`です。  
  
 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, 、<xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, 、および <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> プロパティは、メソッドまたはコンス トラクターに共通言語ランタイム \(CLR\) によって決定される、現在の信頼レベルの透過度をレポートします。 これらのプロパティを使用すると、アセンブリとその型およびメンバーのセキュリティの注釈を調べることを確認したり、現在の信頼レベルをランタイムの規則を複製するよりも単純です。  
  
> [!IMPORTANT]
>  部分的に信頼されたアセンブリでは、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリがドメインに読み込まれて、部分的に信頼されたアプリケーション \(たとえば、サンド ボックス アプリケーション ドメイン\) の場合、ランタイムはアセンブリのセキュリティの注釈を無視します。 アセンブリとそのすべての型を透過的に処理されます。 ランタイムは、そのアセンブリが \(たとえば、デスクトップ アプリケーションの既定のアプリケーション ドメイン\) に完全に信頼されたアプリケーション ドメインに読み込まれる場合にのみ部分的に信頼されたアセンブリのセキュリティの注釈に注意を支払います。 これに対し、信頼されたアセンブリ \(つまり、厳密な名前付きアセンブリがグローバル アセンブリ キャッシュにインストールされている\) は常にアプリケーション ドメインの信頼レベルに関係なく、完全信頼で読み込まれたため、現在の信頼レベルは常に完全に信頼されました。 使用してアセンブリおよびアプリケーション ドメインの現在の信頼レベルを指定できます、 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> プロパティです。  
  
 リフレクションと透過性の詳細については、次を参照してください。 [Security Considerations for Reflection](http://msdn.microsoft.com/ja-jp/42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5)します。 透過性の詳細については、次を参照してください。 [Security Changes in the .NET Framework Version 4.0](http://msdn.microsoft.com/ja-jp/5e87881c-9c13-4b52-8ad1-e34bb46e8aaa)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメソッドが、特別な名前を持つかどうかを示す値を取得します。</summary>
        <value>
          <see langword="true" /> このメソッドは特別な名前がある場合それ以外の場合、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.MethodAttributes.SpecialName> フラグ \(プロパティ アクセサー メソッドのオーバー ロード演算子など\) の一部のコンパイラで特別な方法で処理されるメンバーにビットを設定します。  
  
   
  
## 例  
 使用法を示します <xref:System.Reflection.MethodBase.IsSpecialName%2A> フィルターの内部またはプライベート メンバー リストからにします。  
  
 [!code-cpp[Classic Type.IsSpecialName Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メソッドがあるかどうかを示す値を取得 <see langword="static" />します。</summary>
        <value>
          <see langword="true" /> このメソッドは場合 <see langword="static" />。 そうしないと、 <see langword="false" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 静的メンバーは、クラスのインスタンス データを暗黙的に参照できません。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メソッドが <see langword="virtual" /> であるかどうかを示す値を取得します。</summary>
        <value>このメソッドが <see langword="virtual" /> である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 仮想メンバーは、クラスでインスタンス データを参照し、クラスのインスタンスから参照する必要があります。  
  
 メソッドがオーバーライド可能な場合は、非であることを確認するための十分なを決定する`IsVirtual`は`true`です。 メソッドのオーバーライドに`IsVirtual`する必要があります`true`と<xref:System.Reflection.MethodBase.IsFinal%2A>する必要があります`false`です。 たとえば、メソッドは非仮想かもしれませんが、インターフェイス メソッドを実装します。 共通言語ランタイムでとしてインターフェイス メンバーを実装するすべてのメソッドをマークする必要があります`virtual`。 したがって、コンパイラは、メソッドをマーク`virtual final`です。 メソッドとしてマークする位置のケースがあるように`virtual`がオーバーライドできません。  
  
 メソッドがオーバーライドできるかどうかを確実に確立するには、このようなコードを使用します。  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 場合`IsVirtual`は`false`または`IsFinal`は`true`、メソッドをオーバーライドすることはできません。  
  
 現在のメソッドが呼び出すことによって、基底クラスのメソッドをオーバーライドするかどうかを決定できます、<xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=fullName>メソッドです。 次の例では、実装、`IsOverride`これを行うメソッドです。  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## 例  
 次の例を表示`false`の`IsFinal`を生じることがあると考えるを`MyMethod`オーバーライドします。 コードの出力を`false`にもかかわらず`MyMethod`マークされていない`virtual`のため、オーバーライドできません。  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メソッドの内部メタデータ表現へのハンドルを取得します。</summary>
        <value>
          <see cref="T:System.RuntimeMethodHandle" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ハンドルは、取得されたアプリケーション ドメインでのみ有効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see cref="T:System.Reflection.MethodImplAttributes" /> メソッドの実装の属性を指定するフラグ。</summary>
        <value>メソッド実装フラグ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 参照してください、 <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> 方法の詳細。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Reflection.MethodBase" /> オブジェクトが等しいかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> に等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Reflection.MethodBase" /> オブジェクトが等しくないかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> と等しくない場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetIDsOfNames`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />」を参照してください。</summary>
        <returns>このメンバーの詳細については、「<see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfo`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 \(0 または 1\) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfoCount`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::Invoke`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />」を参照してください。</summary>
        <value>このメンバーの詳細については、「<see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />」を参照してください。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.MethodBase> のインスタンスが <xref:System.Runtime.InteropServices._MethodBase> インターフェイスにキャストされる場合にのみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メソッドまたはこれがリフレクション コンス トラクターを呼び出します <see langword="MethodInfo" /> インスタンス。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したハンドルの使用方法の情報を取得します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>