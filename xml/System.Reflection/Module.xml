<Type Name="Module" FullName="System.Reflection.Module">
  <TypeSignature Language="C#" Value="public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Module, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Module extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Module, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Module" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Module</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Module))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>モジュールにリフレクションを実行します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 モジュールは、type.dll や application.exe、クラスとインターフェイスの 1 つまたは複数から成るなどのポータブル実行可能ファイルです。 複数の名前空間が、単一モジュールに含まれることがあります。また、1 つの名前空間が複数のモジュールにまたがることもあります。  
  
 1 つの単位として配置される 1 つ以上のモジュールによってアセンブリが構成されます。 1 つ以上のモジュールを使用してアセンブリを作成する方法の詳細については、次を参照してください。 [Multifile Assemblies](http://msdn.microsoft.com/ja-jp/13509e73-db77-4645-8165-aad8dfaedff6)します。  
  
 .NET Framework モジュールがない、プログラマが関数と、アプリケーションでのサブルーチンを整理するために使用する Visual Basic でのモジュールと同じに注意してください。  
  
   
  
## 例  
 次のコード例では、リフレクションを使用して、モジュールに関する情報を取得する方法を示します。  
  
 [!code-csharp[System.Reflection.Module\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module/CS/source.cs#1)]
 [!code-vb[System.Reflection.Module\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">for full trust for inheritors. This class cannot be inherited by partially trusted code.</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Module ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Reflection.Module" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは、構築する際に派生クラスによって呼び出される <xref:System.Reflection.Module> オブジェクトです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>適切な取得 <see cref="T:System.Reflection.Assembly" /> のこのインスタンスの <see cref="T:System.Reflection.Module" />です。</summary>
        <value>
          <see langword="Assembly" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、指定したモジュールの指定したアセンブリの完全名を表示します。  
  
 [!code-cpp[System.Reflection.Module.Assembly Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.Assembly Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.Assembly Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このモジュールのカスタム属性を含むコレクションを取得します。</summary>
        <value>このモジュールのカスタム属性を含むコレクションです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">このインスタンスと比較するオブジェクト。</param>
        <summary>このモジュールと、指定したオブジェクトが等しいかどうかを決定します。</summary>
        <returns>
          <see langword="true" /> がこのインスタンスと等しい場合は <paramref name="o" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeName" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に基づいて、このモジュールで定義された型の一覧をフィルター処理する <see langword="TypeFilter" /> オブジェクト。 このフィールドは大文字と小文字を区別し、読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 フィルターは、末尾をサポートしています"\*"ワイルドカードです。  
  
   
  
## 例  
 次の例では、指定した検索条件に一致するモジュール名を表示します。  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FilterTypeNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に基づいて、このモジュールで定義された型の一覧をフィルター処理する <see langword="TypeFilter" /> オブジェクト。 このフィールドは大文字と小文字の区別をせず、読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 末尾に、フィルターがサポートする"\*"ワイルドカードです。  
  
   
  
## 例  
 次の例では、大文字と小文字を無視して、指定した検索条件に一致するモジュール名を表示します。  
  
 [!code-cpp[System.Reflection.Module.FilterTypeNameIgnoreCase Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeNameIgnoreCase Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeNameIgnoreCase Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] FindTypes (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindTypes(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">クラスのフィルター処理に使用するデリゲート。</param>
        <param name="filterCriteria">クラスのフィルター処理に使用するオブジェクト。</param>
        <summary>指定したフィルターとフィルター条件で受け入れられたクラスの配列を返します。</summary>
        <returns>フィルターで受け入れられているクラスを含む <see langword="Type" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.ReflectionTypeLoadException>特殊クラスの読み込み例外です。`ReflectionTypeLoadException.Types`プロパティには、モジュールで定義されたされ、読み込まれたクラスの配列が含まれています。 この配列には、いくつかの null 値が含まれます。`ReflectionTypeLoadException.LoaderExceptions`プロパティをクラス ローダーによってスローされた例外を表す例外の配列です。 クラスの配列の穴は、例外を整列します。  
  
 によって指定されたデリゲート`filter`モジュールでは、渡すには、各クラスに対して呼び出されます、`Type`クラスを表すオブジェクトだけでなく、指定された`filterCriteria`です。 場合`filter`返す特定のクラス、クラスが返される配列に含まれることです。 場合`filter`返します`null`、すべてのクラスが返されると`filterCriteria`は無視されます。  
  
 `FindTypes`パラメーター化された型の配列などの検索に使用できません。  
  
   
  
## 例  
 次の例で、`FindTypes`メソッドです。  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">モジュールの 1 つまたは複数のクラスを読み込むことができませんでした。</exception>
        <altmember cref="F:System.Reflection.Module.FilterTypeName" />
        <altmember cref="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public virtual string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このモジュールへのパスと完全修飾名を表す文字列を取得します。</summary>
        <value>モジュールの完全修飾名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 パスを含まない名前を取得する <xref:System.Reflection.Module.Name%2A>です。  
  
 このモジュールのアセンブリがバイト配列から読み込まれたかどうか、 `FullyQualifiedName` モジュールが表示されます: \< 不明な \> です。  
  
> [!NOTE]
>  モジュール名の大文字と小文字は、プラットフォームによって異なります。  
  
   
  
## 例  
 次の例では、指定したモジュールの完全修飾名を表示します。  
  
 [!code-cpp[System.Reflection.Module.FullyQualifiedName\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FullyQualifiedName\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FullyQualifiedName\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to information in the path. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>すべてのカスタム属性を返します。</summary>
        <returns>型の配列 <see langword="Object" /> すべてのカスタム属性を格納しています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、指定した検索条件に一致するモジュール名を表示します。  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 1Arg Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 1Arg Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 1Arg Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">取得する属性の型。</param>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>指定した型のカスタム属性を取得します。</summary>
        <returns>型の配列 <see langword="Object" /> 指定した型のすべてのカスタム属性を含みます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、指定した検索条件に一致する、指定した種類のモジュール名を表示します。  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 2Arg Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 2Arg Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 2Arg Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> は、ランタイムによって提供された <see cref="T:System.Type" /> オブジェクトではありません。 たとえば、<paramref name="attributeType" /> は <see cref="T:System.Reflection.Emit.TypeBuilder" /> オブジェクトです。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributesData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>一覧を返す <see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトの現在のモジュールは、リフレクションのみのコンテキストで使用できます。</summary>
        <returns>現在のモジュールに適用されている属性に関するデータを表す <see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトのジェネリック リスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 カスタム属性自体のリフレクション専用コンテキストに読み込まれるコードが定義されている場合、リフレクションのみのコンテキスト内のコードのカスタム属性を調べるには、このメソッドを使用します。 などのメソッド <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=fullName> と <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=fullName> 属性のインスタンスを作成するため、このような場合では使用できません。 リフレクションのみのコンテキストでコードを実行できません。 詳細とコード例は、「、 <xref:System.Reflection.CustomAttributeData> クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">フィールド名。</param>
        <summary>指定された名前のフィールドを返します。</summary>
        <returns>指定した名前の <see langword="FieldInfo" /> オブジェクト。フィールドが存在しない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">フィールド名。</param>
        <param name="bindingAttr">検索を制御するために使用される <see langword="BindingFlags" /> ビット フラグのいずれか。</param>
        <summary>指定された名前とバインド属性を持つフィールドを返します。</summary>
        <returns>指定した名前とバインド属性を持つ <see langword="FieldInfo" /> オブジェクト。フィールドが存在しない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>モジュールで定義されたグローバル フィールドを返します。</summary>
        <returns>モジュールで定義されているグローバル フィールドを表す <see cref="T:System.Reflection.FieldInfo" /> オブジェクトの配列。グローバル フィールドがない場合は、空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.Module.GetFields%2A>メソッドで返されないフィールドを特定の順序など、アルファベットまたは宣言の順序。 その順序が異なるので、コードは、フィールドが返される順序に依存しない必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">検索を制限する <see cref="T:System.Reflection.BindingFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したバインディング フラグと一致するモジュールで定義されているグローバル フィールドを返します。</summary>
        <returns>指定したバインディング フラグと一致するモジュールで定義されているグローバル フィールドを表す <see cref="T:System.Reflection.FieldInfo" /> 型の配列。バインディング フラグに一致するグローバル フィールドがない場合は、空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.Module.GetFields%2A>メソッドで返されないフィールド、特定の順序など、アルファベットまたは宣言の順序。 その順序が異なるので、コードは、フィールドが返される順序に依存しない必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">メソッド名。</param>
        <summary>指定された名前のメソッドを返します。</summary>
        <returns>指定された名前の <see langword="MethodInfo" /> オブジェクト。メソッドが存在しない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">メソッド名。</param>
        <param name="types">検索対象のパラメーター型。</param>
        <summary>指定した名前とパラメーター型のメソッドを返します。</summary>
        <returns>指定した条件に一致する <see langword="MethodInfo" /> オブジェクト。メソッドが存在しない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> か、<paramref name="types" /> が <see langword="null" /> か、<paramref name="types" /> \(i\) が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">メソッド名。</param>
        <param name="bindingAttr">検索を制御するために使用される <see langword="BindingFlags" /> ビット フラグのいずれか。</param>
        <param name="binder">このメソッドに関連するプロパティが含まれ、<see langword="Binder" /> を実装するオブジェクト。</param>
        <param name="callConvention">メソッドの呼び出し規則。</param>
        <param name="types">検索対象のパラメーター型。</param>
        <param name="modifiers">型が変更されているパラメーター シグネチャでバインドを機能させるために使われるパラメーター修飾子の配列。</param>
        <summary>指定された名前、バインド情報、呼び出し規則、パラメーターの型と修飾子を持つメソッドを返します。</summary>
        <returns>指定した条件に一致する <see langword="MethodInfo" /> オブジェクト。メソッドが存在しない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> か、<paramref name="types" /> が <see langword="null" /> か、<paramref name="types" /> \(i\) が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">メソッド名。</param>
        <param name="bindingAttr">検索を制御するために使用される <see langword="BindingFlags" /> ビット フラグのいずれか。</param>
        <param name="binder">このメソッドに関連するプロパティが含まれ、<see langword="Binder" /> を実装するオブジェクト。</param>
        <param name="callConvention">メソッドの呼び出し規則。</param>
        <param name="types">検索対象のパラメーター型。</param>
        <param name="modifiers">型が変更されているパラメーター シグネチャでバインドを機能させるために使われるパラメーター修飾子の配列。</param>
        <summary>指定した条件に従って、メソッドの実装を返します。</summary>
        <returns>A <see langword="MethodInfo" /> と指定した実装に関する情報を格納するオブジェクトまたは <see langword="null" /> メソッドが存在しない場合。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <paramref name="types" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>モジュールで定義されたグローバル メソッドを返します。</summary>
        <returns>モジュールで定義されているすべてのグローバル メソッドを表す <see cref="T:System.Reflection.MethodInfo" /> オブジェクトの配列。グローバル メソッドがない場合は、空の配列が返されます。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">検索を制限する <see cref="T:System.Reflection.BindingFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したバインディング フラグと一致するモジュールで定義されているグローバル メソッドを返します。</summary>
        <returns>指定したバインディング フラグと一致するモジュールで定義されているグローバル メソッドを表す <see cref="T:System.Reflection.MethodInfo" /> 型の配列。バインディング フラグに一致するグローバル メソッドがない場合は、空の配列が返されます。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">情報とデータは、オブジェクトを逆シリアル化または逆シリアル化に必要です。</param>
        <param name="context">シリアル化コンテキスト。</param>
        <summary>提供、 <see cref="T:System.Runtime.Serialization.ISerializable" /> シリアル化されたオブジェクトの実装です。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public virtual void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetPEKind(valuetype System.Reflection.PortableExecutableKinds peKind, valuetype System.Reflection.ImageFileMachine machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds&amp;" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">このメソッドが返す場合の組み合わせ、 <see cref="T:System.Reflection.PortableExecutableKinds" /> 、モジュール内のコードの性質を示す値。</param>
        <param name="machine">このメソッドが返す場合のいずれか、 <see cref="T:System.Reflection.ImageFileMachine" /> モジュールによって対象とするプラットフォームを示す値。</param>
        <summary>モジュールは、モジュールによって対象とするプラットフォームでコードの性質を示す値のペアを取得します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetSignerCertificate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します。、 <see langword="X509Certificate" /> にこのモジュールが属するアセンブリの Authenticode 署名に含まれる証明書に対応するオブジェクト。 アセンブリの Authenticode 署名されていない場合 <see langword="null" /> が返されます。</summary>
        <returns>
          <see langword="X509Certificate" /> オブジェクト、または <see langword="null" /> このモジュールが所属するアセンブリ Authenticode 署名されていない場合。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">検索対象の型の名前。 名前は、名前空間を使用して完全修飾する必要があります。</param>
        <summary>大文字小文字を区別する検索を実行して、指定された型を返します。</summary>
        <returns>指定した型がこのモジュールにある場合は、その型を表す <see langword="Type" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  種類は、別のアセンブリに転送されましたが場合、このメソッドからが返されます。 型の転送については、次を参照してください。[Type Forwarding in the Common Language Runtime](http://msdn.microsoft.com/ja-jp/51f8ffa3-c253-4201-a3d3-c4fad85ae097)です。  
  
 特定のモジュールを使用して、型を取得できる<xref:System.Reflection.Module.GetType%2A?displayProperty=fullName>です。 呼び出す<xref:System.Reflection.Module.GetType%2A?displayProperty=fullName>マニフェストが含まれているモジュールには検索されません全体のアセンブリ。 呼び出す必要がありますが、どのモジュールに関係なく、アセンブリから型を取得する<xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName>です。  
  
   
  
## 例  
 次の例では、指定したモジュールの種類の名前が表示されます。  
  
 [!code-cpp[System.Reflection.Module.GetType 1Arg Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 1Arg Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 1Arg Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラスの初期化子が呼び出され、例外がスローされます。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> は長さゼロの文字列です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="className" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="className" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 \-または\-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="className" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="className" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">検索対象の型の名前。 名前は、名前空間を使用して完全修飾する必要があります。</param>
        <param name="ignoreCase">大文字と小文字を区別しない検索では <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定された大文字と小文字の区別でモジュールを検索し、指定された型を返します。</summary>
        <returns>指定した型がこのモジュールにある場合は、その型を表す <see langword="Type" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  種類は、別のアセンブリに転送されましたが場合、このメソッドからが返されます。 型の転送については、次を参照してください。[Type Forwarding in the Common Language Runtime](http://msdn.microsoft.com/ja-jp/51f8ffa3-c253-4201-a3d3-c4fad85ae097)です。  
  
 特定のモジュールを使用して、型を取得できる<xref:System.Reflection.Module.GetType%2A?displayProperty=fullName>です。 呼び出す<xref:System.Reflection.Module.GetType%2A?displayProperty=fullName>マニフェストが含まれているモジュールには検索されません全体のアセンブリ。 呼び出す必要がありますが、どのモジュールに関係なく、アセンブリから型を取得する<xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName>です。  
  
   
  
## 例  
 次の例は、指定したモジュール、型の名前を表示を指定する`false`の`ignoreCase`パラメーターそのケースは無視しないようにします。  
  
 [!code-cpp[System.Reflection.Module.GetType 2Arg Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 2Arg Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 2Arg Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラスの初期化子が呼び出され、例外がスローされます。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> は長さゼロの文字列です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="className" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="className" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 \-または\-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="className" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="className" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">検索対象の型の名前。 名前は、名前空間に完全修飾する必要があります。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。</param>
        <param name="ignoreCase">
          <see langword="true" /> 小文字を区別しない検索です。それ以外の場合、 <see langword="false" />です。</param>
        <summary>モジュールの大文字と小文字を行うかどうかと、型が見つからない場合は、例外をスローするかどうかを指定する、指定された型を返します。</summary>
        <returns>A <see cref="T:System.Type" /> 型がこのモジュールで宣言されている以外の場合は、指定した型を表すオブジェクトを <see langword="null" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `throwOnError` パラメーターは、型が見つからないときの動作のみに影響します。 スローされる可能性のあるその他の例外には影響しません。 具体的には、種類が見つかっても読み込めない場合に <xref:System.TypeLoadException> スローできる場合でも `throwOnError` は `false`です。  
  
> [!NOTE]
>  場合は、型は、別のアセンブリに転送されましたが、このメソッドによっても返されます。 型の転送については、次を参照してください。 [Type Forwarding in the Common Language Runtime](http://msdn.microsoft.com/ja-jp/51f8ffa3-c253-4201-a3d3-c4fad85ae097)します。  
  
 使用して、特定のモジュールから型を取得できる <xref:System.Reflection.Module.GetType%2A?displayProperty=fullName>です。 呼び出す <xref:System.Reflection.Module.GetType%2A?displayProperty=fullName> 、マニフェストが含まれているモジュールには検索しませんアセンブリ全体です。 呼び出す必要がありますにあるかに関係なく、アセンブリから型を取得する <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName>です。  
  
   
  
## 例  
 次の例では、指定したモジュールの型の名前を表示します。`throwOnError` と `ignoreCase` としてパラメーターが指定されている `false`します。  
  
 [!code-cpp[System.Reflection.Module.GetType 3Arg Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 3Arg Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 3Arg Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外がスローされます。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> 長さ 0 の文字列です。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> であり、型が見つかりません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="className" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="className" /> には見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 \-または\-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="className" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> には依存アセンブリが必要ですが、このファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="className" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このモジュール内で定義されたすべての型を返します。</summary>
        <returns>このインスタンスがリフレクションされたモジュール内で定義された型を格納する <see langword="Type" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `ReflectionTypeLoadException`特別な読み込み例外が発生します。`ReflectionTypeLoadException.Types`プロパティには、読み込まれたモジュールで定義された型の配列が含まれています。 この配列は、null 値を含めることがあります。`ReflectionTypeLoadException.LoaderExceptions`プロパティを表すローダーによってスローされた例外の例外の配列です。 クラスの配列の穴は、例外を整列します。  
  
 たとえば、クラスのいずれかのクラスの初期化中に例外をスローした場合は、読み込み、`TargetInvocationException`の対応する要素に格納された、`LoaderExceptions`配列。  
  
> [!NOTE]
>  型は、別のアセンブリに転送されましたが場合、返される配列には含まれません。 型の転送については、次を参照してください。[Type Forwarding in the Common Language Runtime](http://msdn.microsoft.com/ja-jp/51f8ffa3-c253-4201-a3d3-c4fad85ae097)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">モジュールの 1 つまたは複数のクラスを読み込むことができませんでした。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Reflection permission for the current module.</permission>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">テストするためのカスタム属性の型。</param>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>このモジュールに指定された属性の型が適用されているかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> 場合は 1 つまたは複数のインスタンス <paramref name="attributeType" /> このモジュールに適用されている、それ以外の場合にされている <see langword="false" />します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、使用、 `IsDefined` メソッドです。  
  
 [!code-cpp[System.Reflection.Module.IsDefined Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsDefined Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsDefined Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> は、ランタイムによって提供された <see cref="T:System.Type" /> オブジェクトではありません。 たとえば、<paramref name="attributeType" /> は <see cref="T:System.Reflection.Emit.TypeBuilder" /> オブジェクトです。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public virtual bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オブジェクトがリソースであるかどうかを示す値を取得します。</summary>
        <returns>
          <see langword="true" /> オブジェクトがリソースである場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、使用、 `IsResource` メソッドです。  
  
 [!code-cpp[System.Reflection.Module.IsResource Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsResource Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsResource Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public virtual int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータのストリーム バージョンを取得します。</summary>
        <value>メタデータのストリーム バージョンを表す 32 ビット整数。 上位 2 バイトはメジャー バージョン番号を表し、下位 2 バイト マイナー バージョン番号を表します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  メタデータ ヘッダーの詳細については、共通言語基盤 \(CLI\) のドキュメントで"Partition II:: Metadata Definition and Semantics"を参照してください。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public virtual int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータ内のモジュールを識別するトークンを取得します。</summary>
        <value>メタデータ内の現在のモジュールを識別する整数トークンです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アンマネージ リフレクション API には、このプロパティを使用して取得したトークンを渡すことができます。 詳細については、次を参照してください。 [アンマネージ リフレクション API](http://msdn.microsoft.com/ja-jp/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)します。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 \(CLI\) ドキュメント、特に「Partition II:: メタデータ Definition and Semantics」に記載されています。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleHandle">
      <MemberSignature Language="C#" Value="public ModuleHandle ModuleHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ModuleHandle ModuleHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ModuleHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モジュールのハンドルを取得します。</summary>
        <value>A <see cref="T:System.ModuleHandle" /> 、現在のモジュールの構造体。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public virtual Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モジュールの 2 つのバージョンを区別するために使用できる汎用一意識別子 \(UUID\) を取得します。</summary>
        <value>モジュールの 2 つのバージョンを区別するために使用できる <see cref="T:System.Guid" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アンマネージ メタデータで GUID がによって返される、<xref:System.Reflection.Module.ModuleVersionId%2A>プロパティと呼びます、 `mvid`、され、GUID ヒープに格納されます。  
  
> [!NOTE]
>  メタデータの詳細については、共通言語基盤 \(CLI\) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。see [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得、 <see langword="String" /> パスでモジュールの名前を表すを削除します。</summary>
        <value>パスを指定せずにモジュール名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `Name` プラットフォームに依存する文字列です。  
  
 このモジュールのアセンブリがバイト配列から読み込まれたかどうか、 `FullyQualifiedName` モジュールが表示されます: \< 不明な \> です。  
  
 名前とパスを取得する <xref:System.Reflection.Module.FullyQualifiedName%2A>です。  
  
   
  
## 例  
 この例の効果を示しています、 `ScopeName`, 、`FullyQualifiedName`, 、および `Name` プロパティです。  
  
 [!code-cpp[Classic Module.Name Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.Name Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.Name Example/CS/source.cs#1)]
 [!code-vb[Classic Module.Name Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Reflection.Module" /> オブジェクトが等しいかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> に等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Reflection.Module" /> オブジェクトが等しくないかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> と等しくない場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo ResolveField (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内のフィールドを識別するメタデータ トークン。</param>
        <summary>指定したメタデータ トークンによって識別されるフィールドを返します。</summary>
        <returns>A <see cref="T:System.Reflection.FieldInfo" /> 指定したメタデータ トークンによって識別されるフィールドを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 親フィールドを識別するメタデータ トークンを解決するのには `TypeSpec` 要素の型を含む署名を持つ `ELEMENT_TYPE_VAR` または `ELEMENT_TYPE_MVAR`, を使用して、 <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> メソッド オーバー ロードを使用すると、必要なコンテキストを指定します。 つまり、ジェネリック型またはトークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーターに依存するフィールドのメタデータ トークンを解決する場合は、これらの型パラメーターを指定できるオーバー ロードを使用する必要があります。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 \(CLI\) ドキュメント、特に「Partition II:: メタデータ Definition and Semantics」に記載されています。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
 トークンの解像度を示すコードは汎用コンテキスト \(つまり、ジェネリック型またはトークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーター\) を使用して参照してください、 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内のフィールドのトークンではありません。  
  
 または  
  
 <paramref name="metadataToken" /> 親フィールドを識別する <see langword="TypeSpec" /> 要素の型を含む署名を持つ <see langword="var" /> \(ジェネリック型の型パラメーター\) または <see langword="mvar" /> \(ジェネリック メソッドの型パラメーター\)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内で有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内のフィールドを識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">配列 <see cref="T:System.Type" /> トークンが、スコープ内にある型のジェネリック型引数を表すオブジェクトまたは <see langword="null" /> 場合はその型がジェネリックではありません。</param>
        <param name="genericMethodArguments">配列 <see cref="T:System.Type" /> トークンが、スコープ内にあるメソッドのジェネリック型引数を表すオブジェクトまたは <see langword="null" /> 場合はそのメソッドがジェネリックではありません。</param>
        <summary>指定したジェネリック型パラメーターで定義されたコンテキスト内の指定したメタデータ トークンによって識別されるフィールドを返します。</summary>
        <returns>A <see cref="T:System.Reflection.FieldInfo" /> 指定したメタデータ トークンによって識別されるフィールドを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 [ResolveField メソッド \(Int32, Type\<xref:System.Type.GetGenericArguments%2A?displayProperty=fullName> 型のメソッド、 `metadataToken` のジェネリック型引数の配列を取得するスコープに `genericTypeArguments`します。 使用して、 [ResolveField メソッド \(Int32, Type\<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=fullName> メソッドのメソッド、 `metadataToken` のジェネリック型引数の配列を取得するスコープに `genericTypeArguments`します。 必要でない場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 \(CLI\) ドキュメント、特に「Partition II:: メタデータ Definition and Semantics」に記載されています。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
 トークンの解像度を示すコードは汎用コンテキスト \(つまり、ジェネリック型またはトークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーター\) を使用して参照してください、 [ResolveField メソッド \(Int32, Type\<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内のフィールドのトークンではありません。  
  
 または  
  
 <paramref name="metadataToken" /> 親フィールドを識別 <see langword="TypeSpec" /> 要素の型を含む署名を持つ <see langword="var" /> \(ジェネリック型の型パラメーター\) または <see langword="mvar" /> \(ジェネリック メソッドの型パラメーター\)、どちらか一方または両方のために必要なジェネリック型引数が指定されていませんし <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内で有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo ResolveMember (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">型またはモジュール内のメンバーを識別するメタデータ トークン。</param>
        <summary>指定したメタデータ トークンによって識別されるメンバーを返します。</summary>
        <returns>A <see cref="T:System.Reflection.MemberInfo" /> 型または指定したメタデータ トークンによって識別されるメンバーを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メタデータ トークンを解決するのには、 `MethodSpec` または `TypeSpec` 要素の型をシグネチャに含む `ELEMENT_TYPE_VAR` または `ELEMENT_TYPE_MVAR`, を使用して、 <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> メソッド オーバー ロードを使用すると、必要なコンテキストを指定します。 つまり、ジェネリック型またはトークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーターに依存しているメンバーのメタデータ トークンを解決する場合は、これらの型パラメーターを指定できるオーバー ロードを使用する必要があります。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 \(CLI\) ドキュメント、特に「Partition II:: メタデータ Definition and Semantics」に記載されています。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
 トークンの解像度を示すコードは汎用コンテキスト \(つまり、ジェネリック型またはトークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーター\) を使用して参照してください、 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 型または現在のモジュールのスコープ内のメンバーのトークンではありません。  
  
 または  
  
 <paramref name="metadataToken" /> <see langword="MethodSpec" /> または <see langword="TypeSpec" /> 要素の型をシグネチャに含む <see langword="var" /> \(ジェネリック型の型パラメーター\) または <see langword="mvar" /> \(ジェネリック メソッドの型パラメーター\)。  
  
 または  
  
 <paramref name="metadataToken" /> プロパティまたはイベントを識別します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内で有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">型またはモジュール内のメンバーを識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">配列 <see cref="T:System.Type" /> トークンが、スコープ内にある型のジェネリック型引数を表すオブジェクトまたは <see langword="null" /> 場合はその型がジェネリックではありません。</param>
        <param name="genericMethodArguments">配列 <see cref="T:System.Type" /> トークンが、スコープ内にあるメソッドのジェネリック型引数を表すオブジェクトまたは <see langword="null" /> 場合はそのメソッドがジェネリックではありません。</param>
        <summary>指定したジェネリック型パラメーターで定義されたコンテキスト内の指定したメタデータ トークンによって識別されるメンバーを返します。</summary>
        <returns>A <see cref="T:System.Reflection.MemberInfo" /> 型または指定したメタデータ トークンによって識別されるメンバーを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 [ResolveMember メソッド \(Int32, Type\<xref:System.Type.GetGenericArguments%2A?displayProperty=fullName> 型のメソッド、 `metadataToken` のジェネリック型引数の配列を取得するスコープに `genericTypeArguments`します。 使用して、 [ResolveMember メソッド \(Int32, Type\<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=fullName> メソッドのメソッド、 `metadataToken` のジェネリック型引数の配列を取得するスコープに `genericTypeArguments`します。 必要でない場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 \(CLI\) ドキュメント、特に「Partition II:: メタデータ Definition and Semantics」に記載されています。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
 トークンの解像度を示すコードは汎用コンテキスト \(つまり、ジェネリック型またはトークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーター\) を使用して参照してください、 [ResolveMember メソッド \(Int32, Type\<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 型または現在のモジュールのスコープ内のメンバーのトークンではありません。  
  
 または  
  
 <paramref name="metadataToken" /> <see langword="MethodSpec" /> または <see langword="TypeSpec" /> 要素の型をシグネチャに含む <see langword="var" /> \(ジェネリック型の型パラメーター\) または <see langword="mvar" /> \(ジェネリック メソッドの型パラメーター\)、どちらか一方または両方のために必要なジェネリック型引数が指定されていませんし <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" />です。  
  
 または  
  
 <paramref name="metadataToken" /> プロパティまたはイベントを識別します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内で有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase ResolveMethod (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">メソッドまたはコンス トラクターに、モジュールを識別するメタデータ トークン。</param>
        <summary>メソッドまたは指定したメタデータ トークンによって識別されるコンス トラクターを返します。</summary>
        <returns>A <see cref="T:System.Reflection.MethodBase" /> メソッドまたは指定したメタデータ トークンによって識別されるコンス トラクターを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メタデータ トークンを解決するのには、 `MethodSpec` 要素の型をシグネチャに含む `ELEMENT_TYPE_VAR` または `ELEMENT_TYPE_MVAR`, を使用して、 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> メソッド オーバー ロードを使用すると、必要なコンテキストを指定します。 つまり、ジェネリック型のジェネリック型パラメーターに依存するメソッドや、トークンが埋め込まれているジェネリック メソッドのメタデータ トークンを解決する場合は、これらの型パラメーターを指定できるオーバー ロードを使用する必要があります。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 \(CLI\) ドキュメント、特に「Partition II:: メタデータ Definition and Semantics」に記載されています。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
   
  
## 例  
 次の例の 2 つのオーバー ロードを使用する方法を示しています、 <xref:System.Reflection.Module.ResolveMethod%2A> メソッドの呼び出しからのメタデータ トークンを解決するのにはジェネリックと非ジェネリックのコンテキスト内のサイトです。  
  
 このコード例は、2 つのジェネリック型を定義 `G1<Tg1>` と `G2<Tg2>` \(`G1(Of Tg1)` と `G2(Of Tg2)` Visual Basic で\)、それぞれがジェネリック メソッドを持ちます。`G1<Tg1>` 型パラメーターを使用する非ジェネリック メソッドにも `Tg1` パラメーター。 ジェネリック メソッド `GM2<Tgm2>` 型 `G2<Tg2>` いくつかのメソッド呼び出しが含まれています。  
  
-   ケース 1: ジェネリック メソッド `GM1<Tgm1>` の型パラメーターを使用して、呼び出された `G2<Tg2>` と `GM2<Tgm2>` 型引数として。 呼び出されたメソッドのパラメーターの型はクローズ ジェネリック型の種類の定義からの構築に使用される型に依存する言い換えれば、 `G2<Tg2>`です。  
  
-   ケース 2: 非ジェネリック メソッド `M1` が呼び出されます。 このメソッドのパラメーターは、宣言型の型パラメーターを使用して `G1<Tg1>`, 、ここでは、外側の型の型パラメーターによって置き換えは `G2<Tg2>`です。  
  
-   ケース 3: ジェネリック メソッド `GM1<Tgm1>` と呼ばれる指定 <xref:System.Int32> と <xref:System.Object> ジェネリック型とジェネリック メソッドの型引数に対してそれぞれします。 このメソッドの呼び出しは、外側の型またはメソッドの型パラメーターには依存しません。  
  
-   ケース 4: 非ジェネリック メソッド `M1` の `Example` クラスが呼び出されます。 このメソッドの呼び出しは、外側の型またはメソッドの型パラメーターには依存しません。  
  
 また、非ジェネリックの定義例では、 `Example` クラスです。 このクラスにメソッド `M` ジェネリック メソッドの呼び出しを使用します。  
  
-   ケース 5: ジェネリック メソッド `GM1` が呼び出されると、指定する <xref:System.Int32> と <xref:System.Object> ジェネリック型とジェネリック メソッドの型引数のそれぞれします。 囲むこのメソッドのコンテキストを持たないジェネリック型またはジェネリック メソッドです。  
  
 各ケースの例では、まずを構築、 <xref:System.Reflection.MethodInfo> 、呼び出されたメソッドを表し、トークンを使用して、解決する、 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> メソッド オーバー ロードを使用して、 <xref:System.Type.GetGenericArguments%2A?displayProperty=fullName> と <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=fullName> の値を取得するメソッド、 `genericTypeArguments` と `genericMethodArguments` パラメーター。 メソッドを返すために、常に、この手法は <xref:System.Type.EmptyTypes?displayProperty=fullName> 非ジェネリックのコンテキストにします。 例では、比較は解決された <xref:System.Reflection.MethodInfo> で構築された <xref:System.Reflection.MethodInfo>します。  
  
 この例では使用を試みます、 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> トークンを解決するのには、メソッドのオーバー ロードします。 これにより、メソッドの呼び出しは、汎用のコンテキストに依存しないために、3、4、および 5 の場合は機能します。 1 と 2 の場合、トークンを解決するのには不十分な情報があるために、例外がスローされます。  
  
 メタデータ トークンの値は、列挙体としてハード コードされます。 このコード例を変更する場合、トークンの値を変更する可能性があります。 新しいトークンの値を確認するのには、コードをコンパイルし、Ildasm.exe を使用して、 **トークン\/** アセンブリを確認するにはオプションです。 トークンは、呼び出しの時点ではあります。 列挙体に新しい値を挿入し、例では、再コンパイルします。  
  
 [!code-csharp[Module.MethodResolve\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> メソッドまたはコンス トラクター、現在のモジュールのスコープ内のトークンではありません。  
  
 または  
  
 <paramref name="metadataToken" /> <see langword="MethodSpec" /> 要素の型をシグネチャに含む <see langword="var" /> \(ジェネリック型の型パラメーター\) または <see langword="mvar" /> \(ジェネリック メソッドの型パラメーター\)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内で有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">メソッドまたはコンス トラクターに、モジュールを識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">配列 <see cref="T:System.Type" /> トークンが、スコープ内にある型のジェネリック型引数を表すオブジェクトまたは <see langword="null" /> 場合はその型がジェネリックではありません。</param>
        <param name="genericMethodArguments">配列 <see cref="T:System.Type" /> トークンが、スコープ内にあるメソッドのジェネリック型引数を表すオブジェクトまたは <see langword="null" /> 場合はそのメソッドがジェネリックではありません。</param>
        <summary>メソッドまたは指定したジェネリック型パラメーターで定義されたコンテキスト内の指定したメタデータ トークンによって識別されるコンス トラクターを返します。</summary>
        <returns>A <see cref="T:System.Reflection.MethodBase" /> 指定したメタデータ トークンによって識別されるメソッドを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 [ResolveMethod メソッド \(Int32, Type\<xref:System.Type.GetGenericArguments%2A?displayProperty=fullName> 型のメソッド、 `metadataToken` のジェネリック型引数の配列を取得するスコープに `genericTypeArguments`します。 使用して、 [ResolveMethod メソッド \(Int32, Type\<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=fullName> メソッドのメソッド、 `metadataToken` のジェネリック型引数の配列を取得するスコープに `genericMethodArguments`します。 必要でない場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 \(CLI\) ドキュメント、特に「Partition II:: メタデータ Definition and Semantics」に記載されています。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
   
  
## 例  
 次の例の 2 つのオーバー ロードを使用する方法を示しています、 [ResolveMethod メソッド \(Int32, Type\<xref:System.Reflection.Module.ResolveMethod%2A> メソッドの呼び出しからのメタデータ トークンを解決するのにはジェネリックと非ジェネリックのコンテキスト内のサイトです。  
  
 このコード例は、2 つのジェネリック型を定義 `G1<Tg1>` と `G2<Tg2>`, 、それぞれがジェネリック メソッドを持ちます。`G1<Tg1>` 型パラメーターを使用する非ジェネリック メソッドにも `Tg1` パラメーター。 ジェネリック メソッド `GM2<Tgm2>` 型 `G2<Tg2>` いくつかのメソッド呼び出しが含まれています。  
  
-   ケース 1: ジェネリック メソッド `GM1<Tgm1>` の型パラメーターを使用して、呼び出された `G2<Tg2>` と `GM2<Tgm2>` 型引数として。 呼び出されたメソッドのパラメーターの型はクローズ ジェネリック型の種類の定義からの構築に使用される型に依存する言い換えれば、 `G2<Tg2>`です。  
  
-   ケース 2: 非ジェネリック メソッド `M1` が呼び出されます。 このメソッドのパラメーターは、宣言型の型パラメーターを使用して `G1<Tg1>`, 、ここでは、外側の型の型パラメーターによって置き換えは `G2<Tg2>`です。  
  
-   ケース 3: ジェネリック メソッド `GM1<Tgm1>` と呼ばれる指定 [ResolveMethod メソッド \(Int32, Type\<xref:System.Int32> と [ResolveMethod メソッド \(Int32, Type\<xref:System.Object> ジェネリック型とジェネリック メソッドの型引数に対してそれぞれします。 このメソッドの呼び出しは、外側の型またはメソッドの型パラメーターには依存しません。  
  
-   ケース 4: 非ジェネリック メソッド `M1` の `Example` クラスが呼び出されます。 このメソッドの呼び出しは、外側の型またはメソッドの型パラメーターには依存しません。  
  
 また、非ジェネリックの定義例では、 `Example` クラスです。 このクラスにメソッド `M` ジェネリック メソッドの呼び出しを使用します。  
  
-   ケース 5: ジェネリック メソッド `GM1<Tgm1>` が呼び出されると、指定する [ResolveMethod メソッド \(Int32, Type\<xref:System.Int32> と [ResolveMethod メソッド \(Int32, Type\<xref:System.Object> ジェネリック型とジェネリック メソッドの型引数のそれぞれします。 囲むこのメソッドのコンテキストを持たないジェネリック型またはジェネリック メソッドです。  
  
 各ケースの例では、まずを構築、 [ResolveMethod メソッド \(Int32, Type\<xref:System.Reflection.MethodInfo> 、呼び出されたメソッドを表し、トークンを使用して、解決する、 [ResolveMethod メソッド \(Int32, Type\<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> メソッド オーバー ロードを使用して、 [ResolveMethod メソッド \(Int32, Type\<xref:System.Type.GetGenericArguments%2A?displayProperty=fullName> と [ResolveMethod メソッド \(Int32, Type\<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=fullName> の値を取得するメソッド、 `genericTypeArguments` と `genericMethodArguments` パラメーター。 メソッドを返すために、常に、この手法は [ResolveMethod メソッド \(Int32, Type\<xref:System.Type.EmptyTypes?displayProperty=fullName> 非ジェネリックのコンテキストにします。 例では、比較は解決された [ResolveMethod メソッド \(Int32, Type\<xref:System.Reflection.MethodInfo> で構築された [ResolveMethod メソッド \(Int32, Type\<xref:System.Reflection.MethodInfo>します。  
  
 この例では使用を試みます、 [ResolveMethod メソッド \(Int32, Type\<xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> トークンを解決するのには、メソッドのオーバー ロードします。 これにより、メソッドの呼び出しは、汎用のコンテキストに依存しないために、3、4、および 5 の場合は機能します。 1 と 2 の場合、トークンを解決するのには不十分な情報があるために、例外がスローされます。  
  
 メタデータ トークンの値は、列挙体としてハード コードされます。 このコード例を変更する場合、トークンの値を変更する可能性があります。 新しいトークンの値を確認するのには、コードをコンパイルし、Ildasm.exe を使用して、 **トークン\/** アセンブリを確認するにはオプションです。 トークンは、呼び出しの時点ではあります。 列挙体に新しい値を挿入し、例では、再コンパイルします。  
  
 [!code-csharp[Module.MethodResolve\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> メソッドまたはコンス トラクター、現在のモジュールのスコープ内のトークンではありません。  
  
 または  
  
 <paramref name="metadataToken" /> <see langword="MethodSpec" /> 要素の型をシグネチャに含む <see langword="var" /> \(ジェネリック型の型パラメーター\) または <see langword="mvar" /> \(ジェネリック メソッドの型パラメーター\)、どちらか一方または両方のために必要なジェネリック型引数が指定されていませんし <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内で有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public virtual byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveSignature(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内のシグネチャを識別するメタデータ トークン。</param>
        <summary>メタデータ トークンによって識別されるシグネチャ blob を返します。</summary>
        <returns>シグネチャ blob を表すバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  共通言語基盤 \(CLI\) のドキュメントでは、特に"Partition II:: Metadata Definition and Semantics"メタデータ トークンと署名に関する情報が見つかります。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 有効ではありません <see langword="MemberRef" />, 、<see langword="MethodDef" />, 、<see langword="TypeSpec" />, 、署名、または <see langword="FieldDef" /> 、現在のモジュールのスコープ内でトークンです。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内で有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public virtual string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveString(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュールの文字列ヒープ内の文字列を識別するメタデータ トークン。</param>
        <summary>指定したメタデータ トークンによって識別される文字列を返します。</summary>
        <returns>A <see cref="T:System.String" /> メタデータ文字列ヒープから文字列値を格納します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 \(CLI\) ドキュメント、特に「Partition II:: メタデータ Definition and Semantics」に記載されています。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内で文字列をトークンではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内で有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public Type ResolveType (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type ResolveType(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内の型を識別するメタデータ トークン。</param>
        <summary>指定したメタデータ トークンによって識別される型を返します。</summary>
        <returns>A <see cref="T:System.Type" /> 指定したメタデータ トークンによって識別される型を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 メタデータ トークンを解決するのには、 `TypeSpec` シグネチャに含む `ELEMENT_TYPE_VAR` または `ELEMENT_TYPE_MVAR`, を使用して、 <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> メソッド オーバー ロードを使用すると、必要なコンテキストを指定します。 つまり、ジェネリック型またはトークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーターに依存する型のメタデータ トークンを解決する場合は、これらの型パラメーターを指定できるオーバー ロードを使用する必要があります。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 \(CLI\) ドキュメント、特に「Partition II:: メタデータ Definition and Semantics」に記載されています。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内の型のトークンではありません。  
  
 または  
  
 <paramref name="metadataToken" /> <see langword="TypeSpec" /> 要素の型をシグネチャに含む <see langword="var" /> \(ジェネリック型の型パラメーター\) または <see langword="mvar" /> \(ジェネリック メソッドの型パラメーター\)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内で有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public virtual Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内の型を識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">配列 <see cref="T:System.Type" /> トークンが、スコープ内にある型のジェネリック型引数を表すオブジェクトまたは <see langword="null" /> 場合はその型がジェネリックではありません。</param>
        <param name="genericMethodArguments">配列 <see cref="T:System.Type" /> トークンが、スコープ内にあるメソッドのジェネリック型引数を表すオブジェクトまたは <see langword="null" /> 場合はそのメソッドがジェネリックではありません。</param>
        <summary>指定したジェネリック型パラメーターで定義されたコンテキスト内の指定したメタデータ トークンによって識別される型を返します。</summary>
        <returns>A <see cref="T:System.Type" /> 指定したメタデータ トークンによって識別される型を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 [ResolveType メソッド \(Int32, Type\<xref:System.Type.GetGenericArguments%2A?displayProperty=fullName> 型のメソッド、 `metadataToken` のジェネリック型引数の配列を取得するスコープに `genericTypeArguments`します。 使用して、 [ResolveType メソッド \(Int32, Type\<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=fullName> メソッドのメソッド、 `metadataToken` のジェネリック型引数の配列を取得するスコープに `genericTypeArguments`します。 必要でない場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 \(CLI\) ドキュメント、特に「Partition II:: メタデータ Definition and Semantics」に記載されています。 このドキュメントはオンラインです。参照してください [ECMA C\# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) msdn および [Standard ECMA\-335 \- Common Language Infrastructure \(CLI\)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトにします。  
  
 トークンの解像度を示すコードは汎用コンテキスト \(つまり、ジェネリック型またはトークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーター\) を使用して参照してください、 [ResolveType メソッド \(Int32, Type\<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内の型のトークンではありません。  
  
 または  
  
 <paramref name="metadataToken" /> <see langword="TypeSpec" /> 要素の型をシグネチャに含む <see langword="var" /> \(ジェネリック型の型パラメーター\) または <see langword="mvar" /> \(ジェネリック メソッドの型パラメーター\)、どちらか一方または両方のために必要なジェネリック型引数が指定されていませんし <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> 現在のモジュールのスコープ内で有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public virtual string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モジュールの名前を表す文字列を取得します。</summary>
        <value>モジュール名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `ScopeName`プロパティは、共通言語ランタイムでは使用されませんが、これを使用して、メタデータ Api を使用してモジュールを生成するときに、プロパティで使用文字列を格納することができます。 リフレクション自身設定はできません、`ScopeName`プロパティです。  
  
   
  
## 例  
 この例の効果を示しています、 `ScopeName`、 `FullyQualifiedName`、および`Name`プロパティです。  
  
 [!code-cpp[Classic Module.ScopeName Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.ScopeName Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CS/source.cs#1)]
 [!code-vb[Classic Module.ScopeName Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Module.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元割り当て済み配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetIDsOfNames`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfo`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 \(0 または 1\) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfoCount`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.Invoke">
      <MemberSignature Language="C#" Value="void _Module.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::Invoke`, 、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>モジュールの名前を返します。</summary>
        <returns>A <see langword="String" /> このモジュールの名前を表します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、使用、 `ToString` メソッドです。  
  
 [!code-cpp[System.Reflection.Module.ToString Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.ToString Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.ToString Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>モジュールで定義されたグローバル フィールドを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された型を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>カスタム属性を返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ResolveMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メタデータ トークンによって識別されるメンバーを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ResolveMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メタデータ トークンによって識別されるメソッドを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ResolveField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メタデータ トークンによって識別されるフィールドを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した条件を持つメソッドを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このモジュールで定義されているグローバル メソッドを返します</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したフィールドを返します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ResolveType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メタデータ トークンによって識別される型を返します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>