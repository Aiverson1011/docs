<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>再利用でき、バージョン管理可能で自己記述型の共通言語ランタイム アプリケーションのビルド ブロックであるアセンブリを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 Use the <xref:System.Reflection.Assembly> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.  
  
 To get an array of <xref:System.Reflection.Assembly> objects representing the assemblies currently loaded into an application domain \(for example, the default application domain of a simple project\), use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=fullName> method.  
  
 To load assemblies dynamically, the <xref:System.Reflection.Assembly> class provides the following static methods \(**languageKeyword tag is not supported!!!!**  
 methods in Visual Basic\). Assemblies are loaded into the application domain where the load operation occurs.  
  
-   The recommended way to load assemblies is to use the <xref:System.AppDomain.Load%2A> method, which identifies the assembly to be loaded by its display name \(for example, "System.Windows.Forms, Version\=2.0.0.0, Culture\=neutral, PublicKeyToken\=b77a5c561934e089"\). The search for the assembly follows the rules described in [How the Runtime Locates Assemblies](http://msdn.microsoft.com/ja-jp/772ac6f4-64d2-4cfb-92fd-58096dcd6c34).  
  
-   The <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods enable you to load an assembly for reflection, but not for execution. For example, an assembly that targets a 64\-bit platform can be examined by code that is running on a 32\-bit platform.  
  
-   The <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A> methods are provided for rare scenarios in which an assembly must be identified by path.  
  
 To get an <xref:System.Reflection.Assembly> object for the currently executing assembly, use the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method.  
  
 Many members of the <xref:System.Reflection.Assembly> class provide information about an assembly. For example:  
  
-   The <xref:System.Reflection.Assembly.GetName%2A> method returns an <xref:System.Reflection.AssemblyName> object that provides access to the parts of the assembly display name.  
  
-   The <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method lists the attributes applied to the assembly.  
  
-   The <xref:System.Reflection.Assembly.GetFiles%2A> method provides access to the files in the assembly manifest.  
  
-   The <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> method provides the names of the resources in the assembly manifest.  
  
 The <xref:System.Reflection.Assembly.GetTypes%2A> method lists all the types in the assembly. The <xref:System.Reflection.Assembly.GetExportedTypes%2A> method lists the types that are visible to callers outside the assembly. The <xref:System.Reflection.Assembly.GetType%2A> method can be used to search for a particular type in the assembly. The <xref:System.Reflection.Assembly.CreateInstance%2A> method can be used to search for and create instances of types in the assembly.  
  
 For more information on assemblies, see the "Application Domains and Assemblies" section in the [Application Domains](http://msdn.microsoft.com/ja-jp/113a8bbf-6875-4a72-a49d-ca2d92e19cc8) topic.  
  
   
  
## 例  
 The following code example shows how to obtain the currently executing assembly, create an instance of a type contained in that assembly, and invoke one of the type's methods with late binding. For this purpose, the code example defines a class named `Example`, with a method named `SampleMethod`. The constructor of the class accepts an integer, which is used to compute the return value of the method.  
  
 The code example also demonstrates the use of the <xref:System.Reflection.Assembly.GetName%2A> method to obtain an <xref:System.Reflection.AssemblyName> object that can be used to parse the full name of the assembly. The example displays the version number of the assembly, the <xref:System.Reflection.Assembly.CodeBase%2A> property, and the <xref:System.Reflection.Assembly.EntryPoint%2A> property.  
  
 [!code-cpp[AssemblyClass\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">for full trust for inheritors. This class cannot be inherited by partially trusted code.</permission>
    <threadsafe>This type is thread safe.</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Reflection.Assembly" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターは、構築する際に派生クラスによって呼び出される <xref:System.Reflection.Assembly> オブジェクトです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>たとえば <see cref="T:System.Reflection.AssemblyName" /> オブジェクトで、初めに指定されたアセンブリの場所を取得します。</summary>
        <value>初めに指定されたとおりのアセンブリの場所。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マニフェストを格納している読み込み済みファイルへの絶対パスを取得する、<xref:System.Reflection.Assembly.Location%2A?displayProperty=fullName>プロパティ代わりにします。  
  
 アセンブリがバイト配列として読み込まれた場合のオーバー ロードを使用して、<xref:System.Reflection.Assembly.Load%2A>バイトの配列を受け取るメソッドでは、このプロパティは、読み込まれたアセンブリの場所ではなく、メソッドの呼び出し元の場所を返します。  
  
   
  
## 例  
 次の例では、<xref:System.Reflection.Assembly.CodeBase%2A>プロパティです。  
  
 [!code-cpp[System.Reflection.Assembly\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">検索対象の型の <see cref="P:System.Type.FullName" />。</param>
        <summary>大文字小文字を区別する検索を使用してこのアセンブリから指定された型を検索し、システム アクティベーターを使用してこの型のインスタンスを作成します。</summary>
        <returns>既定のコンストラクターを使用して作成された指定した型のインスタンス。<see langword="null" /> が見つからない場合は、<paramref name="typeName" />。 型は、既定のバインダーを使用して解決されます。カルチャまたはアクティベーション属性は指定せず、<see cref="T:System.Reflection.BindingFlags" /> を <see langword="Public" /> または <see langword="Instance" /> に設定します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ランタイムが検索できる場合`typeName`での<xref:System.Reflection.Assembly>を返しますのインスタンス`null`例外をスローする代わりにします。 これは、ために発生する可能性があります。  
  
-   型の完全修飾名を指定していません。  
  
-   完全修飾型名を指定したが、その場合は型のケースと一致しません<xref:System.Type.FullName%2A?displayProperty=fullName>プロパティです。 大文字と小文字の`typeName`型の完全名では、コール、<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>オーバー ロードして、指定`true`の`ignoreCase`引数。  
  
-   現在の型が存在しない<xref:System.Reflection.Assembly>インスタンス。  
  
   
  
## 例  
 次の例では定義、`Person`クラスとの呼び出し、<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>それをインスタンス化するメソッド。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> は空の文字列 \(""\) または null 文字で始まる文字列です。  
  
 \-または\-  
  
 現在のアセンブリは、リフレクションのみのコンテキストに読み込まれました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターは見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 \-または\-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="typeName" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="typeName" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">検索対象の型の <see cref="P:System.Type.FullName" />。</param>
        <param name="ignoreCase">型名の大文字と小文字の違いを無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>オプションの大文字小文字を区別する検索を使用してこのアセンブリから指定された型を検索し、システム アクティベーターを使用してこの型のインスタンスを作成します。</summary>
        <returns>既定のコンストラクターを使用して作成された指定した型のインスタンス。<paramref name="typeName" /> が見つからない場合は、<see langword="null" />。 型は、既定のバインダーを使用して解決されます。カルチャまたはアクティベーション属性は指定せず、<see cref="T:System.Reflection.BindingFlags" /> を <see langword="Public" /> または <see langword="Instance" /> に設定します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ランタイムが検索できる場合`typeName`で、<xref:System.Reflection.Assembly>インスタンスを返します`null`例外をスローする代わりにします。 これは、ために発生する可能性があります。  
  
-   型の完全修飾名を指定していません。  
  
-   現在の型が存在しない<xref:System.Reflection.Assembly>インスタンス。  
  
   
  
## 例  
 次の例では定義、`Person`クラスです。 呼び出して、 <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> 、それをインスタンス化するメソッドがの大文字と小文字、`typeName`引数と一致していない型の<xref:System.Type.FullName%2A>プロパティ、メソッドを返します`null`です。 同じ文字列を渡すとき、<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>をオーバー ロードし、比較は区別されず、する必要がありますを指定します、`Person`クラスが見つかると、および`Person`オブジェクトが正常にインスタンス化します。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> は空の文字列 \(""\) または null 文字で始まる文字列です。  
  
 \-または\-  
  
 現在のアセンブリは、リフレクションのみのコンテキストに読み込まれました。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> に必要な依存アセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 \-または\-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="typeName" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="typeName" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">検索対象の型の <see cref="P:System.Type.FullName" />。</param>
        <param name="ignoreCase">型名の大文字と小文字の違いを無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="bindingAttr">検索の実行方法に影響を与えるビットマスク。 値は、<see cref="T:System.Reflection.BindingFlags" /> のビット フラグの組み合わせです。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションによる <see langword="MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。<c>binder</c> が <see langword="null" /> の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡す引数を格納する配列。 この引数の配列は、呼び出すコンストラクターのパラメーターと、数、順序、および型が同じでなければなりません。 既定のコンストラクターを使用する場合は、<c>args</c> を空の配列または <see langword="null" /> にする必要があります。</param>
        <param name="culture">型の強制変換を制御するために使用する <see langword="CultureInfo" /> のインスタンス。<see langword="null" /> の場合は、現在のスレッドの <see langword="CultureInfo" /> が使用されます。 \(これは、たとえば、1000 を表す <see langword="String" /> を <see langword="Double" /> 値に変換する場合に必要です。これは、カルチャによって 1000 の表記が異なるためです。\)</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation \(WCF\) を使用する必要があります。</param>
        <summary>オプションの大文字小文字を区別する検索を使用して、このアセンブリから指定された型を検索し、システム アクティベーターを使用してこの型のインスタンスを作成し、指定されたカルチャ設定、引数、バインディング属性、およびアクティベーション属性を設定します。</summary>
        <returns>指定した型のインスタンス。<paramref name="typeName" /> が見つからない場合は、<see langword="null" />。 指定された引数は、型を解決するため、およびインスタンスの作成に使用されるコンストラクターをバインドするために使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> は空の文字列 \(""\) または null 文字で始まる文字列です。  
  
 \-または\-  
  
 現在のアセンブリは、リフレクションのみのコンテキストに読み込まれました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.NotSupportedException">空でないアクティベーション属性の配列は、<see cref="T:System.MarshalByRefObject" /> から継承されていない型に渡されます。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> には見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 \-または\-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="typeName" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 \-または\-  
  
 <paramref name="typeName" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to create an instance of a delegate. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。</param>
        <param name="typeName">型の完全名。</param>
        <summary>アセンブリの表示名で修飾された型名を作成します。</summary>
        <returns>アセンブリの表示名で修飾された型の完全名。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返される文字列の形式です。  
  
 \<FullTypeName\>,\<AssemblyDisplayName\>\<\/AssemblyDisplayName\>\<\/FullTypeName\>  
  
 参照してください<xref:System.Reflection.AssemblyName>アセンブリの表示名の形式の詳細についてはします。  
  
 共通言語ランタイムのバージョンの変更に合わせて、修飾名を構築するのではなく、このメソッドを使用します。  アセンブリの修飾名については、次を参照してください。<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=fullName>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリのカスタム属性を含むコレクションを取得します。</summary>
        <value>このアセンブリのカスタム属性を含むコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリで定義されている型のコレクションを取得します。</summary>
        <value>このアセンブリで定義されている型のコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Reflection.Assembly.DefinedTypes%2A> property is comparable to the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName> method, except that the <xref:System.Reflection.Assembly.DefinedTypes%2A> property returns a [collection](http://msdn.microsoft.com/ja-jp/8ff54f66-a56b-4c31-8a93-99e9774ea98e) of <xref:System.Reflection.TypeInfo> objects, and the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName> method returns an array of <xref:System.Type> objects.  
  
 The returned array includes nested types.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリのエントリ ポイントを取得します。</summary>
        <value>このアセンブリのエントリ ポイントを表すオブジェクト。 エントリ ポイントが見つからない場合 \(アセンブリが DLL の場合など\) は、<see langword="null" /> が返されます。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">このインスタンスと比較するオブジェクト。</param>
        <summary>このアセンブリと指定したオブジェクトが等しいかどうかを判断します。</summary>
        <returns>
          <see langword="true" /> がこのインスタンスと等しい場合は <paramref name="o" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Reflection.Assembly.Equals%2A> method performs a test for reference equality to determine whether the current instance and **parameterReference tag is not supported!!!!**  
 are equal.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードベースを表す URI を、エスケープ文字も含めて取得します。</summary>
        <value>エスケープ文字を含んだ URI。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリの証拠を取得します。</summary>
        <value>このアセンブリの証拠。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの外側で参照できる、このアセンブリ内で定義されているパブリック型のコレクションを取得します。</summary>
        <value>アセンブリの外側で参照できる、このアセンブリ内で定義されているパブリック型のコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの表示名を取得します。</summary>
        <value>アセンブリの表示名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 参照してください <xref:System.Reflection.AssemblyName> アセンブリの表示名の形式の詳細についてです。  
  
> [!NOTE]
>  表示名を解析するコードを作成することは推奨されません。 代わりに、表示名を渡す、 <xref:System.Reflection.AssemblyName.%23ctor%2A> に解析し、新しいの適切なフィールドを設定するコンス トラクター <xref:System.Reflection.AssemblyName>します。  
  
 .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id が追加され、アセンブリ名の文字列の一部として指定できます。 ただし、いないに含まれているによって返される文字列、 <xref:System.Reflection.Assembly.FullName%2A> 互換性のためのプロパティです。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>」を参照してください。  
  
   
  
## 例  
 次の例は、実行中のアセンブリの表示名とを含むアセンブリの表示名、 <xref:System.Int32> 型 \(`int` 、C\# の場合は、 `Integer` Visual Basic で\)。  
  
 [!code-cpp[Assembly.FullName\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">返されるアセンブリの型を表すオブジェクト。</param>
        <summary>指定した型が定義されている、現在読み込まれているアセンブリを取得します。</summary>
        <returns>指定した型が定義されているアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値を取得するには、このメソッドを呼び出す、  <xref:System.Type.Assembly?displayProperty=fullName> プロパティです。 ただし、 <xref:System.Type.Assembly?displayProperty=fullName> プロパティが通常よりも優れたパフォーマンスを提供します。  
  
 このメソッドを呼び出すために必要な <xref:System.Type> オブジェクトで、クラスが定義されているアセンブリが読み込む既に必要があることを意味します。  
  
   
  
## 例  
 次の例を含むアセンブリの取得、 <xref:System.Int32> を入力し、その名前とファイルの場所が表示されます。  
  
 [!code-cpp[System.Reflection.Assembly\#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在実行中のメソッドを呼び出したメソッドの <see cref="T:System.Reflection.Assembly" /> を返します。</summary>
        <returns>現在実行中のメソッドを呼び出したメソッドの <see langword="Assembly" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 かどうか、メソッドを呼び出し、 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> メソッドは、・ イン タイム \(JIT\) コンパイラによってインラインで展開されるか、呼び出し元がインライン展開の場合は、アセンブリであるによって返される <xref:System.Reflection.Assembly.GetCallingAssembly%2A>が予期せずに異なる場合があります。 たとえば、次のメソッドおよびアセンブリがあるとします。  
  
-   メソッド `M1` アセンブリに `A1` 呼び出し <xref:System.Reflection.Assembly.GetCallingAssembly%2A>します。  
  
-   メソッド `M2` アセンブリに `A2` 呼び出し `M1`します。  
  
-   メソッド `M3` アセンブリに `A3` 呼び出し `M2`します。  
  
 `M1` がインライン関数では、 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 返します `A2`します。 ときに `M1` インライン化は <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 返します `A3`します。 同様に、 `M2` がインライン関数では、 <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 返します `A2`します。 ときに `M2` インライン化は <xref:System.Reflection.Assembly.GetCallingAssembly%2A> 返します `A3`します。  
  
 この効果にも発生時に `M1` から末尾呼び出しとして実行します。 `M2`, 、または `M2` から末尾呼び出しとして実行します。 `M3`します。 JIT コンパイラでれるを防ぐことができますインライン展開メソッドを呼び出す <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, 、適用することで、 <xref:System.Runtime.CompilerServices.MethodImplAttribute> 属性を <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=fullName> フラグは、末尾呼び出しを防止するための同様のメカニズムはありません。  
  
   
  
## 例  
 次の例では、現在のメソッドの呼び出し元のアセンブリを取得します。  
  
 [!code-cpp[System.Reflection.Assembly\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <see cref="T:System.Reflection.Assembly" /> 型のオブジェクトでは、この引数は無視されます。</param>
        <summary>このアセンブリのすべてのカスタム属性を取得します。</summary>
        <returns>このアセンブリのカスタム属性を格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、対応する <xref:System.Reflection.ICustomAttributeProvider> インターフェイス メソッドです。 したがって、 `inherit` は無視されますが、パラメーターを指定する必要があります。  
  
 擬似属性では、属性が存在する場合に設定する必要があるコア メタデータのビットを示します。 型のメタデータを拡張し、種類と共に保存するカスタム属性、擬似属性型のメタデータの変更し、異なり、破棄されます。 一部の結果のビットは、既存のリフレクション Api を使用してアクセスできません。  
  
 次の表は、擬似属性およびアクセサーをリフレクションで使用可能なビットをまとめたものです。  
  
|擬似属性|メタデータのビット|リフレクションのアクセサー|  
|----------|---------------|-------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL 名|アクセサーはありません PInvokeMap に対する通常メソッド\/グローバル メソッドの属性について。<br /><br /> DLL 名のアクセサーはありません。|  
|GuidAttribute|実際のカスタム属性として格納されます。|実際のカスタム属性としてアクセスされます。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags\(\)<br /><br /> ConstructorInfo.GetMethodImplementationFlags\(\)|  
|MarshalAsAttribute|さまざまな部分です。|アクセサーはありません。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags\(\) します。OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags\(\) します。OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> クラスのパッキングします。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> アクセサーはありません。|  
|FieldOffsetAttribute|フィールドのオフセット。|アクセサーはありません。|  
|AssemblyLoadAttribute|CorAssemblyFlags|アクセサーがないか、列挙子。|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">カスタム属性を返す対象の型。</param>
        <param name="inherit">
          <see cref="T:System.Reflection.Assembly" /> 型のオブジェクトでは、この引数は無視されます。</param>
        <summary>型を指定して、このアセンブリのカスタム属性を取得します。</summary>
        <returns>このアセンブリの、<paramref name="attributeType" /> で指定されたカスタム属性を格納している配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、対応する <xref:System.Reflection.ICustomAttributeProvider> インターフェイス メソッドです。 したがって、 `inherit` は無視されますが、パラメーターを指定する必要があります。  
  
 擬似属性では、属性が存在する場合に設定する必要があるコア メタデータのビットを示します。 型のメタデータを拡張し、種類と共に保存するカスタム属性、擬似属性型のメタデータの変更し、異なり、破棄されます。 一部の結果のビットは、既存のリフレクション Api を使用してアクセスできません。  
  
 次の表は、擬似属性およびアクセサーをリフレクションで使用可能なビットをまとめたものです。  
  
|擬似属性|メタデータのビット|リフレクションのアクセサー|  
|----------|---------------|-------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL 名|アクセサーはありません PInvokeMap に対する通常メソッド\/グローバル メソッドの属性について。<br /><br /> DLL 名のアクセサーはありません。|  
|GuidAttribute|実際のカスタム属性として格納されます。|実際のカスタム属性としてアクセスされます。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags\(\)<br /><br /> ConstructorInfo.GetMethodImplementationFlags\(\)|  
|MarshalAsAttribute|さまざまな部分です。|アクセサーはありません。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags\(\) します。OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags\(\) します。OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> クラスのパッキングします。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> アクセサーはありません。|  
|FieldOffsetAttribute|フィールドのオフセット。|アクセサーはありません。|  
|AssemblyLoadAttribute|CorAssemblyFlags|アクセサーがないか、列挙子。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> はランタイム型ではありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.Assembly" /> に適用されている属性に関する情報を、<see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトとして返します。</summary>
        <returns>現在のアセンブリに適用されている属性に関するデータを表す <see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトのジェネリック リスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 カスタム属性自体のリフレクション専用コンテキストに読み込まれるコードが定義されている場合、リフレクションのみのコンテキスト内のコードのカスタム属性を調べるには、このメソッドを使用します。 メソッドなどの <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=fullName> と <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=fullName> 属性のインスタンスを作成するため、このような場合では使用できません。 リフレクションのみのコンテキストでコードを実行できません。 詳細については、たとえばコードを参照してください、 <xref:System.Reflection.CustomAttributeData> クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定のアプリケーション ドメインで実行できるプロセスを取得します。 他のアプリケーション ドメインでは、<see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> で実行された最初の実行可能ファイルです。</summary>
        <returns>既定のアプリケーション ドメインで実行できるプロセスであるアセンブリ。または、<see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> で実行された最初の実行可能ファイル。 アンマネージ コードから呼び出された場合は、<see langword="null" /> を返すことができます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method can return **languageKeyword tag is not supported!!!!**  
 when a managed assembly has been loaded from an unmanaged application. For example, if an unmanaged application creates an instance of a COM component written in C\#, a call to the <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method from the C\# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在実行中のコードを格納しているアセンブリを取得します。</summary>
        <returns>現在実行中のコードを格納しているアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 パフォーマンス上の理由は不明なデザイン時にどのようなアセンブリが現在実行されている場合にのみ、このメソッドを呼び出す必要があります。 取得することをお勧め、 <xref:System.Reflection.Assembly> を現在のアセンブリを表すオブジェクトは、使用する、 <xref:System.Type.Assembly%2A?displayProperty=fullName> 型のプロパティは、次の例に示すように、アセンブリで見つかった。  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 現在実行中のコードと呼ばれるメソッドを含むアセンブリを取得する <xref:System.Reflection.Assembly.GetCallingAssembly%2A>です。  
  
   
  
## 例  
 次の例で、 <xref:System.Type.Assembly%2A?displayProperty=fullName> 実行中のアセンブリを取得するプロパティは、そのアセンブリに含まれる型に基づいています。 呼び出しも、 <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> が返されることを表示するメソッド、 <xref:System.Reflection.Assembly> を同じアセンブリを表すオブジェクト。  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly\#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリの外側で参照できる、このアセンブリ内で定義されているパブリック型を取得します。</summary>
        <returns>アセンブリの外部で参照できる、このアセンブリ内で定義されている型を表す配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリ外部から参照できる専用の型は、パブリック型と他のパブリック型の中で入れ子になったパブリック型です。  
  
   
  
## 例  
 次のコード サンプルに多数のさまざまなアクセス レベル、および呼び出しとクラスを定義する<xref:System.Reflection.Assembly.GetExportedTypes%2A>をアセンブリの外側から表示されているものを表示します。  
  
 [!code-cpp[Assembly.GetExportedTypes\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このアセンブリは、動的アセンブリです。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">指定されたファイルの名前。 ファイルへのパスを含めないでください。</param>
        <summary>このアセンブリのマニフェストのファイル テーブル内の指定されたファイルの <see cref="T:System.IO.FileStream" /> を取得します。</summary>
        <returns>指定したファイルを格納するストリーム。ファイルが見つからない場合は、<see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、両方のパブリックおよびプライベートのリソース ファイルで機能します。  
  
 `name`ファイルへのパスを含める必要はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> パラメーターが空の文字列 \(""\) になっています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> が見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> は有効なアセンブリ名ではありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path and for reading the specified file. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリ マニフェストのファイル テーブルのファイルを取得します。</summary>
        <returns>ファイルを格納するストリームの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、パブリックとプライベートのリソース ファイルで機能します。  
  
 このオーバー ロードを呼び出すことは、 <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> オーバー ロードを指定して `false`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">ファイルが有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース モジュールを含めるかどうかを指定して、アセンブリ マニフェストのファイル テーブルのファイルを取得します。</summary>
        <returns>ファイルを格納するストリームの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、パブリックとプライベートのリソース ファイルで機能します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">ファイルが有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリの一部であるすべての読み込み済みモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース モジュールを含めるかどうかを指定して、このアセンブリの一部であるすべての読み込み済みモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">大文字と小文字が区別されるリソースの名前。</param>
        <summary>指定されたリソースが永続化された方法に関する情報を返します。</summary>
        <returns>リソースのトポロジに関する情報が設定されたオブジェクト。リソースが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 リソースが、呼び出し元に表示されるか、呼び出し元が場合にのみ、リソース情報が返される <xref:System.Security.Permissions.ReflectionPermission>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> パラメーターが空の文字列 \(""\) です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリのすべてのリソースの名前を返します。</summary>
        <returns>すべてのリソースの名前を格納している配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 次のように、このメソッドによって返される配列では、各リソース名を使用できます。  
  
-   リソース名を渡すことができます、 <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> リソースに関する追加情報を取得します。  
  
-   名前は、バイナリ .resources ファイルを識別する場合は、その .resources ファイルの拡張子を削除およびに渡すこと、 <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=fullName> リソース マネージャーのインスタンスを作成するコンス トラクターです。  
  
-   リソース名を渡すことができます、 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> を取得するメソッド、 <xref:System.IO.Stream> に渡すことができますし、オブジェクト、 <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=fullName> コンス トラクターです。  
  
-   リソース名を渡すことができます、 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> を取得するメソッド、 <xref:System.IO.Stream> に渡すことができますし、オブジェクト、 <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=fullName> コンス トラクターです。  
  
 リソースが、呼び出し元に表示されるか、呼び出し元が場合にのみ、リソース情報が返される <xref:System.Security.Permissions.ReflectionPermission>です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求されているマニフェスト リソースの、大文字と小文字が区別される名前。</param>
        <summary>このアセンブリから、指定されたマニフェスト リソースを読み込みます。</summary>
        <returns>マニフェスト リソース。コンパイル時にリソースが指定されない場合や、リソースが呼び出し元から参照できない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A manifest resource is a resource \(such as an image file\) that is embedded in the assembly at compile time. For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](http://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.  
  
 Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  This method returns **languageKeyword tag is not supported!!!!**  
>  if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=fullName> flag.  
  
 If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time. If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> パラメーターが空の文字列 \(""\) です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">  
<para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または [ポータブル クラス ライブラリ](http://msdn.microsoft.com/ja-jp/c31e1663-c164-4e65-b66d-d3aa8750a154)では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>  
</block>  
  
 検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> が見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> は有効なアセンブリではありません。</exception>
        <exception cref="T:System.NotImplementedException">リソースの長さが <see cref="F:System.Int64.MaxValue" /> を超えています</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">マニフェスト リソース名のスコープを指定するために名前空間を使用する型。</param>
        <param name="name">要求されているマニフェスト リソースの、大文字と小文字が区別される名前。</param>
        <summary>このアセンブリから、指定された型の名前空間によってスコープが指定されている、指定されたマニフェスト リソースを読み込みます。</summary>
        <returns>マニフェスト リソース。コンパイル時にリソースが指定されない場合や、リソースが呼び出し元から参照できない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 完全な名前が指定されている場合など `type` "MyNameSpace.MyClasses"と `name` "MyNameSpace.Net"という名前のリソースを検索、オーバー ロードは、"Net"、このメソッドです。  
  
 マニフェスト リソースは、コンパイル時にアセンブリに埋め込まれているリソース \(画像ファイルなど\) です。 マニフェスト リソースの詳細については、次を参照してください。 [Microsoft .NET Framework Resource Basics](http://go.microsoft.com/fwlink/?LinkId=204554) 、MSDN ライブラリです。  
  
 リソースが、呼び出し元に表示されるか、呼び出し元が場合にのみ、リソース情報が返される <xref:System.Security.Permissions.ReflectionPermission>です。  
  
> [!NOTE]
>  このメソッドが戻る `null` 別のアセンブリのプライベートなリソースがアクセスすると、呼び出し元になくて <xref:System.Security.Permissions.ReflectionPermission> で、 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=fullName> フラグ。  
  
 アセンブリ マニフェストには、リソース ファイルが表示されている場合 <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> 返します、 <xref:System.IO.Stream> オブジェクトの場合でも、リソース ファイルは、時間ディスクで検出されたことはできません。 リソース ファイルが見つからない場合、その結果を渡して <xref:System.IO.Stream> オブジェクトを <xref:System.Resources.ResourceReader> コンス トラクターにより、 <xref:System.ArgumentException>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> パラメーターが空の文字列 \(""\) です。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> が見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> は有効なアセンブリではありません。</exception>
        <exception cref="T:System.NotImplementedException">リソースの長さが <see cref="F:System.Int64.MaxValue" /> を超えています</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late\-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求するモジュールの名前。</param>
        <summary>このアセンブリから指定されたモジュールを取得します。</summary>
        <returns>要求されたモジュール。モジュールが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、ファイル名で機能します。  
  
 内のクラス、 `Reflection.Emit` 名前空間は、動的モジュールのスコープ名を出力します。 スコープ名はによって判別できます、 <xref:System.Reflection.Module.ScopeName%2A?displayProperty=fullName> プロパティです。 モジュールの種類を渡す `Assembly.GetModule`します。 たとえば、アセンブリ マニフェストを含むモジュールを実行する場合に、モジュールのスコープ名を渡す `GetModule`します。 それ以外の場合、モジュールのファイル名を渡します。 1 つによって読み込まれるアセンブリ、 `Load` byte\[\] パラメーターを持つメソッドを 1 つだけのモジュールがあるし、は、です。 スコープ名を使用してこれらのモジュールが常にシークします。  
  
 使用して、特定のモジュールから型を取得できる <xref:System.Reflection.Module.GetType%2A?displayProperty=fullName>です。 呼び出す `Module.GetType` モジュールのマニフェストを含むは開始されませんアセンブリ全体を検索します。 呼び出す必要がありますにあるかに関係なく、アセンブリから型を取得する <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> パラメーターが空の文字列 \(""\) です。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> が見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> は有効なアセンブリ名ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリの一部であるすべてのモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、パブリックとプライベートのリソース ファイルで機能します。  
  
> [!NOTE]
>  ファイル名拡張子では、モジュールを生成する必要があります。  
  
   
  
## 例  
 次の例では、アセンブリ マニフェストを含む、返される配列のモジュールの名前を表示します。  
  
 [!code-cpp[Classic Assembly.GetModules Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">読み込まれるモジュールは、ファイル名拡張子を指定しません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース モジュールを含めるかどうかを指定して、このアセンブリの一部であるすべてのモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、パブリックとプライベートのリソース ファイルで機能します。  
  
> [!NOTE]
>  ファイル名拡張子では、モジュールを生成する必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリの <see cref="T:System.Reflection.AssemblyName" /> を取得します。</summary>
        <returns>このアセンブリのすべて解析された表示名を格納するオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path of the assembly. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">シャドウ コピーの後で <see langword="true" /> をアセンブリの場所に設定する場合は <see cref="P:System.Reflection.Assembly.CodeBase" />。<see langword="false" /> を元の場所に設定する場合は <see cref="P:System.Reflection.Assembly.CodeBase" />。</param>
        <summary>このアセンブリの <see cref="T:System.Reflection.AssemblyName" /> を取得し、<paramref name="copiedName" /> の指定に従ってコードベースを設定します。</summary>
        <returns>このアセンブリのすべて解析された表示名を格納するオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path of the assembly. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">シリアル化情報が設定されるオブジェクト。</param>
        <param name="context">シリアル化の対象コンテキスト。</param>
        <summary>シリアル化情報と、このアセンブリの再インスタンス化に必要なすべてのデータを取得します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリが参照するすべてのアセンブリの <see cref="T:System.Reflection.AssemblyName" /> オブジェクトを取得します。</summary>
        <returns>このアセンブリが参照するすべてのアセンブリのすべて解析された表示名を格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>のプロパティ、<xref:System.Reflection.AssemblyName>このメソッドによって返されるオブジェクトは<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=fullName>参照されたアセンブリ用のハッシュ アルゴリズムが存在しない場合、またはによって参照されたアセンブリのハッシュ アルゴリズムが識別されない場合、<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=fullName>列挙します。 .NET Framework の以前のバージョンで、<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>プロパティによって返される<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=fullName>このような場合です。  
  
   
  
## 例  
 次のコード例を呼び出すことを示しています、<xref:System.Reflection.Assembly.GetReferencedAssemblies%2A>メソッドです。 このコード例に示されている例の一部である、<xref:System.Reflection.Assembly>クラスです。  
  
 [!code-cpp[Reflection\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">指定されたカルチャ。</param>
        <summary>指定されたカルチャ設定のサテライト アセンブリを取得します。</summary>
        <returns>指定されたサテライト アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サテライト アセンブリには、ローカライズできない実行可能コードと、既定またはニュートラル カルチャとして機能する単一カルチャ用のリソースが含まれているアプリケーションのメイン アセンブリをローカライズされたリソースが含まれています。  
  
 現在のアセンブリ バージョンを使用するには、このメソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">アセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">ファイル名が一致するサテライト アセンブリが見つかりましたが、<see langword="CultureInfo" /> は指定されているファイル名とは一致しませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">サテライト アセンブリは、有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">指定されたカルチャ。</param>
        <param name="version">サテライト アセンブリのバージョン。</param>
        <summary>指定されたバージョンの、指定されたカルチャ設定のサテライト アセンブリを取得します。</summary>
        <returns>指定されたサテライト アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 サテライト アセンブリには、ローカライズできない実行可能コードと、既定またはニュートラル カルチャとして機能する単一カルチャ用のリソースが含まれているアプリケーションのメイン アセンブリをローカライズされたリソースが含まれています。  
  
 呼び出す、 <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> の現在のアセンブリ バージョンを使用するオーバー ロードします。  
  
 場合 `version` は `null`, 、リソースとメインのアセンブリの両方が署名されている場合、現在のアセンブリ バージョンを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileLoadException">ファイル名が一致するサテライト アセンブリが見つかりましたが、<see langword="CultureInfo" /> またはバージョンが指定されているファイルとは一致しませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">アセンブリが見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">サテライト アセンブリは、有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">型の完全な名前。</param>
        <summary>指定した名前の <see cref="T:System.Type" /> オブジェクトを、アセンブリ インスタンスから取得します。</summary>
        <returns>指定したクラスを表すオブジェクト。クラスが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method only searches the current assembly instance. The **parameterReference tag is not supported!!!!**  
 parameter includes the namespace but not the assembly. To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=fullName> method overload, which can optionally include an assembly display name as part of the type name.  
  
> [!NOTE]
>  If the type has been forwarded to another assembly, it is still returned by this method. For information on type forwarding, see [Type Forwarding in the Common Language Runtime](http://msdn.microsoft.com/ja-jp/51f8ffa3-c253-4201-a3d3-c4fad85ae097).  
  
   
  
## 例  
 The following example defines an abstract `MeansOfTransportation` class in the `Transportation` namespace. It calls the <xref:System.Reflection.Assembly.GetType%28System.String%29> method to retrieve its <xref:System.Type> object, calls the <xref:System.Type.GetProperties%2A?displayProperty=fullName> method to get an array of <xref:System.Reflection.PropertyInfo> objects that represent the type's properties, and then displays information on the type's abstract properties. Note that the call to the <xref:System.Reflection.Assembly.GetType%28System.String%29> method uses the type's fully qualified name \(that is, its namespace along with its type name\).  
  
 [!code-csharp[System.Reflection.Assembly.GetType\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が正しくありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> には見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">  
<para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または [ポータブル クラス ライブラリ](http://msdn.microsoft.com/ja-jp/c31e1663-c164-4e65-b66d-d3aa8750a154)では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>  
</block>  
  
 <paramref name="name" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 \-または\-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="name" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="name" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">型の完全な名前。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="null" /> を返す場合は <see langword="false" />。</param>
        <summary>指定した名前の <see cref="T:System.Type" /> オブジェクトをアセンブリ インスタンスから取得し、型が見つからない場合は、オプションで例外をスローします。</summary>
        <returns>指定されているクラスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、現在のアセンブリのインスタンスのみを検索します。`name`名前空間はアセンブリではなく、パラメーターが含まれます。 その他のアセンブリで型を検索するを使用して、<xref:System.Type.GetType%28System.String%29?displayProperty=fullName>メソッド オーバー ロードをオプションでアセンブリの表示名を型名の一部として含めることができます。  
  
> [!NOTE]
>  種類は、別のアセンブリに転送されましたが場合、このメソッドからが返されます。 型の転送については、次を参照してください。[Type Forwarding in the Common Language Runtime](http://msdn.microsoft.com/ja-jp/51f8ffa3-c253-4201-a3d3-c4fad85ae097)です。  
  
 `throwOnError`パラメーター型が見つからない場合にのみ影響します。 スローされる可能性がありますのあるその他の例外には影響しません。 特に、種類が見つかりましたが読み込まれなかったため場合、<xref:System.TypeLoadException>スローできる場合でも`throwOnError`は`false`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が正しくありません。  
  
 または  
  
 <paramref name="name" /> の長さが 1024 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> であり、型が見つかりません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 \-または\-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="name" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="name" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">型の完全な名前。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="null" /> を返す場合は <see langword="false" />。</param>
        <param name="ignoreCase">型名の大文字と小文字の違いを無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した名前の <see cref="T:System.Type" /> オブジェクトをアセンブリ インスタンスから取得します。オプションで、大文字と小文字の区別を無視したり、型が見つからない場合は例外をスローしたりできます。</summary>
        <returns>指定されているクラスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、現在のアセンブリのインスタンスのみを検索します。`name` 名前空間、アセンブリではなく、パラメーターが含まれます。 その他のアセンブリで型を検索するを使用して、 <xref:System.Type.GetType%28System.String%29?displayProperty=fullName> メソッド オーバー ロードを型名の一部としてアセンブリの表示名をオプションで含めることができます。  
  
> [!NOTE]
>  場合は、型は、別のアセンブリに転送されましたが、このメソッドによっても返されます。 型の転送については、次を参照してください。 [Type Forwarding in the Common Language Runtime](http://msdn.microsoft.com/ja-jp/51f8ffa3-c253-4201-a3d3-c4fad85ae097)します。  
  
 `throwOnError` パラメーター型が見つからない場合にのみ影響します。 スローされる可能性のあるその他の例外には影響しません。 具体的には、種類が見つかっても読み込めない場合に <xref:System.TypeLoadException> スローできる場合でも `throwOnError` は `false`です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が正しくありません。  
  
 または  
  
 <paramref name="name" /> の長さが 1024 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> であり、型が見つかりません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> には見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 \-または\-  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="name" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> には依存アセンブリが必要ですが、このファイルは有効なアセンブリではありません。  
  
 または  
  
 <paramref name="name" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリで定義されている型を取得します。</summary>
        <returns>このアセンブリで定義されているすべての型を格納している配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返される配列には、入れ子にされた型が含まれています。  
  
 場合、<xref:System.Reflection.Assembly.GetTypes%2A>であるアセンブリが読み込まれていない \(たとえば、2 番目のアセンブリ内の型から派生\) 場合、アセンブリ内の型に依存するアセンブリと型のメソッドが呼び出されます、<xref:System.Reflection.ReflectionTypeLoadException>がスローされます。 たとえば、最初のアセンブリに読み込まれた場合に発生、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>または<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッド、および 2 番目のアセンブリが読み込まれませんでした。 でも発生します。 を使用して読み込まれたアセンブリに、<xref:System.Reflection.Assembly.Load%2A>と<xref:System.Reflection.Assembly.LoadFile%2A>メソッドの場合は、2 番目のアセンブリが見つからない場合に、<xref:System.Reflection.Assembly.GetTypes%2A>メソッドが呼び出されます。  
  
> [!NOTE]
>  型は、別のアセンブリに転送されましたが場合、返される配列には含まれません。 型の転送については、次を参照してください。[Type Forwarding in the Common Language Runtime](http://msdn.microsoft.com/ja-jp/51f8ffa3-c253-4201-a3d3-c4fad85ae097)です。  
  
 コレクションを取得する<xref:System.Reflection.TypeInfo>オブジェクトの配列ではなく<xref:System.Type>、オブジェクトを使用して、<xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=fullName>プロパティです。  
  
   
  
## 例  
 次の例では、指定されたアセンブリで型の 1 つのメソッドのパラメーターが表示されます。  
  
 [!code-cpp[System.Reflection.Assembly\#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">アセンブリには、読み込むことができない 1 つ以上の型が含まれています。 この例外の <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> プロパティによって返される配列には、読み込まれた各型の <see cref="T:System.Type" /> オブジェクト、および読み込むことができなかった各型の <see langword="null" /> が含まれています。<see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> プロパティには、読み込むことができなかった各型の例外が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリがグローバル アセンブリ キャッシュから読み込まれたかどうかを示す値を取得します。</summary>
        <value>アセンブリがグローバル アセンブリ キャッシュから読み込まれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの読み込みに使用したホスト コンテキストを取得します。</summary>
        <value>アセンブリの読み込みに使用したホスト コンテキストがある場合は、そのホスト コンテキストを示す <see cref="T:System.Int64" /> 値。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マニフェストを格納しているファイルに保存された共通言語ランタイム \(CLR: common language runtime\) のバージョンを表す文字列を取得します。</summary>
        <value>CLR バージョン フォルダー名。 これは完全パスではありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 たとえば、v1.1.4322、.NET Framework version 1.1 の値になります。 そのバージョンのバイナリ ファイルは、パス %windir%\\microsoft.net\\framework\\v1.1.4322 に配置するとします。  
  
 既定では、<xref:System.Reflection.Assembly.ImageRuntimeVersion%2A>アセンブリのビルドに使用されている CLR のバージョンに設定されています。 ただし、その可能性がありますは設定されて別の値をコンパイル時に。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">このアセンブリでチェックする属性の型。</param>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>指定した属性がアセンブリに適用されているかどうかを示します。</summary>
        <returns>属性がアセンブリに適用されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次のコード例に適用される、 <xref:System.Reflection.AssemblyTitleAttribute> アセンブリとし、使用する属性 <xref:System.Reflection.Assembly.IsDefined%2A> が適用されたかどうかを示すためにします。 また、属性が適用されていないことをテストします。  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> に無効な型が使用されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリが、現在のプロセスでリフレクション出力を使用して動的に生成されたかどうかを示す値を取得します。</summary>
        <value>現在のアセンブリが現在のプロセスで動的に生成された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 動的アセンブリが、派生クラスによって表される <xref:System.Reflection.Emit.AssemblyBuilder>です。  
  
 動的アセンブリがディスクに保存されたアセンブリに保存された場合に動的ではありません。 保存されたアセンブリが別のアプリケーション ドメインまたはプロセスに読み込まれた場合、 <xref:System.Reflection.Assembly.IsDynamic%2A> プロパティを返します。 `false`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリが完全信頼で読み込まれたかどうかを示す値を取得します。</summary>
        <value>現在のアセンブリが完全信頼で読み込まれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <summary>生成されたアセンブリを含む COFF \(Common Object File Format\) ベースのイメージを使用して、アセンブリを読み込みます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して読み込まれるアセンブリの信頼レベルは、呼び出し元のアセンブリの信頼レベルと同じです。 アプリケーション ドメインの信頼レベルでのバイト配列からアセンブリを読み込むにを使用して、 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> メソッドのオーバー ロードします。 証拠のオーバー ロードでの使用に関する詳細について、 <xref:System.Reflection.Assembly.Load%2A> をバイト配列を受け取るメソッドを参照してください、 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> メソッドのオーバー ロードします。  
  
 発生する C\+\+ 実行可能ファイルへのリフレクション、 <xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C\+\+ コンパイラが再配置アドレスまたは `.reloc` 、実行可能ファイルからセクションです。 保持するために、 `.reloc` C\+\+ 実行可能ファイルのアドレスを指定 `/fixed:no` リンクしています。  
  
 このメソッドのオーバー ロード常に作成する新しい <xref:System.Reflection.Assembly> に独自のマッピングを持つオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="rawAssembly" /> は、より新しいバージョンでコンパイルされています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">読み込むアセンブリを記述するオブジェクト。</param>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> を指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token. The loader does not continue probing for other assemblies that match the simple name.  
  
> [!NOTE]
>  Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set. The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity \(such as name or version\), so loading does not occur according to load\-by\-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method. Instead, the assembly is loaded using load\-from rules. For information about the disadvantages of using the load\-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method overload or [Best Practices for Assembly Loading](http://msdn.microsoft.com/ja-jp/68d1c539-6a47-4614-ab59-4b071c9d4b4c).  
  
 Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows:  
  
-   When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.  
  
-   When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.  
  
-   When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a **languageKeyword tag is not supported!!!!**  
     parameter to load a common object file format \(COFF\) image, evidence is inherited from the calling assembly. This applies to the .NET Framework version 1.1 Service Pack 1 \(SP1\) and subsequent releases.  
  
    > [!NOTE]
    >  In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a **languageKeyword tag is not supported!!!!**  
    >  parameter to load a COFF image, evidence is combined. **languageKeyword tag is not supported!!!!**  
    > , **languageKeyword tag is not supported!!!!**  
    >  and **languageKeyword tag is not supported!!!!**  
    >  are inherited from the calling assembly, and **languageKeyword tag is not supported!!!!**  
    >  and **languageKeyword tag is not supported!!!!**  
    >  are taken from the COFF assembly.  
  
-   When you use a <xref:System.Reflection.Assembly.Load%2A> method with a **languageKeyword tag is not supported!!!!**  
     parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used. Evidence of the calling assembly and evidence of the COFF image is ignored.  
  
 Reflecting on C\+\+ executable files might throw a <xref:System.BadImageFormatException>. This is most likely caused by the C\+\+ compiler stripping the relocation addresses or the **languageKeyword tag is not supported!!!!**  
 section from your executable file. To preserve the **languageKeyword tag is not supported!!!!**  
 address for your C\+\+ executable file, specify **languageKeyword tag is not supported!!!!**  
 when you are linking.  
  
> [!NOTE]
>  If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName> property are set, the first attempt to load the assembly uses the display name \(including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> property\). If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly. If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly. If the match fails, a <xref:System.IO.FileLoadException> is thrown.  
  
   
  
## 例  
 The following example instantiates an <xref:System.Reflection.AssemblyName> object and uses it to load the **languageKeyword tag is not supported!!!!**  
 assembly. The example then displays the full name of the assembly's public types.  
  
 [!code-csharp[System.Reflection.Assembly.Load\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">  
<para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または [ポータブル クラス ライブラリ](http://msdn.microsoft.com/ja-jp/c31e1663-c164-4e65-b66d-d3aa8750a154)では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>  
</block>  
  
 検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> は有効なアセンブリ名ではありません。 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。また <paramref name="assemblyRef" /> は新しいバージョンでコンパイル済みです。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">長い形式のアセンブリ名。</param>
        <summary>長い形式の名前を指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 長い形式のアセンブリ名は、単純な名前 \("System"System.dll アセンブリの\) など、バージョン、カルチャ、公開キー トークン、および必要に応じて、プロセッサ アーキテクチャとで構成されます。 対応するアセンブリの <xref:System.Reflection.Assembly.FullName%2A> プロパティです。 次の例では、.NET Framework 4 向け System.dll アセンブリの読み込みに長い名前の使用を示します。  
  
 [!code-csharp[System.Reflection.Assembly.Load\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> 場合にスローされる `assemblyString` 完全なアセンブリ名と単純な名前に一致する最初のアセンブリが別のバージョン、カルチャ、または公開キー トークンを指定します。 ローダーは、単純な名前と一致している他のアセンブリのプローブを続行できません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリおよびセキュリティの証拠のマージの規則は次のとおりです。  
  
-   使用すると、 <xref:System.Reflection.Assembly.Load%2A> なしでメソッド <xref:System.Security.Policy.Evidence> パラメーター、アセンブリの証拠をローダーが提供する読み込みします。  
  
-   使用すると、 <xref:System.Reflection.Assembly.Load%2A> メソッドを <xref:System.Security.Policy.Evidence> パラメーターの証拠がマージされます。 引数として指定された証拠の部分、 <xref:System.Reflection.Assembly.Load%2A> メソッドがの証拠をローダーによって提供されるよりも優先されます。  
  
-   使用すると、 <xref:System.Reflection.Assembly.Load%2A> メソッドのオーバー ロードで、 `Byte[]` イメージを読み込むため、一般的なオブジェクト ファイル形式 \(COFF\)、証拠パラメーターは、呼び出し元のアセンブリから継承します。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 \(SP1\) およびそれ以降のリリースです。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 および version 1.1 を使用する場合は SP1 がない場合、 <xref:System.Reflection.Assembly.Load%2A> メソッドのオーバー ロードで、 `Byte[]` COFF イメージ、証拠を読み込むためのパラメーターの組み合わせ。`Zone`, 、`Url` と `Site` は呼び出し元のアセンブリから継承し、 `Hash` と `StrongName` COFF アセンブリから取得されます。  
  
-   使用すると、 <xref:System.Reflection.Assembly.Load%2A> メソッドを `Byte[]` パラメーターと <xref:System.Security.Policy.Evidence> 、指定された証拠のみが使用される COFF 画像を読み込めません。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 発生する C\+\+ 実行可能ファイルへのリフレクション、 <xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C\+\+ コンパイラが再配置アドレスまたは `.reloc` 、実行可能ファイルからセクションです。 保持するために、 `.reloc` C\+\+ 実行可能ファイルのアドレスを指定 `/fixed:no` リンクしています。  
  
 .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id が追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture \= msil"です。 ただし、アセンブリ名を指定することをお勧めは作成には、 <xref:System.Reflection.AssemblyName> オブジェクトし、の適切なオーバー ロードに渡す、 <xref:System.Reflection.Assembly.Load%2A> メソッドです。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>」を参照してください。  
  
   
  
## 例  
 次の例では、完全修飾名を指定してアセンブリを読み込み、指定したアセンブリに含まれているすべての種類を一覧表示します。 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 アセンブリの完全修飾名を取得する方法については、次を参照してください。 [&#91;\<topic:\/\/cpconassemblynames\>&#93;](http://msdn.microsoft.com/ja-jp/8f8c2c90-f15d-400e-87e7-a757e4f04d0e)します。  
  
 [!code-cpp[assembly.load1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> は長さゼロの文字列です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyString" /> は、より新しいバージョンでコンパイルされています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納するバイト配列。</param>
        <summary>生成されたアセンブリが含まれている COFF \(Common Object File Format\) ベースのイメージを使用して、このアセンブリを読み込みます。アセンブリのシンボルを含めることもできます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して読み込まれるアセンブリの信頼レベルは、呼び出し元のアセンブリの信頼レベルと同じです。 アプリケーション ドメインの信頼レベルでのバイト配列からアセンブリを読み込むにを使用して、 [Load メソッド \(Byte\<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> メソッドのオーバー ロードします。 証拠のオーバー ロードでの使用に関する詳細について、 [Load メソッド \(Byte\<xref:System.Reflection.Assembly.Load%2A> をバイト配列を受け取るメソッドを参照してください、 [Load メソッド \(Byte\<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> メソッドのオーバー ロードします。  
  
 発生する C\+\+ 実行可能ファイルへのリフレクション、 [Load メソッド \(Byte\<xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C\+\+ コンパイラが再配置アドレスまたは `.reloc` 、実行可能ファイルからセクションです。 保持するために、 `.reloc` C\+\+ 実行可能ファイルのアドレスを指定 `/fixed:no` リンクしています。  
  
 このメソッドのオーバー ロード常に作成する新しい [Load メソッド \(Byte\<xref:System.Reflection.Assembly> に独自のマッピングを持つオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="rawAssembly" /> は、より新しいバージョンでコンパイルされています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">読み込むアセンブリを記述するオブジェクト。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> を指定してアセンブリを読み込みます。 アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.IO.FileLoadException>場合にスローされる`assemblyRef`完全アセンブリ名、および単純な名前に一致する最初のアセンブリが別のバージョン、カルチャ、または公開キー トークンを指定します。 ローダーでは、簡易名に一致する他のアセンブリのプローブは続行されません。  
  
> [!NOTE]
>  使用しないで、<xref:System.Reflection.AssemblyName>のみを持つ、<xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティ セットです。<xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティがすべての要素を指定しないアセンブリの id \(名前、バージョンなど\) のための読み込みは発生しません \- id によって負荷の規則に従ってから想定されるよう、<xref:System.Reflection.Assembly.Load%2A>メソッドです。 代わりに、アセンブリでは、読み込み元の規則を使用してが読み込まれます。 読み込み元コンテキストを使用して、短所については、次を参照してください。、<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName>メソッドのオーバー ロードまたは[Best Practices for Assembly Loading](http://msdn.microsoft.com/ja-jp/68d1c539-6a47-4614-ab59-4b071c9d4b4c)です。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージ セキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>のないメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリはローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.Load%2A>メソッドの置き換えの証拠をローダーによって指定します。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドのオーバー ロードで、`Byte[]`イメージを読み込む一般的なオブジェクト ファイル形式 \(COFF\)、証拠パラメーターは、呼び出し元のアセンブリから継承します。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 \(SP1\) と今後のリリースです。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 および 1.1 を使用するときに SP1 がない場合で、<xref:System.Reflection.Assembly.Load%2A>メソッドのオーバー ロードで、 `Byte[]` COFF イメージ、証拠を読み込むためのパラメーターを組み合わせて使用します。`Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承し、`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみを使用します。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 C\+\+ 実行可能ファイルへのリフレクションをスローする可能性、<xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C\+\+ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクションです。 保持する場合、 `.reloc` C\+\+ 実行可能ファイルのアドレスを指定`/fixed:no`リンクしています。  
  
> [!NOTE]
>  両方の<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>プロパティおよび<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>プロパティが設定されて、アセンブリを読み込むには、最初の試行は、表示名を使用 \(によって返されるバージョン、カルチャ、およびなどを含む、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>プロパティ\)。 ファイルが見つからない場合<xref:System.Reflection.AssemblyName.CodeBase%2A>アセンブリの検索に使用します。 使用して、アセンブリが見つかった場合<xref:System.Reflection.AssemblyName.CodeBase%2A>表示名は、アセンブリと照合します。 一致が見つからない場合、<xref:System.IO.FileLoadException>がスローされます。  
  
 呼び出す場合は、<xref:System.Reflection.Assembly.Load%2A>メソッドの 1 回、同じアセンブリには、異なる証拠を指定した共通言語ランタイムではスローされませんよりも多く、<xref:System.IO.FileLoadException>の異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> が有効なアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyRef" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">アセンブリの表示名。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>表示名を指定してアセンブリを読み込みます。アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.IO.FileLoadException> 場合にスローされる `assemblyString` 完全なアセンブリ名と単純な名前に一致する最初のアセンブリが別のバージョン、カルチャ、または公開キー トークンを指定します。 ローダーは、単純な名前と一致している他のアセンブリのプローブを続行できません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリおよびセキュリティの証拠のマージの規則は次のとおりです。  
  
-   使用すると、 <xref:System.Reflection.Assembly.Load%2A> なしでメソッド <xref:System.Security.Policy.Evidence> パラメーター、アセンブリの証拠をローダーが提供する読み込みします。  
  
-   使用すると、 <xref:System.Reflection.Assembly.Load%2A> メソッドを <xref:System.Security.Policy.Evidence> パラメーターの証拠がマージされます。 引数として指定された証拠の部分、 <xref:System.Reflection.Assembly.Load%2A> メソッドがの証拠をローダーによって提供されるよりも優先されます。  
  
-   使用すると、 <xref:System.Reflection.Assembly.Load%2A> メソッドのオーバー ロードで、 `Byte[]` イメージを読み込むため、一般的なオブジェクト ファイル形式 \(COFF\)、証拠パラメーターは、呼び出し元のアセンブリから継承します。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 \(SP1\) およびそれ以降のリリースです。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 および version 1.1 を使用する場合は SP1 がない場合、 <xref:System.Reflection.Assembly.Load%2A> メソッドのオーバー ロードで、 `Byte[]` COFF イメージ、証拠を読み込むためのパラメーターの組み合わせ。`Zone`, 、`Url` と `Site` は呼び出し元のアセンブリから継承し、 `Hash` と `StrongName` COFF アセンブリから取得されます。  
  
-   使用すると、 <xref:System.Reflection.Assembly.Load%2A> メソッドを `Byte[]` パラメーターと <xref:System.Security.Policy.Evidence> 、指定された証拠のみが使用される COFF 画像を読み込めません。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 発生する C\+\+ 実行可能ファイルへのリフレクション、 <xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C\+\+ コンパイラが再配置アドレスまたは `.reloc` 、実行可能ファイルからセクションです。 保持するために、 `.reloc` C\+\+ 実行可能ファイルのアドレスを指定 `/fixed:no` リンクしています。  
  
 共通言語ランタイムをスローしない場合は、同じアセンブリには、異なる証拠を指定に、このメソッドを複数回呼び出す、 <xref:System.IO.FileLoadException> 異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
 .NET Framework version 2.0 では、プロセッサのアーキテクチャは、アセンブリ id が追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture \= msil"です。 ただし、アセンブリ名を指定することをお勧めは作成には、 <xref:System.Reflection.AssemblyName> オブジェクトし、の適切なオーバー ロードに渡す、 <xref:System.Reflection.Assembly.Load%2A> メソッドです。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyString" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。  
  
 または  
  
 アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納するバイト配列。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>生成されたアセンブリが含まれている COFF ベースのイメージを使用して、このアセンブリを読み込みます。アセンブリのシンボルと証拠を含めることもできます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。 アセンブリのシンボルを表す生バイトも読み込まれます。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリおよびセキュリティの証拠のマージの規則は次のとおりです。  
  
-   使用すると、 [Load メソッド \(Byte\[\], Byte\<xref:System.Reflection.Assembly.Load%2A> なしでメソッド [Load メソッド \(Byte\[\], Byte\<xref:System.Security.Policy.Evidence> パラメーター、アセンブリの証拠をローダーが提供する読み込みします。  
  
-   使用すると、 [Load メソッド \(Byte\[\], Byte\<xref:System.Reflection.Assembly.Load%2A> メソッドを [Load メソッド \(Byte\[\], Byte\<xref:System.Security.Policy.Evidence> パラメーターの証拠がマージされます。 引数として指定された証拠の部分、 [Load メソッド \(Byte\[\], Byte\<xref:System.Reflection.Assembly.Load%2A> メソッドがの証拠をローダーによって提供されるよりも優先されます。  
  
-   使用すると、 [Load メソッド \(Byte\[\], Byte\<xref:System.Reflection.Assembly.Load%2A> メソッドのオーバー ロードで、 `Byte[]` COFF イメージ、証拠を読み込むためのパラメーターは、呼び出し元のアセンブリから継承します。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 \(SP1\) およびそれ以降のリリースです。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 および version 1.1 を使用する場合は SP1 がない場合、 [Load メソッド \(Byte\[\], Byte\<xref:System.Reflection.Assembly.Load%2A> メソッドのオーバー ロードで、 `Byte[]` COFF イメージ、証拠を読み込むためのパラメーターの組み合わせ。`Zone`, 、`Url` と `Site` は呼び出し元のアセンブリから継承し、 `Hash` と `StrongName` COFF アセンブリから取得されます。  
  
-   使用すると、 [Load メソッド \(Byte\[\], Byte\<xref:System.Reflection.Assembly.Load%2A> メソッドを `Byte[]` パラメーターと [Load メソッド \(Byte\[\], Byte\<xref:System.Security.Policy.Evidence> 、指定された証拠のみが使用される COFF 画像を読み込めません。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 発生する C\+\+ 実行可能ファイルへのリフレクション、 [Load メソッド \(Byte\[\], Byte\<xref:System.BadImageFormatException>です。 最も可能性の高い原因は、C\+\+ コンパイラが再配置アドレスまたは `.reloc` 、実行可能ファイルからセクションです。 保持するために、 `.reloc` C\+\+ 実行可能ファイルのアドレスを指定 `/fixed:no` リンクしています。  
  
 呼び出した場合、 [Load メソッド \(Byte\[\], Byte\<xref:System.Reflection.Assembly.Load%2A>1 回、同じアセンブリには、異なる証拠を指定した共通言語ランタイムをスローしないより多くのメソッド、 [Load メソッド \(Byte\[\], Byte\<xref:System.IO.FileLoadException> 異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
 このメソッドのオーバー ロード常に作成する新しい [Load メソッド \(Byte\[\], Byte\<xref:System.Reflection.Assembly> に独自のマッピングを持つオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="rawAssembly" /> 以降のバージョンでコンパイルされました。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> が <see langword="null" /> ではありません。  既定では、従来の CAS ポリシーは .NET Framework 4 で有効ではありません。有効でない場合、<paramref name="securityEvidence" /> は <see langword="null" /> である必要があります。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to supply evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納するバイト配列。</param>
        <param name="securityContextSource">セキュリティ コンテキストのソース。</param>
        <summary>生成されたアセンブリが含まれている COFF ベースのイメージを使用して、このアセンブリを読み込みます。シンボルを含めることも、セキュリティ コンテキストのソースを指定することもできます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリは、セキュリティ コンテキストの指定したソースを使用して、呼び出し元のアプリケーション ドメインに読み込まれます。 場合`rawSymbolStore`が指定されているアセンブリのシンボルを表す生バイトも読み込まれます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="rawAssembly" /> がコンパイルされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="securityContextSource" /> の値は、列挙値の 1 つではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">読み込むファイルの完全修飾パス。</param>
        <summary>指定したパスのアセンブリ ファイルの内容を読み込みます。</summary>
        <returns>読み込まれるアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Reflection.Assembly.LoadFile%2A> をロード済みの同じ id が異なるパスに配置されているアセンブリを調べるメソッド<xref:System.Reflection.Assembly.LoadFile%2A> がファイルを読み込み元コンテキストに読み込まれないしとして、読み込みパスを使用して依存関係が解決しない、 <xref:System.Reflection.Assembly.LoadFrom%2A> メソッドです。<xref:System.Reflection.Assembly.LoadFile%2A> この限られたシナリオで役に立つため <xref:System.Reflection.Assembly.LoadFrom%2A> アセンブリを読み込むには使用できません、同じ id をパスは最初のメッセージだけを読み込むことがこのようなアセンブリ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 引数が絶対パスではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> パラメーターが空の文字列 \(""\) になっているか、存在しません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> が有効なアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="path" /> は、より新しいバージョンでコンパイルされています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">アセンブリ ファイルの絶対パス。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>パスを指定してアセンブリを読み込みます。アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用して、 <xref:System.Reflection.Assembly.LoadFile%2A> を読み込んで済みの同じ id が別のパスにあるアセンブリをチェックするメソッドです。<xref:System.Reflection.Assembly.LoadFile%2A> ファイルを読み込みません、 <xref:System.Reflection.Assembly.LoadFrom%2A> コンテキストとして、読み込みパスを使用して依存関係が解決しないと、 <xref:System.Reflection.Assembly.LoadFrom%2A> メソッドでは。<xref:System.Reflection.Assembly.LoadFile%2A> この限られたシナリオで役に立つため <xref:System.Reflection.Assembly.LoadFrom%2A> アセンブリを読み込むには使用できません、同じ id をパスは最初のメッセージだけを読み込むことがこのようなアセンブリ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 引数が絶対パスではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> パラメーターが空の文字列 \(""\) になっているか、存在しません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれます。また <paramref name="path" /> は新しいバージョでコンパイル済みです。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> が <see langword="null" /> ではありません。 既定では、従来の CAS ポリシーは.NET Framework 4 で有効ではありません。有効でない場合、<paramref name="securityEvidence" /> は <see langword="null" /> である必要があります。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <summary>ファイル名またはパスを指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `assemblyFile` パラメーターは、エスケープ文字は URI を参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を提供します。  
  
> [!NOTE]
>  ファイル転送プロトコル \(FTP\) を指定することはできません。 URI が指定した場合 `assemblyFile` FTP アドレスは、アセンブリが読み込まれない。 例外をスローすることはありません。  
  
 `assemblyFile` 絶対パス、または現在のディレクトリを基準にすることがあり、アセンブリは、呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込まれるか、コンテキストを使用せずに読み込むことが可能します。  
  
-   読み込みコンテキストには、調査で見つかったアセンブリが含まれています。 GAC 内のホスト アセンブリで、ランタイムがホストされている場合、または保存、 <xref:System.AppDomainSetup.ApplicationBase%2A> と <xref:System.AppDomainSetup.PrivateBinPath%2A> アプリケーション ドメインのです。 大部分のオーバー ロード、 <xref:System.Reflection.Assembly.Load%2A> メソッド ロード アセンブリをこのコンテキストにします。  
  
-   読み込み元コンテキストには、ユーザーで調査で検索されるディレクトリに含まれていないパスを指定したアセンブリが含まれています。<xref:System.Reflection.Assembly.LoadFrom%2A>, 、<xref:System.AppDomain.CreateInstanceFrom%2A>, 、および <xref:System.AppDomain.ExecuteAssembly%2A> パスで読み込む方法の例を示します。  
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> と <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> メソッドを返します。 これらのコードのコンテキストを実行することはできません。  
  
-   生成されたか、アセンブリを検出、にない任意のコンテキスト。 このオーバー ロードを使用して読み込まれたアセンブリに適用されます、 <xref:System.Reflection.Assembly.Load%2A> メソッドが指定されたアセンブリを含むバイト配列とリフレクションを使用して作成された一時動的アセンブリを出力のディスクに保存されません。  
  
 読み込み元コンテキスト、調査には含まれないパスから読み込まれるアセンブリは、検出し、パス情報は、コンテキストによって維持されるために読み込むには、そのパスに依存関係ができます。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> メソッドには、次の欠点です。 代わりに <xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ id を持つアセンブリが読み込まれている、既に場合 <xref:System.Reflection.Assembly.LoadFrom%2A> 別のパスが指定されていた場合でも、読み込み済みのアセンブリを返します。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 これは、アセンブリは、シリアル化解除されたときに発生します。  
  
-   アセンブリが使用して読み込まれなかった場合 <xref:System.Reflection.Assembly.LoadFrom%2A>, 、プローブ パスに同じ id は、別の場所を指定したアセンブリが含まれています、 <xref:System.InvalidCastException>, 、<xref:System.MissingMethodException>, 、またはその他の予期しない動作が発生することができます。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 要求 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=fullName> と <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=fullName>, 、または <xref:System.Net.WebPermission>, 、指定したパスにします。  
  
-   ネイティブ イメージが存在する場合は `assemblyFile`, は使用されません。 アセンブリをドメインに中立として読み込むことはできません。  
  
-   .NET framework version 1.0 および 1.1 では、ポリシーは適用されません。  
  
   
  
## 例  
 次の例では、そのファイル名またはパスを指定してアセンブリを読み込みます。  
  
 [!code-cpp[System.Reflection.Assembly\#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、または読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません \(64 ビット プロセスの 32 ビット アセンブリなど\)。 詳細については、例外に関するトピックを参照してください。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">"file:\/\/" で始まっていないコードベースが、必須の <see cref="T:System.Net.WebPermission" /> なしで指定されました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> パラメーターが空の文字列 \(""\) になっています。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX\_PATH の文字数を超えています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading a URI that begins with "file:\/\/". Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>ファイル名またはパスを指定してアセンブリを読み込み、セキュリティ証拠を提供します。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `assemblyFile` パラメーターは、エスケープ文字は URI を参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を提供します。  
  
> [!NOTE]
>  ファイル転送プロトコル \(FTP\) を指定することはできません。 URI が指定した場合 `assemblyFile` FTP アドレスは、アセンブリが読み込まれない。 例外をスローすることはありません。  
  
 `assemblyFile` 絶対パス、または現在のディレクトリを基準にすることがあり、アセンブリは、呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込まれるか、コンテキストを使用せずに読み込むことが可能します。  
  
-   読み込みコンテキストには、調査で見つかったアセンブリが含まれています。 GAC 内のホスト アセンブリで、ランタイムがホストされている場合、または保存、 <xref:System.AppDomainSetup.ApplicationBase%2A> と <xref:System.AppDomainSetup.PrivateBinPath%2A> アプリケーション ドメインのです。 大部分のオーバー ロード、 <xref:System.Reflection.Assembly.Load%2A> メソッド ロード アセンブリをこのコンテキストにします。  
  
-   読み込み元コンテキストには、ユーザーで調査で検索されるディレクトリに含まれていないパスを指定したアセンブリが含まれています。<xref:System.Reflection.Assembly.LoadFrom%2A>, 、<xref:System.AppDomain.CreateInstanceFrom%2A>, 、および <xref:System.AppDomain.ExecuteAssembly%2A> パスで読み込む方法の例を示します。  
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> と <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> メソッドを返します。 これらのコードのコンテキストを実行することはできません。  
  
-   生成されたか、アセンブリを検出、にない任意のコンテキスト。 このオーバー ロードを使用して読み込まれたアセンブリに適用されます、 <xref:System.Reflection.Assembly.Load%2A> メソッドが指定されたアセンブリを含むバイト配列とリフレクションを使用して作成された一時動的アセンブリを出力のディスクに保存されません。  
  
 読み込み元コンテキスト、調査には含まれないパスから読み込まれるアセンブリは、検出し、パス情報は、コンテキストによって維持されるために読み込むには、そのパスに依存関係ができます。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A> メソッドには、次の欠点です。 代わりに <xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ id を持つアセンブリが読み込まれている、既に場合 <xref:System.Reflection.Assembly.LoadFrom%2A> 別のパスが指定されていた場合でも、読み込み済みのアセンブリを返します。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 これは、アセンブリが逆シリアル化されるときに発生します。  
  
-   アセンブリが使用して読み込まれなかった場合 <xref:System.Reflection.Assembly.LoadFrom%2A>, 、プローブ パスに同じ id は、別の場所を指定したアセンブリが含まれています、 <xref:System.InvalidCastException>, 、<xref:System.MissingMethodException>, 、またはその他の予期しない動作が発生することができます。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 要求 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=fullName> と <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=fullName>, 、または <xref:System.Net.WebPermission>, 、指定したパスにします。  
  
-   ネイティブ イメージが存在する場合は `assemblyFile`, は使用されません。 アセンブリをドメインに中立として読み込むことはできません。  
  
-   .NET framework version 1.0 および 1.1 では、ポリシーは適用されません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリおよびセキュリティの証拠のマージの規則は次のとおりです。  
  
-   使用すると、 <xref:System.Reflection.Assembly.LoadFrom%2A> なしでメソッド <xref:System.Security.Policy.Evidence> パラメーター、アセンブリの証拠をローダーが提供する読み込みします。  
  
-   使用すると、 <xref:System.Reflection.Assembly.LoadFrom%2A> メソッドを <xref:System.Security.Policy.Evidence> パラメーターの証拠がマージされます。 引数として指定された証拠の部分、 <xref:System.Reflection.Assembly.LoadFrom%2A> メソッドがの証拠をローダーによって提供されるよりも優先されます。  
  
-   共通言語ランタイムをスローしない場合は、同じアセンブリには、異なる証拠を指定に、このメソッドを複数回呼び出す、 <xref:System.IO.FileLoadException> 異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
-   使用すると、 <xref:System.Reflection.Assembly.LoadFrom%2A> メソッドを `Byte[]` イメージを読み込むため、一般的なオブジェクト ファイル形式 \(COFF\)、証拠のパラメーターの組み合わせ。`Zone`, 、`Url` と `Site` は呼び出し元のアセンブリから継承し、 `Hash` と `StrongName` COFF アセンブリから取得されます。  
  
-   使用すると、 <xref:System.Reflection.Assembly.LoadFrom%2A> メソッドを `Byte[]` パラメーターと <xref:System.Security.Policy.Evidence> 、指定された証拠のみが使用される COFF イメージを読み込めません。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、または読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。  
  
 \-または\-  
  
 <paramref name="securityEvidence" /> はあいまいではなく、正しくないと判断されました。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません \(64 ビット プロセスの 32 ビット アセンブリなど\)。 詳細については、例外に関するトピックを参照してください。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">"file:\/\/" で始まっていないコードベースが、必須の <see cref="T:System.Net.WebPermission" /> なしで指定されました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> パラメーターが空の文字列 \(""\) になっています。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX\_PATH の文字数を超えています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading a URI that begins with "file:\/\/". Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <param name="hashValue">計算されたハッシュ コードの値。</param>
        <param name="hashAlgorithm">ファイルのハッシュ処理および厳密な名前の生成に使用されるハッシュ アルゴリズム。</param>
        <summary>ファイル名またはパス、ハッシュ値、およびハッシュ アルゴリズムを指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `assemblyFile` パラメーターは、エスケープ文字は URI を参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を提供します。  
  
> [!NOTE]
>  ファイル転送プロトコル \(FTP\) を指定することはできません。 URI が指定した場合 `assemblyFile` FTP アドレスは、アセンブリが読み込まれない。 例外をスローすることはありません。  
  
 `assemblyFile` 絶対パス、または現在のディレクトリを基準にすることがあり、アセンブリは、呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込まれるか、コンテキストを使用せずに読み込むことが可能します。  
  
-   読み込みコンテキストには、調査で見つかったアセンブリが含まれています。 グローバル アセンブリ キャッシュ内のホスト アセンブリで、ランタイムがホストされている場合、または保存、 [LoadFrom メソッド \(String, Byte\<xref:System.AppDomainSetup.ApplicationBase%2A> と [LoadFrom メソッド \(String, Byte\<xref:System.AppDomainSetup.PrivateBinPath%2A> アプリケーション ドメインのです。 大部分のオーバー ロード、 [LoadFrom メソッド \(String, Byte\<xref:System.Reflection.Assembly.Load%2A> メソッド ロード アセンブリをこのコンテキストにします。  
  
-   読み込み元コンテキストには、ユーザーで調査に含まれていないパスを指定したアセンブリが含まれています。[LoadFrom メソッド \(String, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A>, 、[LoadFrom メソッド \(String, Byte\<xref:System.AppDomain.CreateInstanceFrom%2A>, 、および [LoadFrom メソッド \(String, Byte\<xref:System.AppDomain.ExecuteAssembly%2A> パスで読み込む方法の例を示します。  
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、 [LoadFrom メソッド \(String, Byte\<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> と [LoadFrom メソッド \(String, Byte\<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> メソッドを返します。 これらのコードのコンテキストを実行することはできません。  
  
-   生成されたか、アセンブリを検出、にない任意のコンテキスト。 このオーバー ロードを使用して読み込まれたアセンブリに適用されます、 [LoadFrom メソッド \(String, Byte\<xref:System.Reflection.Assembly.Load%2A> メソッドが指定されたアセンブリを含むバイト配列とリフレクションを使用して作成された一時動的アセンブリを出力のディスクに保存されません。  
  
 読み込み元コンテキスト、調査に含まれていないパスから読み込まれるアセンブリは、検出し、パス情報は、コンテキストによって維持されるために読み込むには、そのパスに依存関係ができます。  
  
 [LoadFrom メソッド \(String, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> メソッドには、次の欠点です。 代わりに [LoadFrom メソッド \(String, Byte\<xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ id を持つアセンブリが読み込まれている、既に場合 [LoadFrom メソッド \(String, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> 別のパスが指定されていた場合でも、読み込み済みのアセンブリを返します。  
  
-   [LoadFrom メソッド \(String, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 これは、アセンブリが逆シリアル化されるときに発生します。  
  
-   アセンブリが使用して読み込まれなかった場合 [LoadFrom メソッド \(String, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A>, 、プローブ パスに同じ id は、別の場所を指定したアセンブリが含まれています、 [LoadFrom メソッド \(String, Byte\<xref:System.InvalidCastException>, 、[LoadFrom メソッド \(String, Byte\<xref:System.MissingMethodException>, 、またはその他の予期しない動作が発生することができます。  
  
-   [LoadFrom メソッド \(String, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> 要求 [LoadFrom メソッド \(String, Byte\<xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=fullName> と [LoadFrom メソッド \(String, Byte\<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=fullName>, 、または [LoadFrom メソッド \(String, Byte\<xref:System.Net.WebPermission>, 、指定したパスにします。  
  
-   ネイティブ イメージが存在する場合は `assemblyFile`, は使用されません。 アセンブリは、ドメイン中立として読み込むことはできません。  
  
 アセンブリは、ローダーが提供する証拠を使用して読み込まれます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、または読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません \(64 ビット プロセスの 32 ビット アセンブリなど\)。 詳細については、例外に関するトピックを参照してください。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</exception>
        <exception cref="T:System.Security.SecurityException">"File:\/\/" で始まっていないコードベースが、必須の <see cref="T:System.Net.WebPermission" /> なしで指定されました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> パラメーターが空の文字列 \(""\) になっています。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX\_PATH の文字数を超えています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading a URI that begins with "file:\/\/". Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <param name="hashValue">計算されたハッシュ コードの値。</param>
        <param name="hashAlgorithm">ファイルのハッシュ処理および厳密な名前の生成に使用されるハッシュ アルゴリズム。</param>
        <summary>ファイル名またはパス、セキュリティ証拠、ハッシュ値、およびハッシュ アルゴリズムを指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `assemblyFile` パラメーターは、エスケープ文字は URI を参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を提供します。  
  
> [!NOTE]
>  ファイル転送プロトコル \(FTP\) を指定することはできません。 URI が指定した場合 `assemblyFile` FTP アドレスは、アセンブリが読み込まれない。 例外をスローすることはありません。  
  
 `assemblyFile` 絶対パス、または現在のディレクトリを基準にすることがあり、アセンブリは、呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込まれるか、コンテキストを使用せずに読み込むことが可能します。  
  
-   読み込みコンテキストには、調査で見つかったアセンブリが含まれています。 GAC 内のホスト アセンブリで、ランタイムがホストされている場合、または保存、 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.AppDomainSetup.ApplicationBase%2A> と [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.AppDomainSetup.PrivateBinPath%2A> アプリケーション ドメインのです。 大部分のオーバー ロード、 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.Load%2A> メソッド ロード アセンブリをこのコンテキストにします。  
  
-   読み込み元コンテキストには、ユーザーで調査で検索されるディレクトリに含まれていないパスを指定したアセンブリが含まれています。[LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A>, 、[LoadFrom メソッド \(String, Evidence, Byte\<xref:System.AppDomain.CreateInstanceFrom%2A>, 、および [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.AppDomain.ExecuteAssembly%2A> パスで読み込む方法の例を示します。  
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> と [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> メソッドを返します。 これらのコードのコンテキストを実行することはできません。  
  
-   生成されたか、アセンブリを検出、にない任意のコンテキスト。 このオーバー ロードを使用して読み込まれたアセンブリに適用されます、 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.Load%2A> メソッドが指定されたアセンブリを含むバイト配列とリフレクションを使用して作成された一時動的アセンブリを出力のディスクに保存されません。  
  
 読み込み元コンテキスト、調査には含まれないパスから読み込まれるアセンブリは、検出し、パス情報は、コンテキストによって維持されるために読み込むには、そのパスに依存関係ができます。  
  
 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> メソッドには、次の欠点です。 代わりに [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ id を持つアセンブリが読み込まれている、既に場合 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> 別のパスが指定されていた場合でも、読み込み済みのアセンブリを返します。  
  
-   [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 これは、アセンブリが逆シリアル化されるときに発生します。  
  
-   アセンブリが使用して読み込まれなかった場合 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A>, 、プローブ パスに同じ id は、別の場所を指定したアセンブリが含まれています、 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.InvalidCastException>, 、[LoadFrom メソッド \(String, Evidence, Byte\<xref:System.MissingMethodException>, 、またはその他の予期しない動作が発生することができます。  
  
-   [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> 要求 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=fullName> と [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=fullName>, 、または [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Net.WebPermission>, 、指定したパスにします。  
  
-   ネイティブ イメージが存在する場合は `assemblyFile`, は使用されません。 アセンブリをドメインに中立として読み込むことはできません。  
  
-   .NET framework version 1.0 および 1.1 では、ポリシーは適用されません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリおよびセキュリティの証拠のマージの規則は次のとおりです。  
  
-   使用すると、 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> なしでメソッド [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Security.Policy.Evidence> パラメーター、アセンブリの証拠をローダーが提供する読み込みします。  
  
-   使用すると、 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> メソッドを [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Security.Policy.Evidence> パラメーターの証拠がマージされます。 引数として指定された証拠の部分、 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> メソッドがの証拠をローダーによって提供されるよりも優先されます。  
  
-   共通言語ランタイムをスローしない場合は、同じアセンブリには、異なる証拠を指定に、このメソッドを複数回呼び出す、 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.IO.FileLoadException> 異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
-   使用すると、 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> メソッドを `Byte[]` イメージを読み込むため、一般的なオブジェクト ファイル形式 \(COFF\)、証拠のパラメーターの組み合わせ。`Zone`, 、`Url` と `Site` は呼び出し元のアセンブリから継承し、 `Hash` と `StrongName` COFF アセンブリから取得されます。  
  
-   使用すると、 [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Reflection.Assembly.LoadFrom%2A> メソッドを `Byte[]` パラメーターと [LoadFrom メソッド \(String, Evidence, Byte\<xref:System.Security.Policy.Evidence> 、指定された証拠のみが使用される COFF イメージを読み込めません。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、または読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。  
  
 \-または\-  
  
 <paramref name="securityEvidence" /> はあいまいではなく、正しくないと判断されました。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません \(64 ビット プロセスの 32 ビット アセンブリなど\)。 詳細については、例外に関するトピックを参照してください。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">"file:\/\/" で始まっていないコードベースが、必須の <see cref="T:System.Net.WebPermission" /> なしで指定されました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> パラメーターが空の文字列 \(""\) になっています。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX\_PATH の文字数を超えています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading a URI that begins with "file:\/\/". Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">モジュールの名前。 この文字列は、このアセンブリのマニフェストのファイル名に対応する必要があります。</param>
        <param name="rawModule">生成されたモジュールを含んだ COFF ベースのイメージまたはリソースになっているバイト配列。</param>
        <summary>生成されたモジュールを含んだ COFF ベースのイメージ、またはリソース ファイルと共に、このアセンブリの内部モジュールを読み込みます。</summary>
        <returns>読み込み済みのモジュール。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> または <paramref name="rawModule" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> がこのアセンブリのマニフェストでファイル エントリと一致しません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> は有効なモジュールではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">モジュールの名前です。 この文字列は、このアセンブリのマニフェストのファイル名に対応する必要があります。</param>
        <param name="rawModule">生成されたモジュールを含んだ COFF ベースのイメージまたはリソースになっているバイト配列。</param>
        <param name="rawSymbolStore">モジュールのシンボルを表す生バイトを格納しているバイト配列。 リソース ファイルの場合は <see langword="null" /> にする必要があります。</param>
        <summary>生成されたモジュールを含んだ COFF ベースのイメージ、またはリソース ファイルと共に、このアセンブリの内部モジュールを読み込みます。 モジュールのシンボルを表す生バイトも読み込まれます。</summary>
        <returns>読み込み済みのモジュール。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> または <paramref name="rawModule" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> がこのアセンブリのマニフェストでファイル エントリと一致しません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> は有効なモジュールではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アプリケーション ディレクトリまたはグローバル アセンブリ キャッシュから、部分名を使用してアセンブリを読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  オーバー ロード、 <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=fullName> メソッドは廃止され、下位互換性のために保持されています。 旧式でない代替手段は、<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=fullName> です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">アセンブリの表示名。</param>
        <summary>アプリケーション ディレクトリまたはグローバル アセンブリ キャッシュから、部分名を使用してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。<paramref name="partialName" /> が見つからない場合、このメソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> メソッドが残されていると、下位互換性のために残されています。 旧式でない代替手段は、<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=fullName> です。  
  
 このメソッドを使用してアセンブリを読み込むアプリケーションは、これらのアセンブリのアップグレードの影響を受けます。 したがって、このメソッドを使用しないでください。使用するアプリケーションを再設計、 <xref:System.Reflection.Assembly.Load%28System.String%29> メソッドのオーバー ロードまたは <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> メソッドのオーバー ロードします。  
  
 このメソッドは、最初 <xref:System.Reflection.Assembly.Load%2A>します。 アセンブリが見つからない場合、このメソッドは、同じ簡易名と最新のバージョン番号を持つグローバル アセンブリ キャッシュからアセンブリを返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="partialName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">アセンブリの表示名。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>アプリケーション ディレクトリまたはグローバル アセンブリ キャッシュから、部分名を使用してアセンブリを読み込みます。 アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。<paramref name="partialName" /> が見つからない場合、このメソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> メソッドが残されていると、下位互換性のために残されています。 旧式でない代替手段は、<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=fullName> です。  
  
 証拠とは、セキュリティ ポリシーがアクセス許可を決定するときに使用する一連の情報 \(コードにどのようなアクセス許可を付与できるかなど\) のことです。  
  
 このメソッドを使用してアセンブリを読み込むアプリケーションは、これらのアセンブリのアップグレードの影響を受けます。 したがって、このメソッドを使用しないでください。使用するアプリケーションを再設計、 <xref:System.Reflection.Assembly.Load%2A> メソッドまたは <xref:System.Reflection.Assembly.LoadFrom%2A> メソッドです。  
  
 このメソッドは、最初 <xref:System.Reflection.Assembly.Load%2A>します。 アセンブリが見つからない場合、このメソッドは、同じ簡易名と最新のバージョン番号を持つグローバル アセンブリ キャッシュからアセンブリを返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠セットを使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="partialName" /> は、より新しいバージョンでコンパイルされています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for calling unmanaged code and to load an assembly with evidence. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マニフェストを格納している読み込み済みファイルの完全パスまたは UNC 位置を取得します。</summary>
        <value>マニフェストを格納している読み込み済みファイルの場所。 読み込み済みファイルがシャドウ コピーされている場合、この場所はシャドウ コピーされた後のファイルの場所です。<see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> メソッド オーバーロードを使用したときなど、アセンブリがバイト配列から読み込まれた場合に返される値は、空の文字列 \(""\) です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 To get the location before the file has been shadow\-copied, use the <xref:System.Reflection.Assembly.CodeBase%2A> property.  
  
   
  
## 例  
 The following example displays the location of the loaded file that contains the manifest.  
  
 [!code-cpp[System.Reflection.Assembly\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在のアセンブリは、<see cref="T:System.Reflection.Emit.AssemblyBuilder" /> オブジェクトによって表される動的アセンブリです。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリのマニフェストを格納しているモジュールを取得します。</summary>
        <value>アセンブリのマニフェストを格納しているモジュール。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>共通言語ランタイム クラス ローダーが、通常の方法で参照をアセンブリの内部モジュールに解決できないときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このイベントは、コールバックを検索して、モジュール自体を読み込む戻す機会を与えます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリ内のモジュールを含むコレクションを取得します。</summary>
        <value>このアセンブリのモジュールを含むコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <c>right</c> と比較するアセンブリ。</param>
        <param name="right">
          <c>left</c> と比較するアセンブリ。</param>
        <summary>2 つの <see cref="T:System.Reflection.Assembly" /> オブジェクトが等しいかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> に等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <c>right</c> と比較するアセンブリ。</param>
        <param name="right">
          <c>left</c> と比較するアセンブリ。</param>
        <summary>2 つの <see cref="T:System.Reflection.Assembly" /> オブジェクトが等しくないかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> と等しくない場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリの許可セットを取得します。</summary>
        <value>現在のアセンブリの許可セット。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Security.PermissionSet> オブジェクトは、パスなどの機密情報を含めることができます。 そのため、これらのオブジェクトにアクセスするには、完全な信頼が必要です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリがリフレクションのみのコンテキストに読み込まれたかどうかを示す <see cref="T:System.Boolean" /> 値を取得します。</summary>
        <value>アセンブリが実行コンテキストではなく、リフレクションのみのコンテキストに読み込まれている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用してアセンブリをリフレクションのみのコンテキストに読み込まれた場合、 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> メソッド、アセンブリのコードを実行することはできません。 コードを実行するには、アセンブリが実行コンテキストに読み込まれる必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <summary>生成されたアセンブリを含む COFF ベースのイメージを使用して、アセンブリを読み込みます。 アセンブリは、呼び出し元のアプリケーション ドメインの、リフレクションのみのコンテキストに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 リフレクション専用コンテキストに読み込まれたアセンブリからコードを実行することはできません。 コードを実行するアセンブリ読み込む必要がある実行コンテキストを同様を使用して、 <xref:System.Reflection.Assembly.Load%2A> メソッドです。  
  
 リフレクションのみのコンテキストは、他のコンテキストと同じです。 アプリケーション ドメインのアンロードのコンテキストに読み込まれるアセンブリをアンロードできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="rawAssembly" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="rawAssembly" /> を読み込めません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <see cref="P:System.Reflection.AssemblyName.FullName" /> プロパティによって返される、アセンブリの表示名。</param>
        <summary>表示名を指定して、アセンブリをリフレクションのみのコンテキストに読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 依存関係は、リフレクションのみのコンテキストに自動的には読み込まれません。  
  
 リフレクション専用コンテキストに読み込まれたアセンブリからコードを実行することはできません。 コードを実行するアセンブリ読み込む必要がある実行コンテキストを同様を使用して、 <xref:System.Reflection.Assembly.Load%2A> メソッドです。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリおよびセキュリティの証拠のマージの規則は次のとおりです。  
  
> [!NOTE]
>  C\+\+ でコンパイルされた実行可能ファイルへのリフレクションが発生する、 <xref:System.IO.FileLoadException>です。 これは多くの場合、再配置アドレスまたは .reloc セクション、実行可能ファイルから、C\+\+ コンパイラによって原因します。 .Reloc アドレスを保持するために次のように指定します。 `/fixed:no` リンクしています。  
  
 リフレクションのみのコンテキストは、他のコンテキストと同じです。 アプリケーション ドメインをアンロードによってのみのコンテキストに読み込まれるアセンブリをアンロードできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> が空の文字列 \(""\) です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyString" /> が見つかりましたが、読み込めません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は有効なアセンブリではありません。  
  
 \-または\-  
  
 バージョン 2.0 以降の共通言語ランタイムが現在読み込まれていると <paramref name="assemblyString" /> 以降のバージョンでコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを含むファイルのパス。</param>
        <summary>パスを指定して、アセンブリをリフレクションのみのコンテキストに読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 依存関係は、リフレクションのみのコンテキストに自動的には読み込まれません。 依存関係を自動的にロードするには、処理、 <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> イベントとイベント ハンドラー内の依存関係をロードします。  
  
 リフレクション専用コンテキストに読み込まれたアセンブリからコードを実行することはできません。 使用してアセンブリを読み込むコードを実行する、 <xref:System.Reflection.Assembly.LoadFile%2A> メソッドです。  
  
 `assemblyFile` パラメーターは、エスケープ文字は URI を参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を提供します。  
  
 指定されたパス `assemblyFile` 、現在のディレクトリに対する相対パスです。 アセンブリは、呼び出し元のドメインに読み込まれます。  
  
 リフレクションのみのコンテキストは、他のコンテキストと同じです。 アプリケーション ドメインをアンロードによってのみのコンテキストに読み込まれるアセンブリをアンロードできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyFile" /> が見つかりましたが、読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
 \-または\-  
  
 共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">"file:\/\/" で始まっていないコードベースが、必要な <see cref="T:System.Net.WebPermission" /> なしで指定されました。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX\_PATH の文字数を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> が空の文字列 \(""\) です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading a URI that begins with "file:\/\/". Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file:\/\/".</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>共通言語ランタイム \(CLR: Common Language Runtime\) によってこのアセンブリに適用されるセキュリティ規則のセットを示す値を取得します。</summary>
        <value>CLR によってこのアセンブリに適用されるセキュリティ規則のセット。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 既定では、使用してコンパイルしたアセンブリ、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 代わりに明示的に行うには、透過性があります。 .NET Framework の以前のバージョンでコンパイルされたアセンブリでは、レベル 1 の透過性があります。  
  
 「[Security Changes in the .NET Framework 4](http://msdn.microsoft.com/ja-jp/5e87881c-9c13-4b52-8ad1-e34bb46e8aaa)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスの型を返します。</summary>
        <returns>
          <see cref="T:System.Reflection.Assembly" /> 型を表すオブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリの完全名を返します。この名前は表示名とも呼ばれます。</summary>
        <returns>アセンブリの完全名。アセンブリの完全名を判断できない場合は、クラス名。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <summary>一部のセキュリティ チェックをバイパスして、アセンブリを読み込み元コンテキストに読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドを使用して、Web \(たとえば、一時ファイル、インターネットまたはイントラネットからダウンロードした\) から読み込まれたものとして、オペレーティング システムのフラグが付けられているローカル アセンブリを読み込みます。 前に、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 、このようなアセンブリがサンド ボックス アプリケーション ドメインに自動的に読み込まれます。 以降で、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 、完全信頼で読み込まれています。  
  
 このメソッドを使用する代わりに、適用できる、 [\<NetFx40\_LegacySecurityPolicy\> Element](http://msdn.microsoft.com/ja-jp/07132b9c-4a72-4710-99d7-e702405e02d4) 、アプリケーション構成ファイルにします。 これにより、共通言語ランタイムのセキュリティ ポリシーに戻すには、 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]です。  
  
> [!CAUTION]
>  これらのソリューションのいずれかを使用するとする必要がありますに読み込んでも安全である `assemblyFile` 完全に信頼します。  
  
 読み込み元コンテキストを含む読み込みコンテキストの詳細については「、 <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、または読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
 または  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</exception>
        <exception cref="T:System.Security.SecurityException">"File:\/\/" で始まっていないコードベースが、必須の <see cref="T:System.Net.WebPermission" /> なしで指定されました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> パラメーターが空の文字列 \(""\) になっています。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名が MAX\_PATH の文字数を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリから、指定されたマニフェスト リソースを読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリをリフレクションのみのコンテキストに読み込みます。リフレクションのみのコンテキストでは、アセンブリのチェックはできますが、実行はできません。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>サテライト アセンブリを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリのカスタム属性を取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリを読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリ内部のモジュールを読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリを読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリから型を検索し、システム アクティベーターを使用してこの型のインスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリの一部であるすべての読み込み済みモジュールを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリの一部であるすべてのモジュールを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された型を表す <see cref="T:System.Type" /> オブジェクトを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリ ファイルの内容を読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリ マニフェストのファイル テーブルのファイルを取得します。</summary>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリの <see cref="T:System.Reflection.AssemblyName" /> を取得します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>