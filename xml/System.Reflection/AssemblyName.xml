<Type Name="AssemblyName" FullName="System.Reflection.AssemblyName">
  <TypeSignature Language="C#" Value="public sealed class AssemblyName : ICloneable, System.Runtime.InteropServices._AssemblyName, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AssemblyName extends System.Object implements class System.ICloneable, class System.Runtime.InteropServices._AssemblyName, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.AssemblyName" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._AssemblyName</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._AssemblyName))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>アセンブリの一意の ID を詳細に記述します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Reflection.AssemblyName> object contains information about an assembly, which you can use to bind to that assembly. An assembly's identity consists of the following:  
  
-   Simple name.  
  
-   Version number.  
  
-   Cryptographic key pair.  
  
-   Supported culture.  
  
 The simple name is typically the file name for the manifest file without its extension. The key pair includes a public and private key, used to create strong\-name signatures for assemblies.  
  
 All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  
  
|Delimiter|Meaning|  
|---------------|-------------|  
|Backslash \(\\\)|Escape character.|  
|Comma \(,\)|Precedes the assembly name.|  
|Plus sign \(\+\)|Precedes a nested class.|  
  
 For example, the fully qualified name for a class might look like this:  
  
 ContainingClass\+NestedClass,MyAssembly  
  
 A "\+\+" becomes "\\\+\\\+", and a "\\" becomes "\\\\".  
  
 This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.  
  
 A fully specified <xref:System.Reflection.AssemblyName> must have the name, culture, public key or public key token, major version, minor version, build number, and revision number parameters. The last four are packaged in the <xref:System.Version> type.  
  
 To create a simple name, create an <xref:System.Reflection.AssemblyName> object using the default constructor and set the <xref:System.Reflection.AssemblyName.Name%2A>. The other properties are optional.  
  
 To create a full strong name, create an <xref:System.Reflection.AssemblyName> object using the default constructor and set the <xref:System.Reflection.AssemblyName.Name%2A> and <xref:System.Reflection.AssemblyName.KeyPair%2A>. The other properties are optional. Use <xref:System.Reflection.AssemblyName.SetPublicKey%2A> and <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> to set the public key and the strong name. The strong name signing always uses the <xref:System.Security.Cryptography.SHA1> hash algorithm.  
  
 To ensure that the names are constructed correctly, use the following properties:  
  
-   <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>  
  
-   <xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=fullName>  
  
-   <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=fullName>  
  
 You can also get the name by using the **userInput tag is not supported!!!!**  
 option with the [Global Assembly Cache Tool \(Gacutil.exe\)](http://msdn.microsoft.com/ja-jp/4c7be9c8-72ae-481f-a01c-1a4716806e99)  
  
 For a partially specified strong name, create an <xref:System.Reflection.AssemblyName> object using the default constructor and set the name and public key. An assembly created using such an <xref:System.Reflection.AssemblyName> can be signed later using the Assembly Linker \(Al.exe\).  
  
 It is possible to specify a public key and a <xref:System.Reflection.AssemblyName.KeyPair%2A> with inconsistent values. This can be useful in developer scenarios. In this case, the public key retrieved with <xref:System.Reflection.AssemblyName.GetPublicKey%2A> specifies the correct public key, while the <xref:System.Reflection.AssemblyName.KeyPair%2A> specifies the public and private keys used during development. When the runtime detects a mismatch between the <xref:System.Reflection.AssemblyName.KeyPair%2A> and the public key, it looks up in the registry the correct key that matches the public key.  
  
 The format of the display name of an <xref:System.Reflection.AssemblyName> is a comma\-delimited Unicode string that begins with the name, as follows:  
  
 `Name <,Culture = CultureInfo> <,Version = Major.Minor.Build.Revision> <, StrongName> <,PublicKeyToken> '\0'`  
  
 `Name` is the textual name of the assembly. `CultureInfo` is the RFC1766\-format\-defined culture. `Major`, `Minor`, `Build`, and `Revision` are the major version, minor version, build number, and revision number of the assembly. `StrongName` is the hexadecimal\-encoded low\-order 64 bits of the hash value of the public key generated using the SHA\-1 hashing algorithm and the public key specified by <xref:System.Reflection.AssemblyName.SetPublicKey%2A>. `PublicKeyToken` is the hexadecimal\-encoded public key specified by <xref:System.Reflection.AssemblyName.SetPublicKey%2A>.  
  
 Hexadecimal encoding is defined as the conversion of each byte of a binary object to two hexadecimal characters, progressing from least to most significant byte. Additional display values will be added as deemed necessary.  
  
 If the full public key is known, then PublicKey may be substituted for StrongName.  
  
 Also note that except for `Name`, which must come first, the lexical order of parameters is unimportant. However, any parameter \(`Version`, `Culture`, `StrongName` or `PublicKey`\) not specifically set is considered to be omitted, and the <xref:System.Reflection.AssemblyName> is then considered partial. When specifying partial information, Name parameters must be specified in the order described above.  
  
 When supplying a display name, the convention `StrongName =null` or `PublicKey= null` indicates that binding and matching against a simply named assembly is required. Additionally, the convention `Culture= ""` \(double quote representing an empty string\) indicates matching against the default culture.  
  
 The following example shows an <xref:System.Reflection.AssemblyName> for a simply named assembly with default culture.  
  
```  
ExampleAssembly, Culture=""  
```  
  
 The following example shows a fully specified reference for a strongly named assembly with culture "en".  
  
```  
ExampleAssembly, Version=1.0.0.0, Culture=en, PublicKeyToken=a5d015c7d5a0b012  
```  
  
   
  
## 例  
 This example shows how to use various reflection classes to analyze the metadata contained in an assembly.  
  
 [!code-cpp[Reflection\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Version" />
    <altmember cref="M:System.Reflection.AssemblyName.GetPublicKey" />
    <altmember cref="M:System.Reflection.AssemblyName.GetPublicKeyToken" />
    <altmember cref="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" />
    <altmember cref="M:System.Reflection.AssemblyName.SetPublicKeyToken(System.Byte[])" />
    <altmember cref="P:System.Type.FullName" />
    <altmember cref="M:System.Type.GetType" />
    <altmember cref="P:System.Type.AssemblyQualifiedName" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、という名前の動的アセンブリ `MyAssembly.exe` され、ハード\_ディスクに保存します。 例を実行すると、使用することができます、 [MSIL Disassembler \(Ildasm.exe\)](http://msdn.microsoft.com/ja-jp/db27f6b2-f1ec-499e-be3a-7eecf95ca42b) アセンブリ メタデータを確認します。  
  
 [!code-cpp[AssemblyName\_Constructor\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#1)]
 [!code-csharp[AssemblyName\_Constructor\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#1)]
 [!code-vb[AssemblyName\_Constructor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">
          <see cref="P:System.Reflection.AssemblyName.FullName" /> プロパティによって返される、アセンブリの表示名。</param>
        <summary>指定した表示名を使用して、<see cref="T:System.Reflection.AssemblyName" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The supplied **parameterReference tag is not supported!!!!**  
 is parsed, and the appropriate fields of the new <xref:System.Reflection.AssemblyName> are initialized with values from the display name. This is the recommended way of parsing display names. Writing your own code to parse display names is not recommended.  
  
   
  
## 例  
 The following example creates an instance of <xref:System.Reflection.AssemblyName> from a display name. The individual elements of the display name are output to the console as properties of the <xref:System.Reflection.AssemblyName>object.  
  
 [!code-cpp[AssemblyName\_Constructor\_2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor_2/CPP/source.cpp#1)]
 [!code-csharp[AssemblyName\_Constructor\_2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor_2/CS/source.cs#1)]
 [!code-vb[AssemblyName\_Constructor\_2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor_2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> は長さゼロの文字列です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">  
<para>  
 [Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または [ポータブル クラス ライブラリ](http://msdn.microsoft.com/ja-jp/c31e1663-c164-4e65-b66d-d3aa8750a154)では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>  
</block>  
  
 参照アセンブリは見つからない、または読み込めませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このコピーを作成 <see cref="T:System.Reflection.AssemblyName" /> オブジェクトです。</summary>
        <returns>このコピーであるオブジェクト <see cref="T:System.Reflection.AssemblyName" /> オブジェクトです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しいオブジェクトは作成元と同じです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public string CodeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または URL として、アセンブリの場所を設定します。</summary>
        <value>アセンブリの場所を表す文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 アセンブリが読み込まれると、この値も取得できますを使用して、 <xref:System.Reflection.Assembly.CodeBase%2A?displayProperty=fullName> プロパティです。  
  
 アセンブリがバイト配列として読み込まれた、このプロパティはの呼び出し元の場所を返します、 <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%29> メソッドのオーバー ロード、読み込まれたアセンブリの場所ではありません。  
  
> [!NOTE]
>  使用しないでください、 <xref:System.Reflection.AssemblyName> だけを持つ、 <xref:System.Reflection.AssemblyName.CodeBase%2A> プロパティ セット。<xref:System.Reflection.AssemblyName.CodeBase%2A> プロパティがすべての要素を提供しないアセンブリの id \(名前、バージョンなど\) のための読み込みが存在しない id での負荷の規則に従ってから想像のとおり、 <xref:System.Reflection.Assembly.Load%2A> メソッドです。 代わりに、アセンブリでは、読み込み元の規則を使用してが読み込まれます。 読み込み元コンテキストを使用して、短所については、次を参照してください。、 <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> メソッドのオーバー ロードまたは [Best Practices for Assembly Loading](http://msdn.microsoft.com/ja-jp/68d1c539-6a47-4614-ab59-4b071c9d4b4c)です。  
  
   
  
## 例  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、 <xref:System.Reflection.AssemblyName.CodeBase%2A> アセンブリが保存されているディレクトリを指定するプロパティが使用されます。  
  
 [!code-cpp[AssemblyName\_CodeBase\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#1)]
 [!code-csharp[AssemblyName\_CodeBase\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#1)]
 [!code-vb[AssemblyName\_CodeBase\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public System.Reflection.AssemblyContentType ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.AssemblyContentType ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyContentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアセンブリに含まれるコンテンツの種類を示す値を設定します。</summary>
        <value>アセンブリのコンテンツの種類を示す値が含まれています。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CultureInfo">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CultureInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CultureInfo" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CultureInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアセンブリによってサポートされているカルチャを設定します。</summary>
        <value>アセンブリによってサポートされているカルチャを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、 <xref:System.Reflection.AssemblyName.CultureInfo%2A> プロパティを使用して、これは、アセンブリの表示名の一部と、カルチャを指定します。  
  
 [!code-cpp[AssemblyName\_CodeBase\#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#2)]
 [!code-csharp[AssemblyName\_CodeBase\#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#2)]
 [!code-vb[AssemblyName\_CodeBase\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CultureName">
      <MemberSignature Language="C#" Value="public string CultureName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CultureName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.CultureName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアセンブリに関連付けられているカルチャの名前を設定します。</summary>
        <value>カルチャ名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードベースを表す URI を、エスケープ文字も含めて取得します。</summary>
        <value>エスケープ文字を含んだ URI。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public System.Reflection.AssemblyNameFlags Flags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.AssemblyNameFlags Flags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyNameFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアセンブリの属性を設定します。</summary>
        <value>アセンブリの属性を表す値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、 <xref:System.Reflection.AssemblyName.Flags%2A> プロパティを使用して、アセンブリに公開キーがあることを指定します。  
  
 [!code-cpp[AssemblyName\_KeyPair\#4](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#4)]
 [!code-csharp[AssemblyName\_KeyPair\#4](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#4)]
 [!code-vb[AssemblyName\_KeyPair\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示名とも呼ばれる、アセンブリの完全名を取得します。</summary>
        <value>表示名とも呼ばれる、アセンブリの完全名を表す文字列です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 表示名は通常、単純な名前、バージョン番号、サポートされるカルチャ、および公開キーで構成されます。 例:  
  
```  
mylib, Version=1.2.1900.0, Culture=neutral, PublicKeyToken=a14f3033def15840  
```  
  
 表示名を解析するコードを作成することは推奨されません。 代わりに、表示名を渡す、 <xref:System.Reflection.AssemblyName.%23ctor%2A> に解析し、新しいの適切なフィールドを設定するコンス トラクター <xref:System.Reflection.AssemblyName>します。  
  
 アセンブリが読み込まれると、この値も取得できますを使用して、 <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> プロパティです。  
  
   
  
## 例  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリが作成されると、コード例を設定、 <xref:System.Reflection.AssemblyName.Name%2A>, 、<xref:System.Reflection.AssemblyName.Version%2A>, 、<xref:System.Reflection.AssemblyName.CultureInfo%2A>, 、および <xref:System.Reflection.AssemblyName.KeyPair%2A> プロパティでは、一緒にアセンブリのフルネームを構成または表示名。<xref:System.Reflection.AssemblyName.FullName%2A> 表示名を取得するプロパティを使用しています。  
  
 [!code-cpp[AssemblyName\_CodeBase\#4](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#4)]
 [!code-csharp[AssemblyName\_CodeBase\#4](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#4)]
 [!code-vb[AssemblyName\_CodeBase\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetAssemblyName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのパスが <see cref="T:System.Reflection.AssemblyName" /> が返されます。</param>
        <summary>取得、 <see cref="T:System.Reflection.AssemblyName" /> ファイルにします。</summary>
        <returns>指定したアセンブリ ファイルを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 これは、ファイルには、アセンブリ マニフェストが含まれている場合のみ機能します。 このメソッドにより、ファイルを開いたり、閉じたりが、アセンブリは、このドメインには追加されません。  
  
   
  
## 例  
 次の例では取得、 <xref:System.Reflection.AssemblyName> ディスク上のアセンブリ。 これは実行されません"MyAssembly.exe"文字列に置換する場合を除き、\(必要な場合、パスを含む\) アセンブリのファイル名と、ハード\_ディスク。 また、"MyAssembly.exe"として、この例をコンパイルできます。  
  
 [!code-cpp[AssemblyName\_GetAssemblyName\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CPP/assemblyname_getassemblyname.cpp#1)]
 [!code-csharp[AssemblyName\_GetAssemblyName\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CS/assemblyname_getassemblyname.cs#1)]
 [!code-vb[AssemblyName\_GetAssemblyName\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_GetAssemblyName/VB/assemblyname_getassemblyname.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> 無効なカルチャでのアセンブリなど、無効です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元には、パス検出のアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはモジュールが、2 つの異なる証拠セットを使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to information in the path. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">シリアル化情報が設定されるオブジェクト。</param>
        <param name="context">シリアル化の対象コンテキスト。</param>
        <summary>このインスタンスの再作成に必要なすべてのデータをシリアル化情報を取得 <see langword="AssemblyName" />します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> は <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetPublicKey">
      <MemberSignature Language="C#" Value="public byte[] GetPublicKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetPublicKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetPublicKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリの公開キーを取得します。</summary>
        <returns>アセンブリの公開キーを含むバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、 <xref:System.Reflection.AssemblyName.SetPublicKey%2A> メソッドは、アセンブリの名前は公開キーを使用します。<xref:System.Reflection.AssemblyName.GetPublicKey%2A> をコンソールに表示される公開キーを取得するメソッドを使用しています。  
  
 [!code-cpp[AssemblyName\_KeyPair\#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#2)]
 [!code-csharp[AssemblyName\_KeyPair\#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#2)]
 [!code-vb[AssemblyName\_KeyPair\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">公開キーが提供された \(たとえばを使用して、 <see cref="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" /> メソッド\)、公開キー トークンが指定されていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicKeyToken">
      <MemberSignature Language="C#" Value="public byte[] GetPublicKeyToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetPublicKeyToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.GetPublicKeyToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションまたはアセンブリが署名に使用された公開キーの sha\-1 ハッシュの最後の 8 バイトは、公開キー トークンを取得します。</summary>
        <returns>公開キー トークンを格納するバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、 <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> メソッドの使用をアセンブリの公開キー トークンを設定します。<xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> がコンソールに表示される公開キー トークンを取得するメソッドを使用しています。  
  
 [!code-cpp[AssemblyName\_KeyPair\#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#3)]
 [!code-csharp[AssemblyName\_KeyPair\#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#3)]
 [!code-vb[AssemblyName\_KeyPair\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Assemblies.AssemblyHashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはアセンブリ マニフェストで使用されるハッシュ アルゴリズムを設定します。</summary>
        <value>アセンブリ マニフェストが使用するハッシュ アルゴリズム。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!IMPORTANT]
>  以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 、 <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> のプロパティ、 <xref:System.Reflection.AssemblyName> によって返されるオブジェクト、 <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=fullName> メソッドは <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=fullName> 参照アセンブリのハッシュ アルゴリズムが存在しない場合、または参照先アセンブリのハッシュ アルゴリズムがで認識されない場合、 <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=fullName> 列挙します。 .NET Framework の以前のバージョンで、 <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> プロパティによって返される <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=fullName> このような場合です。  
  
   
  
## 例  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、 <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> プロパティを使用して、アセンブリ マニフェストのハッシュ アルゴリズムを設定します。  
  
 [!code-cpp[AssemblyName\_CodeBase\#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_CodeBase/CPP/assemblyname_codebase.cpp#3)]
 [!code-csharp[AssemblyName\_CodeBase\#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_CodeBase/CS/assemblyname_codebase.cs#3)]
 [!code-vb[AssemblyName\_CodeBase\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_CodeBase/VB/assemblyname_codebase.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPair">
      <MemberSignature Language="C#" Value="public System.Reflection.StrongNameKeyPair KeyPair { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.StrongNameKeyPair KeyPair" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.KeyPair" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.StrongNameKeyPair</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定、パブリックとプライベートの暗号キー ペアをアセンブリの厳密な名前の署名を作成するために使用します。</summary>
        <value>パブリックおよびプライベート暗号化するキー ペア、アセンブリの厳密な名前の作成に使用します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ランタイムがアセンブリを読み込んだときに設定せず、 <xref:System.Reflection.AssemblyName.KeyPair%2A> プロパティです。 プロパティの get アクセス操作子は、ユーザーは、使用する前に、プロパティを設定する場合に役立ちます。 のみ、 <xref:System.Reflection.AssemblyName> オブジェクトの動的アセンブリを作成すると、後で取得しようとするキーのペアです。  
  
   
  
## 例  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、 <xref:System.Reflection.AssemblyName.KeyPair%2A> プロパティを使用してアセンブリの公開キーと秘密暗号化キーを設定します。 」を参照してください。  
  
 [!code-cpp[AssemblyName\_KeyPair\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_KeyPair/CPP/assemblyname_keypair.cpp#1)]
 [!code-csharp[AssemblyName\_KeyPair\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_KeyPair/CS/assemblyname_keypair.cs#1)]
 [!code-vb[AssemblyName\_KeyPair\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_KeyPair/VB/assemblyname_keypair.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの簡易名を取得または設定します。 これは通常、限りませんが、その拡張子を除く、アセンブリのマニフェスト ファイルのファイル名です。</summary>
        <value>アセンブリの簡易名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 マニフェスト ファイルは、アセンブリ マニフェストを含むファイルです。  
  
 たとえば、"MyAssembly.dll"という名前の単一ファイル アセンブリの簡易名には、"MyAssembly"が、します。  
  
   
  
## 例  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、 <xref:System.Reflection.AssemblyName.Name%2A> プロパティを使用して動的アセンブリの簡易名を設定します。  
  
 [!code-cpp[AssemblyName\_Constructor\#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#2)]
 [!code-csharp[AssemblyName\_Constructor\#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#2)]
 [!code-vb[AssemblyName\_Constructor\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.OnDeserialization(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">逆シリアル化イベントのソース。</param>
        <summary>
          <see cref="T:System.Runtime.Serialization.ISerializable" /> インターフェイスを実装し、逆シリアル化が完了したときに逆シリアル化イベントによってコールバックされます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="M:System.Reflection.AssemblyName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorArchitecture">
      <MemberSignature Language="C#" Value="public System.Reflection.ProcessorArchitecture ProcessorArchitecture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.ProcessorArchitecture ProcessorArchitecture" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.ProcessorArchitecture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ProcessorArchitecture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはプロセッサと、実行可能ファイルの対象となるプラットフォームのワードあたりのビットを示す値を設定します。</summary>
        <value>プロセッサと、実行可能ファイルの対象となるプラットフォームのワードあたりのビットを識別する列挙値の 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 以降で、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 、このプロパティは常に返します <xref:System.Reflection.ProcessorArchitecture.None?displayProperty=fullName> 参照アセンブリ。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      </Docs>
    </Member>
    <Member MemberName="ReferenceMatchesDefinition">
      <MemberSignature Language="C#" Value="public static bool ReferenceMatchesDefinition (System.Reflection.AssemblyName reference, System.Reflection.AssemblyName definition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceMatchesDefinition(class System.Reflection.AssemblyName reference, class System.Reflection.AssemblyName definition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.ReferenceMatchesDefinition(System.Reflection.AssemblyName,System.Reflection.AssemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reference" Type="System.Reflection.AssemblyName" />
        <Parameter Name="definition" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="reference">参照アセンブリ名。</param>
        <param name="definition">参照アセンブリと比較するアセンブリ名。</param>
        <summary>2 つのアセンブリ名が同じであるかどうかを示す値を返します。 比較は、単純なアセンブリの名前に基づいています。</summary>
        <returns>
          <see langword="true" /> 単純なアセンブリ名が同じである場合それ以外の場合、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 比較は、単純なアセンブリ名だけに依存します。 これは、バージョン、カルチャ、および公開キー トークンは無視されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPublicKey">
      <MemberSignature Language="C#" Value="public void SetPublicKey (byte[] publicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPublicKey(unsigned int8[] publicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="publicKey" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="publicKey">アセンブリの公開キーを含むバイト配列。</param>
        <summary>アセンブリを識別する公開キーを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することも必要があります、 <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> メソッドを公開キー トークンを提供します。 それ以外の場合、 <xref:System.Security.SecurityException> 場合にスローされますが、 <xref:System.Reflection.AssemblyName.GetPublicKey%2A> メソッドが呼び出されます。  
  
   
  
## 例  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、 <xref:System.Reflection.AssemblyName.SetPublicKey%2A> メソッドは、アセンブリの名前は公開キーを使用します。<xref:System.Reflection.AssemblyName.GetPublicKey%2A> をコンソールに表示される公開キーを取得するメソッドを使用しています。  
  
 [!code-cpp[AssemblyName\_SetPublicKey\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CPP/assemblyname_setpublickey.cpp#1)]
 [!code-csharp[AssemblyName\_SetPublicKey\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CS/assemblyname_setpublickey.cs#1)]
 [!code-vb[AssemblyName\_SetPublicKey\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_SetPublicKey/VB/assemblyname_setpublickey.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPublicKeyToken">
      <MemberSignature Language="C#" Value="public void SetPublicKeyToken (byte[] publicKeyToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPublicKeyToken(unsigned int8[] publicKeyToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.SetPublicKeyToken(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="publicKeyToken" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="publicKeyToken">アセンブリの公開キー トークンを含むバイト配列。</param>
        <summary>公開キー トークン、アプリケーションまたはアセンブリが署名に使用された公開キーの sha\-1 ハッシュの最後の 8 バイトを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出すことによって、公開キーを設定すると、 <xref:System.Reflection.AssemblyName.SetPublicKey%2A> メソッドを使用することがありますも、 <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> 公開キー トークンを提供するメソッドです。 それ以外の場合、 <xref:System.Security.SecurityException> 場合にスローされますが、 <xref:System.Reflection.AssemblyName.GetPublicKey%2A> メソッドが呼び出されます。  
  
   
  
## 例  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、 <xref:System.Reflection.AssemblyName.SetPublicKeyToken%2A> メソッドの使用をアセンブリの公開キー トークンを設定します。<xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> がコンソールに表示される公開キー トークンを取得するメソッドを使用しています。  
  
 [!code-cpp[AssemblyName\_SetPublicKey\#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CPP/assemblyname_setpublickey.cpp#2)]
 [!code-csharp[AssemblyName\_SetPublicKey\#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_SetPublicKey/CS/assemblyname_setpublickey.cs#2)]
 [!code-vb[AssemblyName\_SetPublicKey\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_SetPublicKey/VB/assemblyname_setpublickey.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元割り当て済み配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetIDsOfNames`, 、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfo`, 、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AssemblyName.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 \(0 または 1\) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::GetTypeInfoCount`, 、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyName.Invoke">
      <MemberSignature Language="C#" Value="void _AssemblyName.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyName.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID\_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびないマネージ コードから呼び出す必要があります。 詳細については `IDispatch::Invoke`, 、MSDN ライブラリを参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.AssemblyName.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリの完全名を返します。この名前は表示名とも呼ばれます。</summary>
        <returns>アセンブリの完全名または完全な名前を特定できない場合は、クラス名。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 説明を参照して <xref:System.Reflection.AssemblyName> 返される文字列の形式にします。  
  
   
  
## 例  
 次の例では取得、 <xref:System.Reflection.AssemblyName> 仮定のオブジェクト `MyAssembly.exe` アセンブリ、および、使用して、 <xref:System.Reflection.AssemblyName.ToString%2A> メソッドの完全なアセンブリ名を取得または表示名にします。  
  
 [!code-cpp[AssemblyName\_GetAssemblyName\#2](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CPP/assemblyname_getassemblyname.cpp#2)]
 [!code-csharp[AssemblyName\_GetAssemblyName\#2](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_GetAssemblyName/CS/assemblyname_getassemblyname.cs#2)]
 [!code-vb[AssemblyName\_GetAssemblyName\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_GetAssemblyName/VB/assemblyname_getassemblyname.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public Version Version { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定のメジャー、マイナー、ビルド、およびアセンブリのリビジョン番号。</summary>
        <value>オブジェクトを表すメジャー、マイナー、ビルド、およびアセンブリのリビジョン番号、します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 バージョンのすべてのコンポーネントは、0 以上の整数である必要があります。 メタデータによって、メジャー、マイナー、ビルド、および最大値はアセンブリのリビジョン コンポーネント <xref:System.UInt16.MaxValue?displayProperty=fullName> \- 1 です。 コンポーネントは、この値を超えると、エラーはスローされません。ただし、動的アセンブリでそのコンポーネントは 0 です。  
  
   
  
## 例  
 このセクションには、2 つの例が含まれています。 最初の例では、現在実行中のアセンブリのバージョンを取得する方法を示します。 2 番目の例では、使用する方法、 <xref:System.Reflection.AssemblyName.Version%2A> プロパティを動的アセンブリを生成するときに、アセンブリのバージョンを指定します。  
  
 **例 1**  
  
 次の例は、取得し、実行中のアセンブリと格納するアセンブリのバージョン番号を表示、 <xref:System.String> クラスです。  
  
 [!code-cpp[AssemblyName.Version\#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName.Version/cpp/Example.cpp#1)]
 [!code-csharp[AssemblyName.Version\#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName.Version/cs/Example.cs#1)]
 [!code-vb[AssemblyName.Version\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName.Version/vb/Example.vb#1)]  
  
 **例 2**  
  
 次の例では、動的アセンブリを生成し、現在のディレクトリに保存します。 アセンブリの作成時に、 <xref:System.Reflection.AssemblyName.Version%2A> プロパティの使用をアセンブリのバージョン情報を指定します。  
  
 [!code-cpp[AssemblyName\_Constructor\#3](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyName_Constructor/CPP/assemblyname_constructor.cpp#3)]
 [!code-csharp[AssemblyName\_Constructor\#3](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyName_Constructor/CS/assemblyname_constructor.cs#3)]
 [!code-vb[AssemblyName\_Constructor\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyName_Constructor/VB/assemblyname_constructor.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VersionCompatibility">
      <MemberSignature Language="C#" Value="public System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.AssemblyName.VersionCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Assemblies.AssemblyVersionCompatibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得またはとその他のアセンブリとの互換性に関連する情報を設定します。</summary>
        <value>その他のアセンブリとの互換性に関する情報を表す値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Reflection.AssemblyName.VersionCompatibility%2A> 情報を示します、たとえば、アセンブリがデバイス ドライバーで競合のためには、他のバージョンと並行してを実行できません。  
  
 現在のところ、 <xref:System.Reflection.AssemblyName.VersionCompatibility%2A> は常に返します <xref:System.Configuration.Assemblies.AssemblyVersionCompatibility.SameMachine?displayProperty=fullName>, 、ローダーでは使用されません。 将来の機能では、このプロパティは予約されています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>