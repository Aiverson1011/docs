<Type Name="Binder" FullName="System.Reflection.Binder">
  <TypeSignature Language="C#" Value="public abstract class Binder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Binder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Binder" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>候補の一覧からメンバーを選択し、実引数の型から仮引数の型への型変換を実行します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 実装、 <xref:System.Reflection.Binder> クラスがなどのメソッドで使用される <xref:System.Type.InvokeMember%2A?displayProperty=fullName>, 、一連のパラメーターの型と引数の値に基づいて実行するには、可能なメンバーのセットから選択を <xref:System.Type.GetMethod%2A?displayProperty=fullName>, 、パラメーターの型。 というようにに基づいてメソッドを選択します。  
  
 既定の実装、 <xref:System.Reflection.Binder> によってクラスが提供される、 <xref:System.Type.DefaultBinder%2A?displayProperty=fullName> プロパティです。  
  
   
  
## 例  
 次の例を実装し、すべてのメンバーを示しています、 `Binder` クラスです。 プライベート メソッド `CanConvertFrom` 、指定された型の互換性のある型を検索します。  
  
 [!code-cpp[Binder\_1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder\_1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder\_1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>When you inherit from <see cref="T:System.Reflection.Binder" />, you must override the following members: <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, <see cref="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />, <see cref="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />, <see cref="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />, and <see cref="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Binder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Reflection.Binder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This constructor is called by the constructors of derived classes, to initialize state in this type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindToField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo BindToField (System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo BindToField(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.FieldInfo[] match, object value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.FieldInfo[]" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <see cref="T:System.Reflection.BindingFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="match">一連のフィールドに一致する候補であります。 たとえば、 <see cref="T:System.Reflection.Binder" /> でオブジェクトを使用して <see cref="Overload:System.Type.InvokeMember" />, 、このパラメーターは、一連のリフレクションが可能にすると判断しましたフィールド一致すると、通常ための適切なメンバーの名前があることを指定します。 によって提供される既定の実装 <see cref="P:System.Type.DefaultBinder" /> この配列の順序を変更します。</param>
        <param name="value">フィールドの値が一致するフィールドを検出するために使用します。</param>
        <param name="culture">インスタンス <see cref="T:System.Globalization.CultureInfo" /> を使用して型を強制バインダーの実装では、データ型の強制変換を制御します。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。  
  
 メモの例では、バインダーの実装は、文字列の値を数値型の強制変換をこのパラメーターに変換するために必要な <see langword="String" /> に 1000年を表す、 <see langword="Double" /> 値、1000年の表記がカルチャによって異なるためです。 既定のバインダーは、このような文字列の強制型変換を実行しません。</param>
        <summary>指定された条件に基づくフィールドの指定したセットからフィールドを選択します。</summary>
        <returns>一致するフィールドです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 `bindingAttr` 含まない [BindToField メソッド \(BindingFlags, FieldInfo\<xref:System.Reflection.BindingFlags.SetField?displayProperty=fullName>, 、によって提供される既定のバインダー実装 [BindToField メソッド \(BindingFlags, FieldInfo\<xref:System.Type.DefaultBinder%2A?displayProperty=fullName> の最初の要素を単純に返します `match`します。 選択は実行されません。  
  
 このメソッドによって提供されるバインディングの制御 [BindToField メソッド \(BindingFlags, FieldInfo\<xref:System.Type.InvokeMember%2A?displayProperty=fullName>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">既定のバインダー <paramref name="bindingAttr" /> が含まれています <see cref="F:System.Reflection.BindingFlags.SetField" />, 、および <paramref name="match" /> 一致している複数のフィールドが含まれています <paramref name="value" />します。 たとえば、 <paramref name="value" /> が含まれています、 <c>MyClass</c> を実装するオブジェクト、 <c>IMyClass</c> インターフェイス、および <paramref name="match" /> 型のフィールドが含まれています <c>MyClass</c> と型のフィールド <c>IMyClass</c>します。</exception>
        <exception cref="T:System.MissingFieldException">既定のバインダー <paramref name="bindingAttr" /> が含まれています <see cref="F:System.Reflection.BindingFlags.SetField" />, 、および <paramref name="match" /> 受け取りが可能なフィールドが含まれていない <paramref name="value" />します。</exception>
        <exception cref="T:System.NullReferenceException">既定のバインダー <paramref name="bindingAttr" /> が含まれています <see cref="F:System.Reflection.BindingFlags.SetField" />, 、および <paramref name="match" /> は <see langword="null" /> または空の配列。  
  
 または  
  
 <paramref name="bindingAttr" /> 含む <see cref="F:System.Reflection.BindingFlags.SetField" />, 、および <paramref name="value" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
      </Docs>
    </Member>
    <Member MemberName="BindToMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase BindToMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase BindToMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] names, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="args" Type="System.Object[]&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="names" Type="System.String[]" />
        <Parameter Name="state" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <see cref="T:System.Reflection.BindingFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="match">一致する候補であるメソッドのセットです。 たとえば、 <see cref="T:System.Reflection.Binder" /> でオブジェクトを使用 <see cref="Overload:System.Type.InvokeMember" />, 、このパラメーターは、一連のメソッドを可能にするリフレクションが判断されている一致すると、通常ための適切なメンバーの名前があることを指定します。 によって提供される既定の実装 <see cref="P:System.Type.DefaultBinder" /> この配列の順序を変更します。</param>
        <param name="args">渡される引数。 バインダーは、この配列内の引数の順序を変更できます。既定のバインダーが引数の順序を変更する場合など、 <c>names</c> 位置指定の順序ではないという順序を指定するパラメーターを使用します。 バインダーの実装では、引数の型を変換する場合、型と、引数の値はもします。</param>
        <param name="modifiers">種類が変更されているパラメーターのシグネチャを使用するバインディングを有効にするパラメーター修飾子の配列。 既定のバインダーの実装では、このパラメーターを使用しません。</param>
        <param name="culture">インスタンス <see cref="T:System.Globalization.CultureInfo" /> を使用して型を強制バインダーの実装では、データ型の強制変換を制御します。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。  
  
 メモの例では、バインダーの実装は、文字列の値を数値型の強制変換をこのパラメーターに変換するために必要な <see langword="String" /> に 1000年を表す、 <see langword="Double" /> 値、1000年の表記がカルチャによって異なるためです。 既定のバインダーは、このような文字列の強制型変換を実行しません。</param>
        <param name="names">パラメーター名では、一致する場合に考慮する場合、パラメーター名または <see langword="null" /> 引数がパラメーターで処理される場合。 たとえば、引数が位置指定の順序で指定されていない場合は、パラメーター名を使用する必要があります。</param>
        <param name="state">このメソッドから制御が戻た後 <c>state</c> 引数の順序変更の追跡、バインダー指定のオブジェクトが含まれています。 バインダーは、このオブジェクトを作成し、バインダーはこのオブジェクトの唯一のコンシューマーです。 場合 <c>state</c> は <see langword="null" /> と <see langword="BindToMethod" /> 返しますを渡す必要があります <c>state</c> に、 <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" /> メソッドを復元する場合 <c>args</c> を元の値を取得できるようにするなど、注文 <see langword="ref" /> パラメーター \(<see langword="ByRef" /> Visual Basic でのパラメーター\)。</param>
        <summary>指定された引数に基づいて、メソッドの指定したセットから、呼び出すメソッドを選択します。</summary>
        <returns>一致するメソッド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 両方のパラメーター値を持つアカウントに、既定のバインダーと `params` 配列 \(`ParamArray` Visual Basic における配列\)。 したがって、可能であればの場合、検索する場所 `args` と `match` 同じ数要素にはが含まれていません。  
  
 バインダーにより、クライアントは、引数の配列がによって操作されている場合、元の形式に引数の配列を割り当てる [BindToMethod メソッド \(BindingFlags, MethodBase\[\], Object\[\], ParameterModifier\[\], CultureInfo, String\<xref:System.Reflection.Binder.BindToMethod%2A>します。 このような引数が存在する場合は、参照渡しの引数を戻るには、この再割り当て機能を使用します。 名前で引数を渡した場合、binder は引数の配列を並べ替えます。`state` パラメーターの追跡引数の順序変更、常時、バインダー [BindToMethod メソッド \(BindingFlags, MethodBase\[\], Object\[\], ParameterModifier\[\], CultureInfo, String\<xref:System.Reflection.Binder.ReorderArgumentArray%2A> を元の形式に引数の配列を並べ替えるにはメソッドです。  
  
 [BindToMethod メソッド \(BindingFlags, MethodBase\[\], Object\[\], ParameterModifier\[\], CultureInfo, String\<xref:System.Reflection.Binder.BindToMethod%2A> メソッドを使用して、 [BindToMethod メソッド \(BindingFlags, MethodBase\[\], Object\[\], ParameterModifier\[\], CultureInfo, String\<xref:System.Type.InvokeMember%2A?displayProperty=fullName> メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">既定のバインダー <paramref name="match" /> 一致している複数のメソッドを含む <paramref name="args" />します。 たとえば、 <paramref name="args" /> が含まれています、 <c>MyClass</c> を実装するオブジェクト、 <c>IMyClass</c> インターフェイス、および <paramref name="match" /> を受け取るメソッドが含まれています <c>MyClass</c> およびを受け取るメソッド <c>IMyClass</c>します。</exception>
        <exception cref="T:System.MissingMethodException">既定のバインダー <paramref name="match" /> で指定された引数を受け入れることができるメソッドが含まれていない <paramref name="args" />します。</exception>
        <exception cref="T:System.ArgumentException">既定のバインダー <paramref name="match" /> は <see langword="null" /> または空の配列。</exception>
        <altmember cref="T:System.Reflection.MethodBase" />
      </Docs>
    </Member>
    <Member MemberName="CanChangeType">
      <MemberSignature Language="C#" Value="public virtual bool CanChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.CanChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="type">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeType">
      <MemberSignature Language="C#" Value="public abstract object ChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">新しい変更するのにはオブジェクト <see langword="Type" />します。</param>
        <param name="type">新しい <see langword="Type" /> を <c>value</c> になります。</param>
        <param name="culture">インスタンス <see cref="T:System.Globalization.CultureInfo" /> を使用してデータ型の強制変換を制御します。<c>culture</c> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。  
  
 メモの例では、このパラメーターは変換するために必要な <see langword="String" /> に 1000年を表す、 <see langword="Double" /> 1000年の表記がカルチャによって異なるので、値します。</param>
        <summary>型を変更、指定された <see langword="Object" /> を指定された <see langword="Type" />します。</summary>
        <returns>新しい種類として指定した値を格納するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 リフレクションは、共通型システムのアクセシビリティ規則をモデル化します。 たとえば、呼び出し元が同じアセンブリ内にある場合は、呼び出し元は必要はありません特殊なアクセス許可内部メンバーに対する。 それ以外の場合、呼び出し元が必要な <xref:System.Security.Permissions.ReflectionPermission>です。 これは、保護されているメンバーの検索、private、およびなどです。  
  
 一般的な方針は `ChangeType` 拡大変換で、データが失われることだけを実行する必要があります。 拡大型の強制の例は、強制型変換は 64 ビット符号付き整数の値を 32 ビット符号付き整数の値。 これは、データが失われる可能性があります縮小強制変換と区別されます。 縮小強制変換の例は、強制型変換は 32 ビット符号付き整数に 64 ビット符号付き整数。  
  
 次の表に、既定では、実行の強制型変換 `ChangeType`します。  
  
|ソースの種類|ターゲットの種類|  
|------------|--------------|  
|任意の型|その基本型です。|  
|任意の型|実装するインターフェイスです。|  
|Char|UInt16、UInt32、Int32、UInt64、Int64 を Single、Double|  
|Byte|Char、UInt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double|  
|SByte|Int16、Int32、Int64 を Single、Double|  
|UInt16|UInt32、Int32、UInt64、Int64 を Single、Double|  
|Int16|Int32、Int64 を Single、Double|  
|UInt32|UInt64、Int64 を Single、Double|  
|Int32|Int64、Single、Double します。|  
|UInt64|Single、Double|  
|Int64|Single、Double|  
|Single|倍精度浮動小数点型|  
|非参照|参照渡しされます。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReorderArgumentArray">
      <MemberSignature Language="C#" Value="public abstract void ReorderArgumentArray (ref object[] args, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReorderArgumentArray(object[] args, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]&amp;" RefType="ref" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="args">渡される実際の引数。 型と引数の値の両方を変更できます。</param>
        <param name="state">引数の順序変更の追跡をバインダー指定のオブジェクト。</param>
        <summary>戻ったときに <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, 、復元、 <paramref name="args" /> から送信されているときに引数 <see langword="BindToMethod" />します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合に、共通言語ランタイムがこのメソッドを呼び出して `state` は `null` から戻った後 `BindToMethod`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase SelectMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase SelectMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <see cref="T:System.Reflection.BindingFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="match">一致する候補であるメソッドのセットです。 たとえば、 <see cref="T:System.Reflection.Binder" /> でオブジェクトを使用 <see cref="Overload:System.Type.InvokeMember" />, 、このパラメーターは、一連のメソッドを可能にするリフレクションが判断されている一致すると、通常ための適切なメンバーの名前があることを指定します。 によって提供される既定の実装 <see cref="P:System.Type.DefaultBinder" /> この配列の順序を変更します。</param>
        <param name="types">パラメーターの型が一致するメソッドを検索するために使用します。</param>
        <param name="modifiers">種類が変更されているパラメーターのシグネチャを使用するバインディングを有効にするパラメーター修飾子の配列。</param>
        <summary>指定した引数の型に基づき、メソッドのセットからメソッドを選択します。</summary>
        <returns>場合、一致メソッドが見つかりました。それ以外の場合、 <see langword="null" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドが返す `null` 条件に一致するメソッドがない場合。 このメソッドによって提供される選択を制御する、 `GetConstructor` と `GetMethod` メソッド `Type`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">既定のバインダー <paramref name="match" /> で説明されているパラメーターの型の同等に一致する複数のメソッドを含む <paramref name="types" />します。 配列など <paramref name="types" /> が含まれています、 <see cref="T:System.Type" /> の <c>MyClass</c> とに配列 <paramref name="match" /> の基本クラスを受け取るメソッドが含まれています <c>MyClass</c> とインターフェイスを受け取るメソッド <c>MyClass</c> を実装します。</exception>
        <exception cref="T:System.ArgumentException">既定のバインダー <paramref name="match" /> は <see langword="null" /> または空の配列。  
  
 または  
  
 要素 <paramref name="types" /> から派生した <see cref="T:System.Type" />, 、型ではありませんが、 <see langword="RuntimeType" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectProperty">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo SelectProperty (System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, Type returnType, Type[] indexes, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo SelectProperty(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.PropertyInfo[] match, class System.Type returnType, class System.Type[] indexes, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.PropertyInfo[]" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="indexes" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <see cref="T:System.Reflection.BindingFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="match">照合の対象となるプロパティのセット。 たとえば、 <see cref="T:System.Reflection.Binder" /> でオブジェクトを使用 <see cref="Overload:System.Type.InvokeMember" />, 、このパラメーターは、一連のプロパティを可能にするリフレクションが判断されている一致すると、通常ための適切なメンバーの名前があることを指定します。 によって提供される既定の実装 <see cref="P:System.Type.DefaultBinder" /> この配列の順序を変更します。</param>
        <param name="returnType">戻り値に一致するプロパティが必要です。</param>
        <param name="indexes">検索対象のプロパティのインデックスの種類。 クラスのインデクサーなどのインデックスのプロパティに使用します。</param>
        <param name="modifiers">種類が変更されているパラメーターのシグネチャを使用するバインディングを有効にするパラメーター修飾子の配列。</param>
        <summary>指定した条件に基づいて、プロパティの指定したセットからプロパティを選択します。</summary>
        <returns>一致するプロパティです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドによって提供される選択を制御する、 `GetProperty` メソッドを `Type`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">既定のバインダー <paramref name="match" /> 一致している複数のプロパティを含む <paramref name="returnType" /> と <paramref name="indexes" />です。</exception>
        <exception cref="T:System.ArgumentException">既定のバインダー <paramref name="match" /> は <see langword="null" /> または空の配列。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>