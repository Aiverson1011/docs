<Type Name="SortedList" FullName="System.Collections.SortedList">
  <TypeSignature Language="C#" Value="public class SortedList : ICloneable, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.SortedList" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.SortedList/SortedListDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>キーによって並べ替えられ、キーとインデックスを使ってアクセスできる、キー\/値ペアのコレクションを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコレクションのジェネリック バージョンは、 <xref:System.Collections.Generic.SortedList%602?displayProperty=fullName>です。  
  
 A <xref:System.Collections.SortedList> 要素は、いずれかで、要素と同様に、キーを使用してアクセスできる <xref:System.Collections.IDictionary> 実装では、いずれかで、要素と同様に、インデックスを使用して、または <xref:System.Collections.IList> 実装します。  
  
 A <xref:System.Collections.SortedList> オブジェクトは、2 つの配列、リスト、つまり、キーの 1 つの配列の要素を格納し、関連付けられている値を別の配列に内部で保持します。 各要素は、キー\/値ペアとしてアクセスできる、 <xref:System.Collections.DictionaryEntry> オブジェクトです。 キーには `null`, 、値を指定できますが、します。  
  
 容量、 <xref:System.Collections.SortedList> オブジェクトは、要素の数、 <xref:System.Collections.SortedList> を保持できます。 要素が追加されると、 <xref:System.Collections.SortedList>, 、容量が増加すると自動的に再割り当て、必要に応じて。 呼び出すことによって、容量を削減できる <xref:System.Collections.SortedList.TrimToSize%2A> を設定したり、 <xref:System.Collections.SortedList.Capacity%2A> プロパティに明示的にします。  
  
 非常に大きな <xref:System.Collections.SortedList> オブジェクトを設定して、64 ビット システム上の 20億要素に最大の容量を増やすことができます、 `enabled` する構成要素の属性 `true` 、実行時の環境にします。  
  
 要素、 <xref:System.Collections.SortedList> オブジェクトは、キーによって並べ替えられますに従って特定のいずれかの <xref:System.Collections.IComparer> 実装では、時に指定された、 <xref:System.Collections.SortedList> 作成時またはそれに対応する、 <xref:System.IComparable> キー自体によって提供された実装。 いずれの場合、 <xref:System.Collections.SortedList> 重複キーではできません。  
  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、 <xref:System.Collections.SortedList> で正しい並べ替え順序、およびインデックス作成は、それに応じて調整します。 要素が削除されると、インデックス作成は、それに応じても調整します。 要素が追加されたり削除されたり、そのため、特定のキー\/値ペアのインデックスを変更可能性があります、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 操作、 <xref:System.Collections.SortedList> に対して操作をより低速傾向があるオブジェクト、 <xref:System.Collections.Hashtable> 並べ替えを行うためのオブジェクト。 ただし、 <xref:System.Collections.SortedList> の関連するキーまたはインデックスのいずれかの値へのアクセスを許可することで高い柔軟性を提供しています。  
  
 このコレクション内の要素は、整数インデックスを使用してアクセスできます。  このコレクションのインデックスは 0 から始まります。  
  
 `foreach` C\# 言語のステートメント \(`for each` Visual Basic で\)、コレクション内の要素の型のオブジェクトを返します。 各要素から、 <xref:System.Collections.SortedList> オブジェクトは、キー\/値ペアで要素型は、キーの型または値の型ではありません。 代わりに、要素型は <xref:System.Collections.DictionaryEntry>です。 例:  
  
 [!code-cpp[Classic SortedList Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic SortedList Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/remarks.cs#2)]
 [!code-vb[Classic SortedList Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/remarks.vb#2)]  
  
 `foreach` ステートメントは、コレクションに書き込まないことからのみ読み取りが許可される列挙子のラッパーです。  
  
   
  
## 例  
 次のコード例は、作成して初期化する方法を示しています、 <xref:System.Collections.SortedList> オブジェクトと、そのキーと値を印刷する方法です。  
  
 [!code-cpp[Classic SortedList Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>パブリック静的 \(<see langword="Shared" /> Visual Basic では\) この型のメンバーは、スレッド セーフであります。 インスタンス メンバーの場合は、スレッド セーフであるとは限りません。  
  
 A <see cref="T:System.Collections.SortedList" /> オブジェクト複数リーダー同時にサポートできます、コレクションが変更されない限り、します。 スレッド セーフを確保する、 <see cref="T:System.Collections.SortedList" />, 、によって返されるラッパーを通じて、すべての操作を行う必要があります、 <see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" /> メソッドです。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.Collections.IComparer" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.Generic.SortedList`2" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Collections.SortedList" /> 空では、クラスの既定の初期量を備え、に従って並べ替えられた、 <see cref="T:System.IComparable" /> に追加された各キーによって実装されるインターフェイス、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各キーを実装する必要があります、 <xref:System.IComparable> での他のすべてのキーとの比較ができるようにするインターフェイス、 <xref:System.Collections.SortedList> オブジェクトです。 要素は」の手順に従って、 <xref:System.IComparable> に追加された各キーの実装、 <xref:System.Collections.SortedList>です。  
  
 容量、 <xref:System.Collections.SortedList> オブジェクトは、要素の数を <xref:System.Collections.SortedList> を保持できます。 要素が追加されると、 <xref:System.Collections.SortedList>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 このコンス トラクターは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、別を使用するコレクションが作成 <xref:System.Collections.SortedList> コンス トラクターと、コレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList\_ctor\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList\_ctor\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList\_ctor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 または  
  
 <see langword="null" /> 使用する、 <see cref="T:System.IComparable" /> 各キーによって実装されます。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Collections.SortedList" /> 空では、クラスが既定の初期量を備えが並べ替えられて、指定に従って <see cref="T:System.Collections.IComparer" /> インターフェイスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素は、指定に従って <xref:System.Collections.IComparer> 実装します。 場合、 `comparer` パラメーターは `null`, 、 <xref:System.IComparable> 各キーの実装が使用されます。 したがって、各キーを実装する必要があります、 <xref:System.IComparable> でのその他のすべてのキーとの比較ができるようにするインターフェイス、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 容量、 <xref:System.Collections.SortedList> オブジェクトは、要素の数を <xref:System.Collections.SortedList> を保持できます。 要素が追加されると、 <xref:System.Collections.SortedList>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 このコンス トラクターは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例では、別を使用するコレクションが作成 <xref:System.Collections.SortedList> コンス トラクターと、コレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList\_ctor\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList\_ctor\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList\_ctor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> 実装を新しいコピーを <see cref="T:System.Collections.SortedList" /> オブジェクトです。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Collections.SortedList" /> を指定したディクショナリからコピーした要素を含むクラスは、コピーした要素の数と同じ初期量とに従って並べ替えられた、 <see cref="T:System.IComparable" /> 各キーによって実装されるインターフェイスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各キーを実装する必要があります、 <xref:System.IComparable> での他のすべてのキーとの比較ができるようにするインターフェイス、 <xref:System.Collections.SortedList> オブジェクトです。 要素は」の手順に従って、 <xref:System.IComparable> に追加された各キーの実装、 <xref:System.Collections.SortedList>です。  
  
 A <xref:System.Collections.Hashtable> オブジェクトの例は、 <xref:System.Collections.IDictionary> このコンス トラクターに渡すことができる実装します。 新しい <xref:System.Collections.SortedList> オブジェクトに格納された値、キーのコピーを格納して、 <xref:System.Collections.Hashtable>です。  
  
 容量、 <xref:System.Collections.SortedList> オブジェクトは、要素の数を <xref:System.Collections.SortedList> を保持できます。 要素が追加されると、 <xref:System.Collections.SortedList>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 このコンス トラクターは、O \(`n`\) 操作の場合、 `n` 内の要素の数は、 `d`です。  
  
   
  
## 例  
 次のコード例では、別を使用するコレクションが作成 <xref:System.Collections.SortedList> コンス トラクターと、コレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList\_ctorDictionary\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList\_ctorDictionary\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList\_ctorDictionary\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="d" /> 内の 1 つ以上の要素が、<see cref="T:System.IComparable" /> インターフェイスを実装していません。</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity">最初の要素数を <see cref="T:System.Collections.SortedList" /> オブジェクトを含めることができます。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Collections.SortedList" /> 空では、クラスが指定した初期量を備え、に従って並べ替えられた、 <see cref="T:System.IComparable" /> に追加された各キーによって実装されるインターフェイス、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各キーを実装する必要があります、 <xref:System.IComparable> での他のすべてのキーとの比較ができるようにするインターフェイス、 <xref:System.Collections.SortedList> オブジェクトです。 要素は」の手順に従って、 <xref:System.IComparable> に追加された各キーの実装、 <xref:System.Collections.SortedList>です。  
  
 容量、 <xref:System.Collections.SortedList> オブジェクトは、要素の数を <xref:System.Collections.SortedList> を保持できます。 要素が追加されると、 <xref:System.Collections.SortedList>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 このコンス トラクターは、O \(`n`\) 操作の場合、 `n` は `initialCapacity`です。  
  
   
  
## 例  
 次のコード例では、別を使用するコレクションが作成 <xref:System.Collections.SortedList> コンス トラクターと、コレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList\_ctorInt\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList\_ctorInt\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList\_ctorInt\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCapacity" /> が 0 未満です。</exception>
        <exception cref="T:System.OutOfMemoryException">作成するための十分な使用可能なメモリがない、 <see cref="T:System.Collections.SortedList" /> 、指定したオブジェクト <paramref name="initialCapacity" />します。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 または  
  
 <see langword="null" /> 使用する、 <see cref="T:System.IComparable" /> 各キーによって実装されます。</param>
        <param name="capacity">最初の要素数を <see cref="T:System.Collections.SortedList" /> オブジェクトを含めることができます。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Collections.SortedList" /> 空では、クラスを選択し、指定した初期量を備えが並べ替えられて、指定に従って <see cref="T:System.Collections.IComparer" /> インターフェイスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素は、指定に従って <xref:System.Collections.IComparer> 実装します。 場合、 `comparer` パラメーターは `null`, 、 <xref:System.IComparable> 各キーの実装が使用されます。 したがって、各キーを実装する必要があります、 <xref:System.IComparable> でのその他のすべてのキーとの比較ができるようにするインターフェイス、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 容量、 <xref:System.Collections.SortedList> オブジェクトは、要素の数を <xref:System.Collections.SortedList> を保持できます。 要素が追加されると、 <xref:System.Collections.SortedList>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 このコンス トラクターは、O \(`n`\) 操作の場合、 `n` は `capacity`です。  
  
   
  
## 例  
 次のコード例では、別を使用するコレクションが作成 <xref:System.Collections.SortedList> コンス トラクターと、コレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList\_ctorInt\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList\_ctorInt\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList\_ctorInt\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> が 0 未満です。</exception>
        <exception cref="T:System.OutOfMemoryException">作成するための十分な使用可能なメモリがない、 <see cref="T:System.Collections.SortedList" /> 、指定したオブジェクト <paramref name="capacity" />します。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">
          <see cref="T:System.Collections.IDictionary" /> 実装を新しいコピーを <see cref="T:System.Collections.SortedList" /> オブジェクトです。</param>
        <param name="comparer">キーの比較時に使用する <see cref="T:System.Collections.IComparer" /> の実装。  
  
 または  
  
 <see langword="null" /> 使用する、 <see cref="T:System.IComparable" /> 各キーによって実装されます。</param>
        <summary>新しいインスタンスを初期化、 <see cref="T:System.Collections.SortedList" /> を指定したディクショナリからコピーした要素を含むクラスは、コピーした要素の数と同じ初期量とが並べ替えられて、指定に従って <see cref="T:System.Collections.IComparer" /> インターフェイスです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素は、指定に従って <xref:System.Collections.IComparer> 実装します。 場合、 `comparer` パラメーターは `null`, 、 <xref:System.IComparable> 各キーの実装が使用されます。 したがって、各キーを実装する必要があります、 <xref:System.IComparable> でのその他のすべてのキーとの比較ができるようにするインターフェイス、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 A <xref:System.Collections.Hashtable> オブジェクトの例は、 <xref:System.Collections.IDictionary> このコンス トラクターに渡すことができる実装します。 新しい <xref:System.Collections.SortedList> オブジェクトに格納された値、キーのコピーを格納して、 <xref:System.Collections.Hashtable>です。  
  
 容量、 <xref:System.Collections.SortedList> オブジェクトは、要素の数を <xref:System.Collections.SortedList> を保持できます。 要素が追加されると、 <xref:System.Collections.SortedList>, 、容量が増加すると自動的に内部の配列を再割り当てすることで必要とします。  
  
 初期量を指定する、さまざまな要素を追加するときにサイズ変更操作を実行する必要があるコレクションのサイズを推定できる場合、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 このコンス トラクターは、O \(`n`\) 操作の場合、 `n` 内の要素の数は、 `d`です。  
  
   
  
## 例  
 次のコード例では、別を使用するコレクションが作成 <xref:System.Collections.SortedList> コンス トラクターと、コレクションの動作の違いを示しています。  
  
 [!code-cpp[System.Collections.SortedList\_ctorDictionary\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList\_ctorDictionary\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList\_ctorDictionary\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="comparer" /> が <see langword="null" /> であり、かつ <paramref name="d" /> 内の 1 つ以上の要素で、<see cref="T:System.IComparable" /> インターフェイスが実装されていません。</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">追加する要素のキー。</param>
        <param name="value">追加する要素の値。 値として <see langword="null" /> を指定できます。</param>
        <summary>指定したキーと値を持つ要素を追加、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 カーソルは、比較演算子を選択すると、明示的にまたは既定では、いずれかで決まるときに、 <xref:System.Collections.SortedList> オブジェクトが作成されました。  
  
 場合 <xref:System.Collections.SortedList.Count%2A> と既に同じ <xref:System.Collections.SortedList.Capacity%2A>, 、容量、 <xref:System.Collections.SortedList> オブジェクトが内部の配列を自動的に再割り当てが増加し、新しい要素が追加される前に、既存の要素が新しい配列にコピーします。  
  
 使用することも、 <xref:System.Collections.SortedList.Item%2A> にキーの値を設定して新しい要素を追加するプロパティが存在しない、 <xref:System.Collections.SortedList> オブジェクト \(たとえば、 `myCollection["myNonexistentKey"] = myValue`\)。 ただしで指定したキーが既に存在する場合、 <xref:System.Collections.SortedList>, で、設定、 <xref:System.Collections.SortedList.Item%2A> プロパティには、古い値が上書きされます。 これに対し、 <xref:System.Collections.SortedList.Add%2A> メソッドでは、既存の要素は変更しません。  
  
 要素、 <xref:System.Collections.SortedList> オブジェクトは、キーによって並べ替えられますに従って特定のいずれかの <xref:System.Collections.IComparer> 実装では、時に指定された、 <xref:System.Collections.SortedList> 作成時またはそれに対応する、 <xref:System.IComparable> キー自体によって提供された実装。  
  
 キーには `null`, 、値を指定できますが、します。  
  
 このメソッドは O \(`n`\) 並べ替えられていないデータの操作、 `n` は <xref:System.Collections.SortedList.Count%2A>です。 新しい要素がリストの末尾に追加された場合は、O\(log `n`\) 操作になります。 カーソルでは、サイズ変更が発生する場合、操作は O \(`n`\)。  
  
   
  
## 例  
 次のコード例は、要素を追加する方法を示しています、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 [!code-cpp[Classic SortedList.Add Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Add Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Add Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">指定した要素 <paramref name="key" /> に既に存在する、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。  
  
 または  
  
 <see cref="T:System.Collections.SortedList" /> を使用する設定、 <see cref="T:System.IComparable" /> インターフェイス、および <paramref name="key" /> が実装していない、 <see cref="T:System.IComparable" /> インターフェイスです。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.SortedList" /> は読み取り専用です。  
  
 \-または\-  
  
 <see cref="T:System.Collections.SortedList" /> のサイズが固定されています。</exception>
        <exception cref="T:System.OutOfMemoryException">要素を追加するための十分な使用可能なメモリがない、 <see cref="T:System.Collections.SortedList" />です。</exception>
        <exception cref="T:System.InvalidOperationException">比較演算子では、例外をスローします。</exception>
        <altmember cref="P:System.Collections.SortedList.Item(System.Object)" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または設定の容量、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <value>要素の数を <see cref="T:System.Collections.SortedList" /> オブジェクトを含めることができます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.SortedList.Capacity%2A> 要素の数を <xref:System.Collections.SortedList> オブジェクトを格納できます。<xref:System.Collections.SortedList.Count%2A> 実際に含まれる要素の数が、 <xref:System.Collections.SortedList>です。  
  
 <xref:System.Collections.SortedList.Capacity%2A> 以上の値には、常に <xref:System.Collections.SortedList.Count%2A>します。 場合 <xref:System.Collections.SortedList.Count%2A> を超える <xref:System.Collections.SortedList.Capacity%2A> 要素を追加するときに、容量は自動的に変更前の要素をコピーし、新しい要素を追加する前に、内部配列の再割り当てして増加します。  
  
 呼び出すことによって、容量を削減できる <xref:System.Collections.SortedList.TrimToSize%2A> を設定したり、 <xref:System.Collections.SortedList.Capacity%2A> プロパティに明示的にします。 ときに、値の <xref:System.Collections.SortedList.Capacity%2A> を設定すると、明示的に指定した容量に合わせて、内部配列が再割り当てもします。  
  
 このプロパティの値を取得する場合は、o \(1\) 操作です。O は、プロパティを設定 \(`n`\) 操作、 `n` 新しい容量します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">割り当てられている値が現在の要素数より小さい、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</exception>
        <exception cref="T:System.OutOfMemoryException">システムで使用可能なメモリが不足しています。</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Collections.SortedList" /> オブジェクトからすべての要素を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.SortedList.Count%2A> 0 に設定し、コレクションの要素からその他のオブジェクトへの参照も解放します。  
  
 <xref:System.Collections.SortedList.Capacity%2A> 変更されません。 容量をリセットする、 <xref:System.Collections.SortedList> オブジェクトで呼び出す <xref:System.Collections.SortedList.TrimToSize%2A> 設定や、 <xref:System.Collections.SortedList.Capacity%2A> プロパティを直接します。 空のトリミング <xref:System.Collections.SortedList> のキャパシティを設定、 <xref:System.Collections.SortedList> を既定の容量。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.SortedList.Count%2A>です。  
  
   
  
## 例  
 次のコード例は、未使用の部分をトリミングする方法を示しています、 <xref:System.Collections.SortedList> オブジェクトとの値をクリアする方法、 <xref:System.Collections.SortedList>です。  
  
 [!code-cpp[Classic SortedList.Clear Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.SortedList" /> オブジェクトは読み取り専用です。  
  
 または  
  
 <see cref="T:System.Collections.SortedList" /> のサイズが固定されています。</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>簡易コピーを作成、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <returns>簡易コピー、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コレクションの簡易コピーは、参照型または値の型が参照先オブジェクトをコピーしないかどうか、コレクションの要素のみをコピーします。 新しいコレクション内の参照は、元のコレクション内の参照を指しているのと同じオブジェクトをポイントします。  
  
 これに対し、コレクションの詳細コピーが、要素をコピーし、要素が直接または間接的に参照するすべてします。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.SortedList.Count%2A>です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Collections.SortedList" /> オブジェクト内で検索されるキー。</param>
        <summary>指定するかどうか、 <see cref="T:System.Collections.SortedList" /> オブジェクトには、特定のキーが含まれています。</summary>
        <returns>
          <see langword="true" /> 場合、 <see cref="T:System.Collections.SortedList" /> オブジェクトには、指定した要素が含まれる <paramref name="key" />。 そうしないと、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素、 <xref:System.Collections.SortedList> オブジェクトは、キーによって並べ替えられますに従って特定のいずれかの <xref:System.Collections.IComparer> 実装では、時に指定された、 <xref:System.Collections.SortedList> 作成時またはそれに対応する、 <xref:System.IComparable> キー自体によって提供された実装。  
  
 <xref:System.Collections.SortedList.Contains%2A> は、<xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName> を実装します。 まったく同様に機能 <xref:System.Collections.SortedList.ContainsKey%2A>です。  
  
 このメソッドは、バイナリ サーチ アルゴリズムを使用します。そのため、このメソッドは、O\(log `n`\) 操作では、ここで `n` は <xref:System.Collections.SortedList.Count%2A>です。  
  
 以降、.NET Framework 2.0 では、このメソッドを使用して、コレクションのオブジェクトの <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> メソッド `item` 項目が存在するかどうかを調べる。 .NET Framework の以前のバージョンでは、この判断を下しますを使用して行われた、 <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> のメソッド、 `item` コレクション内のオブジェクトのパラメーターです。  
  
   
  
## 例  
 次のコード例を確認する方法を示して かどうか、 <xref:System.Collections.SortedList> オブジェクトには、特定の要素が含まれています。  
  
 [!code-cpp[Classic SortedList.Contains Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">比較演算子では、例外をスローします。</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Collections.SortedList" /> オブジェクト内で検索されるキー。</param>
        <summary>指定するかどうか、 <see cref="T:System.Collections.SortedList" /> オブジェクトには、特定のキーが含まれています。</summary>
        <returns>
          <see langword="true" /> 場合、 <see cref="T:System.Collections.SortedList" /> オブジェクトには、指定した要素が含まれる <paramref name="key" />。 そうしないと、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素、 <xref:System.Collections.SortedList> オブジェクトは、キーによって並べ替えられますに従って特定のいずれかの <xref:System.Collections.IComparer> 実装では、時に指定された、 <xref:System.Collections.SortedList> 作成時またはそれに対応する、 <xref:System.IComparable> キー自体によって提供された実装。  
  
 このメソッドは、 <xref:System.Collections.SortedList.Contains%2A> メソッドです。  
  
 このメソッドは、バイナリ サーチ アルゴリズムを使用します。そのため、このメソッドは、O\(log `n`\) 操作では、ここで `n` は <xref:System.Collections.SortedList.Count%2A>です。  
  
 以降、.NET Framework 2.0 では、このメソッドを使用して、コレクションのオブジェクトの <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> メソッド `item` 項目が存在するかどうかを調べる。 .NET Framework の以前のバージョンでは、この判断を下しますを使用して行われた、 <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> のメソッド、 `item` コレクション内のオブジェクトのパラメーターです。  
  
   
  
## 例  
 次のコード例を確認する方法を示して かどうか、 <xref:System.Collections.SortedList> オブジェクトには、特定の要素が含まれています。  
  
 [!code-cpp[Classic SortedList.Contains Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">比較演算子では、例外をスローします。</exception>
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsValue(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">内で検索する値、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。 値として <see langword="null" /> を指定できます。</param>
        <summary>指定するかどうか、 <see cref="T:System.Collections.SortedList" /> オブジェクトには、特定の値が含まれています。</summary>
        <returns>
          <see langword="true" /> 場合、 <see cref="T:System.Collections.SortedList" /> オブジェクトには、指定した要素が含まれる <paramref name="value" />。 そうしないと、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素の値、 <xref:System.Collections.SortedList> オブジェクトを使用して、指定した値と比較、 <xref:System.Object.Equals%2A> メソッドです。  
  
 このメソッドは、一方向の検索を実行します。したがって、平均実行時間に比例 <xref:System.Collections.SortedList.Count%2A>します。 たとえば、このメソッドは、O \(`n`\) 操作、ここで `n` は <xref:System.Collections.SortedList.Count%2A>です。  
  
 以降、.NET Framework 2.0 では、このメソッドを使用して、コレクションのオブジェクトの <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> メソッド `item` 項目が存在するかどうかを調べる。 .NET Framework の以前のバージョンでは、この判断を下しますを使用して行われた、 <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> のメソッド、 `item` コレクション内のオブジェクトのパラメーターです。  
  
   
  
## 例  
 次のコード例を確認する方法を示して かどうか、 <xref:System.Collections.SortedList> オブジェクトには、特定の要素が含まれています。  
  
 [!code-cpp[Classic SortedList.Contains Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">1 次元 <see cref="T:System.Array" /> オブジェクトのコピー先である、 <see cref="T:System.Collections.DictionaryEntry" /> からコピーされるオブジェクト <see cref="T:System.Collections.SortedList" />します。<see cref="T:System.Array" /> には、0 から始まるインデックス番号が必要です。</param>
        <param name="arrayIndex">コピーの開始位置とする <c>array</c> のインデックス \(0 から始まる\)。</param>
        <summary>コピー <see cref="T:System.Collections.SortedList" /> 要素を 1 次元 <see cref="T:System.Array" /> オブジェクト、配列の指定したインデックスから始まります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 キー\/値ペアをコピー、 <xref:System.Array> オブジェクトを列挙子が反復処理する順序と同じ順序で、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 キーだけをコピーする、 <xref:System.Collections.SortedList>, を使用して `SortedList.Keys.CopyTo`します。  
  
 値だけをコピーする、 <xref:System.Collections.SortedList>, を使用して `SortedList.Values.CopyTo`します。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.SortedList.Count%2A>です。  
  
   
  
## 例  
 次のコード例の値をコピーする方法を示しています、 <xref:System.Collections.SortedList> オブジェクトを 1 次元 <xref:System.Array> オブジェクトです。  
  
 [!code-cpp[Classic SortedList.CopyTo Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.CopyTo Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.CopyTo Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> が多次元です。  
  
 または  
  
 ソース内の要素の数 <see cref="T:System.Collections.SortedList" /> オブジェクトがから使用可能な領域より大きい <paramref name="arrayIndex" /> 変換先の末尾に <paramref name="array" />します。</exception>
        <exception cref="T:System.InvalidCastException">ソースの種類 <see cref="T:System.Collections.SortedList" /> 先の型に自動的にキャストできない <paramref name="array" />します。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.SortedList.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>含まれる要素の数を取得、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <value>含まれる要素の数、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 各要素は、キー\/値ペアとしてアクセスできる、 <xref:System.Collections.DictionaryEntry> オブジェクトです。  
  
 <xref:System.Collections.SortedList.Capacity%2A> 要素の数を <xref:System.Collections.SortedList> オブジェクトを格納できます。<xref:System.Collections.SortedList.Count%2A> 実際に含まれる要素の数が、 <xref:System.Collections.SortedList>です。  
  
 <xref:System.Collections.SortedList.Capacity%2A> 以上の値には、常に <xref:System.Collections.SortedList.Count%2A>します。 場合 <xref:System.Collections.SortedList.Count%2A> を超える <xref:System.Collections.SortedList.Capacity%2A> 要素を追加するときに、容量は自動的に変更前の要素をコピーし、新しい要素を追加する前に、内部配列の再割り当てして増加します。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetByIndex">
      <MemberSignature Language="C#" Value="public virtual object GetByIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetByIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetByIndex(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得する値の 0 から始まるインデックス。</param>
        <summary>指定したインデックスの値を取得、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <returns>指定したインデックス位置にある値、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、 <xref:System.Collections.SortedList> で正しい並べ替え順序、およびインデックス作成は、それに応じて調整します。 要素が削除されると、インデックス作成は、それに応じても調整します。 要素が追加されたり削除されたり、そのため、特定のキー\/値ペアのインデックスを変更可能性があります、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例は、1 つまたはすべてのキーを取得する方法を示しますまたは値、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 有効なインデックスの範囲から外れて、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します。、 <see cref="T:System.Collections.IDictionaryEnumerator" /> を反復処理するオブジェクト、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <returns>
          <see cref="T:System.Collections.IDictionaryEnumerator" /> オブジェクトの <see cref="T:System.Collections.SortedList" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 C\# 言語の `foreach` ステートメント \(Visual Basic の場合は `for each`\) を使用することで列挙子の複雑さを回避できます。  したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。<xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。  この位置では、<xref:System.Collections.IEnumerator.Current%2A> が未定義です。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、<xref:System.Collections.IEnumerator.Current%2A> は定義されていません。<xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 コレクションに対して変更 \(要素の追加、変更、削除など\) が行われると、列挙子は回復不可能な無効状態になり、その動作は未定義になります。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。  列挙処理でスレッド セーフを確保するには、列挙処理が終わるまでコレクションをロックできます。  コレクションに対し複数のスレッドがアクセスして読み取りや書き込みを行うことができるようにするには、独自に同期化を実装する必要があります。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetKey">
      <MemberSignature Language="C#" Value="public virtual object GetKey (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetKey(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKey(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">取得するキーの 0 から始まるインデックス。</param>
        <summary>指定したインデックスにあるキーを取得、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <returns>キーの指定したインデックスにある、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、 <xref:System.Collections.SortedList> で正しい並べ替え順序、およびインデックス作成は、それに応じて調整します。 要素が削除されると、インデックス作成は、それに応じても調整します。 要素が追加されたり削除されたり、そのため、特定のキー\/値ペアのインデックスを変更可能性があります、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例は、1 つまたはすべてのキーを取得する方法を示しますまたは値、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 有効なインデックスの範囲から外れて、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetKeyList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetKeyList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetKeyList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKeyList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キーを取得します、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <returns>
          <see cref="T:System.Collections.IList" /> 内のキーを格納するオブジェクト、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Collections.IList> オブジェクトは、のキーの読み取り専用ビュー、 <xref:System.Collections.SortedList> オブジェクトです。 基になるに加えられた変更 <xref:System.Collections.SortedList> すぐに反映されます、 <xref:System.Collections.IList>です。  
  
 返された要素 <xref:System.Collections.IList> のキーと同じ順序で並べ替えられて、 <xref:System.Collections.SortedList>です。  
  
 このメソッドは、 <xref:System.Collections.SortedList.Keys%2A> ですが、取得、 <xref:System.Collections.IList> オブジェクトの代わりに、 <xref:System.Collections.ICollection> オブジェクトです。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例は、1 つまたはすべてのキーを取得する方法を示しますまたは値、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
      </Docs>
    </Member>
    <Member MemberName="GetValueList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetValueList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetValueList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetValueList" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>内の値を取得、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <returns>
          <see cref="T:System.Collections.IList" /> オブジェクトの値を含む、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Collections.IList> オブジェクトは、の値の読み取り専用ビュー、 <xref:System.Collections.SortedList> オブジェクトです。 基になるに加えられた変更 <xref:System.Collections.SortedList> すぐに反映されます、 <xref:System.Collections.IList>です。  
  
 返された要素 <xref:System.Collections.IList> の値と同じ順序で並べ替えられて、 <xref:System.Collections.SortedList>です。  
  
 このメソッドは、 <xref:System.Collections.SortedList.Values%2A> ですが、取得、 <xref:System.Collections.IList> オブジェクトの代わりに、 <xref:System.Collections.ICollection> オブジェクトです。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例は、1 つまたはすべてのキーを取得する方法を示しますまたは値、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 [!code-cpp[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <altmember cref="P:System.Collections.SortedList.Values" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public virtual int IndexOfKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">
          <see cref="T:System.Collections.SortedList" /> オブジェクト内で検索されるキー。</param>
        <summary>指定したキーの 0 から始まるインデックスを返す、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <returns>0 から始まるインデックス、 <paramref name="key" /> パラメーター場合 <paramref name="key" /> で見つかった、 <see cref="T:System.Collections.SortedList" /> オブジェクト。 それ以外の場合、\-1 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 要素、 <xref:System.Collections.SortedList> オブジェクトは、キーによって並べ替えられますに従って特定のいずれかの <xref:System.Collections.IComparer> 実装では、時に指定された、 <xref:System.Collections.SortedList> が作成された、またはそれに対応する、 <xref:System.IComparable> キー自体によって提供された実装。  
  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、 <xref:System.Collections.SortedList> で正しい並べ替え順序、およびインデックス作成は、それに応じて調整します。 要素が削除されると、インデックス作成は、それに応じても調整します。 要素が追加されたり削除されたり、そのため、特定のキー\/値ペアのインデックスを変更可能性があります、 <xref:System.Collections.SortedList>です。  
  
 このメソッドは、バイナリ サーチ アルゴリズムを使用します。そのため、このメソッドは、O\(log `n`\) 操作では、ここで `n` は <xref:System.Collections.SortedList.Count%2A>です。  
  
 以降、.NET Framework 2.0 では、このメソッドを使用して、コレクションのオブジェクトの <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> メソッド `item` 項目が存在するかどうかを調べる。 .NET Framework の以前のバージョンでは、この判断を下しますを使用して行われた、 <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> のメソッド、 `item` コレクション内のオブジェクトのパラメーターです。  
  
   
  
## 例  
 次のコード例は、キーまたは値のインデックスを特定する方法を示しています、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">比較演算子では、例外をスローします。</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public virtual int IndexOfValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">内で検索する値、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。 値として <see langword="null" /> を指定できます。</param>
        <summary>指定された値の最初に見つかった位置の 0 から始まるインデックスを返します、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <returns>最初に見つかった位置の 0 から始まるインデックス、 <paramref name="value" /> パラメーター場合 <paramref name="value" /> で見つかった、 <see cref="T:System.Collections.SortedList" /> オブジェクト。 それ以外の場合、\-1 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、 <xref:System.Collections.SortedList> で正しい並べ替え順序、およびインデックス作成は、それに応じて調整します。 要素が削除されると、インデックス作成は、それに応じても調整します。 要素が追加されたり削除されたり、そのため、特定のキー\/値ペアのインデックスを変更可能性があります、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 要素の値、 <xref:System.Collections.SortedList> を使用して、指定した値と比較、 <xref:System.Object.Equals%2A> メソッドです。  
  
 このメソッドは、一方向の検索を使用します。そのため、このメソッドは、O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.SortedList.Count%2A>です。  
  
 以降、.NET Framework 2.0 では、このメソッドを使用して、コレクションのオブジェクトの <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> メソッド `item` 項目が存在するかどうかを調べる。 .NET Framework の以前のバージョンでは、この判断を下しますを使用して行われた、 <xref:System.Object.Equals%2A> と <xref:System.IComparable.CompareTo%2A> のメソッド、 `item` コレクション内のオブジェクトのパラメーターです。  
  
   
  
## 例  
 次のコード例は、キーまたは値のインデックスを特定する方法を示しています、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Collections.SortedList" /> オブジェクトのサイズが固定されています。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Collections.SortedList" /> オブジェクトが固定サイズでない場合は <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 固定サイズのコレクションは、追加または削除できません要素のコレクションが作成された後で、既存の要素の変更はできます。  
  
 固定サイズのコレクションは、コレクションの追加と要素の削除を防止するラッパーです。そのため、追加または削除、要素を含む、基になるコレクションに変更が加えられた場合、固定サイズ コレクションにはそれらの変更が反映されます。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>示す値を取得するかどうか、 <see cref="T:System.Collections.SortedList" /> オブジェクトは読み取り専用です。</summary>
        <value>
          <see langword="true" /> 場合、 <see cref="T:System.Collections.SortedList" /> オブジェクトが読み取り専用でない場合は <see langword="false" />です。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 読み取り専用のコレクションでは、コレクション作成後に要素の追加、削除、または変更はできません。  
  
 読み取り専用であるコレクションは、コレクションのコレクションの変更を防止するラッパーです。そのため、基になるコレクションの変更が加えられた、読み取り専用コレクションはそれらの変更を反映します。  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アクセスをするかどうかを示す値を取得、 <see cref="T:System.Collections.SortedList" /> オブジェクトが同期されている \(スレッド セーフ\)。</summary>
        <value>
          <see langword="true" /> オブジェクトへのアクセスが同期されている \(スレッド セーフである\) 場合は <see cref="T:System.Collections.SortedList" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッド セーフを確保する、 <xref:System.Collections.SortedList> オブジェクトによって返されるラッパーを通じて、すべての操作を行う必要があります、 <xref:System.Collections.SortedList.Synchronized%2A> メソッドです。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
   
  
## 例  
 次のコード例を使用してコレクションをロックする方法を示しています、 <xref:System.Collections.SortedList.SyncRoot%2A> 列挙中にプロパティです。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 次のコード例を同期する方法を示しています、 <xref:System.Collections.SortedList> オブジェクトを特定しているかどうか、 <xref:System.Collections.SortedList> が同期されているし、同期を使用して <xref:System.Collections.SortedList>します。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Item(System.Object)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">取得または設定する値に関連付けられたキー。</param>
        <summary>取得し、\[特定のキーに関連付けられている値を設定、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <value>関連付けられている値、 <paramref name="key" /> 内のパラメーター、 <see cref="T:System.Collections.SortedList" /> 場合 <paramref name="key" /> 場合は、 <see langword="null" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することができます、 <xref:System.Collections.SortedList.Item%2A> 、次の構文を指定することによって、コレクション内の特定の要素にアクセスするプロパティ。 `myCollection[key]`します。  
  
 このプロパティを使用してに存在しないキーの値を設定して新しい要素を追加する、 <xref:System.Collections.SortedList> オブジェクト \(たとえば、 `myCollection["myNonexistentKey"] = myValue)`です。 ただしで指定したキーが既に存在する場合、 <xref:System.Collections.SortedList>, で、設定、 <xref:System.Collections.SortedList.Item%2A> プロパティには、古い値が上書きされます。 これに対し、 <xref:System.Collections.SortedList.Add%2A> メソッドでは、既存の要素は変更しません。  
  
 キーには `null`, 、値を指定できますが、します。 識別するために `null` 、指定したキーが見つからないために返されると `null` 指定したキーの値が返される `null`, を使用して、 <xref:System.Collections.SortedList.Contains%2A> メソッドまたは <xref:System.Collections.SortedList.ContainsKey%2A> 一覧で、キーが存在するかどうかを決定する方法です。  
  
 要素、 <xref:System.Collections.SortedList> キーによって並べ替えに従って特定のいずれかの <xref:System.Collections.IComparer> 実装では、時に指定された、 <xref:System.Collections.SortedList> 作成時またはそれに対応する、 <xref:System.IComparable> キー自体によって提供された実装。  
  
 C\# 言語キーワードを使用して実装する代わりに、インデクサーの定義、 <xref:System.Collections.SortedList.Keys%2A>プロパティです。 Visual Basic は、<xref:System.Collections.SortedList.Item%2A> を既定のプロパティとして実装しており、同様のインデックス機能を提供します。  
  
 O\(log `n`\) 操作は、このプロパティの値を取得する場所 `n` は <xref:System.Collections.SortedList.Count%2A>です。 キーになっている場合は O\(log `n`\) 操作にプロパティを設定、 <xref:System.Collections.SortedList>です。 キーが一覧にない場合、プロパティは設定は O \(`n`\) 並べ替えられていないデータまたは O\(log `n`\) 一覧の最後に、新しい要素が追加された場合の操作です。 カーソルでは、サイズ変更が発生する場合、操作は O \(`n`\)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">プロパティが設定され、 <see cref="T:System.Collections.SortedList" /> オブジェクトは読み取り専用です。  
  
 または  
  
 プロパティを設定すると、 <paramref name="key" /> 、コレクションに存在しません、 <see cref="T:System.Collections.SortedList" /> のサイズが固定されています。</exception>
        <exception cref="T:System.OutOfMemoryException">要素を追加するための十分な使用可能なメモリがない、 <see cref="T:System.Collections.SortedList" />です。</exception>
        <exception cref="T:System.InvalidOperationException">比較演算子では、例外をスローします。</exception>
        <altmember cref="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キーを取得します、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> 内のキーを格納するオブジェクト、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.ICollection> オブジェクトは、のキーの読み取り専用ビュー、 <xref:System.Collections.SortedList> オブジェクトです。 基になるに加えられた変更 <xref:System.Collections.SortedList> すぐに反映されます、 <xref:System.Collections.ICollection>です。  
  
 要素、 <xref:System.Collections.ICollection> のキーと同じ順序で並べ替えられて、 <xref:System.Collections.SortedList>です。  
  
 このプロパティは、 <xref:System.Collections.SortedList.GetKeyList%2A> メソッドが返す、 <xref:System.Collections.ICollection> の代わりにオブジェクト、 <xref:System.Collections.IList> オブジェクトです。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Values" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Remove(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">削除する要素のキー。</param>
        <summary>指定したキーを持つ要素を削除、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定したキーを持つ要素が <xref:System.Collections.SortedList> オブジェクトに格納されていない場合、<xref:System.Collections.SortedList> は変更されません。 例外をスローすることはありません。  
  
 リストなどの連続する要素のコレクションでは、空白になった位置を埋めるために、削除された要素の後にある要素の位置が繰り上げられます。 コレクションにインデックスがある場合、移動した要素のインデックスも更新されます。 この動作は、要素が概念的にバケットにグループ化されているハッシュ テーブルなどのコレクションには適用されません。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.SortedList.Count%2A>です。  
  
   
  
## 例  
 次のコード例は、要素を削除する方法を示しています、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 [!code-cpp[Classic SortedList.RemoveAt Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.SortedList" /> オブジェクトは読み取り専用です。  
  
 または  
  
 <see cref="T:System.Collections.SortedList" /> のサイズが固定されています。</exception>
        <altmember cref="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">削除する要素の 0 から始まるインデックス。</param>
        <summary>指定したインデックス位置の要素を削除、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、 <xref:System.Collections.SortedList> で正しい並べ替え順序、およびインデックス作成は、それに応じて調整します。 要素が削除されると、インデックス作成は、それに応じても調整します。 要素が追加されたり削除されたり、そのため、特定のキー\/値ペアのインデックスを変更可能性があります、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 リストなどの連続する要素のコレクションでは、空白になった位置を埋めるために、削除された要素の後にある要素の位置が繰り上げられます。 コレクションにインデックスがある場合、移動した要素のインデックスも更新されます。 この動作は、要素が概念的にバケットにグループ化されているハッシュ テーブルなどのコレクションには適用されません。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.SortedList.Count%2A>です。  
  
   
  
## 例  
 次のコード例は、要素を削除する方法を示しています、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 [!code-cpp[Classic SortedList.RemoveAt Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 有効なインデックスの範囲から外れて、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.SortedList" /> は読み取り専用です。  
  
 \-または\-  
  
 <see cref="T:System.Collections.SortedList" /> のサイズが固定されています。</exception>
        <altmember cref="M:System.Collections.SortedList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SetByIndex">
      <MemberSignature Language="C#" Value="public virtual void SetByIndex (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetByIndex(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">保存先となる位置の 0 から始まるインデックス <c>value</c>します。</param>
        <param name="value">
          <see cref="T:System.Object" /> に保存する、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。 値として <see langword="null" /> を指定できます。</param>
        <summary>特定のインデックスにある値を置換する <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インデックス順序は、並べ替え順序に基づいています。 挿入される要素が追加されると、 <xref:System.Collections.SortedList> で正しい並べ替え順序、およびインデックス作成は、それに応じて調整します。 要素が削除されると、インデックス作成は、それに応じても調整します。 要素が追加されたり削除されたり、そのため、特定のキー\/値ペアのインデックスを変更可能性があります、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 このメソッドは、o \(1\) 操作です。  
  
   
  
## 例  
 次のコード例で既存の要素の値を交換する方法を示しています、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 [!code-cpp[Classic SortedList.SetByIndex Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.SetByIndex Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.SetByIndex Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 有効なインデックスの範囲から外れて、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.SortedList Synchronized (System.Collections.SortedList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.SortedList Synchronized(class System.Collections.SortedList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.SortedList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.SortedList" />
      </Parameters>
      <Docs>
        <param name="list">同期する <see cref="T:System.Collections.SortedList" /> オブジェクト。</param>
        <summary>用の同期 \(スレッド セーフな\) ラッパーを返す、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <returns>同期された \(スレッド セーフな\) ラッパーを <see cref="T:System.Collections.SortedList" /> オブジェクトです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 スレッド セーフを確保する、 <xref:System.Collections.SortedList> オブジェクトに、このラッパー経由のすべての操作を行う必要があります。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
   
  
## 例  
 次のコード例を使用してコレクションをロックする方法を示しています、 <xref:System.Collections.SortedList.SyncRoot%2A> 列挙中にプロパティです。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 このメソッドは、o \(1\) 操作です。  
  
 次のコード例を同期する方法を示しています、 <xref:System.Collections.SortedList> オブジェクトを特定しているかどうか、 <xref:System.Collections.SortedList> が同期されているし、同期を使用して <xref:System.Collections.SortedList>します。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="list" /> は <see langword="null" /> です。</exception>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アクセスを同期するために使用できるオブジェクトを取得、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <value>
          <see cref="T:System.Collections.SortedList" /> オブジェクトへのアクセスを同期するために使用できるオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 同期されたバージョンを作成する、 <xref:System.Collections.SortedList> オブジェクトを使用して、 <xref:System.Collections.SortedList.Synchronized%2A> メソッドです。 ただし、派生クラスが備わっての同期バージョンを独自の <xref:System.Collections.SortedList> を使用して、 <xref:System.Collections.SortedList.SyncRoot%2A> プロパティです。 同期されたコードに対して操作を実行、 <xref:System.Collections.SortedList.SyncRoot%2A> の <xref:System.Collections.SortedList>, 、上で直接、 <xref:System.Collections.SortedList>です。 これにより、他のオブジェクトから派生したコレクションを適切に操作できるようになります。 具体的には、同時に変更する可能性があるその他のスレッドと、正常な同期を維持、 <xref:System.Collections.SortedList> オブジェクトです。  
  
 コレクションの列挙は、本質的にスレッド セーフなプロシージャではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
   
  
## 例  
 次のコード例を使用してコレクションをロックする方法を示しています、 <xref:System.Collections.SortedList.SyncRoot%2A> 列挙中にプロパティです。  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example\#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example\#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 このプロパティ値を取得することは、O\(1\) 操作になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返します。、 <see cref="T:System.Collections.IEnumerator" /> を反復処理する、 <see cref="T:System.Collections.SortedList" />です。</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> の <see cref="T:System.Collections.SortedList" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 \[Visual Basic、C\# の場合\]  
  
 C\# 言語の `foreach` ステートメント \(Visual Basic の場合は `for each`\) を使用することで列挙子の複雑さを回避できます。  したがって、列挙子を直接操作するのではなく、`foreach` を使用することをお勧めします。  
  
 列挙子を使用すると、コレクション内のデータを読み取ることができますが、基になるコレクションを変更することはできません。  
  
 最初に、列挙子はコレクション内の 1 番目の要素の前に位置付けられます。<xref:System.Collections.IEnumerator.Reset%2A> を実行した場合も、列挙子はこの位置に戻されます。 この位置で、呼び出す <xref:System.Collections.IEnumerator.Current%2A> 例外をスローします。 そのため、<xref:System.Collections.IEnumerator.MoveNext%2A> の値を読み取る前に、<xref:System.Collections.IEnumerator.Current%2A> を呼び出して列挙子をコレクションの最初の要素に進める必要があります。  
  
 <xref:System.Collections.IEnumerator.Current%2A> は、<xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> が呼び出されるまでは同じオブジェクトを返します。<xref:System.Collections.IEnumerator.MoveNext%2A> は、<xref:System.Collections.IEnumerator.Current%2A> を次の要素に設定します。  
  
 場合 <xref:System.Collections.IEnumerator.MoveNext%2A> コレクション、列挙子の末尾が、コレクション内の最後の要素の後に配置されているパスと <xref:System.Collections.IEnumerator.MoveNext%2A> 返します `false`します。 列挙子があるときはこの位置にある場合、それ以降の呼び出しは、 <xref:System.Collections.IEnumerator.MoveNext%2A> を返すことも `false`です。 最後の呼び出しの場合 <xref:System.Collections.IEnumerator.MoveNext%2A> 返される `false`, 、呼び出し元 <xref:System.Collections.IEnumerator.Current%2A> 例外をスローします。<xref:System.Collections.IEnumerator.Current%2A> をコレクションの最初の要素にもう一度設定するには、<xref:System.Collections.IEnumerator.Reset%2A> を呼び出してから <xref:System.Collections.IEnumerator.MoveNext%2A> を呼び出します。  
  
 コレクションが変更されない限り、列挙子は有効です。 無効になり、次の呼び出しの変更が加えられた場合を追加するなど、コレクションを変更すると、要素を削除するには、列挙子は回復不可能 <xref:System.Collections.IEnumerator.MoveNext%2A> または <xref:System.Collections.IEnumerator.Reset%2A> スロー、 <xref:System.InvalidOperationException>です。 間にコレクションが変更された場合 <xref:System.Collections.IEnumerator.MoveNext%2A> と <xref:System.Collections.IEnumerator.Current%2A>, 、<xref:System.Collections.IEnumerator.Current%2A> 、列挙子が既に無効になっている場合でもに設定されている要素を返します。  
  
 列挙子にはコレクションへの排他アクセス権限はないため、コレクションの列挙処理は本質的にスレッド セーフな処理ではありません。 コレクションの同期がとられている場合でも、別のスレッドによってそのコレクションを変更できるため、変更の結果として列挙子は例外をスローします。 列挙処理を確実にスレッド セーフに行うには、列挙中にコレクションをロックするか、他のスレッドによって行われた変更によってスローされる例外をキャッチします。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.TrimToSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キャパシティを実際の要素数に設定、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コレクションのメモリ オーバーヘッドを最小コレクションに新しい要素が追加されない場合に使用できます。  
  
 リセット、 <xref:System.Collections.SortedList> オブジェクトをその初期状態の呼び出しに、 <xref:System.Collections.SortedList.Clear%2A> メソッドを呼び出す前に <xref:System.Collections.SortedList.TrimToSize%2A>します。 空のトリミング <xref:System.Collections.SortedList> のキャパシティを設定、 <xref:System.Collections.SortedList> を既定の容量。  
  
 このメソッドは O \(`n`\) 操作の場合、 `n` は <xref:System.Collections.SortedList.Count%2A>です。  
  
   
  
## 例  
 次のコード例は、未使用の部分をトリミングする方法を示しています、 <xref:System.Collections.SortedList> オブジェクトと、その値をクリアする方法です。  
  
 [!code-cpp[Classic SortedList.Clear Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.SortedList" /> オブジェクトは読み取り専用です。  
  
 または  
  
 <see cref="T:System.Collections.SortedList" /> のサイズが固定されています。</exception>
        <altmember cref="M:System.Collections.SortedList.Clear" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>内の値を取得、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</summary>
        <value>
          <see cref="T:System.Collections.ICollection" /> オブジェクトの値を含む、 <see cref="T:System.Collections.SortedList" /> オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Collections.ICollection> オブジェクトは、の値の読み取り専用ビュー、 <xref:System.Collections.SortedList> オブジェクトです。 基になるに加えられた変更 <xref:System.Collections.SortedList> すぐに反映されます、 <xref:System.Collections.ICollection>です。  
  
 要素、 <xref:System.Collections.ICollection> の値と同じ順序で並べ替えられて、 <xref:System.Collections.SortedList>です。  
  
 このプロパティは、 <xref:System.Collections.SortedList.GetValueList%2A> メソッドが返す、 <xref:System.Collections.ICollection> の代わりにオブジェクト、 <xref:System.Collections.IList> オブジェクトです。  
  
 このメソッドは、o \(1\) 操作です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
      </Docs>
    </Member>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Collections.SortedList" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>