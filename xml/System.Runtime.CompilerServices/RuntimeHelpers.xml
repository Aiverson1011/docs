<Type Name="RuntimeHelpers" FullName="System.Runtime.CompilerServices.RuntimeHelpers">
  <TypeSignature Language="C#" Value="public static class RuntimeHelpers" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RuntimeHelpers extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.RuntimeHelpers" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>さまざまなコンパイラのためのサポートを提供する静的メソッドと静的プロパティのセットを提供します。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例を使用してハンドルを確実に設定する方法を示しています、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> メソッドです。 確実にハンドルを指定した既存のハンドルに設定するにすることが必要、ネイティブのハンドルの割り当てとそのハンドル内の後続の記録、 <xref:System.Runtime.InteropServices.SafeHandle> オブジェクトはアトミックです。 ネイティブのハンドルがリークされている \(スレッドの中止またはメモリ不足の例外\) など、これらの操作の間で障害が発生します。  使用することができます、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> メソッド ハンドルがリークしないことを確認します。  
  
 [!code-csharp[SafeHandle\-RuntimeHelpers.PrepareConstrainedRegions\#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle\-RuntimeHelpers.PrepareConstrainedRegions\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="EnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static void EnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>それにより、残りのスタック領域が平均の .NET Framework 関数を実行するのに十分な大きさです。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> 例外を発生させるための十分な領域を保持する意図的に制限付きの履歴に関する情報と実行される回復の動作を提供します。 人為的なスタックの制限は、安全な例外をスローするのに十分な領域があることを確認、共通言語ランタイムによって選択されます。  
  
 このメソッドは、無限再帰の結果としてのスタック オーバーフローが発生する状況の場合に便利です。 これはため、コンパイラ サービス シナリオで使用するにも使用できますが安全に他の開発シナ リオでします。  
  
 スタック領域が十分では、例外はスローされませんし、ほとんどの .NET Framework の型とメンバーも呼び出すことができます。  
  
> [!NOTE]
>  このメソッドは、制約された実行領域 \(CER\) サポートの一部ではないとを混同しないようにする、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=fullName> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientExecutionStackException">使用可能なスタック領域は、.NET Framework の関数の平均を実行するための十分なです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object o1, object o2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object o1, object o2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o1" Type="System.Object" />
        <Parameter Name="o2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o1">比較する最初のオブジェクト。</param>
        <param name="o2">比較する 2 番目のオブジェクト。</param>
        <summary>指定するかどうか、指定した <see cref="T:System.Object" /> インスタンスが等しいと見なされます。</summary>
        <returns>
          <see langword="true" /> 場合、 <paramref name="o1" /> パラメーターと同じインスタンスは、 <paramref name="o2" /> パラメーターか、どちら <see langword="null" />, 、または <c>o1.Equals(o2)</c> を返します <see langword="true" />。 そうしないと、 <see langword="false" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コンパイラで使用します。  
  
   
  
## 例  
 次の例では、2 つのオブジェクトを使用して、比較、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> メソッドです。  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.Equals\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.Equals\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteCodeWithGuaranteedCleanup">
      <MemberSignature Language="C#" Value="public static void ExecuteCodeWithGuaranteedCleanup (System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExecuteCodeWithGuaranteedCleanup(class System.Runtime.CompilerServices.RuntimeHelpers/TryCode code, class System.Runtime.CompilerServices.RuntimeHelpers/CleanupCode backoutCode, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Runtime.CompilerServices.RuntimeHelpers+TryCode" />
        <Parameter Name="backoutCode" Type="System.Runtime.CompilerServices.RuntimeHelpers+CleanupCode" />
        <Parameter Name="userData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="code">コードへのデリゲート。</param>
        <param name="backoutCode">例外が発生した場合に実行するコードのデリゲート。</param>
        <param name="userData">渡すデータ <c>code</c> と <c>backoutCode</c>です。</param>
        <summary>使用してコードを実行、 <see cref="T:System.Delegate" /> 別の使用中に <see cref="T:System.Delegate" /> 例外が発生した場合の他のコードを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コンパイラで使用します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">ハッシュ コードを取得するオブジェクト。</param>
        <summary>特定のオブジェクトのハッシュ関数として機能し、ハッシュ テーブルなどのハッシュ コードを使用するアルゴリズムやデータの構造での使用に適しています。</summary>
        <returns>識別されるオブジェクトのハッシュ コード、 <paramref name="o" /> パラメーター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> メソッドは常に呼び出し、 <xref:System.Object.GetHashCode%2A?displayProperty=fullName> メソッド非事実上オブジェクトの型がオーバーライドされた場合でも、 <xref:System.Object.GetHashCode%2A?displayProperty=fullName> メソッドです。 したがってを使用して <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> 呼び出すことと異なる場合があります `GetHashCode` 使用してオブジェクトに直接、 <xref:System.Object.GetHashCode%2A?displayProperty=fullName> メソッドです。  
  
> [!WARNING]
>  ただし、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> メソッドには、同一のオブジェクト参照を同一のハッシュ コードが返されます、する必要がありますメソッドを使用してこのオブジェクトの id のテストこのハッシュ コードがオブジェクト参照を一意に識別されないためです。 テスト オブジェクトを識別するには \(つまり、2 つのテスト オブジェクトにメモリ内の同じオブジェクトを参照\)、呼び出す、 <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> メソッドです。 使用する必要がありますも <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> 文字列がインターンされるため、2 つの文字列が等しいオブジェクト参照を表すかどうかをテストします。 をテストする文字列インターンの使用に呼び出す、 <xref:System.String.IsInterned%2A?displayProperty=fullName> メソッドです。  
  
 <xref:System.Object.GetHashCode%2A?displayProperty=fullName> と <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> メソッドは次のように異なります。  
  
-   <xref:System.Object.GetHashCode%2A?displayProperty=fullName> 等しいかどうかのオブジェクトの定義に基づくハッシュ コードを返します。 たとえば、同じ内容の 2 つの文字列がに対して同じ値を返す <xref:System.Object.GetHashCode%2A?displayProperty=fullName>します。  
  
-   <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> オブジェクト id を表すハッシュ コードを返します。 つまり、2 つの文字列と同じ内容が、隔離されている場合、文字列を表す変数 \(を参照してください、 [文字列インターンの使用](#interning) セクション\) またはメモリ内の 1 つの文字列を返すと同じを表すハッシュ コード。  
  
> [!IMPORTANT]
>  なお <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> 常に同じオブジェクト参照のと同じハッシュ コードを返します。 ただし、その逆はできません: と等しいオブジェクト参照と同じハッシュ コードが示されていません。 特定のハッシュ コード値は、特定のオブジェクト参照に一意ではありません。異なるオブジェクト参照には、同一のハッシュ コードを生成できます。  
  
 このメソッドは、コンパイラで使用します。  
  
<a name="interning"></a>   
## 文字列インターンの使用  
 共通言語ランタイム \(CLR\) では、文字列の内部プールを保持し、リテラルをプールに格納します。 場合は 2 つの文字列 \(たとえば、 `str1` と `str2`\) 形式のデータは、同一の文字列リテラルでは、CLR の設定を `str1` と `str2` メモリを節約するために、マネージ ヒープ上の同じ場所を指定します。 呼び出す <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> これら 2 つの文字列でオブジェクトが前のセクションで、2 番目の箇条書き項目とは反対に、同じハッシュ コードを生成します。  
  
 CLR は、リテラルだけをプールに追加します。 コンパイラによって 1 つの文字列リテラルとして文字列の連結が解決しない限り、連結などの文字列操作の結果は、プールに追加されません。 そのため場合、 `str2` 、連結操作の結果として作成されたと `str2` と同じ `str1`, を使用して、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> オブジェクトが同じハッシュ コードをもたらさないこれら 2 つの文字列にします。  
  
 プールに連結された文字列を明示的に追加する場合を使用して、 <xref:System.String.Intern%2A?displayProperty=fullName> メソッドです。  
  
 使用することも、 <xref:System.String.IsInterned%2A?displayProperty=fullName> 文字列がインターンの参照を持つかどうかをチェックするメソッドです。  
  
   
  
## 例  
 次の例では、違い、 <xref:System.Object.GetHashCode%2A?displayProperty=fullName> と <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> メソッドです。 この例の出力を次に示します。  
  
-   渡される文字列の最初のセットのハッシュ コードの両方のセット、 `ShowHashCodes` 文字列が完全に異なるために、メソッドが異なる、できます。  
  
-   <xref:System.Object.GetHashCode%2A?displayProperty=fullName> 渡される文字列の 2 番目のセットの同じハッシュ コードを生成、 `ShowHashCodes` メソッドを文字列が等しいためです。 ただし、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> メソッドはありません。 最初の文字列は、リテラル文字列を使用して定義され、ように隔離されている場合。 2 番目の文字列の値は同じですが、そのいない隔離されている場合への呼び出しによって返されるため、 <xref:System.String.Format%2A?displayProperty=fullName> メソッドです。  
  
-   3 番目の文字列の場合、によって生成されたハッシュ コード <xref:System.Object.GetHashCode%2A?displayProperty=fullName> によって生成されたハッシュ コードをされるとして両方の文字列が同一の <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName>です。 これは、同一の隔離された文字列に、文字列変数が参照して、コンパイラが 1 つの文字列リテラルとして、両方の文字列に割り当てられた値を扱われるためです。  
  
 [!code-csharp[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/cs/gethashcodeex1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/vb/gethashcodeex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectValue">
      <MemberSignature Language="C#" Value="public static object GetObjectValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">値の型をボックス化します。</param>
        <summary>値型がボックス化します。</summary>
        <returns>ボックス化されたコピー <paramref name="obj" /> 値クラスである場合は、それ以外の場合、 <paramref name="obj" /> 自体です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値の型をボックス化では、オブジェクトを作成し、新しいオブジェクトに指定した値型のフィールドの簡易コピーを実行します。  
  
 このメソッドは、値クラスのエイリアスの動作を維持したまま、オブジェクトとして操作するためには、ある値クラスを使用します。  
  
 戻り値は、値クラスは、変更可能または変更できないかどうかによって異なります。  
  
-   割り当てられている値が変更可能な値クラスの場合は、値クラスは、コピーのセマンティクスを持つため、メソッド、クラスの簡易コピーを返します。  
  
-   割り当てられている値が変更できない値クラスの場合は、クラスのコピーではなく、オブジェクト自体を返します。  
  
 動的に型指定された言語のコンパイラでは、このメソッドを使用して、ボックス化解除された値型をボックス化された値型が同じように機能しているかどうかを確認します。 ボックス化された値型に複製すると、それらに渡す値によって常に渡されます。 コンパイラを呼び出すことができます <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> 値の型をオブジェクトに割り当てるか、値型、型のオブジェクトのパラメーターとして渡します。  
  
 このメソッドは、コンパイラで使用します。  
  
   
  
## 例  
 次の例では、値クラスを使用して、ボックス、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> メソッドです。  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue\#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUninitializedObject">
      <MemberSignature Language="C#" Value="public static object GetUninitializedObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUninitializedObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeArray">
      <MemberSignature Language="C#" Value="public static void InitializeArray (Array array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitializeArray(class System.Array array, valuetype System.RuntimeFieldHandle fldHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="fldHandle" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="array">初期化される配列。</param>
        <param name="fldHandle">配列の初期化に使用されるデータの場所を指定するフィールドのハンドル。</param>
        <summary>モジュールに格納されているデータから、配列を初期化するために高速の方法を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コンパイラで使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceOrContainsReferences&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsReferenceOrContainsReferences&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReferenceOrContainsReferences&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetToStringData">
      <MemberSignature Language="C#" Value="public static int OffsetToStringData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 OffsetToStringData" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した文字列内のデータをバイト単位での相対位置を取得します。</summary>
        <value>先頭からのバイト オフセット、 <see cref="T:System.String" /> 文字列の最初の文字へのオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コンパイラは、マネージ文字列内の文字の安全でない、かつ効率的に、ポインターの操作にこのプロパティを使用します。 コンパイラは、文字列を使用する前に、ガベージ コレクターによって移動されないを固定する必要があります。 共通言語ランタイムの文字列が不変であり、いないことに注意してください。つまり、その内容を読み取るが変更されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegions">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegions ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>制約された実行領域 \(CER\) として、コードの本文を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コンパイラでは、このメソッドを使用して、マーク `catch`, 、`finally`, 、および `fault` 制約された実行領域 \(Cer\) としてブロックします。 制約された領域は、信頼性のコントラクトには、その他のコードを呼び出す必要がありますのみとしてマークされたコードです。 割り当てや、エラーを処理する準備ができた場合を除き、仮想メソッドの呼び出しを準備解除または信頼性の低いを作成してする必要がありますできません。  
  
 いいえ言語オペコードを除く中級レベルの注 `NOP`, への呼び出しが許可されている、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> メソッドおよび `try` ブロックします。 Cer の詳細についてでクラスを参照してください、 <xref:System.Runtime.ConstrainedExecution> 名前空間。  
  
 Cer を使用してマークされている、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> メソッドが完全に機能しない場合、 <xref:System.StackOverflowException> から生成された、 `try` ブロックします。 詳細については、<xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> メソッドを参照してください。  
  
 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> メソッドは <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> メソッドを呼び出します。  
  
   
  
## 例  
 次の例を使用してハンドルを確実に設定する方法を示しています、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> メソッドです。 確実にハンドルを指定した既存のハンドルに設定するにすることが必要、ネイティブのハンドルの割り当てとそのハンドル内の後続の記録、 <xref:System.Runtime.InteropServices.SafeHandle> オブジェクトはアトミックです。 ネイティブのハンドルがリークされている \(スレッドの中止またはメモリ不足の例外\) など、これらの操作の間で障害が発生します。 使用することができます、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> メソッド ハンドルがリークしないことを確認します。  
  
 [!code-csharp[SafeHandle\-RuntimeHelpers.PrepareConstrainedRegions\#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle\-RuntimeHelpers.PrepareConstrainedRegions\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegionsNoOP">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegionsNoOP ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegionsNoOP() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>制約された実行領域 \(CER\) としてプローブを実行しないでコードの本文を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コンパイラでは、このメソッドを直接呼び出さないでください。 代わりに呼び出すことによって、CER を定義、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareContractedDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareContractedDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareContractedDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">準備するイベントのデリゲート。</param>
        <summary>アプリケーションを動的に準備するための手段を提供 <see cref="T:System.AppDomain" /> イベント デリゲート。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.AppDomain> イベントのデリゲートなど <xref:System.AppDomain.DomainUnload>, 、<xref:System.AppDomain.ProcessExit>, 、および <xref:System.AppDomain.UnhandledException> 起動時に自動的に準備されていません。 準備のためには、次のメソッドを使用できます。  
  
-   メソッドを使用して、属性、 <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> 属性です。  
  
-   メソッドを使用して、属性、 <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> 属性です。  
  
-   呼び出す、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> メソッドを動的にデリゲートを準備します。  
  
 詳細については、記事を参照してください。 [Keep Your Code Running with the Reliability Features of the .NET Framework](http://go.microsoft.com/fwlink/?LinkId=145491) MSDN Magazine にします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">準備するデリゲート型。</param>
        <summary>制約された実行領域 \(CER\) に含めるように指定したデリゲートを準備する必要があることを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コンパイラを使用してこのメソッドをデリゲートの呼び出しメソッドを準備し、その呼び出し \(およびデリゲートの統計的に確定できる呼び出しグラフ\) のターゲットを準備する制約された実行領域 \(CER\) として。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="method">準備するメソッドへのハンドル。</param>
        <summary>制約された実行領域 \(CER\) に含めるのためのメソッドを準備します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 コンパイラを使用して、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> 制約された実行領域 \(CER\) 内で行われます仮想呼び出しを処理するメソッドです。 JIT コンパイル時に、共通言語ランタイムは通常ありません仮想呼び出しのターゲットに関する十分な情報。 そのため、ランタイムは呼び出し先のセグメントを最初に準備できません。 CER を使用しているコードに十分な知識がある場合は、CER までの時間の任意の時点でターゲットを確認するのには、実際に入力された、呼び出すことができます <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> を行いますが、CER ルートを引数として指定されたメソッドと同じランタイム準備を実行します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle[] instantiation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
        <Parameter Name="instantiation" Type="System.RuntimeTypeHandle[]" />
      </Parameters>
      <Docs>
        <param name="method">準備するメソッドへのハンドル。</param>
        <param name="instantiation">メソッドに渡すようにインスタンス化します。</param>
        <summary>指定されたインスタンス化と制約された実行領域 \(CER\) に含めるのためのメソッドを準備します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ジェネリックを使用して、コンパイラのサポートを提供する、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> メソッドです。 共通言語ランタイムは、制約された実行領域 \(Cer\) のジェネリック型パラメーター \(型パラメーター、メソッド、または 1 つは、メソッド自体を含むクラスに\) を持つメソッドに基づいたを準備できない参照型としてこれらの型パラメーターがインスタンス化されるときです。  
  
 このオーバー ロードを使用すると、特定のインスタンス化 \(型の配列\) などを渡すことができます \(存在する場合\)、最初にクラスの型のパラメーターを指定するメソッドの型パラメーター \(存在する場合\) と、その後です。 ランタイムは、メソッドのインスタンス化を準備します。 \(これはでインスタンス化使用するにはには、少なくとも 1 つの参照型のパラメーターが含まれている場合にのみ必要です。\) したがって、CER 形式を使用して `try` ジェネリック メソッド \(またはジェネリック クラスの非ジェネリック メソッド\) 句のインスタンス化で確実に動作して <xref:System.Int32> またはその他の値の型。 などの参照をインスタンス化する型 <xref:System.String>, 、明示的なを使用する必要があります <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> メソッド、CER を最初のメソッドのルートです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="ProbeForSufficientStack">
      <MemberSignature Language="C#" Value="public static void ProbeForSufficientStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ProbeForSufficientStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>後続の \(コードが有限かつ適度なスタック領域の量のみを使用すると仮定\) コード ブロック内でスタック オーバーフローが発生しないことを確認するスタック領域量をプローブします。 このメソッドの代わりに、制約された実行領域 \(CER\) を使用することをお勧めします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Microsoft SQL Server や Microsoft Exchange Server などのスタック オーバーフローに対する回復力のあるホストで実行する場合は、このメソッドを制約された実行領域 \(CER\) インフラストラクチャによって使用されます。 このメソッドは現在、x86 の場合は、48 KB のスタック領域のプローブ時間の経過と共に変更することがありますが、プラットフォーム、正確な量と、他のプラットフォームで異なる場合があります。  
  
 このメソッドは、コンパイラによっても使用されます。  
  
 使用する代わりに、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> メソッド、標準的な CER を使用する必要があります。 つまり、スタック領域量が中程度の使用を計画している場合を呼び出す、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> メソッドの直前に、 `try`\/`finally` または `try`\/`catch` ブロックします。 再帰的なメソッドや、大量のスタック領域を使用する計画を呼び出すことを使用する、 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=fullName> メソッドです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="RunClassConstructor">
      <MemberSignature Language="C#" Value="public static void RunClassConstructor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunClassConstructor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type">実行するクラスのコンス トラクター メソッドを指定する型ハンドル。</param>
        <summary>指定したクラスのコンス トラクター メソッドを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コンパイラで使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException">クラス初期化子では、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="RunModuleConstructor">
      <MemberSignature Language="C#" Value="public static void RunModuleConstructor (ModuleHandle module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunModuleConstructor(valuetype System.ModuleHandle module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.ModuleHandle" />
      </Parameters>
      <Docs>
        <param name="module">実行するモジュールのコンス トラクター メソッドを指定するハンドル。</param>
        <summary>指定したモジュールのコンス トラクター メソッドを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、コンパイラで使用します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException">モジュールのコンス トラクターでは、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static bool TryEnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PrepareMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>制約された実行領域 \(CER\) に含めるのためのメソッドを準備します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>