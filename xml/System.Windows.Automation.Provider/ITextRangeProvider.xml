<Type Name="ITextRangeProvider" FullName="System.Windows.Automation.Provider.ITextRangeProvider">
  <TypeSignature Language="C#" Value="public interface ITextRangeProvider" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ITextRangeProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Provider.ITextRangeProvider" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationProvider</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("5347ad7b-c355-46f8-aff5-909033582f63")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.InterfaceType(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see cref="T:System.Windows.Automation.Provider.ITextProvider" /> を実装するテキスト コンテナー内の連続するテキストの範囲への、UI オートメーション クライアントのアクセスをサポートするメソッドとプロパティを公開します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 サポートが必要な UI オートメーション プロバイダーに実装されている、 <xref:System.Windows.Automation.TextPattern> コントロール パターンです。  
  
 A <xref:System.Windows.Automation.Text.TextPatternRange> 挿入ポイント、サブセットまたはすべてのテキストを表すことができます、 <xref:System.Windows.Automation.TextPattern> コンテナーです。  
  
   
  
## 例  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.Text.TextPatternRange" />
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.AddToSelection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>複数の非結合選択をサポートするテキスト コンテナー内の強調表示されたテキストのコレクションに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 テキスト挿入ポイントは、新しい選択範囲の領域に移動します。  
  
 低次元テキスト範囲を提供すると、カーソルが移動します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">テキスト プロバイダーは、複数をサポートしていない場合の非結合選択 \(つまり、 <see cref="P:System.Windows.Automation.Provider.ITextProvider.SupportedTextSelection" /> の値が必要 <see langword="Multiple" />\)。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>元の <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> と同一で、元のプロパティをすべて継承する新しい <see cref="T:System.Windows.Automation.Provider.ITextRangeProvider" /> を返します。</summary>
        <returns>新しいテキスト範囲。 null 参照 \(Microsoft Visual Basic .NET では <see langword="Nothing" />\) は返されません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 新しい範囲は、元から独立して操作できます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Provider.ITextRangeProvider range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Compare(class System.Windows.Automation.Provider.ITextRangeProvider range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Compare(System.Windows.Automation.Provider.ITextRangeProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
      </Parameters>
      <Docs>
        <param name="range">比較するテキスト範囲</param>
        <summary>テキスト範囲全体 \(<see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> エンドポイントから <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> エンドポイントまで\) が別のテキスト範囲と同じであるかどうかを示す値を返します。</summary>
        <returns>両方のテキスト範囲が同じである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">範囲の比較対象となる場合は、同じテキスト プロバイダーからになりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Provider.ITextRangeProvider targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Provider.ITextRangeProvider targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Provider.ITextRangeProvider,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">呼び出し元の <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> エンドポイントまたは <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> エンドポイント。</param>
        <param name="targetRange">比較対象の範囲。</param>
        <param name="targetEndpoint">比較対象の <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> エンドポイントまたは <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> エンドポイント。</param>
        <summary>2 つのテキスト範囲のエンドポイントが同じかどうかを示す値を返します。</summary>
        <returns>テキストにおいて、呼び出し元のエンドポイントが比較対象のエンドポイントよりも前方にある場合は、負の値を返します。  
  
 呼び出し元のエンドポイントが比較対象のエンドポイントと同じ位置にある場合は、0 を返します。  
  
 テキストにおいて、呼び出し元のエンドポイントが比較対象のエンドポイントより後方にある場合は、正の値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">場合 <paramref name="targetRange" /> から別のテキスト プロバイダー。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">テキスト単位。</param>
        <summary>指定されたテキスト単位にテキスト範囲を拡大します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the range is already an exact quantity of the specified units then it remains unchanged.  
  
 There is a series of steps are involved behind the scenes in order for the <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> method to execute successfully.  
  
1.  The text range is normalized; that is, the text range is collapsed to a degenerate range at the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> endpoint, which makes the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint superfluous. This step is necessary to remove ambiguity in situations where a text range spans **parameterReference tag is not supported!!!!**  
     boundaries; for example, "{The U}RL [http:\/\/www.microsoft.com](http://www.microsoft.com) is embedded in text" where "{" and "}" are the text range endpoints.  
  
2.  The resulting range is moved backward in the <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> to the beginning of the requested **parameterReference tag is not supported!!!!**  
     boundary.  
  
3.  The range is moved forward or backward in the <xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> by the requested number of **parameterReference tag is not supported!!!!**  
     boundaries.  
  
4.  The range is then expanded from a degenerate range state by moving the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint by one requested **parameterReference tag is not supported!!!!**  
     boundary.  
  
 e92fb703-05d1-4ba2-a554-0c1eff710dec  
Examples of how a text range is adjusted for Move\(\) and ExpandToEnclosingUnit\(\)  
  
> [!NOTE]
>  These steps are necessary since it is common for a screen reader to read out a full word, sentence, or entire paragraph at the insertion point or any virtual cursor position.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A> respects both hidden and visible text.  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit%2A> defers to the next largest <xref:System.Windows.Automation.Text.TextUnit> supported if the given <xref:System.Windows.Automation.Text.TextUnit> is not supported by the control.  
  
 The order, from smallest unit to largest, is listed below.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider FindAttribute (int attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider FindAttribute(int32 attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.FindAttribute(System.Int32,System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">検索対象の属性。</param>
        <param name="value">検索対象の属性値。 この値は、属性に指定されている型と一致する必要があります。</param>
        <param name="backward">最初に発生したテキスト範囲ではなく、最後に発生したテキスト範囲を返す必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定された属性の値を持つテキスト範囲のサブセットを返します。</summary>
        <returns>一致する属性と属性値を持つテキスト範囲。それ以外の場合は null \(Microsoft Visual Basic .NET では <see langword="Nothing" />\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非表示と表示されるテキストの区別はありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.ITextRangeProvider FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.ITextRangeProvider FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.ITextRangeProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">検索対象の文字列。</param>
        <param name="backward">最初に発生したテキスト範囲ではなく、最後に発生したテキスト範囲を返す必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="ignoreCase">大文字と小文字を区別しない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定したテキストを含むテキスト範囲のサブセットを返します。</summary>
        <returns>指定したテキストと一致するテキスト範囲。それ以外の場合は null \(Microsoft Visual Basic .NET では <see langword="Nothing" />\)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非表示と表示されるテキストの区別はありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (int attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAttributeValue(int32 attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetAttributeValue(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="attribute">テキスト属性。</param>
        <summary>指定した属性の値をテキスト範囲から取得します。</summary>
        <returns>指定した属性の値を表すオブジェクトを取得します。 たとえば、<c>GetAttributeValue(TextPattern.FontNameAttribute)</c> は、テキスト範囲のフォント名を表す文字列を返し、<c>GetAttributeValue(TextPattern.IsItalicAttribute)</c> は <see cref="T:System.Boolean" /> 型の値を返します。  
  
 指定した属性の値がテキスト範囲内で異なる場合は <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> を返します。  
  
 指定された属性がプロバイダーまたはコントロールによってサポートされない場合は <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 非表示と表示されるテキストの区別はありません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定した属性が無効な場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public double[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetBoundingRectangles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>テキスト範囲内のテキストの表示されている各行 \(全体または一部\) に外接する四角形のコレクションを取得します。</summary>
        <returns>テキスト範囲内の各行 \(全体または一部\) に外接する四角形の配列。  
  
 低次元テキスト範囲の空の配列。  
  
 完全に画面外となる、スクロール アウトする、または重なったウィンドウによって隠れる画面座標を持つテキスト範囲を表す空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.IRawElementProviderSimple[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.IRawElementProviderSimple[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.IRawElementProviderSimple[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>テキスト範囲内にあるすべての埋め込みオブジェクトのコレクションを取得します。</summary>
        <returns>範囲内にある子オブジェクトのコレクション。 テキスト範囲と重なっているが完全には範囲に含まれていない子オブジェクトも、コレクションに含まれます。  
  
 子オブジェクトが存在しない場合は、空のコレクションを返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Provider.IRawElementProviderSimple GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Automation.Provider.IRawElementProviderSimple GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetEnclosingElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Provider.IRawElementProviderSimple</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>テキスト範囲を囲む最も内側のコントロールを返します。</summary>
        <returns>囲んでいるコントロール。通常はテキスト範囲を提供するテキスト プロバイダー。 ただし、テキスト プロバイダーがテーブル、ハイパーリンクなどの子要素をサポートする場合は、外側の要素がそのテキスト プロバイダーの子孫である可能性があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.GetText(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">返す文字列の最大長。 制限が必要ない場合は、<c>-1</c> を使用します。</param>
        <summary>範囲のプレーン テキストを取得します。</summary>
        <returns>テキスト範囲のプレーンテキスト。指定した <paramref name="maxLength" /> で切り捨てられている可能性があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A> 表示と非表示の両方のテキストを優先します。  
  
 場合 `maxLength` 長さを超える値は、呼び出し元のテキスト範囲の返される文字列はテキスト範囲のプレーン テキストになります。  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.GetText%2A> テキスト フローのエンドポイントの順序は影響しません常に論理テキスト フローの順序でテキスト範囲の開始と終了のエンドポイント間でテキストが返されます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxLength" /> が \-1 より小さい場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">テキスト単位の境界。</param>
        <param name="count">移動するテキスト単位の数。  
  
 正の値はテキスト範囲を前方に移動し、負の値はテキスト範囲を後方に移動します。0 の場合は移動されません。</param>
        <summary>指定されたテキスト単位数の分、テキスト範囲を移動します。</summary>
        <returns>実際に移動された単位の数。 移動後のテキスト範囲のエンドポイントのいずれかが <see cref="P:System.Windows.Automation.Provider.ITextProvider.DocumentRange" /> エンドポイントよりも大きい、または小さい場合、要求した数よりも小さくなる場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 テキスト範囲の内容を走査する必要がある場合、<xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> メソッドを正常に実行するために、一連の手順がその背後で関係しています。  
  
1.  テキスト範囲は正規化されます。つまり、テキスト範囲は <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> エンドポイントで低次元テキスト範囲に縮小されるため、<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> エンドポイントは不要になります。 この手順は、テキスト範囲にまたがる場合にあいまいさを削除する必要は `unit` 境界。 たとえば、"{U} RL [http:\/\/www.microsoft.com](http://www.microsoft.com) テキストに埋め込まれた"、"{"と"}"のテキスト範囲のエンドポイントを、します。  
  
2.  結果として得られる範囲は、<xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> 内で、要求された `unit` 境界の先頭に向かって後方に移動されます。  
  
3.  この範囲は、<xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> 内で、`unit` 境界の要求された数だけ、前方または後方に移動されます。  
  
4.  その後、この範囲は、要求された 1 つの `unit` 境界の分、<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> エンドポイントを移動することによって、低次元テキスト範囲の状態から展開されます。  
  
 e92fb703-05d1-4ba2-a554-0c1eff710dec  
テキスト範囲を Move\(\) と ExpandToEnclosingUnit\(\) に対して調整する方法の例  
  
 テキスト コンテナーのテキスト コンテンツ \(内部テキスト\) と埋め込みオブジェクト \(ハイパーリンクやテーブルのセルなど\) は、連続する単一のテキスト ストリームとして、[!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] ツリーのコントロール ビューとコンテンツ ビューの両方で公開されます。そのため、オブジェクトの境界は無視されます。  
  
 d9c87135-a34f-43a1-be3e-119360bfc2d7  
埋め込みオブジェクトとその範囲を含むテキスト ストリームの例  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> 表示と非表示の両方のテキストを優先します。  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> 次の手順を延期最大 <xref:System.Windows.Automation.Text.TextUnit> サポートされている場合、指定された <xref:System.Windows.Automation.Text.TextUnit> コントロールによってサポートされていません。  
  
 最大値、最小単位からの注文を以下にリストします。  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
 テキストが変更されることはできません、単にまたがるテキストの別の部分をテキスト範囲。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Provider.ITextRangeProvider targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Provider.ITextRangeProvider targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Provider.ITextRangeProvider,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Provider.ITextRangeProvider" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">移動するエンドポイント。</param>
        <param name="targetRange">同じテキスト プロバイダーからの別の範囲。</param>
        <param name="targetEndpoint">他の範囲にあるエンドポイント。</param>
        <summary>テキスト範囲の 1 つのエンドポイントを、2 番目のテキスト範囲の指定のエンドポイントに移動します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If the endpoint being moved crosses the other endpoint of the same text range then that other endpoint is moved also, resulting in a degenerate range and ensuring the correct ordering of the endpoints \(that is, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> is always less than or equal to <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>\).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">移動するエンドポイント。</param>
        <param name="unit">移動するためのテキスト単位。</param>
        <param name="count">移動する単位の数。 正の値はエンドポイントを前方に移動します。 負の値は後方に移動します。 0 の場合は移動されません。</param>
        <summary>テキスト範囲の 1 つのエンドポイントを、指定されたテキスト単位数の分、ドキュメントの範囲内で移動します。</summary>
        <returns>実際に移動した単位の数。エンドポイントの移動によりドキュメントの先頭または末尾に達した場合は、要求した数よりも小さくなる場合があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 テキスト範囲の内容を走査する必要がある場合、<xref:System.Windows.Automation.Provider.ITextRangeProvider.Move%2A> メソッドを正常に実行するために、一連の手順がその背後で関係しています。  
  
1.  テキスト範囲は正規化されます。つまり、テキスト範囲は <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> エンドポイントで低次元テキスト範囲に縮小されるため、<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> エンドポイントは不要になります。 この手順は、テキスト範囲にまたがる場合にあいまいさを削除する必要は `unit` 境界。 たとえば、"{U} RL [http:\/\/www.microsoft.com](http://www.microsoft.com) テキストに埋め込まれた"、"{"と"}"のテキスト範囲のエンドポイントを、します。  
  
2.  結果として得られる範囲は、<xref:System.Windows.Automation.Provider.ITextProvider.DocumentRange%2A> 内で、要求された `unit` 境界の先頭に向かって後方に移動されます。  
  
3.  その後、この範囲は、要求された 1 つの `unit` 境界の分、<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> エンドポイントを移動することによって、低次元テキスト範囲の状態から展開されます。  
  
 e92fb703-05d1-4ba2-a554-0c1eff710dec  
テキスト範囲を Move\(\) と ExpandToEnclosingUnit\(\) に対して調整する方法の例  
  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit%2A> 次の手順を延期最大 <xref:System.Windows.Automation.Text.TextUnit> サポートされている場合、指定された <xref:System.Windows.Automation.Text.TextUnit> コントロールによってサポートされていません。  
  
 最大値、最小単位からの注文を以下にリストします。  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.RemoveFromSelection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>複数の非結合選択をサポートするテキスト コンテナー内の強調表示されたテキストのコレクションから、呼び出し元の <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> エンドポイントおよび <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> エンドポイントに対応する、強調表示されたセクションを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 テキスト挿入ポイントが削除された、強調表示の領域に移動します。  
  
 低次元テキスト範囲を提供すると、カーソルを移動します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">テキスト プロバイダーは、複数をサポートしていない場合の非結合選択 \(たとえば、 <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> の値が必要 <see langword="Multiple" />\)。</exception>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop">テキスト範囲をスクロールしてビューポートの上辺と揃える場合は <see langword="true" />。ビューポートの底辺と揃える場合は <see langword="false" /></param>
        <summary>テキスト範囲がビューポート内に表示されるまで、テキスト コントロールを垂直方向にスクロールします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView%2A> respects both hidden and visible text.  
  
 If the text range is hidden, the text control will scroll only if the hidden text has an anchor in the viewport.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.ITextRangeProvider.Select" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>テキスト範囲の <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> エンドポイントおよび <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> エンドポイントに対応するテキスト コントロール内のテキストを強調表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 If a degenerate text range is provided, the text insertion point will move to the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> endpoint of the text range.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">テキストの選択がテキスト コントロールによってサポートされていない場合に発生します。</exception>
      </Docs>
    </Member>
  </Members>
</Type>