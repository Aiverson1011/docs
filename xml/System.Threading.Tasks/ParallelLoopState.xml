<Type Name="ParallelLoopState" FullName="System.Threading.Tasks.ParallelLoopState">
  <TypeSignature Language="C#" Value="public class ParallelLoopState" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ParallelLoopState extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.ParallelLoopState" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ShouldExitCurrentIteration = {ShouldExitCurrentIteration}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>他のイテレーションと対話するように、並列ループのイテレーションを有効にします。 このクラスのインスタンスは、<see cref="T:System.Threading.Tasks.Parallel" /> クラスから各ループに提供されるため、コードでインスタンスを作成することはできません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 このクラスのインスタンスをインスタンス化できないことに注意してください。 自動的にへの呼び出しで引数として、コンパイラによって生成しますが、 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=fullName> または <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName> メソッドです。 具体的な例を次に示します。  
  
 などを構築 `for` と `foreach` \(c\#\) のおよび `For` と `For Each` \(Visual Basic\) で順次実行最高の値を最小のインデックスとは、セット内の最初のオブジェクトから最後にします。 これに対し、 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=fullName> と <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName> メソッドはありません。 ループの各イテレーションが並列で実行するため始めるし、任意の順序で終了できます。<xref:System.Threading.Tasks.ParallelLoopState> クラス間の対話に、並列ループの各イテレーションを使用できます。<xref:System.Threading.Tasks.ParallelLoopState> クラスをすることができます。  
  
-   現在のイテレーションを終了し、追加のイテレーションを呼び出すことによって起動を防ぐため、 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドです。 これは既に実行が開始されているイテレーションには影響しません。  
  
-   現在のインデックスより大きいインデックスで、イテレーションを呼び出すことによって実行されないようにする、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドです。 これは既に実行が開始されているイテレーションには影響しません。  
  
-   値を取得することによって、ループが繰り返される例外が発生したかどうかを特定、 <xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A> プロパティです。  
  
-   ループのイテレーションが呼び出されているかどうかを判断、 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> の値を取得することによって、 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> プロパティです。 このプロパティを使用するにを呼び出しの前に開始したループのイテレーションから返す、 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドが実行中であります。  
  
-   ループのイテレーションが呼び出されているかどうかを判断、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> または <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>メソッドまたはの値を取得することによって、例外がスローされた、 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> プロパティです。  
  
-   インデックスがある中断が呼び出したの値を取得することによって、イテレーションごとのインデックスよりも大きい実行時間の長いイテレーションを終了する、 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> プロパティです。  
  
   
  
## 例  
 次の例では、並列ループの最大 100 個のイテレーションを実行します。 各イテレーションは、1 から 1,000 ミリ秒単位までのランダムな間隔の一時停止します。 ランダムに生成された値がループのイテレーションの決定、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドが呼び出されます。 例に示す、インデックスがあるより大きいなしのイテレーションからの出力として、 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 呼び出しの後にプロパティ値の開始、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドです。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method. If  the property value is **languageKeyword tag is not supported!!!!**  
, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property and, if it is greater than the current iteration's index value, returns immediately.  
  
 ]]></format>
    </remarks>
    <threadsafe>A <see cref="T:System.Threading.Tasks.ParallelLoopState" /> インスタンスはインスタンスが提供されたループの本体でのみの使用を目的としています。  指定されたを使用して安全ではありません <see cref="T:System.Threading.Tasks.ParallelLoopState" /> 関連付けられているループの後にインスタンス終了もを安全に明示的を受け取り、その他のスレッドにし、そのスレッドがいつでもアクセスできます。  異なる <see cref="T:System.Threading.Tasks.ParallelLoopState" /> インスタンスは、ループに含まれる各スレッドに提供されます。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public void Break ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Break() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Break" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のイテレーションの終了後、システムはできるだけ早く <see cref="T:System.Threading.Tasks.Parallel" /> ループの実行を終了する必要があることを通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 現在のイテレーションの後のイテレーションを実行しないことを示します。 実質的に、ループの追加、イテレーションをキャンセルします。 ただし、実行が既に開始されているすべてのイテレーションは停止しません。 たとえば場合、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 100 の反復処理する 0 から 1,000、すべてのイテレーションに 100 よりも小さいまだ実行が 101 までからイテレーションを開始していないを持っていないを 1000年に実行される並列ループのイテレーションから呼び出されます。  
  
 既に実行中、実行時間の長いイテレーション <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 設定、 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> プロパティ、現在のインデックスが現在の値より小さい場合は、現在のイテレーションのインデックスを <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>します。 インデックスが競合している場合の実行から最下位の区切りイテレーションより大きい反復処理を停止するには、次の操作を行う必要があります。  
  
1.  確認するかどうか、 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> プロパティは `true`です。  
  
2.  インデックスがより大きい場合は、イテレーションを終了、 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> プロパティの値。  
  
 具体的な例を次に示します。  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 順序付けはデータ ソースに存在検索ベースのアルゴリズムで一般的に使用します。  
  
   
  
## 例  
 次の例では、並列ループの最大 100 個のイテレーションを実行します。 各イテレーションは、1 から 1,000 ミリ秒単位までのランダムな間隔の一時停止します。 ランダムに生成された値がループのイテレーションの決定、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドが呼び出されます。 例に示す、インデックスがあるより大きいなしのイテレーションからの出力として、 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> 呼び出しの後にプロパティ値の開始、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドです。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method. If  the property value is **languageKeyword tag is not supported!!!!**  
, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> property and, if it is greater than the current iteration's index value, returns immediately.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> メソッドが呼び出されました。<see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /><see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> 同じループのイテレーションで組み合わせて使用できません。</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      </Docs>
    </Member>
    <Member MemberName="IsExceptional">
      <MemberSignature Language="C#" Value="public bool IsExceptional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExceptional" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsExceptional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ループのいずれかのイテレーションが、そのイテレーションによって処理されなかった例外をスローしたかどうかを示す値を取得します。</summary>
        <value>処理されない例外がスローされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStopped">
      <MemberSignature Language="C#" Value="public bool IsStopped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStopped" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ループのいずれかのイテレーションが <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> メソッドを呼び出したかどうかを示す値を取得します。</summary>
        <value>
          <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> メソッドを呼び出していずれかのイテレーションが停止した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ループの実行時間の長いイテレーションの値を取得できます、 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> プロパティを決定するかどうか、ループのすべてのイテレーションを呼び出す前に実行を開始、 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドがまだ実行中です。 値を使用することができますし、 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> プロパティをすぐに返すまたは正常に実行するかどうかする必要があります。  
  
   
  
## 例  
 次の例では、並列ループの最大 10,000 個までのイテレーションを実行します。 各イテレーションは、1 から 1,000 ミリ秒単位までのランダムな間隔の一時停止します。 ランダムに生成された値がループのイテレーションの決定、 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドが呼び出されます。 ループの反復処理がまだときに実行されている可能性があるため、 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドを呼び出すラムダ式の呼び出し、 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> 別のイテレーションが呼び出されているかどうかを確認する方法を <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドです。 返された場合 `true`, 、イテレーションがすぐに返されます。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LowestBreakIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;long&gt; LowestBreakIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int64&gt; LowestBreakIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> を呼び出したループのイテレーションのうち、最下位のイテレーションを取得します。</summary>
        <value>
          <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> を呼び出したイテレーションのうち、最下位のイテレーション。<see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" /> ループの場合、値は内部的に生成されたインデックスに基づきます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す並列ループの複数のイテレーションに可能であれば、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドです。 この値は、最小のインデックスを呼び出したイテレーションの場合は、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>です。 ループの繰り返しが呼び出されない場合 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, 、このプロパティを返します `null`します。 プロパティの値がへの呼び出しによって影響を受けることに注意してください、 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドです。  
  
 呼び出す反復処理にすべてのイテレーションが実行時間の長い一連のイテレーションで、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドが実行されない必要がある、 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> プロパティを使用して、呼び出しの前に実行を開始したイテレーションの終了、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドです。 インデックスが競合している場合の実行から最下位の区切りイテレーションより大きい反復処理を停止するには、次の操作を行う必要があります。  
  
1.  確認するかどうか、 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> プロパティは `true`です。  
  
2.  インデックスがより大きい場合は、イテレーションを終了、 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> プロパティの値。  
  
 具体的な例を次に示します。  
  
   
  
## 例  
 次の例では、並列ループの最大 100 個のイテレーションを実行します。 各イテレーションは、1 から 1,000 ミリ秒単位までのランダムな間隔の一時停止します。 ランダムに生成された値がループのイテレーションの決定、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドが呼び出されます。 これにより、インデックスがあるより大きいイテレーション、 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> プロパティの値への呼び出し後の開始から、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドに、すでに実行されており、イテレーションは影響しません。 これらを完了するを防ぐためには、各反復処理を呼び出す、 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> 別のイテレーションが呼び出されているかどうかを確認する方法を <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドです。 イテレーションがの値をチェックするため場合、 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> プロパティと、現在のイテレーションのインデックス値より大きい場合は、\[直ちに返されます。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Note that, because the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> value is out of scope outside of the parallel loop, you must assign it to a variable that is visible outside of the loop if you want to preserve its value.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
      </Docs>
    </Member>
    <Member MemberName="ShouldExitCurrentIteration">
      <MemberSignature Language="C#" Value="public bool ShouldExitCurrentIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldExitCurrentIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このイテレーションまたは他のイテレーションからの要求に基づいて、ループの現在のイテレーションを終了する必要があるかどうかを示す値を取得します。</summary>
        <value>現在のイテレーションを終了する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> にプロパティが設定されている `true` 次の条件のいずれか。  
  
-   ループの呼び出しのイテレーション <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> または <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>です。  
  
-   ループの反復処理では、例外をスローします。  
  
-   ループは取り消されます。  
  
 このプロパティが `true`, 、 <xref:System.Threading.Tasks.Parallel> クラスは、ループの追加のイテレーションが実行を開始することを禁止する積極的に試みます。 ただし、開始から追加のイテレーションを防ぐことができない場合があります。  
  
 実行時間の長いイテレーションが実行を開始したことの場合もあります。 このような場合のイテレーションを調べることに明示的に、 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> プロパティを返す場合は、プロパティは、中止の実行 `true`します。  
  
   
  
## 例  
 次の例では、並列ループの最大 100 個のイテレーションを実行します。 各イテレーションは、1 から 1,000 ミリ秒単位までのランダムな間隔の一時停止します。 ランダムに生成された値がループのイテレーションの決定、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドが呼び出されます。 これにより、インデックスがあるより大きいイテレーション、 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> プロパティの値への呼び出し後の開始から、 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドに、すでに実行されており、イテレーションは影響しません。 これらを完了するを防ぐためには、各反復処理を呼び出す、 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> 別のイテレーションが呼び出されているかどうかを確認する方法を <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドです。 イテレーションがの値をチェックするため場合、 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> プロパティと、現在のイテレーションのインデックス値より大きい場合は、\[直ちに返されます。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>システムはできるだけ早く <see cref="T:System.Threading.Tasks.Parallel" /> ループの実行を終了する必要があることを通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す、 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドでは、まだ開始されていないループの反復を実行しない必要があることを示します。 実質的に、ループの追加、イテレーションをキャンセルします。 ただし、実行が既に開始されているすべてのイテレーションは停止しません。  
  
 呼び出す、 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッド、 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> を返すプロパティ `true` がまだ実行中、ループのいずれかのイテレーションにします。 これは、実行時間の長いイテレーションは、確認できる場合に特に役立ちます、 <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> プロパティと終了値が初期場合 `true`します。  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> ここで、結果は見つかった、他のイテレーション必要がある実行検索ベースのアルゴリズムで一般的に使用します。  
  
   
  
## 例  
 次の例では、並列ループの最大 10,000 個までのイテレーションを実行します。 各イテレーションは、1 から 1,000 ミリ秒単位までのランダムな間隔の一時停止します。 ランダムに生成された値がループのイテレーションの決定、 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドが呼び出されます。 例の出力に示すように、イテレーションは実行されない呼び出しの後に、 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドです。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> method to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method. If it returns **languageKeyword tag is not supported!!!!**  
, the iteration returns immediately.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> メソッドが既に呼び出されています。<see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /><see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> 同じループのイテレーションで組み合わせて使用できません。</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      </Docs>
    </Member>
  </Members>
</Type>