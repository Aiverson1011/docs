<Type Name="TaskFactory" FullName="System.Threading.Tasks.TaskFactory">
  <TypeSignature Language="C#" Value="public class TaskFactory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskFactory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskFactory" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.Threading.Tasks.Task" /> オブジェクトを作成およびスケジュールするためのサポートを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework には、2 つのファクトリの作成とタスクのスケジュールが用意されています。  
  
-   <xref:System.Threading.Tasks.TaskFactory> クラスを作成する <xref:System.Threading.Tasks.Task> と <xref:System.Threading.Tasks.Task%601> オブジェクトです。 作成し、既定以外の引数を必要とするタスクを実行するには、このメソッドのオーバー ロードを呼び出すことができます。  
  
    > [!WARNING]
    >  以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName> メソッドは既定の構成値を使ってタスクを作成し、それをすぐに開始するには、最も簡単な方法を提供します。  
  
-   <xref:System.Threading.Tasks.TaskFactory%601> クラスを作成する <xref:System.Threading.Tasks.Task%601> オブジェクトです。  
  
 <xref:System.Threading.Tasks.TaskFactory> クラスでは、以下を実行することができます。  
  
-   タスクを作成し、それを呼び出すことによってすぐに開始、 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> メソッドです。  
  
    > [!WARNING]
    >  以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName> メソッドは既定の構成値を使ってタスクを作成し、それをすぐに開始するには、最も簡単な方法を提供します。  
  
-   配列内のタスクのいずれかが呼び出すことによって完了したときに起動するタスクを作成、 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> メソッドです。  
  
-   呼び出して配列内のすべてのタスクの完了したときに開始するタスクを作成、 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> メソッドです。  
  
 静的な <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=fullName> プロパティは、既定値を返します <xref:System.Threading.Tasks.TaskFactory%601> オブジェクトです。 いずれかを呼び出すことができます、 <xref:System.Threading.Tasks.TaskFactory> クラスのコンス トラクターを構成する、 <xref:System.Threading.Tasks.Task> オブジェクトを <xref:System.Threading.Tasks.TaskFactory> クラスを作成します。 次の例は、新しい構成 <xref:System.Threading.Tasks.TaskFactory> を持つ指定したキャンセル トークン、タスク作成オプション、継続オプション、およびカスタマイズされたタスク スケジューラのタスクを作成するオブジェクト。  
  
 [!code-csharp[TPL\_Factories\#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_factories/cs/program.cs#1)]
 [!code-vb[TPL\_Factories\#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_factories/vb/factories_vb.vb#1)]  
  
 ほとんどの場合は、新しいインスタンスを作成する必要はありません <xref:System.Threading.Tasks.TaskFactory> インスタンス。 代わりに、使用、 <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=fullName> プロパティで、既定値を使用するファクトリ オブジェクトを返します。 新しいタスクを開始または継続タスクを定義するには、そのメソッドを呼び出すことができます。 具体的な例を参照してください。  
  
   
  
## 例  
 次の例は、静的な <xref:System.Threading.Tasks.Task.Factory%2A> 2 つの呼び出しのためのプロパティを <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> メソッドです。 1 つ目は、2 つ目はユーザーのマイ ドキュメント ディレクトリのサブディレクトリの名前を持つ配列を設定中に、ユーザーのマイ ドキュメント ディレクトリ内のファイルの名前を持つ配列を設定します。 呼び出して、 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=fullName> メソッドで、最初の 2 つのタスクの実行が完了した後、2 つの配列でファイルとディレクトリの数についての情報を表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>すべてのパブリック、プロテクト メンバー <see cref="T:System.Threading.Tasks.TaskFactory" /> スレッド セーフでは、複数のスレッドから同時に使用される場合があります。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>既定の構成を使用して、<see cref="T:System.Threading.Tasks.TaskFactory" /> インスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターを作成、 <xref:System.Threading.Tasks.TaskFactory> 既定の構成とインスタンス。<xref:System.Threading.Tasks.TaskCreationOptions> プロパティが初期化 <xref:System.Threading.Tasks.TaskCreationOptions.None>, 、 <xref:System.Threading.Tasks.TaskContinuationOptions> プロパティが初期化 <xref:System.Threading.Tasks.TaskContinuationOptions.None>, 、および <xref:System.Threading.Tasks.TaskScheduler> プロパティは、現在のスケジューラに初期化 \(を参照してください <xref:System.Threading.Tasks.TaskScheduler.Current%2A>\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">ファクトリ メソッドの呼び出し時に別の CancellationToken が明示的に指定されていない場合に、この <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> によって作成されたタスクに割り当てられる <see cref="T:System.Threading.Tasks.TaskFactory" />。</param>
        <summary>指定された構成を使用して、<see cref="T:System.Threading.Tasks.TaskFactory" /> インスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターを作成、 <xref:System.Threading.Tasks.TaskFactory> 既定の構成とインスタンス。<xref:System.Threading.Tasks.TaskCreationOptions> プロパティが初期化 <xref:System.Threading.Tasks.TaskCreationOptions.None>, 、 <xref:System.Threading.Tasks.TaskContinuationOptions> プロパティが初期化 <xref:System.Threading.Tasks.TaskContinuationOptions.None>, 、および <xref:System.Threading.Tasks.TaskScheduler> プロパティは、現在のスケジューラに初期化 \(を参照してください <xref:System.Threading.Tasks.TaskScheduler.Current%2A>\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">この TaskFactory を使用して作成されたタスクをスケジュールするときに使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。 null 値は、現在の TaskScheduler が使用されることを示します。</param>
        <summary>指定された構成を使用して、<see cref="T:System.Threading.Tasks.TaskFactory" /> インスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターで、 <xref:System.Threading.Tasks.TaskCreationOptions> プロパティが初期化 <xref:System.Threading.Tasks.TaskCreationOptions.None>, 、 <xref:System.Threading.Tasks.TaskContinuationOptions> プロパティが初期化 <xref:System.Threading.Tasks.TaskContinuationOptions.None>, 、および <xref:System.Threading.Tasks.TaskScheduler> にプロパティを初期化 `scheduler`, 、プロパティが現在のスケジューラに初期化されている場合、null である場合を除き、\(を参照してください <xref:System.Threading.Tasks.TaskScheduler.Current%2A>\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions">この TaskFactory を使用してタスクを作成するときに使用する既定の <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <param name="continuationOptions">この TaskFactory を使用して継続タスクを作成するときに使用する既定の <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />。</param>
        <summary>指定された構成を使用して、<see cref="T:System.Threading.Tasks.TaskFactory" /> インスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターで、 <xref:System.Threading.Tasks.TaskCreationOptions> プロパティが初期化 `creationOptions`, 、 <xref:System.Threading.Tasks.TaskContinuationOptions> プロパティが初期化 `continuationOptions`, 、および <xref:System.Threading.Tasks.TaskScheduler> プロパティは、現在のスケジューラに初期化 \(を参照してください <xref:System.Threading.Tasks.TaskScheduler.Current%2A>\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引数の指定、無効な <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 値。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />します。  
  
 または  
  
 <paramref name="continuationOptions" /> 引数が無効な値を指定します。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">ファクトリ メソッドの呼び出し時に別の CancellationToken が明示的に指定されていない場合に、この <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> によって作成されたタスクに割り当てられる既定の <see cref="T:System.Threading.Tasks.TaskFactory" />。</param>
        <param name="creationOptions">この TaskFactory を使用してタスクを作成するときに使用する既定の <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <param name="continuationOptions">この TaskFactory を使用して継続タスクを作成するときに使用する既定の <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />。</param>
        <param name="scheduler">この TaskFactory を使用して作成されたタスクをスケジュールするときに使用する既定の <see cref="T:System.Threading.Tasks.TaskScheduler" />。 null 値は、TaskScheduler.Current が使用されることを示します。</param>
        <summary>指定された構成を使用して、<see cref="T:System.Threading.Tasks.TaskFactory" /> インスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このコンス トラクターで、 <xref:System.Threading.Tasks.TaskCreationOptions> プロパティが初期化 `creationOptions`, 、 <xref:System.Threading.Tasks.TaskContinuationOptions> プロパティが初期化 `continuationOptions`, 、および <xref:System.Threading.Tasks.TaskScheduler> にプロパティを初期化 `scheduler`, 、プロパティが現在のスケジューラに初期化されている場合、null である場合を除き、\(を参照してください <xref:System.Threading.Tasks.TaskScheduler.Current%2A>\)。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引数の指定、無効な <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 値。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />します。  
  
 または  
  
 <paramref name="continuationOptions" /> 引数が無効な値を指定します。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken CancellationToken" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このタスク ファクトリの既定のキャンセル トークンを取得します。</summary>
        <value>このタスク ファクトリの既定のタスク キャンセル トークン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティは、既定値を返します。 <xref:System.Threading.CancellationToken> しない限り、このファクトリによって作成されたすべてのタスクに割り当てられる別 <xref:System.Threading.CancellationToken> ファクトリ メソッドへの呼び出し時に値が明示的に指定します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinuationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskContinuationOptions ContinuationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このタスク ファクトリの既定のタスク継続オプションを取得します。</summary>
        <value>このタスク ファクトリの既定のタスク継続オプション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 その他のオプションがこのファクトリ メソッドへの呼び出し中に明示的に指定されている場合を除き、すべての継続タスクを作成するプロパティの値が使用します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに実行するアクション デリゲート。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [ContinueWhenAll メソッド \(Task\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> メソッドが実行される、 `continuationAction` デリゲートであるすべてのタスクと、 `tasks` その完了ステータスに関係なく、配列が完了します。  
  
 内のタスクによってスローされた例外、 `tasks` 配列が構造化例外処理を継続タスクにご利用いただけません。 調べることによってスローされた例外を指定できます、 [ContinueWhenAll メソッド \(Task\<xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=fullName> 内の各タスクのプロパティ、 `tasks` 配列。 構造化例外内のタスクによってスローされる例外を処理する処理を使用する、 `tasks` 配列を呼び出し、 [ContinueWhenAll メソッド \(Task\<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=fullName> メソッドです。  
  
   
  
## 例  
 次の例では、一連のテキスト ファイル内の単語の数をカウントする正規表現を使用する別のタスクを起動します。[ContinueWhenAll メソッド \(Task\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> メソッドを使用してすべての継続元タスクが完了した場合に、全ワード数を表示するタスクを起動します。  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall1.vb#1)]  
  
 継続タスクへの呼び出し [ContinueWhenAll メソッド \(Task\<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> メソッドは許可されていないため、例では、検証、継続元タスクによってスローされる例外を処理する、 [ContinueWhenAll メソッド \(Task\<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=fullName> タスクが成功したかどうかを判断する各継続元タスクのプロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てるキャンセル トークン。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [ContinueWhenAll メソッド \(Task\[\], Action\(Task\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%2CSystem.Threading.CancellationToken%29> メソッドが実行される、 `continuationAction` デリゲートであるすべてのタスクと、 `tasks` その完了ステータスに関係なく、配列が完了します。  
  
   
  
## 例  
 次の例では、個別の一連のテキスト ファイル内の単語の数をカウントする正規表現を使用してタスクに渡されますキャンセル トークンを作成します。 ファイルが見つからない場合、キャンセル トークンが設定されています。[ContinueWhenAll メソッド \(Task\[\], Action\(Task\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> メソッドを使用してすべての継続元タスクが完了した場合に、全ワード数を表示するタスクを起動します。 1 つまたは複数のタスクが取り消された、処理のことを示すキャンセル トークンが設定されている場合、 [ContinueWhenAll メソッド \(Task\[\], Action\(Task\<xref:System.AggregateException> 例外とエラー メッセージが表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。  
  
 または  
  
 <see cref="T:System.Threading.CancellationTokenSource" /> 作成 <paramref name="cancellationToken" /> 既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="continuationOptions">新しい継続タスクの動作を制御する列挙値のビットごとの組み合わせ。 NotOn\* メンバーと OnlyOn\* メンバーはサポートされていません。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が無効な値を指定します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てるキャンセル トークン。</param>
        <param name="continuationOptions">新しい継続タスクの動作を制御する列挙値のビットごとの組み合わせ。</param>
        <param name="scheduler">新しい継続タスクをスケジュールするときに使用するオブジェクト。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationAction" /> 引数が <see langword="null" /> です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに実行するアクション デリゲート。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てるキャンセル トークン。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。  
  
 または  
  
 <see cref="T:System.Threading.CancellationTokenSource" /> 作成 <paramref name="cancellationToken" /> 既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="continuationOptions">新しい継続タスクの動作を制御する列挙値のビットごとの組み合わせ。 NotOn\* メンバーと OnlyOn\* メンバーはサポートされていません。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が無効な値を指定します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てるキャンセル トークン。</param>
        <param name="continuationOptions">新しい継続タスクの動作を制御する列挙値のビットごとの組み合わせ。 NotOn\* メンバーと OnlyOn\* メンバーはサポートされていません。</param>
        <param name="scheduler">新しい継続タスクをスケジュールするときに使用するオブジェクト。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationAction" /> 引数が <see langword="null" /> です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成されたタスクに関連付けられている結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成されたタスクに関連付けられている結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てるキャンセル トークン。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。  
  
 または  
  
 <see cref="T:System.Threading.CancellationTokenSource" /> 作成 <paramref name="cancellationToken" /> 既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成されたタスクに関連付けられている結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="continuationOptions">新しい継続タスクの動作を制御する列挙値のビットごとの組み合わせ。 NotOn\* メンバーと OnlyOn\* メンバーはサポートされていません。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が無効な値を指定します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成されたタスクに関連付けられている結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てるキャンセル トークン。</param>
        <param name="continuationOptions">新しい継続タスクの動作を制御する列挙値のビットごとの組み合わせ。 NotOn\* メンバーと OnlyOn\* メンバーはサポートされていません。</param>
        <param name="scheduler">新しい継続タスクをスケジュールするときに使用するオブジェクト。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationFunction" /> 引数が <see langword="null" /> です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成されたタスクに関連付けられている結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成されたタスクに関連付けられている結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てるキャンセル トークン。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。  
  
 または  
  
 <see cref="T:System.Threading.CancellationTokenSource" /> 作成<paramref name=" cancellationToken" /> 既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成されたタスクに関連付けられている結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="continuationOptions">新しい継続タスクの動作を制御する列挙値のビットごとの組み合わせ。 NotOn\* メンバーと OnlyOn\* メンバーはサポートされていません。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が無効な値を指定します。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成されたタスクに関連付けられている結果の型。</typeparam>
        <param name="tasks">継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のすべてのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てるキャンセル トークン。</param>
        <param name="continuationOptions">新しい継続タスクの動作を制御する列挙値のビットごとの組み合わせ。 NotOn\* メンバーと OnlyOn\* メンバーはサポートされていません。</param>
        <param name="scheduler">新しい継続タスクをスケジュールするときに使用するオブジェクト。</param>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationFunction" /> 引数が <see langword="null" /> です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が空または null 値が含まれています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が無効な値を指定します。</exception>
        <exception cref="T:System.ObjectDisposedException">内の要素、 <paramref name="tasks" /> 配列が破棄されています。  
  
 または  
  
 <see cref="T:System.Threading.CancellationTokenSource" /> 作成 <paramref name="cancellationToken" /> 既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに実行するアクション デリゲート。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例は、使用する方法を示しています`ContinueWhenAny`と`ContinueWhenAll`:。  
  
 [!code-csharp[System.Threading.Tasks.Task\#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuewhenmulti.cs#05)]
 [!code-vb[System.Threading.Tasks.Task\#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuewhenmulti.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="tasks" /> 配列の要素の 1 つは破棄されました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" /> です。  
  
 または  
  
 <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列には <see langword="null" /> の値が含まれます。  
  
 または  
  
 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">内の要素の 1 つ、 <paramref name="tasks" /> 配列が破棄されています。  
  
 または  
  
 <paramref name="cancellationToken" /> 既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 配列が <see langword="null" />です。  
  
 または  
  
 <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が含まれる、 <see langword="null" /> 値。  
  
 または  
  
 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="continuationOptions">作成された継続 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の動作を制御する <see cref="T:System.Threading.Tasks.Task" /> 値。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 NotOn \* と OnlyOn \* [ContinueWhenAny メソッド \(Task\<xref:System.Threading.Tasks.TaskContinuationOptions>, を制約する [ContinueWhenAny メソッド \(Task\<xref:System.Threading.Tasks.TaskStatus> ContinueWhenAny で継続タスクは実行され、状態はできません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">場合にスローされる例外で要素の 1 つ、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationAction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="continuationOptions" /> 引数が無効な TaskContinuationOptions 値を指定します。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">作成された継続 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の動作を制御する <see cref="T:System.Threading.Tasks.Task" /> 値。</param>
        <param name="scheduler">作成された継続 <see cref="T:System.Threading.Tasks.TaskScheduler" /> をスケジュールするときに使用する <see cref="T:System.Threading.Tasks.Task" />。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationAction" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに実行するアクション デリゲート。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">場合にスローされる例外で要素の 1 つ、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationAction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">場合にスローされる例外で要素の 1 つ、 <paramref name="tasks" /> 配列が破棄されています。  
  
 または  
  
 指定された <see cref="T:System.Threading.CancellationToken" /> 既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationAction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="continuationOptions">作成された継続 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の動作を制御する <see cref="T:System.Threading.Tasks.Task" /> 値。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 NotOn \* と OnlyOn \* [ContinueWhenAny\(TAntecedentResult\) メソッド \(Task\(TAntecedentResult\)\<xref:System.Threading.Tasks.TaskContinuationOptions>, を制約する [ContinueWhenAny\(TAntecedentResult\) メソッド \(Task\(TAntecedentResult\)\<xref:System.Threading.Tasks.TaskStatus> ContinueWhenAny で継続タスクは実行され、状態はできません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">場合にスローされる例外で要素の 1 つ、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationAction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="continuationOptions" /> 引数が無効な TaskContinuationOptions 値を指定します。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationAction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに実行するアクション デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">作成された継続 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の動作を制御する <see cref="T:System.Threading.Tasks.Task" /> 値。</param>
        <param name="scheduler">作成された継続 <see cref="T:System.Threading.Tasks.TaskScheduler" /> をスケジュールするときに使用する <see cref="T:System.Threading.Tasks.Task`1" />。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 NotOn \* と OnlyOn \* [ContinueWhenAny\(TAntecedentResult\) メソッド \(Task\(TAntecedentResult\)\<xref:System.Threading.Tasks.TaskContinuationOptions>, を制約する [ContinueWhenAny\(TAntecedentResult\) メソッド \(Task\(TAntecedentResult\)\<xref:System.Threading.Tasks.TaskStatus> ContinueWhenAny で継続タスクは実行され、状態はできません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationAction" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成された <see cref="T:System.Threading.Tasks.Task`1" /> に関連付けられている結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">場合にスローされる例外で要素の 1 つ、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成された <see cref="T:System.Threading.Tasks.Task`1" /> に関連付けられている結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">場合にスローされる例外で要素の 1 つ、 <paramref name="tasks" /> 配列が破棄されています。  
  
 または  
  
 指定された <see cref="T:System.Threading.CancellationToken" /> 既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成された <see cref="T:System.Threading.Tasks.Task`1" /> に関連付けられている結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="continuationOptions">作成された継続 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の動作を制御する <see cref="T:System.Threading.Tasks.Task`1" /> 値。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 NotOn \* と OnlyOn \* [ContinueWhenAny\(TResult\) メソッド \(Task\<xref:System.Threading.Tasks.TaskContinuationOptions>, を制約する [ContinueWhenAny\(TResult\) メソッド \(Task\<xref:System.Threading.Tasks.TaskStatus> ContinueWhenAny で継続タスクは実行され、状態はできません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">場合にスローされる例外で要素の 1 つ、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="continuationOptions" /> 引数が無効な TaskContinuationOptions 値を指定します。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成された <see cref="T:System.Threading.Tasks.Task`1" /> に関連付けられている結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">作成された継続 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の動作を制御する <see cref="T:System.Threading.Tasks.Task`1" /> 値。</param>
        <param name="scheduler">作成された継続 <see cref="T:System.Threading.Tasks.TaskScheduler" /> をスケジュールするときに使用する <see cref="T:System.Threading.Tasks.Task`1" />。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 NotOn \* と OnlyOn \* [ContinueWhenAny\(TResult\) メソッド \(Task\<xref:System.Threading.Tasks.TaskContinuationOptions>, を制約する [ContinueWhenAny\(TResult\) メソッド \(Task\<xref:System.Threading.Tasks.TaskStatus> ContinueWhenAny で継続タスクは実行され、状態はできません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationFunction" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成された <see cref="T:System.Threading.Tasks.Task`1" /> に関連付けられている結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">場合にスローされる例外で要素の 1 つ、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成された <see cref="T:System.Threading.Tasks.Task`1" /> に関連付けられている結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">場合にスローされる例外で要素の 1 つ、 <paramref name="tasks" /> 配列が破棄されています。  
  
 または  
  
 指定された <see cref="T:System.Threading.CancellationToken" /> 既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成された <see cref="T:System.Threading.Tasks.Task`1" /> に関連付けられている結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="continuationOptions">作成された継続 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の動作を制御する <see cref="T:System.Threading.Tasks.Task`1" /> 値。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 NotOn \* と OnlyOn \* [ContinueWhenAny\(TAntecedentResult, TResult\) メソッド \(Task\(TAntecedentResult\)\<xref:System.Threading.Tasks.TaskContinuationOptions>, を制約する [ContinueWhenAny\(TAntecedentResult, TResult\) メソッド \(Task\(TAntecedentResult\)\<xref:System.Threading.Tasks.TaskStatus> ContinueWhenAny で継続タスクは実行され、状態はできません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">場合にスローされる例外で要素の 1 つ、 <paramref name="tasks" /> 配列が破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="continuationOptions" /> 引数が無効な TaskContinuationOptions 値を指定します。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">継続元の <c>tasks</c> の結果の型。</typeparam>
        <typeparam name="TResult">
          <c>continuationFunction</c> デリゲートによって返され、作成された <see cref="T:System.Threading.Tasks.Task`1" /> に関連付けられている結果の型。</typeparam>
        <param name="tasks">いずれかのタスクが完了したときに開始される継続タスクの配列。</param>
        <param name="continuationFunction">
          <c>tasks</c> 配列内のいずれかのタスクが完了したときに非同期的に実行する関数デリゲート。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">作成された継続 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の動作を制御する <see cref="T:System.Threading.Tasks.Task`1" /> 値。</param>
        <param name="scheduler">作成された継続 <see cref="T:System.Threading.Tasks.TaskScheduler" /> をスケジュールするときに使用する <see cref="T:System.Threading.Tasks.Task`1" />。</param>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 NotOn \* と OnlyOn \* [ContinueWhenAny\(TAntecedentResult, TResult\) メソッド \(Task\(TAntecedentResult\)\<xref:System.Threading.Tasks.TaskContinuationOptions>, を制約する [ContinueWhenAny\(TAntecedentResult, TResult\) メソッド \(Task\(TAntecedentResult\)\<xref:System.Threading.Tasks.TaskStatus> ContinueWhenAny で継続タスクは実行され、状態はできません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="tasks" /> 配列が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="continuationFunction" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentException">場合にスローされる例外、 <paramref name="tasks" /> 配列には、null 値が含まれています。  
  
 または  
  
 場合にスローされる例外、 <paramref name="tasks" /> 配列が空です。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このタスク ファクトリの既定のタスク作成オプションを取得します。</summary>
        <value>このタスク ファクトリの既定のタスク作成オプション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The property value is used to create all tasks, unless other options are explicitly specified during calls to this factory's methods.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
      </Parameters>
      <Docs>
        <param name="asyncResult">完了時に <c>endMethod</c> の処理が開始される IAsyncResult。</param>
        <param name="endMethod">完了した <c>asyncResult</c> を処理するアクション デリゲート。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task" /> の完了時に終了メソッド アクションを実行する <see cref="T:System.IAsyncResult" /> を作成します。</summary>
        <returns>非同期操作を表す <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> を受け取るオーバー ロード、 `asyncResult` パラメーターが使用するオーバー ロードとして、効率的ではありません、 `beginMethod` パラメーター。 パフォーマンスが問題の場合は、指定できるオーバー ロードを使用して、 `beginMethod`\/`endMethod` パターンです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="asyncResult" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。  このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="asyncResult">完了時に <c>endMethod</c> の処理が開始される IAsyncResult。</param>
        <param name="endMethod">完了した <c>asyncResult</c> を処理するアクション デリゲート。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task" /> の完了時に終了メソッド アクションを実行する <see cref="T:System.IAsyncResult" /> を作成します。</summary>
        <returns>非同期操作を表す <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> を受け取るオーバー ロード、 `asyncResult` パラメーターが使用するオーバー ロードとして、効率的ではありません、 `beginMethod` パラメーター。 パフォーマンスが問題の場合は、指定できるオーバー ロードを使用して、 `beginMethod`\/`endMethod` パターンです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="asyncResult" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。<xref:System.Threading.Tasks.TaskCreationOptions> 値 <xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness>, 、<xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> と <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> すべてが相互に排他的です。 FromAsync メソッドで、 `LongRunning` または `AttachedToParent` とが単独で、 <xref:System.ArgumentOutOfRangeException> がスローされます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="asyncResult">完了時に <c>endMethod</c> の処理が開始される IAsyncResult。</param>
        <param name="endMethod">完了した <c>asyncResult</c> を処理するアクション デリゲート。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task" /> の動作を制御する TaskCreationOptions 値。</param>
        <param name="scheduler">終了メソッドを実行するタスクをスケジュールするときに使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task" /> の完了時に終了メソッド アクションを実行する <see cref="T:System.IAsyncResult" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> を受け取るオーバー ロード、 `asyncResult` パラメーターが使用するオーバー ロードとして、効率的ではありません、 `beginMethod` パラメーター。 パフォーマンスが問題の場合は、指定できるオーバー ロードを使用して、 `beginMethod`\/`endMethod` パターンです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="asyncResult" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="asyncResult">完了時に <c>endMethod</c> の処理が開始される IAsyncResult。</param>
        <param name="endMethod">完了した <c>asyncResult</c> を処理する関数デリゲート。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に終了メソッド関数を実行する <see cref="T:System.IAsyncResult" /> を作成します。</summary>
        <returns>非同期操作を表す <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> を受け取るオーバー ロード、 `asyncResult` パラメーターが使用するオーバー ロードとして、効率的ではありません、 `beginMethod` パラメーター。 パフォーマンスが問題の場合は、指定できるオーバー ロードを使用して、 `beginMethod`\/`endMethod` パターンです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="asyncResult" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="asyncResult">完了時に <c>endMethod</c> の処理が開始される IAsyncResult。</param>
        <param name="endMethod">完了した <c>asyncResult</c> を処理する関数デリゲート。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task`1" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に終了メソッド関数を実行する <see cref="T:System.IAsyncResult" /> を作成します。</summary>
        <returns>非同期操作を表す <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> を受け取るオーバー ロード、 `asyncResult` パラメーターが使用するオーバー ロードとして、効率的ではありません、 `beginMethod` パラメーター。 パフォーマンスが問題の場合は、指定できるオーバー ロードを使用して、 `beginMethod`\/`endMethod` パターンです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="asyncResult" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task`1" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="asyncResult">完了時に <c>endMethod</c> の処理が開始される IAsyncResult。</param>
        <param name="endMethod">完了した <c>asyncResult</c> を処理する関数デリゲート。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task`1" /> の動作を制御する TaskCreationOptions 値。</param>
        <param name="scheduler">終了メソッドを実行するタスクをスケジュールするときに使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に終了メソッド関数を実行する <see cref="T:System.IAsyncResult" /> を作成します。</summary>
        <returns>非同期操作を表す <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> を受け取るオーバー ロード、 `asyncResult` パラメーターが使用するオーバー ロードとして、効率的ではありません、 `beginMethod` パラメーター。 パフォーマンスが問題の場合は、指定できるオーバー ロードを使用して、 `beginMethod`\/`endMethod` パターンです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="asyncResult" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 2 引数の型。</typeparam>
        <typeparam name="TArg2">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="arg2">
          <c>beginMethod</c> デリゲートに渡される第 2 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 2 引数の型。</typeparam>
        <typeparam name="TArg2">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="arg2">
          <c>beginMethod</c> デリゲートに渡される第 2 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task`1" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 2 引数の型。</typeparam>
        <typeparam name="TArg2">
          <c>beginMethod</c> デリゲートに渡される第 3 引数の型。</typeparam>
        <typeparam name="TArg3">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="arg2">
          <c>beginMethod</c> デリゲートに渡される第 2 引数。</param>
        <param name="arg3">
          <c>beginMethod</c> デリゲートに渡される第 3 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 2 引数の型。</typeparam>
        <typeparam name="TArg2">
          <c>beginMethod</c> デリゲートに渡される第 3 引数の型。</typeparam>
        <typeparam name="TArg3">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="arg2">
          <c>beginMethod</c> デリゲートに渡される第 2 引数。</param>
        <param name="arg3">
          <c>beginMethod</c> デリゲートに渡される第 3 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 2 引数の型。</typeparam>
        <typeparam name="TArg2">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="arg2">
          <c>beginMethod</c> デリゲートに渡される第 2 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 2 引数の型。</typeparam>
        <typeparam name="TArg2">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="arg2">
          <c>beginMethod</c> デリゲートに渡される第 2 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task`1" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 2 引数の型。</typeparam>
        <typeparam name="TArg2">
          <c>beginMethod</c> デリゲートに渡される第 3 引数の型。</typeparam>
        <typeparam name="TArg3">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="arg2">
          <c>beginMethod</c> デリゲートに渡される第 2 引数。</param>
        <param name="arg3">
          <c>beginMethod</c> デリゲートに渡される第 3 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">
          <c>beginMethod</c> デリゲートに渡される第 2 引数の型。</typeparam>
        <typeparam name="TArg2">
          <c>beginMethod</c> デリゲートに渡される第 3 引数の型。</typeparam>
        <typeparam name="TArg3">
          <c>beginMethod</c> デリゲートに渡される第 1 引数の型。</typeparam>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="beginMethod">非同期操作を開始するデリゲート。</param>
        <param name="endMethod">非同期操作を終了するデリゲート。</param>
        <param name="arg1">
          <c>beginMethod</c> デリゲートに渡される第 1 引数。</param>
        <param name="arg2">
          <c>beginMethod</c> デリゲートに渡される第 2 引数。</param>
        <param name="arg3">
          <c>beginMethod</c> デリゲートに渡される第 3 引数。</param>
        <param name="state">
          <c>beginMethod</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task`1" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>非同期操作を表す作成された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `beginMethod` スレッドでデリゲートが起動される <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> で実行しています。 このメソッドによってスローされた例外をスローする、 `beginMethod`です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="beginMethod" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="endMethod" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Scheduler">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskScheduler Scheduler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.TaskScheduler Scheduler" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このタスク ファクトリの既定のタスク スケジューラを取得します。</summary>
        <value>このタスク ファクトリの既定のタスク スケジューラ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 別のスケジューラがこのファクトリ メソッドへの呼び出し中に明示的に指定されている場合を除き、すべてのタスクのスケジュールを設定するプロパティの値が使用します。  
  
 このプロパティの値がある場合 `null`, の値、 <xref:System.Threading.Tasks.TaskScheduler.Current%2A> プロパティを使用します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartNew">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> を作成して開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName> メソッドは、計算主体のタスクを起動することをお勧めします。 使用して、 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> メソッド、実行時間の長い計算主体のタスクの詳細に制御が必要な場合にのみです。 これには、以下を制御するシナリオが含まれます。  
  
-   タスク作成オプション。 によって作成されたタスク、 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName> で既定ではメソッドが作成された、 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=fullName> オプション。 この動作をオーバーライドやその他の指定に <xref:System.Threading.Tasks.TaskCreationOptions> オプションを呼び出す、 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> オーバー ロードします。  
  
-   パラメーターの引き渡しです。 オーバー ロード、 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName> メソッド パラメーターをタスク デリゲートに渡すはできません。 オーバー ロードにより、 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> メソッドを実行します。  
  
-   タスク スケジューラー。 オーバー ロード、 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName> メソッドは、既定のタスク スケジューラを使用します。 タスク スケジューラを制御するには、呼び出し、 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> でオーバー ロード、 `scheduler` パラメーター。 詳細については、次を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">非同期で実行するアクション デリゲート。</param>
        <summary>タスクを作成して開始します。</summary>
        <returns>開始されたタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> コンス トラクターのいずれかを使用し、呼び出すことによってタスクの作成に相当する機能は、 <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=fullName> メソッドを実行するためのタスクをスケジュールします。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=fullName> メソッドを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> 既定のパラメーターを使用します。 ただし、2 つのメソッドの動作の違いがあることについて: <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=fullName> 既定では許可されません子タスクの使用を開始、 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=fullName> 現在アタッチ オプション <xref:System.Threading.Tasks.Task> インスタンス <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> です。 詳細とコード例については、次を参照してください。 [Task.Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 次の例では、 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> メソッドを繰り返し呼び出して、 <xref:System.Action> 、乱数を生成するデリゲートは、Unicode コード ポイントとして解釈および、UTF16 でエンコードされたコード単位に変換結果の文字または文字に関する情報が表示されます。  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew1.cs#1)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">非同期で実行するアクション デリゲート。</param>
        <param name="cancellationToken">新しいタスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す `StartNew` 機能的、コンス トラクターと、通話のいずれかを使用してタスクを作成するのには、 <xref:System.Threading.Tasks.Task.Start%2A> 実行をスケジュールします。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=fullName> メソッドを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> 既定のパラメーターを使用します。 ただし、2 つのメソッドの動作の違いがあることについて: <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=fullName> 既定では許可されません子タスクの使用を開始、 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=fullName> 現在アタッチ オプション <xref:System.Threading.Tasks.Task> インスタンス <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> です。 詳細とコード例については、次を参照してください。 [Task.Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 次の例では、 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> C:\\Windows\\System32 ディレクトリ内のファイルを反復処理するタスクを作成します。 ラムダ式の呼び出し、 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName> する各ファイルに関する情報を追加する方法、 <xref:System.Collections.Generic.List%601> オブジェクトです。 入れ子のタスクによって呼び出された各デタッチ、 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName> ループは、キャンセル トークンの状態を確認し、キャンセルが要求される場合、 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> メソッドです。<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> メソッドでのスロー、 <xref:System.OperationCanceledException> で処理される例外、 `catch` 呼び出し元のスレッドを呼び出す場合に、ブロック、 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> メソッドです。  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew2.cs#2)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="action" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">非同期で実行するアクション デリゲート。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 StartNew の呼び出しは機能的には、コンス トラクターと、通話のいずれかを使用してタスクを作成する同じ <xref:System.Threading.Tasks.Task.Start%2A> 実行をスケジュールします。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、次を参照してください。 [Task.Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">非同期で実行するアクション デリゲート。</param>
        <param name="state">
          <c>action</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 機能的を作成するのには、 <xref:System.Threading.Tasks.Task> コンス トラクターのいずれかを使用しを呼び出す、 <xref:System.Threading.Tasks.Task.Start%2A> メソッドの実行スケジュールを設定します。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、次を参照してください。 [Task.Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 次の例では、6 文字の単語の配列を定義します。 各単語に渡されます、 <xref:System.Action%601> デリゲートでは、単語にスクランブルをかけるし、元の単語とそのスクランブルされたバージョンが表示されます。  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew3.vb#3)]  
  
 Note that the example initializes a single random number generator, which is protected by a lock. For the need of a lock, see "The System.Random class and thread safety" in the <xref:System.Random> class topic.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">非同期で実行するアクション デリゲート。</param>
        <param name="state">
          <c>action</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="cancellationToken">新しい <see cref="T:System.Threading.Tasks.Task" /> に割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 StartNew の呼び出しは機能的には、コンス トラクターと、通話のいずれかを使用してタスクを作成する同じ <xref:System.Threading.Tasks.Task.Start%2A> 実行をスケジュールします。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、次を参照してください。 [Task.Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 次の例では、6 文字の単語の配列を定義します。 各単語に渡されます、 <xref:System.Action%601> デリゲートでは、単語にスクランブルをかけるし、元の単語とそのスクランブルされたバージョンが表示されます。  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew4.cs#4)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew4.vb#4)]  
  
 Note that the example initializes a single random number generator, which is protected by a lock. For the need of a lock, see "The System.Random class and thread safety" in the <xref:System.Random> class topic. To handle the possibility of corruption of the random number generator, a cancellation token is passed to task. If two random numbers equal zero, the method assumes that the random number generator is corrupted and sets the cancellation token. Before sorting the `chars` array that contains the six characters in a word, the method calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> method to throw an <xref:System.OperationCanceledException> if the token has been canceled.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="action" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">非同期で実行するアクション デリゲート。</param>
        <param name="state">
          <c>action</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 StartNew の呼び出しは機能的には、コンス トラクターと、通話のいずれかを使用してタスクを作成する同じ <xref:System.Threading.Tasks.Task.Start%2A> 実行をスケジュールします。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、次を参照してください。 [Task.Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">非同期で実行するアクション デリゲート。</param>
        <param name="cancellationToken">新しい <see cref="T:System.Threading.Tasks.Task" /> に割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task" /> の動作を制御する TaskCreationOptions 値。</param>
        <param name="scheduler">作成された <see cref="T:System.Threading.Tasks.TaskScheduler" /> をスケジュールするときに使用する <see cref="T:System.Threading.Tasks.Task" />。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 StartNew の呼び出しは機能的には、コンス トラクターと、通話のいずれかを使用してタスクを作成する同じ <xref:System.Threading.Tasks.Task.Start%2A> 実行をスケジュールします。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、次を参照してください。 [Task.Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="action" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">非同期で実行するアクション デリゲート。</param>
        <param name="state">
          <c>action</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="cancellationToken">新しいタスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task" /> の動作を制御する TaskCreationOptions 値。</param>
        <param name="scheduler">作成された <see cref="T:System.Threading.Tasks.TaskScheduler" /> をスケジュールするときに使用する <see cref="T:System.Threading.Tasks.Task" />。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 StartNew の呼び出しは機能的には、コンス トラクターと、通話のいずれかを使用してタスクを作成する同じ <xref:System.Threading.Tasks.Task.Start%2A> 実行をスケジュールします。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、次を参照してください。 [Task.Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="action" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="function">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得される結果を返す関数デリゲート。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task`1" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 機能的を作成するのには、 <xref:System.Threading.Tasks.Task%601> コンス トラクターのいずれかを使用し、呼び出す <xref:System.Threading.Tasks.Task.Start%2A> の実行スケジュールを設定します。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、呼び出すことができます、 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=fullName> メソッドを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 ただし、2 つのメソッドの動作の違いがあることについて: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=fullName> 既定では許可されません子タスクの使用を開始、 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=fullName> 現在アタッチ オプション <xref:System.Threading.Tasks.Task%601> インスタンス <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29> です。 詳細とコード例については、エントリを参照してください。 [Task.Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 次の例は、2 つの乱数を生成し、その合計を入力するように求める単純な加算アプリです。 また、答えが正しいか、ユーザーの応答が有効な数値でない場合は、有効な数値を再入力をユーザーにメッセージが表示されますを示します。<xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 作成に使用される、 <xref:System.Threading.Tasks.Task%601> を追加する乱数を返すオブジェクトです。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Run\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="function">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得される結果を返す関数デリゲート。</param>
        <param name="state">
          <c>function</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task`1" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 作成に相当する機能は、StartNew を呼び出して、 <xref:System.Threading.Tasks.Task%601> コンス トラクターのいずれかを使用しを呼び出す <xref:System.Threading.Tasks.Task.Start%2A> の実行スケジュールを設定します。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、エントリを参照してください。 [Task.Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="function" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="function">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得される結果を返す関数デリゲート。</param>
        <param name="cancellationToken">新しい <see cref="T:System.Threading.Tasks.Task" /> に割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task`1" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出す <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 機能的を作成するのには、 <xref:System.Threading.Tasks.Task%601> コンス トラクターのいずれかを使用し、呼び出す <xref:System.Threading.Tasks.Task.Start%2A> の実行スケジュールを設定します。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=fullName> メソッドを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> 既定のパラメーターを使用します。 ただし、2 つのメソッドの動作の違いがあることについて: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=fullName> 既定では許可されません子タスクの使用を開始、 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=fullName> 現在アタッチ オプション <xref:System.Threading.Tasks.Task%601> インスタンス <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> です。 詳細とコード例については、エントリを参照してください。 [Task.Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 次の例では、2 つのタスクを使用して、コンピューティング F で終わるフィボナッチ シーケンス100 F \=100\-1 \+ F100 2 にシード値 F1\= 1, F2 \= 1 F1 \= 0、F2\= 1 です。 約、時間の半分、キャンセル トークンが設定操作を実行します。 この例の出力は、2 つのタスクが正常に完了し、トークンが取り消された場合に結果を示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run9.cs#9)]
 [!code-vb[System.Threading.Tasks.Task.Run\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="function" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="function">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得される結果を返す関数デリゲート。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task`1" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task`1" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 作成に相当する機能は、StartNew を呼び出して、 <xref:System.Threading.Tasks.Task%601> コンス トラクターのいずれかを使用しを呼び出す <xref:System.Threading.Tasks.Task.Start%2A> の実行スケジュールを設定します。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、エントリを参照してください。 [Task.Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="function" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="function">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得される結果を返す関数デリゲート。</param>
        <param name="state">
          <c>function</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="cancellationToken">新しい <see cref="T:System.Threading.Tasks.Task" /> に割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task`1" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 作成に相当する機能は、StartNew を呼び出して、 <xref:System.Threading.Tasks.Task%601> コンス トラクターのいずれかを使用しを呼び出す <xref:System.Threading.Tasks.Task.Start%2A> の実行スケジュールを設定します。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、エントリを参照してください。 [Task.Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="function" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="function">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得される結果を返す関数デリゲート。</param>
        <param name="state">
          <c>function</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task`1" /> の動作を制御する TaskCreationOptions 値。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task`1" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 作成に相当する機能は、StartNew を呼び出して、 <xref:System.Threading.Tasks.Task%601> コンス トラクターのいずれかを使用しを呼び出す <xref:System.Threading.Tasks.Task.Start%2A> の実行スケジュールを設定します。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、エントリを参照してください。 [Task.Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="function" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="function">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得される結果を返す関数デリゲート。</param>
        <param name="cancellationToken">新しいタスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task`1" /> の動作を制御する TaskCreationOptions 値。</param>
        <param name="scheduler">作成された <see cref="T:System.Threading.Tasks.TaskScheduler" /> をスケジュールするときに使用する <see cref="T:System.Threading.Tasks.Task`1" />。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task`1" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 作成に相当する機能は、StartNew を呼び出して、 <xref:System.Threading.Tasks.Task%601> コンス トラクターのいずれかを使用しを呼び出す <xref:System.Threading.Tasks.Task.Start%2A> の実行スケジュールを設定します。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、エントリを参照してください。 [Task.Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="function" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得できる結果の型。</typeparam>
        <param name="function">
          <see cref="T:System.Threading.Tasks.Task`1" /> を通じて取得される結果を返す関数デリゲート。</param>
        <param name="state">
          <c>function</c> デリゲートによって使用されるデータを格納しているオブジェクト。</param>
        <param name="cancellationToken">新しいタスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">作成された <see cref="T:System.Threading.Tasks.Task`1" /> の動作を制御する TaskCreationOptions 値。</param>
        <param name="scheduler">作成された <see cref="T:System.Threading.Tasks.TaskScheduler" /> をスケジュールするときに使用する <see cref="T:System.Threading.Tasks.Task`1" />。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task`1" /> を作成して開始します。</summary>
        <returns>開始された <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 作成に相当する機能は、StartNew を呼び出して、 <xref:System.Threading.Tasks.Task%601> コンス トラクターのいずれかを使用しを呼び出す <xref:System.Threading.Tasks.Task.Start%2A> の実行スケジュールを設定します。  
  
 以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、使用することができます、 <xref:System.Threading.Tasks.Task.Run%2A> メソッドを <xref:System.Action> オブジェクトを呼び出す簡単な方法として <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 既定のパラメーターを使用します。 詳細とコード例については、エントリを参照してください。 [Task.Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">場合にスローされる例外、 <paramref name="function" /> 引数が null です。  
  
 または  
  
 場合にスローされる例外、 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 場合にスローされる例外、 <paramref name="creationOptions" /> 引数が無効な TaskCreationOptions 値を指定します。 詳細については、「解説」を参照してください。 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>一連の指定したタスクが完了したときに開始する継続タスクを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Tasks.TaskFactory" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ContinueWhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された一連のタスクのうち任意のタスクが完了したときに開始される継続 <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="FromAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同期プログラミング モデルのパターンに準拠した開始メソッドと終了メソッドの組み合わせを表す <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>