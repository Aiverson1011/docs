<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>非同期操作を表します。  
  
 この型の .NET Framework ソース コードを参照するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs#045a746eb48cbaa9)します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを参照してください、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs#045a746eb48cbaa9)します。 ソース コードをオンラインで参照、オフライン表示のリファレンスをダウンロードおよびデバッグ中にソース \(パッチや更新を含む\) をステップsee [instructions](http://referencesource.microsoft.com/).  
  
 <xref:System.Threading.Tasks.Task> クラスの 1 つの操作を返さない値、通常は非同期的に実行を表します。<xref:System.Threading.Tasks.Task> オブジェクトが 1 つの主要コンポーネント、  [タスク ベースの非同期パターン](http://msdn.microsoft.com/ja-jp/8cef1fcf-6f9f-417c-b21f-3fd8bac75007) 、.NET Framework 4 で初めて導入されました。 によって、作業が実行されるため、 <xref:System.Threading.Tasks.Task> オブジェクト通常非同期的に実行スレッド プールのスレッドで同期的にでメイン アプリケーション スレッドを使用するのではなく、 <xref:System.Threading.Tasks.Task.Status%2A> プロパティには、だけでなく、 <xref:System.Threading.Tasks.Task.IsCanceled%2A>, 、<xref:System.Threading.Tasks.Task.IsCompleted%2A>, 、および <xref:System.Threading.Tasks.Task.IsFaulted%2A> タスクの状態を判断するためのプロパティです。 ほとんどの場合、ラムダ式を使用して、タスクを実行する作業を指定します。  
  
 使用する値を返す操作の場合、 <xref:System.Threading.Tasks.Task%601> クラスです。  
  
 このセクションの内容:  
  
 [作成してタスクを実行します。](#Creating)   
 [タスクの作成と実行を分離します。](#Separating)   
 [1 つまたは複数のタスクを完了するを待機](#WaitingForOne)   
 [タスクとカルチャ](#Culture)   
 [デバッガーの開発者向け](#Debugger)  
  
<a name="Creating"></a>   
## 作成してタスクを実行します。  
 <xref:System.Threading.Tasks.Task> さまざまな方法でインスタンスを作成することがあります。 以降で利用可能な最も一般的なアプローチ、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], は、静的な <xref:System.Threading.Tasks.Task.Run%2A> メソッドです。<xref:System.Threading.Tasks.Task.Run%2A> メソッドは、既定値を使用してタスクを開始する簡単な方法を提供せず、追加のパラメーターです。 次の例で、 <xref:System.Threading.Tasks.Task.Run%28System.Action%29> メソッドをループ処理し、ループの反復処理の数を表示するタスクを開始します。  
  
 [!code-csharp[System.Threading.Tasks.Task\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 別の方法と、タスクを開始する最も一般的な方法 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], は、静的な <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> メソッドです。<xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=fullName> プロパティを返します。、 <xref:System.Threading.Tasks.TaskFactory> オブジェクトです。 オーバー ロードにより、 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> メソッドを使用して、タスク作成オプションとタスク スケジューラに渡すパラメーターを指定できます。 次の例では、 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> タスクを開始するメソッドです。 このメソッドは、前の例のコードには  
  
 [!code-csharp[System.Threading.Tasks.Task\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 完全な例については、次を参照してください。 [Task Parallelism \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/458b5e69-5210-45e5-bc44-3888f86abd6f)します。  
  
<a name="Separating"></a>   
## タスクの作成と実行を分離します。  
 <xref:System.Threading.Tasks.Task> クラスも、タスクを初期化するが、するスケジュールを設定しないで、実行するためのコンス トラクターを提供します。 パフォーマンス向上のため、 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName> または <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> メソッドが作成および計算タスクをスケジュールするための推奨メカニズムが、シナリオの作成とスケジュール設定を区切る必要がありますコンス トラクターを使用しを呼び出す、 <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=fullName> を後で実行するためのタスクをスケジュールする方法です。  
  
<a name="WaitingForOne"></a>   
## 1 つまたは複数のタスクを完了するを待機  
 タスクは通常、スレッド プールのスレッドで非同期的に実行、されるためを作成して、タスクを開始したスレッドは、タスクをインスタンス化されていると、すぐに実行を継続します。 場合によっては、呼び出し元のスレッドは、メイン アプリケーション スレッド アプリ可能性がありますタスクを終了前に、実際に実行を開始します。 他のユーザーに、アプリケーションのロジックは、1 つまたは複数のタスクの実行が完了した場合にのみ、呼び出し元のスレッドが実行を継続する必要があります。 呼び出し元のスレッドの実行を同期して、非同期タスクを起動を呼び出して、 `Wait` メソッドを 1 つ以上のタスクを完了するまで待機します。  
  
 1 つのタスクが完了するまで待機するを呼び出すことができます、 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> メソッドです。 呼び出し、  <xref:System.Threading.Tasks.Task.Wait%2A> メソッドは、1 つのクラス インスタンスの実行が完了するまで、呼び出し元のスレッドをブロックします。  
  
 次の例では、パラメーターなし <xref:System.Threading.Tasks.Task.Wait> メソッドが、タスクが完了するまで、無条件に待機します。 タスクが呼び出すことによって作業をシミュレート、 <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> メソッドを 2 秒間スリープ状態にします。  
  
 [!code-csharp[System.Threading.Tasks.Task\#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task\#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 条件付きで、タスクの完了を待機できます。<xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> と <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> メソッドが、タスクが終了するまで、呼び出し元のスレッドをブロックまたはタイムアウト間隔が経過すると、どちらか早い。 次の例を 2 秒間スリープ状態になりますが、定義されている 1 秒間のタイムアウト値、呼び出し元スレッドは、タイムアウトになるまでブロックするタスクを起動するため、および、タスクが実行を完了します。  
  
 [!code-csharp[System.Threading.Tasks.Task\#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task\#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 呼び出して、キャンセル トークンを提供することも、 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> と  <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> メソッドです。 場合、トークンの <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> プロパティは、 `true`, 、待機が取り消される; 中に true になる場合、 <xref:System.Threading.Tasks.Task.Wait%2A> メソッドを終了します。  
  
 場合によっては、待機することがありますをしたとしてもしない一連のタスクを実行して、最初のタスクのことを注意ができます。  この目的で、1 つのオーバー ロードを呼び出すことができます、 <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> メソッドです。  次の例では、乱数ジェネレーターして間隔を決定するがスリープ状態の 3 つのタスクを作成します。<xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> メソッドは最初のタスクが完了するまで待機します。 3 つのタスクの状態に関する情報を表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task\#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task\#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 すべて、一連のタスクを呼び出すことによって完了するを待機することも、 <xref:System.Threading.Tasks.Task.WaitAll%2A> メソッドです。 次の例は、10 個のタスクを作成する、すべての 10 を完了するまで待機し、それらの状態を表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 1 つまたは複数のタスクを完了するを待機する場合に、実行中のタスクでスローされた例外が呼び出しスレッドに伝達されているに注意してください、 `Wait` メソッドを次の例のようにです。 12 タスク、正常に完了する 3 つおよび 3 つで例外をスローするを起動します。 残りの 6 つのタスクの開始する前に取り消される 3 つとしながら実行する、3 つが取り消されます。 例外がスローされた、 <xref:System.Threading.Tasks.Task.WaitAll%2A> によって処理されるメソッドの呼び出しおよびは、 `try`\/`catch` ブロックします。  
  
 [!code-csharp[System.Threading.Tasks.Task\#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task\#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 タスク ベースの非同期操作での例外処理の詳細については、次を参照してください。 [Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1)します。  
  
<a name="Culture"></a>   
## タスクとカルチャ  
 以降を対象とデスクトップ アプリ、 [!INCLUDE[net_v46](~/includes/net-v46-md.md)], を作成し、タスクを呼び出してスレッドのカルチャがスレッドのコンテキストの一部になります。 つまり、タスクが実行されるスレッドの現在のカルチャに関係なく、タスクの現在のカルチャは呼び出し元のスレッドのカルチャです。 前のバージョンの .NET Framework のバージョンを対象とするアプリに対して、 [!INCLUDE[net_v46](~/includes/net-v46-md.md)], 、タスクのカルチャは、タスクが実行されるスレッドのカルチャ。 詳細については、「カルチャとタスク ベースの非同期操作」セクションを参照して、 <xref:System.Globalization.CultureInfo> トピックです。  
  
> [!NOTE]
>  ストア アプリでは、設定と取得の既定のカルチャでの Windows ランタイムに従います。  
  
<a name="Debugger"></a>   
## デバッガーの開発者向け  
 開発者がカスタムのデバッガーを実装する、タスクのいくつかの内部、プライベート メンバーあります \(これらは、リリースごとを変更可能\) に便利です。`m_taskId` のバッキング ストアとしてのフィールドは、 <xref:System.Threading.Tasks.Task.Id%2A> プロパティには、ただしへのアクセス、デバッガーから直接には、このフィールドがあります、プロパティの getter メソッドを通じて同じ値にアクセスするよりも効率的 \(、 `s_taskIdCounter` カウンターを使用して、タスクの次の使用可能な ID を取得する\)。 同様に、 `m_stateFlags` フィールドからもアクセスできる情報は、タスクの現在のステージのライフ サイクルに関する情報を格納する、 <xref:System.Threading.Tasks.Task.Status%2A> プロパティです。`m_action` フィールドに、タスクのデリゲートへの参照が格納され、 `m_stateObject` フィールドが、開発者によって、タスクに渡される非同期状態を格納します。 スタック フレームを解析するデバッガーに対して最後に、 `InternalWait` メソッドには、タスクが待機操作を入力する場合の潜在的なマーカーは機能します。  
  
   
  
## 例  
 次の例を作成し、4 つのタスクを実行します。 3 つのタスクの実行、 <xref:System.Action%601> という名前のデリゲート `action`, 、型の引数を受け入れる <xref:System.Object>します。 4 番目のタスクは、ラムダ式を実行し \(、 <xref:System.Action> 委任\) タスクの作成方法への呼び出しでインラインで定義されています。 各タスクがインスタンス化し、別の方法で実行します。  
  
-   タスク `t1` タスク クラスのコンス トラクターを呼び出すことによってインスタンス化が呼び出すことによって開始がその <xref:System.Threading.Tasks.Task.Start> 作業した後にのみ `t2` が開始します。  
  
-   タスク `t2` がインスタンス化され、呼び出すことによって、単一メソッド呼び出しで開始、 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=fullName> メソッドです。  
  
-   タスク `t3` がインスタンス化され、呼び出すことによって、単一メソッド呼び出しで開始、 <xref:System.Threading.Tasks.Task.Run%28System.Action%29> メソッドです。  
  
-   タスク `t4` を呼び出して、メイン スレッドで同期的に実行、 <xref:System.Threading.Tasks.Task.RunSynchronously> メソッドです。  
  
 タスク `t4` 同期的に実行されるメイン アプリケーション スレッド上で実行します。 残りのタスク実行非同期的に通常 1 つまたは複数のスレッド プールのスレッドでします。  
  
 [!code-csharp[System.Threading.Tasks.Task\#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task\#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)]  
  
 ]]></format>
    </remarks>
    <threadsafe>すべてのメンバー <see cref="T:System.Threading.Tasks.Task" />, 、除く <see cref="M:System.Threading.Tasks.Task.Dispose" />, スレッド セーフであるは、同時に複数のスレッドから使用できます。</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <summary>指定したアクションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、 <xref:System.Threading.Tasks.Task> オブジェクトとタスクは、静的なを呼び出すことによって、起動 <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=fullName> または <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=fullName> メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクトのインスタンス化タスクの呼び出しから分離することができることです。  
  
   
  
## 例  
 次の例では、 <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> でファイル名を取得するタスクを作成するコンス トラクターは、ディレクトリを指定します。 すべてのタスクを 1 つのファイル名の記述 <xref:System.Collections.Concurrent.ConcurrentBag%601> オブジェクトです。 次の <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> に書き込まれるファイル名の合計数のカウントを表示し、すべてのタスクが完了したら、あることを確認する方法、 <xref:System.Collections.Concurrent.ConcurrentBag%601> オブジェクトです。  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 次の例は、それを使用する点を除いて同じですが、 <xref:System.Threading.Tasks.Task.Run%28System.Action%29> メソッドをインスタンス化し、単一の操作でタスクを実行します。 このメソッドを返します、 <xref:System.Threading.Tasks.Task> タスクを表すオブジェクト。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引数が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>指定したアクションおよび <see cref="T:System.Threading.Tasks.Task" /> で新しい <see cref="T:System.Threading.CancellationToken" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、 <xref:System.Threading.Tasks.Task> オブジェクトとタスクは、静的なを呼び出すことによって、起動 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=fullName> と <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=fullName> メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクトのインスタンス化タスクの呼び出しから分離することができることです。  
  
 詳細については、次を参照してください。 [タスクの並列化 \(タスク並列ライブラリ\)](http://msdn.microsoft.com/ja-jp/458b5e69-5210-45e5-bc44-3888f86abd6f) と [マネージ スレッドのキャンセル](http://msdn.microsoft.com/ja-jp/eea11fe5-d8b0-4314-bb5d-8a58166fb1c3)します。  
  
   
  
## 例  
 次の例では、 <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> C:\\Windows\\System32 ディレクトリ内のファイルを反復処理するタスクを作成するコンス トラクターです。 ラムダ式の呼び出し、 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName> する各ファイルに関する情報を追加する方法、 <xref:System.Collections.Generic.List%601> オブジェクトです。 入れ子のタスクによって呼び出された各デタッチ、 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName> ループは、キャンセル トークンの状態を確認し、キャンセルが要求される場合、 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> メソッドです。<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> メソッドでのスロー、 <xref:System.OperationCanceledException> で処理される例外、 `catch` 呼び出し元のスレッドを呼び出す場合に、ブロック、 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> メソッドです。<xref:System.Threading.Tasks.Task.Start%2A> タスクを開始するメソッドが呼び出されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクションと作成オプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、 <xref:System.Threading.Tasks.Task> オブジェクトとタスクは、静的なを呼び出すことによって、起動 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=fullName> メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクトのインスタンス化タスクの呼び出しから分離することができることです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <summary>指定したアクションと状態で新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、 <xref:System.Threading.Tasks.Task> オブジェクトとタスクは、静的なを呼び出すことによって、起動 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=fullName> メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクトのインスタンス化タスクの呼び出しから分離することができることです。  
  
   
  
## 例  
 次の例では、6 文字の単語の配列を定義します。 各単語が、引数として渡されます、 <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> コンス トラクターが <xref:System.Action%601> デリゲートは、単語内の文字にスクランブルをかけるし、元の単語とそのスクランブルされたバージョンが表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引数が null です。</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクションと作成オプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、 <xref:System.Threading.Tasks.Task> オブジェクトとタスクは、静的なを呼び出すことによって、起動 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=fullName> メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクトのインスタンス化タスクの呼び出しから分離することができることです。  
  
 詳細については、次を参照してください。 [タスクの並列化 \(タスク並列ライブラリ\)](http://msdn.microsoft.com/ja-jp/458b5e69-5210-45e5-bc44-3888f86abd6f) と [タスクのキャンセル](http://msdn.microsoft.com/ja-jp/3ecf1ea9-e399-4a6a-a0d6-8475f48dcb28)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> 作成 <paramref name="cancellationToken" /> 既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、 <xref:System.Threading.Tasks.Task> オブジェクトとタスクは、静的なを呼び出すことによって、起動 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=fullName> メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクトのインスタンス化タスクの呼び出しから分離することができることです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> 作成 <paramref name="cancellationToken" /> 既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、 <xref:System.Threading.Tasks.Task> オブジェクトとタスクは、静的なを呼び出すことによって、起動 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=fullName> メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクトのインスタンス化タスクの呼び出しから分離することができることです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">タスクで実行するコードを表すデリゲート。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しいタスクが観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 インスタンスを作成する最も一般的な方法、コンス トラクターを呼び出すのではなく、 <xref:System.Threading.Tasks.Task> オブジェクトとタスクは、静的なを呼び出すことによって、起動 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=fullName> メソッドです。 このコンス トラクターが提供する唯一の利点は、オブジェクトのインスタンス化タスクの呼び出しから分離することができることです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> 作成 <paramref name="cancellationToken" /> 既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> が作成されたときに渡される状態オブジェクトを取得します。渡されなかった場合は null。</summary>
        <value>タスクの作成時にそのタスクに渡された状態データを表す <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Cast the object back to the original type to retrieve its data.  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既に正常に完了したタスクを取得します。</summary>
        <value>正常に完了したタスク。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This property returns a task whose <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName>. To create task that returns a value and runs to completion, call the <xref:System.Threading.Tasks.Task.FromResult%2A> method.  
  
 Repeated attempts to retrieve this property value may not always return the same instance.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">継続をキャプチャされた元のコンテキストにマーシャリングする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> を待機するために使用する awaiter を構成します。</summary>
        <returns>このタスクを待機するために使用するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期に実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.  
  
   
  
## 例  
 The following example defines a task that populates an array with 100 random date and time values. It uses the <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> method to select the earliest and the latest date values once the array is fully populated.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Because a console application may terminate before the continuation task executes, the <xref:System.Threading.Tasks.Task.Wait> method is called to ensure that the continuation finishes executing before the example ends.  
  
 For an additional example, see [Chaining Tasks by Using Continuation Tasks](http://msdn.microsoft.com/ja-jp/0b45e9a2-de28-46ce-8212-1817280ed42d).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">タスクの完了時に実行するアクション。 実行されると、完了したタスクと、呼び出し元が指定する状態オブジェクトが、引数としてデリゲートに渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <summary>呼び出し元から提供される状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに実行される継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task> はスケジュールされません実行するため、現在のタスクが完了するまで正常に完了するまで実行されて、未処理の例外のための障害発生またはキャンセルにより早く終了するために完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>キャンセル トークンを受け取って、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期的に実行される継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task> はスケジュールされません実行するため、現在のタスクが完了するまで正常に完了するまで実行、未処理の例外のための障害発生、または取り消されることによって早期に終了が完了するかどうか。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> が既に破棄されているトークンを作成します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">指定した <c>continuationOptions</c> に従って実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>対象のタスクが完了したときに、指定した <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> に従って実行される継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task> 、現在のタスクが完了するまでない実行対象にスケジュールされます。 を通じて、継続条件が指定されている場合、 `continuationOptions` パラメーターが満たされていない、継続タスクが取り消されるの代わりにスケジュールします。  
  
   
  
## 例  
 次の例では、使用方法を示します <xref:System.Threading.Tasks.TaskContinuationOptions> に継続元タスクの完了時に同期的に継続タスクを実行するように指定します。 \(指定したタスクが既に完了時間して <xref:System.Threading.Tasks.Task.ContinueWith%2A> が呼び出されると、同期継続呼び出すスレッドで実行されます <xref:System.Threading.Tasks.Task.ContinueWith%2A>.\)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期に実行する継続タスクを作成します。 継続タスクは、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が <see langword="null" /> です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>呼び出し元から提供される状態情報およびキャンセル トークンを受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> の完了時に非同期的に実行される継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task> はスケジュールされません実行するため、現在のタスクが完了するまで正常に完了するまで実行、未処理の例外のための障害発生、または取り消されることによって早期に終了が完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> 既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>呼び出し元から提供される状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに実行される継続タスクを作成します。 継続タスクは、指定した一連の条件に基づいて実行されます。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task> 、現在のタスクが完了するまでない実行対象にスケジュールされます。 を通じて、継続条件が指定されている場合、 `continuationOptions` パラメーターが満たされていない、継続タスクが取り消されるの代わりにスケジュールします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。  実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>呼び出し元から提供される状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期的に実行される継続タスクを作成します。 継続タスクは、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task> はスケジュールされません実行するため、現在のタスクが完了するまで正常に完了するまで実行、未処理の例外のための障害発生、または取り消されることによって早期に終了が完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">指定した <c>continuationOptions</c> に従って実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>対象のタスクが完了したときに、指定した <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> に従って実行される継続タスクを作成します。 この継続タスクは、キャンセル トークンを受け取り、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task> 、現在のタスクが完了するまでない実行対象にスケジュールされます。 使用条件が指定されている場合、 `continuationOptions` パラメーターが満たされていない、継続タスクが取り消されるの代わりにスケジュールします。  
  
   
  
## 例  
 作業を実行するバック グラウンドでし、ユーザー インターフェイス スレッドの ContinueWith の使用例を次に示します。  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> が既に破棄されているトークンを作成します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が null です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>呼び出し元から提供される状態情報およびキャンセル トークンを受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行される継続タスクを作成します。 継続タスクは、指定した一連の条件に基づき、指定したスケジューラを使用して実行されます。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task> 、現在のタスクが完了するまでない実行対象にスケジュールされます。 使用条件が指定されている場合、 `continuationOptions` パラメーターが満たされていない、継続タスクが取り消されるの代わりにスケジュールします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> 既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task`1" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.  
  
   
  
## 例  
 The following example shows how to use the ContinueWith method:  
  
 [!code-csharp[System.Threading.Tasks.Task\#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task\#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <summary>呼び出し元から提供される状態情報を受け取り、対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期的に実行され、値を返す継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。 この継続タスクは、キャンセル トークンを受け取ります。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task%601> はスケジュールされません実行するため、現在のタスクが完了するまで正常に完了するまで実行、未処理の例外のための障害発生、または取り消されることによって早期に終了が完了するかどうか。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。  
  
 または  
  
 <see cref="T:System.Threading.CancellationTokenSource" /> が既に破棄されているトークンを作成します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <c>continuationOptions</c> で指定した条件に従って実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>指定された継続のオプションに従って実行され、値を返す継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task%601> 、現在のタスクが完了するまでない実行対象にスケジュールされます。 を通じて、継続条件が指定されている場合、 `continuationOptions` パラメーターが満たされていない、継続タスクが取り消されるの代わりにスケジュールします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。 継続タスクは、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が null です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了して値を返したときに非同期的に実行される継続タスクを作成します。 この継続タスクは、呼び出し元から提供される状態情報とキャンセル トークンを受け取ります。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task%601> はスケジュールされません実行するため、現在のタスクが完了するまで正常に完了するまで実行、未処理の例外のための障害発生、または取り消されることによって早期に終了が完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> 既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに、指定したタスク継続オプションに基づいて実行される継続タスクを作成します。 この継続タスクは、呼び出し元から提供される状態情報を受け取ります。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task%601> 、現在のタスクが完了するまでない実行対象にスケジュールされます。 を通じて、継続条件が指定されている場合、 `continuationOptions` パラメーターが満たされていない、継続タスクが取り消されるの代わりにスケジュールします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。  実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期に実行する継続タスクを作成します。 この継続タスクは、呼び出し元から提供される状態情報を受け取り、指定したスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task%601> はスケジュールされません実行するため、現在のタスクが完了するまで正常に完了するまで実行、未処理の例外のための障害発生、または取り消されることによって早期に終了が完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">指定した <c>continuationOptions.</c> に従って実行する関数。実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>指定された継続のオプションに従って実行され、値を返す継続タスクを作成します。 継続タスクは、キャンセル トークンを渡され、指定されたスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task%601> 、現在のタスクが完了するまでない実行対象にスケジュールされます。 使用条件が指定されている場合、 `continuationOptions` パラメーターが満たされていない、継続タスクが取り消されるの代わりにスケジュールします。  
  
   
  
## 例  
 次の例では、継続のオプションでの ContinueWith メソッドを使用する方法を示します。  
  
 [!code-csharp[System.Threading.Tasks.Task\#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task\#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。  
  
 または  
  
 <see cref="T:System.Threading.CancellationTokenSource" /> が既に破棄されているトークンを作成します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。  
  
 または  
  
 <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task" /> が完了したときに、指定したタスク継続オプションに基づいて実行され、値を返す継続タスクを作成します。 この継続タスクは、呼び出し元から提供される状態情報とキャンセル トークンを受け取り、指定したスケジューラを使用します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返された <xref:System.Threading.Tasks.Task%601> 、現在のタスクが完了するまでない実行対象にスケジュールされます。 使用条件が指定されている場合、 `continuationOptions` パラメーターが満たされていない、継続タスクが取り消されるの代わりにスケジュールします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数に対して無効な値を指定する <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> 既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このタスクの作成に使用される <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> を取得します。</summary>
        <value>このタスクの作成に使用される <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中の <see cref="T:System.Threading.Tasks.Task" /> の ID を返します。</summary>
        <value>システムによって現在実行中のタスクに割り当てられた整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task.CurrentId%2A> is a `static` \(`Shared` in Visual Basic\) property that is used to get the identifier of the currently executing task from the code that the task is executing. It differs from the <xref:System.Threading.Tasks.Task.Id%2A> property, which returns the identifier of a particular <xref:System.Threading.Tasks.Task> instance. If you attempt to retrieve the <xref:System.Threading.Tasks.Task.CurrentId%2A> value from outside the code that a task is executing, the property returns `null`.  
  
 Note that although collisions are very rare, task identifiers are not guaranteed to be unique.  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">戻されるタスクが完了するまでに待機するミリ秒数。無期限に待機する場合は \-1。</param>
        <summary>遅延後に完了するタスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task.Delay%2A> メソッドは、通常、すべての操作またはタスクの一部を指定した時間間隔の遅延を使用します。 ほとんどの場合、遅延時間が導入されています。  
  
-   次の例として、タスクの先頭を示します。  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   タスクが実行されて中にいずれかの時点います。 この場合への呼び出し、 <xref:System.Threading.Tasks.Task.Delay%2A> メソッドは次の例のように、タスク内の子タスクとして実行されます。 以降、タスクを呼び出しているに注意してください、 <xref:System.Threading.Tasks.Task.Delay%2A> メソッドが非同期的に実行される、親タスクを使用して完了するまでの待機する必要があります、 `await` キーワードです。  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 指定した時間の遅延の後で、タスクの完了、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態です。  
  
 このメソッドは、システム クロックに依存します。 つまり、エントリの場合は、遅延時間はシステム クロックの分解能が等しく約、 `millisecondsDelay` 引数は、約 15 ミリ秒 Windows システムでは、システム時計の解像度より小さい。  
  
   
  
## 例  
 次の例の簡単な使用、 <xref:System.Threading.Tasks.Task.Delay%2A> メソッドです。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsDelay" /> 引数は、\-1 より小さくします。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">戻されるタスクが完了するまでに待機する時間。無期限に待機する場合は <see langword="TimeSpan.FromMilliseconds(-1)" />。</param>
        <summary>指定の時間間隔後に完了するタスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定した時間の遅延の後で、タスクの完了 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態です。  
  
 使用シナリオとその他の例では、ドキュメントを参照して、 <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> オーバー ロードします。  
  
 このメソッドは、システム クロックに依存します。 つまり、エントリの場合は、遅延時間はシステム クロックの分解能が等しく約、 `delay` 引数は、約 15 ミリ秒 Windows システムでは、システム時計の解像度より小さい。  
  
   
  
## 例  
 次の例の簡単な使用、 <xref:System.Threading.Tasks.Task.Delay%2A> メソッドです。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> 以外の負の時間間隔を表す <see langword="TimeSpan.FromMillseconds(-1)" />します。  
  
 または  
  
 <paramref name="delay" /> 引数の <see cref="P:System.TimeSpan.TotalMilliseconds" /> プロパティがよりも大きい <see cref="F:System.Int32.MaxValue" />します。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">戻されるタスクが完了するまでに待機するミリ秒数。無期限に待機する場合は \-1。</param>
        <param name="cancellationToken">戻されるタスクが完了する前にチェックされるキャンセル トークン。</param>
        <summary>遅延後に完了するキャンセル可能タスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定した時間の遅延の前にキャンセル トークンがシグナル通知された場合、 <xref:System.Threading.Tasks.TaskCanceledException> で例外の結果とタスクが完了した、 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=fullName> 状態です。  タスクを完了するそれ以外の場合、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態の指定した時間の遅延時間が経過します。  
  
 使用シナリオとその他の例では、ドキュメントを参照して、 <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> オーバー ロードします。  
  
 このメソッドは、システム クロックに依存します。 つまり、エントリの場合は、遅延時間はシステム クロックの分解能が等しく約、 `millisecondsDelay` 引数は、約 15 ミリ秒 Windows システムでは、システム時計の解像度より小さい。  
  
   
  
## 例  
 次の例への呼び出しが含まれるタスクの起動、 <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> 秒の遅延を 1 つを持つメソッドです。 待機時間の間隔が経過する前に、トークンが取り消されました。 この例の出力で示すは、その結果、 <xref:System.Threading.Tasks.TaskCanceledException> スローされるとタスクの <xref:System.Threading.Tasks.Task.Status%2A> にプロパティが設定されている <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=fullName>します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsDelay" /> 引数は、\-1 より小さくします。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <paramref name="cancellationToken" /> は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">戻されるタスクが完了するまでに待機する時間。無期限に待機する場合は <see langword="TimeSpan.FromMilliseconds(-1)" />。</param>
        <param name="cancellationToken">戻されるタスクが完了する前にチェックされるキャンセル トークン。</param>
        <summary>指定の時間間隔後に完了するキャンセル可能タスクを作成します。</summary>
        <returns>遅延を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 指定した時間の遅延の前にキャンセル トークンがシグナル通知された場合、 <xref:System.Threading.Tasks.TaskCanceledException> で例外の結果とタスクが完了した、 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=fullName> 状態です。  タスクを完了するそれ以外の場合、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態の指定した時間の遅延時間が経過します。  
  
 使用シナリオとその他の例では、ドキュメントを参照して、 <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> オーバー ロードします。  
  
 このメソッドは、システム クロックに依存します。 つまり、エントリの場合は、遅延時間はシステム クロックの分解能が等しく約、 `delay` 引数は、約 15 ミリ秒 Windows システムでは、システム時計の解像度より小さい。  
  
   
  
## 例  
 次の例への呼び出しが含まれるタスクの起動、 <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> 1 と\-半秒の遅延を持つメソッドです。 待機時間の間隔が経過する前に、トークンが取り消されました。 この例の出力で示すは、その結果、 <xref:System.Threading.Tasks.TaskCanceledException> スローされるとタスクの <xref:System.Threading.Tasks.Task.Status%2A> にプロパティが設定されている <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=fullName>します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Note that this example includes a potential race condition: it depends on the task asynchronously executing the delay when the token is cancelled. Although the 1.5 second delay from the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method makes that assumption likely, it is nevertheless possible that the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method could return before the token is cancelled. In that case, the example produces the following output:  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> 以外の負の時間間隔を表す <see langword="TimeSpan.FromMillseconds(-1)" />します。  
  
 または  
  
 <paramref name="delay" /> 引数の <see cref="P:System.TimeSpan.TotalMilliseconds" /> プロパティがよりも大きい <see cref="F:System.Int32.MaxValue" />します。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <paramref name="cancellationToken" /> は既に破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task> クラスが実装する、 <xref:System.IDisposable> インターフェイスを実装するリソースを使用して内部的にいるため <xref:System.IDisposable>です。 ただし場合に特に、アプリのターゲット、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] または後を呼び出す必要がない <xref:System.Threading.Tasks.Task.Dispose%2A> パフォーマンスやスケーラビリティをテストすることを示します、しない限り、使用パターンに基づいて、アプリケーションのパフォーマンスはタスクを破棄して向上します。 詳細については、次を参照してください。 [Do I need to dispose of Tasks?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) .NET ブログでの並列プログラミングにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">タスクが終了状態のいずれかでできません: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, 、<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, 、または <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see cref="M:System.Threading.Tasks.Task.Dispose" /> が呼び出されたことが原因でこのメソッドが呼び出されているかどうかを示すブール値。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> を破棄し、そのすべてのアンマネージ リソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task> クラスが実装する、 <xref:System.IDisposable> インターフェイスを実装するリソースを使用して内部的にいるため <xref:System.IDisposable>です。 ただし場合に特に、アプリのターゲット、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] または後を呼び出す必要がない <xref:System.Threading.Tasks.Task.Dispose%2A> パフォーマンスやスケーラビリティをテストすることを示します、しない限り、使用パターンに基づいて、アプリケーションのパフォーマンスはタスクを破棄して向上します。 詳細については、次を参照してください。 [Do I need to dispose of Tasks?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) .NET ブログでの並列プログラミングにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">タスクが終了状態のいずれかでできません: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, 、<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, 、または <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />です。</exception>
        <threadsafe>ほとんどのメンバーのとは異なり、 <see cref="T:System.Threading.Tasks.Task" /> クラスでは、このメソッドはスレッド セーフではありません。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.AggregateException" /> が途中で終了する原因となった <see cref="T:System.Threading.Tasks.Task" /> を取得します。<see cref="T:System.Threading.Tasks.Task" /> が正常に完了した場合、または例外がスローされていない場合は、<see langword="null" /> が戻ります。</summary>
        <value>
          <see cref="T:System.AggregateException" /> が途中で終了する原因となった <see cref="T:System.Threading.Tasks.Task" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a <xref:System.AggregateException> in calls to <xref:System.Threading.Tasks.Task.Wait%2A> or in accesses to the <xref:System.Threading.Tasks.Task.Exception%2A> property. Any exceptions not observed by the time the task instance is garbage collected will be propagated on the finalizer thread. For more information and an example, see [Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1).  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> インスタンスおよび <see cref="T:System.Threading.Tasks.Task`1" /> インスタンスを作成して構成するためのファクトリ メソッドへのアクセスを提供します。</summary>
        <value>さまざまな <see cref="T:System.Threading.Tasks.Task" /> オブジェクトおよび <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトを作成可能なファクトリ オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このプロパティの既定のインスタンスを返す、 <xref:System.Threading.Tasks.TaskFactory> クラスは、パラメーターなしで呼び出すことによって作成したものと同じである <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=fullName> コンス トラクターです。 次のプロパティ値があります。  
  
|プロパティ|値|  
|-----------|-------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=fullName>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=fullName>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=fullName>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=fullName>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=fullName>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=fullName>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=fullName>|`null`, 、または <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=fullName>|  
  
 このプロパティの最も一般的な使用が作成して 1 回の呼び出しで新しいタスクを開始するには、 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> メソッドです。  
  
> [!NOTE]
>  以降で、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 、 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName> メソッドを作成する最も簡単な方法を提供する、 <xref:System.Threading.Tasks.Task> 既定の構成値を持つオブジェクト。  
  
 次の例は、静的な <xref:System.Threading.Tasks.Task.Factory%2A> 2 つの呼び出しのためのプロパティを <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> メソッドです。 1 つ目は、2 つ目はユーザーのマイ ドキュメント ディレクトリのサブディレクトリの名前を持つ配列を設定中に、ユーザーのマイ ドキュメント ディレクトリ内のファイルの名前を持つ配列を設定します。 呼び出して、 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=fullName> メソッドで、最初の 2 つのタスクの実行が完了した後、2 つの配列でファイルとディレクトリの数についての情報を表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">タスクを完了させるキャンセル トークン。</param>
        <summary>指定されたキャンセル トークンを使用したキャンセルにより完了した <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>キャンセルされたタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="cancellationToken" /> は、キャンセルが要求されていません。<see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクによって返される結果の型。</typeparam>
        <param name="cancellationToken">タスクを完了させるキャンセル トークン。</param>
        <summary>指定されたキャンセル トークンを使用したキャンセルにより完了した <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>キャンセルされたタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="cancellationToken" /> は、キャンセルが要求されていません。<see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> プロパティは <see langword="false" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">タスクを完了させる例外。</param>
        <summary>指定した例外で完了した <see cref="T:System.Threading.Tasks.Task" /> を作成します。</summary>
        <returns>エラーが発生したタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、作成、 <xref:System.Threading.Tasks.Task> オブジェクト <xref:System.Threading.Tasks.Task.Status%2A> プロパティは、 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=fullName> とが <xref:System.Threading.Tasks.Task.Exception%2A> プロパティが含まれています `exception`します。 メソッドはすぐにタスクを実行する作業では、長いコード パスを実行する前に例外をスローを識別するときによく使用されます。 例については、次を参照してください。、 <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> オーバー ロードします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクによって返される結果の型。</typeparam>
        <param name="exception">タスクを完了させる例外。</param>
        <summary>指定した例外で完了した <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>エラーが発生したタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、作成、 <xref:System.Threading.Tasks.Task%601> オブジェクト <xref:System.Threading.Tasks.Task.Status%2A> プロパティは、 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=fullName> とが <xref:System.Threading.Tasks.Task.Exception%2A> プロパティが含まれています `exception`します。 メソッドはすぐにタスクを実行する作業では、長いコード パスを実行する前に例外をスローを識別するときによく使用されます。 具体的な例を次に示します。  
  
   
  
## 例  
 次の例は、名前を持つが、コマンドライン引数として渡された各ディレクトリ内のファイルのバイト数を計算するコマンド ライン ユーティリティです。 インスタンス化する長いコード パスを実行するのではなく、 <xref:System.IO.FileInfo> オブジェクトし、の値を取得、 <xref:System.IO.FileInfo.Length%2A?displayProperty=fullName> ディレクトリ内の各ファイルのプロパティは、例では、単に呼び出す、 <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> メソッドを特定のサブディレクトリが存在しない場合は、エラーが発生したタスクを作成します。  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクによって返される結果の型。</typeparam>
        <param name="result">完了したタスクに格納する結果。</param>
        <summary>指定した結果で成功した <see cref="T:System.Threading.Tasks.Task`1" /> を作成します。</summary>
        <returns>正常に完了したタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、作成、 <xref:System.Threading.Tasks.Task%601> オブジェクト <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=fullName> プロパティは、 `result` とが <xref:System.Threading.Tasks.Task.Status%2A> プロパティは、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName>です。 メソッドは、タスクの戻り値が長いコード パスを実行することがなくすぐにわかっている場合によく使用されます。 具体的な例を次に示します。  
  
 値を返さないタスク オブジェクトを作成するからタスク オブジェクトを取得、 <xref:System.Threading.Tasks.Task.CompletedTask%2A> プロパティです。  
  
   
  
## 例  
 次の例は、名前を持つが、コマンドライン引数として渡された各ディレクトリ内のファイルのバイト数を計算するコマンド ライン ユーティリティです。 インスタンス化する長いコード パスを実行するのではなく、 <xref:System.IO.FileStream> オブジェクトし、の値を取得、 <xref:System.IO.FileStream.Length%2A?displayProperty=fullName> ディレクトリ内の各ファイルのプロパティは、例では、単に呼び出す、 <xref:System.Threading.Tasks.Task.FromResult%2A> タスクを作成するメソッドが <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=fullName> ディレクトリにファイルがない場合、プロパティはゼロ \(0\)。  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> を待機するために使用する awaiter を取得します。</summary>
        <returns>awaiter のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは、アプリケーション コードで使用するのではなく、コンパイラ用です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> インスタンスの一意の ID を取得します。</summary>
        <value>システムによってこの <see cref="T:System.Threading.Tasks.Task" /> インスタンスに割り当てられた識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タスク Id は、オンデマンドでは割り当てられ、タスク インスタンスの作成順序は限りません。 ある競合は非常にまれですが、タスクの識別子は保証されません一意であることに注意してください。  
  
 現在の実行タスクからそのタスクが実行されるコード内のタスク ID を取得する、 <xref:System.Threading.Tasks.Task.CurrentId%2A> プロパティです。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行が取り消されることによって完了したかどうかを示す値を取得します。</summary>
        <value>タスクが取り消されることによって完了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 A <xref:System.Threading.Tasks.Task> は完了する、 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=fullName> 次の条件のいずれかの状態。  
  
-   その <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> 、実行開始前に、キャンセルに設定されました  
  
-   タスクが既にシグナルでキャンセル要求を受信確認 <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> スローすることによって、 <xref:System.OperationCanceledException> を負いません同じ <xref:System.Threading.CancellationToken>します。  
  
-   タスクが既にシグナルでキャンセル要求を受信確認 <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> を呼び出して、 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> メソッドを <xref:System.Threading.CancellationToken>です。  
  
> [!IMPORTANT]
>  値を取得して、 <xref:System.Threading.Tasks.Task.IsCanceled%2A> タスクが完了するまでに、プロパティで呼び出し元のスレッドがブロックされません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task" /> が完了したかどうかを示す値を取得します。</summary>
        <value>タスクが完了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task.IsCompleted%2A> 戻ります `true` 3 つの最終的な状態のいずれかでは、タスク: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, 、<xref:System.Threading.Tasks.TaskStatus.Faulted>, 、または <xref:System.Threading.Tasks.TaskStatus.Canceled>です。  
  
> [!IMPORTANT]
>  値を取得して、 <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=fullName> タスクが完了するまでに、プロパティで呼び出し元のスレッドがブロックされません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>処理されない例外が発生したことが原因で <see cref="T:System.Threading.Tasks.Task" /> が完了したかどうかを示す値を取得します。</summary>
        <value>タスクがハンドルされない例外をスローした場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 場合 <xref:System.Threading.Tasks.Task.IsFaulted%2A> は `true`, 、タスクの <xref:System.Threading.Tasks.Task.Status%2A> に等しい <xref:System.Threading.Tasks.TaskStatus.Faulted>, 、およびその <xref:System.Threading.Tasks.Task.Exception%2A> プロパティは null になります。  
  
> [!IMPORTANT]
>  値を取得して、 <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=fullName> タスクが完了するまでに、プロパティで呼び出し元のスレッドがブロックされません。  
  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ThreadPool 上で実行する指定された作業をキューに配置し、その作業のタスクまたは <see cref="T:System.Threading.Tasks.Task`1" /> のハンドルを戻します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task.Run%2A> メソッドには、一連の既定値を使用してタスクを開始しやすくオーバー ロードが用意されています。 軽量の代わりには、 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> オーバー ロードします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">非同期的に実行する処理</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see cref="T:System.Threading.Tasks.Task" /> オブジェクトを戻します。</summary>
        <returns>ThreadPool で実行するためにキューに配置された作業を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 The <xref:System.Threading.Tasks.Task.Run%2A> method allows you to create and execute a task in a single method call and is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method. It creates a task with the following default values:  
  
-   Its cancellation token is <xref:System.Threading.CancellationToken.None%2A?displayProperty=fullName>.  
  
-   Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=fullName>.  
  
-   It uses the default task scheduler.  
  
 For information on handling exceptions thrown by task operations, see [Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1).  
  
   
  
## 例  
 The following example defines a `ShowThreadInfo` method  that displays the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>of the current thread. It is called directly from the application thread, and is called from the <xref:System.Action> delegate passed to the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run\#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run\#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 The following example is similar to the previous one, except that it uses a lambda expression to define the code that the task is to execute.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 The examples show that the asynchronous task executes on a different thread than the main application thread.  
  
 The call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that the task completes and displays its output before the application ends. Otherwise, it is possible that the `Main` method will complete before the task finishes.  
  
 The following example illustrates the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method. It defines an array of directory names and starts a separate task to retrieve the file names in each directory. All tasks write the file names to a single <xref:System.Collections.Concurrent.ConcurrentBag%601> object. The example then calls the <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <xref:System.Collections.Concurrent.ConcurrentBag%601> object.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> パラメーターが <see langword="null" /> でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">非同期的に実行する処理</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、<paramref name="function" /> によって返されるタスクのプロキシを返します。</summary>
        <returns>
          <paramref name="function" /> によって返されるタスクのプロキシを表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タスクの操作によってスローされる例外を処理する方法の詳細については、次を参照してください。 [Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> パラメーターが <see langword="null" /> でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">非同期的に実行する処理</param>
        <param name="cancellationToken">処理を取り消すために使用できるキャンセル トークン。</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see cref="T:System.Threading.Tasks.Task" /> オブジェクトを戻します。 キャンセル トークンで作業をキャンセルできます。</summary>
        <returns>スレッド プールで実行するためにキューに配置された作業を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タスクが実行を開始する前にキャンセルが要求される場合、タスクは実行されません。 設定されている代わりに、 <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態とスロー、 <xref:System.Threading.Tasks.TaskCanceledException> 例外です。  
  
 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> メソッドより簡単、 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=fullName> メソッドです。 次の既定値では、タスクが作成されます。  
  
-   その <xref:System.Threading.Tasks.Task.CreationOptions%2A> プロパティの値が <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=fullName>です。  
  
-   既定のタスク スケジューラを使用します。  
  
 タスクの操作によってスローされる例外を処理する方法の詳細については、次を参照してください。 [Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1)します。  
  
   
  
## 例  
 次の例では、 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> C:\\Windows\\System32 ディレクトリ内のファイルを反復処理するタスクを作成します。 ラムダ式の呼び出し、 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName> する各ファイルに関する情報を追加する方法、 <xref:System.Collections.Generic.List%601> オブジェクトです。 入れ子のタスクによって呼び出された各デタッチ、 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName> ループは、キャンセル トークンの状態を確認し、キャンセルが要求される場合、 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> メソッドです。<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=fullName> メソッドでのスロー、 <xref:System.OperationCanceledException> で処理される例外、 `catch` 呼び出し元のスレッドを呼び出す場合に、ブロック、 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> メソッドです。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> パラメーターが <see langword="null" /> でした。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">非同期的に実行する処理。</param>
        <param name="cancellationToken">処理を取り消すために使用されるキャンセル トークン。</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、<paramref name="function" /> によって返されるタスクのプロキシを返します。</summary>
        <returns>
          <paramref name="function" /> によって返されるタスクのプロキシを表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タスクの操作によってスローされる例外を処理する方法の詳細については、次を参照してください。 [Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> パラメーターは <see langword="null" /> でした。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">プロキシ タスクによって返される結果の型。</typeparam>
        <param name="function">非同期的に実行する処理</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、<paramref name="function" /> によって返される <see langword="Task(TResult)" /> のプロキシを返します。</summary>
        <returns>
          <see langword="Task(TResult)" /> によって返される <see langword="Task(TResult)" /> のプロキシを表す <paramref name="function" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 For information on handling exceptions thrown by task operations, see [Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> パラメーターは <see langword="null" /> でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクの戻り値の型。</typeparam>
        <param name="function">非同期的に実行する処理。</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトを戻します。</summary>
        <returns>スレッド プールで実行するためキューに配置された処理を表すタスク オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task.Run%2A> メソッドより簡単、 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=fullName> メソッドです。 次の既定値では、タスクが作成されます。  
  
-   そのキャンセル トークンが <xref:System.Threading.CancellationToken.None%2A?displayProperty=fullName>です。  
  
-   その <xref:System.Threading.Tasks.Task.CreationOptions%2A> プロパティの値が <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=fullName>です。  
  
-   既定のタスク スケジューラを使用します。  
  
 タスクの操作によってスローされる例外を処理する方法の詳細については、次を参照してください。 [Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1)します。  
  
   
  
## 例  
 次の例では、パブリッシュされたブックを表しているテキスト ファイル内の単語のおおよその数をカウントします。 各タスクは、ファイルを開く、内容をすべての非同期的に読み取り、および正規表現を使用して、ワード カウントを計算します。<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> メソッドが呼び出され、各書籍のワード カウントをコンソールに表示する前にすべてのタスクが完了したことを確認します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 The regular expression `\p{P}*\s+` matches zero, one, or more punctuation characters followed by one or more whitespace characters. It assumes that the total number of matches equals the approximate word count.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">プロキシ タスクによって返される結果の型。</typeparam>
        <param name="function">非同期的に実行する処理</param>
        <param name="cancellationToken">処理を取り消すために使用されるキャンセル トークン</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、<paramref name="function" /> によって返される <see langword="Task(TResult)" /> のプロキシを返します。</summary>
        <returns>
          <see langword="Task(TResult)" /> によって返される <see langword="Task(TResult)" /> のプロキシを表す <paramref name="function" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> パラメーターは <see langword="null" /> でした。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">タスクの結果の型。</typeparam>
        <param name="function">非同期的に実行する処理</param>
        <param name="cancellationToken">処理を取り消すために使用されるキャンセル トークン</param>
        <summary>スレッド プール上で実行する指定された作業をキューに配置し、その作業を表す <see langword="Task(TResult)" /> オブジェクトを戻します。 キャンセル トークンで作業をキャンセルできます。</summary>
        <returns>スレッド プールで実行するためにキューに配置された作業を表す <see langword="Task(TResult)" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タスクが実行を開始する前にキャンセルが要求される場合、タスクは実行されません。 設定されている代わりに、 <xref:System.Threading.Tasks.TaskStatus.Canceled> 状態とスロー、 <xref:System.Threading.Tasks.TaskCanceledException> 例外です。  
  
 <xref:System.Threading.Tasks.Task.Run%2A> メソッドより簡単、 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> メソッドです。 次の既定値では、タスクが作成されます。  
  
-   その <xref:System.Threading.Tasks.Task.CreationOptions%2A> プロパティの値が <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=fullName>です。  
  
-   既定のタスク スケジューラを使用します。  
  
 タスクの操作によってスローされる例外を処理する方法の詳細については、次を参照してください。 [Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1)します。  
  
   
  
## 例  
 次の例では、カウンターがインクリメント 200万の値になるまでループする 20 件のタスクを作成します。 200万に達すると、最初の 10 個のタスク、キャンセル トークンが取り消されがカウンター 200万に達していない任意のタスクが取り消されます。 この例では、使用可能な出力を示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 Instead of using the <xref:System.AggregateException.InnerExceptions%2A> property to   examine exceptions, the example iterates all tasks to determine which have completed successfully and which have been cancelled. For those that have completed, it displays the value returned by the task.  
  
 キャンセルは協調的であるために、各タスクは、キャンセルに応答する方法を決定できます。 次の例は、タスクは、例外をスローするのではなく、完了したイテレーションの数を返すと、トークンが取り消されるとする点を除いて、最初です。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run\#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run\#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 The example still must handle the <xref:System.AggregateException> exception,   since any tasks that have not started when cancellation is requested still throw an exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">タスクが取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="cancellationToken" /> に関連付けられた <see cref="T:System.Threading.CancellationTokenSource" /> が破棄されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.Tasks.Task" /> で <see cref="T:System.Threading.Tasks.TaskScheduler" /> を同期的に実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 通常、タスクは、スレッド プールのスレッドで非同期的に実行され、呼び出し元のスレッドをブロックしません。 呼び出すことによって実行されるタスク、 <xref:System.Threading.Tasks.Task.RunSynchronously> メソッドは、現在に関連付けられた <xref:System.Threading.Tasks.TaskScheduler> 呼び出し元のスレッドで実行されます。 ターゲットのスケジューラが呼び出し元のスレッドでこのタスクの実行をサポートしていない場合、スケジューラで実行するため、タスクがスケジュールされ、タスクの実行が完了するまで、呼び出し元のスレッドはブロックされます。 呼び出し元のスレッドが呼び出す必要がありますが、タスクを同期的に実行する場合でも <xref:System.Threading.Tasks.Task.Wait%2A> タスクをスローする例外を処理します。  例外処理の詳細については、次を参照してください。 [Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1)します。  
  
 呼び出すことによって実行されるタスク、 <xref:System.Threading.Tasks.Task.RunSynchronously%2A> メソッドが呼び出すことによってインスタンス化、 <xref:System.Threading.Tasks.Task> または <xref:System.Threading.Tasks.Task%601> クラスのコンス トラクターです。 タスクを同期的に実行する必要があります、 <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=fullName> 状態です。 タスクを開始して 1 回だけ実行可能性があります。 例外時の結果が 2 番目のタスクをスケジュールするしようとするとします。  
  
   
  
## 例  
 次の例では、呼び出すことによって実行されるタスク、 <xref:System.Threading.Tasks.Task.RunSynchronously%2A> メソッドを 1 つの非同期的に実行します。 どちらの場合も、タスクの実行タスクの ID とスレッドの ID を表示する同一のラムダ式、タスクが実行されています。 タスクでは、1 ~ 1,000,000 の整数の合計を計算します。 呼び出して、タスクを実行する例の出力に示すように、 <xref:System.Threading.Tasks.Task.RunSynchronously%2A> 、非同期タスクが不要にそのメソッドがアプリケーション スレッド上で実行します。  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">このタスク インラインの実行を試みるスケジューラ。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task" /> で <see cref="T:System.Threading.Tasks.TaskScheduler" /> を同期的に実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出すことによって実行されるタスク、<xref:System.Threading.Tasks.Task.RunSynchronously%2A>メソッドが呼び出すことによってインスタンス化、<xref:System.Threading.Tasks.Task>または<xref:System.Threading.Tasks.Task%601>クラスのコンス トラクターです。 タスクを同期的に実行する必要があります、<xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=fullName>状態です。 タスクを開始して 1 回だけ実行可能性があります。 例外時の結果が 2 番目のタスクをスケジュールしようとするとします。  
  
 ターゲット スケジューラが現在のスレッドでこのタスクの実行をサポートしていない場合、スケジューラ上で実行する、タスクがスケジュールされ、タスクの実行が完了するまで、現在のスレッドがブロックされます。 そのため、呼び出し元のスレッド必要はありませんメソッドを呼び出すよう<xref:System.Threading.Tasks.Task.Wait%2A>にタスクの実行が完了したことを確認してください。 タスクの操作の例外処理の詳細については、次を参照してください。[Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1)です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.Tasks.Task" /> に <see cref="T:System.Threading.Tasks.TaskScheduler" /> の実行をスケジュールし、それを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タスクを開始して 1 回だけ実行可能性があります。 しようとすると、2 回目のタスクをスケジュールすると、例外が発生します。  
  
 <xref:System.Threading.Tasks.Task.Start%2A> のいずれかを呼び出すことによって作成されたタスクの実行に使用される、 <xref:System.Threading.Tasks.Task> コンス トラクターです。 通常、これを行うなど、条件付きでに作成したタスクを実行すると、その実行から、タスクの作成を分離する必要がある場合。 実行タスクのインスタンス化を分離する必要はありませんより一般的なケースのことをお勧めのオーバー ロードを呼び出すこと、 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=fullName> または <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=fullName> メソッドです。  
  
 タスクの操作によってスローされる例外を処理する方法の詳細については、次を参照してください。 [Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1)します。  
  
   
  
## 例  
 次の例では、 <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> 、新しいインスタンスを作成するコンス トラクター <xref:System.Threading.Tasks.Task> オブジェクト ID とマネージ スレッド ID は、そのタスクを表示し、ループを実行します。 呼び出して、 <xref:System.Threading.Tasks.Task.Start%2A> タスクを実行するメソッドです。  これは、コンソール アプリケーションへの呼び出しなので、 <xref:System.Threading.Tasks.Task.Wait%2A> メソッドは、タスクの実行を終了する前に終了してから、アプリを防ぐために必要です。  
  
 [!code-csharp[System.Threading.Tasks.Task.Start\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">このタスクを関連付けて実行する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>指定された <see cref="T:System.Threading.Tasks.Task" /> に <see cref="T:System.Threading.Tasks.TaskScheduler" /> の実行をスケジュールし、それを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 タスクの開始し、1 回だけ実行のみ可能性があります。 しようとすると、2 回目のタスクをスケジュールすると、例外が発生します。  
  
 タスクの操作によってスローされる例外を処理する方法については、次を参照してください。[Exception Handling \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/beb51e50-9061-4d3d-908c-56a4f7c2e8c1)です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> は、開始する有効な状態にはありません。 既に開始、実行、またはキャンセルされたか、ダイレクト スケジューリングをサポートしない方法で作成された可能性があります。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> インスタンスは破棄されています。</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">スケジューラは、このタスクをキューに入れられませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このタスクの <see cref="T:System.Threading.Tasks.TaskStatus" /> を取得します。</summary>
        <value>このタスク インスタンスの現在の <see cref="T:System.Threading.Tasks.TaskStatus" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 値を取得して、 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=fullName> タスクが完了するまでに、プロパティで呼び出し元のスレッドがブロックされません。  
  
 詳細と例では、次を参照してください。 [を使用して継続タスクをタスクの連結](http://msdn.microsoft.com/ja-jp/0b45e9a2-de28-46ce-8212-1817280ed42d) と [方法: タスクとその子を取り消す](http://msdn.microsoft.com/ja-jp/08574301-8331-4719-ad50-9cf7f6ff3048)します。  
  
   
  
## 例  
 次の例では、カウンターがインクリメント 200万の値になるまでループする 20 件のタスクを作成します。 200万に達すると、最初の 10 個のタスク、キャンセル トークンが取り消されがカウンター 200万に達していない任意のタスクが取り消されます。 例がから、調査、 <xref:System.Threading.Tasks.Task.Status%2A> に正常に完了したか取り消されたかどうかを示すためには、各タスクのプロパティです。 完了している方は、タスクによって返される値が表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run\#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run\#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タスクの完了を待機するために使用できる <see cref="T:System.Threading.WaitHandle" /> を取得します。</summary>
        <value>タスクの完了を待機するために使用できる <see cref="T:System.Threading.WaitHandle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 によって提供される待機機能を使用して<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName>を使用することをお勧め<xref:System.IAsyncResult.AsyncWaitHandle%2A>同様の機能をします。 詳細についてを参照してください「タスクを待機している」[Task Parallelism \(Task Parallel Library\)](http://msdn.microsoft.com/ja-jp/458b5e69-5210-45e5-bc44-3888f86abd6f)と[とその他の非同期パターンを使用して TPL](http://msdn.microsoft.com/ja-jp/7add905b-ff60-4353-af79-5089038d9a08)です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作が同期的に完了したかどうかを示す値を取得します。</summary>
        <value>操作が同期的に完了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task.Wait%2A>現在のタスクが完了するまで待機する呼び出し元のスレッドの同期方法です。 現在のタスクが実行を開始していない場合 Wait メソッドは、スケジューラからタスクを削除し、現在のスレッドでインラインを実行を試みます。 、を実行することがない場合、または現在のタスクが既に実行を開始した場合は、タスクが完了するまで、呼び出し元のスレッドをブロックします。 詳細については、次を参照してください。 [Task.Wait and "Inlining"](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) .NET ブログでの並列プログラミングでします。  
  
 詳細と例では、次を参照してください。[する方法: 1 つまたは複数のタスクが完了するのを待つ](http://msdn.microsoft.com/ja-jp/79cb522b-9c93-46ed-b23a-c06908f3a374)です。  
  
   
  
## 例  
 次の例では、100万 0 ~ 100 の範囲の整数の乱数を生成およびの平均を計算するタスクを開始します。 この例では、<xref:System.Threading.Tasks.Task.Wait%2A>メソッドをアプリケーションが終了する前に、タスクが完了したことを確認してください。 それ以外の場合、これは、コンソール アプリケーションであるため、例では、終了タスクおよび計算、平均値を表示する前にします。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。<see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.Threading.Tasks.TaskCanceledException" /> オブジェクトが含まれています。  
  
 または  
  
 タスクの実行時に例外がスローされました。<see cref="P:System.AggregateException.InnerExceptions" /> コレクションには、例外に関する情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <summary>提供された <see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで、指定したミリ秒数以内の間、待機します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> の実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>現在のタスク インスタンスを次のいずれかが発生するまでに完了するまで待機する呼び出し元のスレッド同期方法を示します。  
  
-   タスクが正常に完了します。  
  
-   タスク自体が取り消された例外をスローします。 この例を処理する、<xref:System.AggregateException>例外。<xref:System.AggregateException.InnerExceptions%2A?displayProperty=fullName>プロパティには、例外または例外に関する詳細が含まれています。  
  
-   によって定義された間隔`millisecondsTimeout`が経過しました。 この場合、現在のスレッドが実行を再開し、メソッドを返します`false`です。  
  
   
  
## 例  
 次の例では、500万 0 ~ 100 の範囲の整数の乱数を生成およびの平均を計算するタスクを開始します。 この例では、<xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>メソッドをアプリケーションで 150 ミリ秒以内に完了するまで待機します。 アプリケーションが正常終了した場合、タスクには、それによって生成されたランダムな数値の平均と合計が表示されます。 タイムアウト間隔が経過した場合、例は、終了前にメッセージを表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait\#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait\#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。<see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.Threading.Tasks.TaskCanceledException" /> オブジェクトが含まれています。  
  
 または  
  
 タスクの実行時に例外がスローされました。<see cref="P:System.AggregateException.InnerExceptions" /> コレクションには、例外に関する情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">タスクの完了の待機中に観察するキャンセル トークン。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで待機します。 タスクの完了前にキャンセル トークンが取り消される場合は、待機が終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>メソッド作成キャンセルできる待機; は、次のいずれかが発生するまで待機する現在のスレッドになります。  
  
-   タスクを完了します。  
  
-   キャンセル トークンが取り消されました。 この場合への呼び出し、<xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>メソッドがスローされます、<xref:System.OperationCanceledException>です。  
  
> [!NOTE]
>  キャンセル、`cancellationToken`キャンセル トークンも何も起こりません実行中のタスクでない場合は、そのキャンセル トークンが渡されても取り消しを処理する準備ができます。 渡す、`cancellationToken`このメソッドにオブジェクトが取り消されるようにする待機を使用するとします。  
  
   
  
## 例  
 次の例は、タスクの完了の待機をキャンセルするキャンセル トークンの簡単な使用を示しています。 タスクの起動は、呼び出し、 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=fullName> 5 秒のキャンセル トークン ソースのキャンセル トークンとし、遅延のいずれかのメソッドです。 タスク自体は、キャンセル トークンが渡されていないがキャンセル可能でないことに注意してください。 アプリケーション スレッドを呼び出すタスクの<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName>、キャンセル トークンが取り消された後に、タスクを完了するまで待機するメソッドが、待機が取り消された<xref:System.OperationCanceledException>がスローされます。 例外ハンドラーは、例外を報告し、し、6 秒間スリープ状態になります。 その遅延によりで完了するタスク、例からの出力に示す、<xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName>状態です。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> は取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">タスクが破棄されました。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。<see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.Threading.Tasks.TaskCanceledException" /> オブジェクトが含まれています。  
  
 または  
  
 タスクの実行時に例外がスローされました。<see cref="P:System.AggregateException.InnerExceptions" /> コレクションには、例外に関する情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、\-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>提供された <see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで、指定した時間間隔内の間、待機します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> の実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>現在のタスク インスタンスを次のいずれかが発生するまでに完了するまで待機する呼び出し元のスレッド同期方法を示します。  
  
-   タスクが正常に完了します。  
  
-   タスク自体が取り消された例外をスローします。 この例を処理する、<xref:System.AggregateException>例外。<xref:System.AggregateException.InnerExceptions%2A?displayProperty=fullName>プロパティには、例外または例外に関する詳細が含まれています。  
  
-   によって定義された間隔`timeout`が経過しました。 この場合、現在のスレッドが実行を再開し、メソッドを返します`false`です。  
  
   
  
## 例  
 次の例では、500万 0 ~ 100 の範囲の整数の乱数を生成およびの平均を計算するタスクを開始します。 この例では、<xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>メソッドをアプリケーションで 150 ミリ秒以内に完了するまで待機します。 アプリケーションが正常終了した場合、タスクには、それによって生成されたランダムな数値の平均と合計が表示されます。 タイムアウト間隔が経過した場合、例は、終了前にメッセージを表示します。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait\#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait\#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す \-1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。<see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.Threading.Tasks.TaskCanceledException" /> オブジェクトが含まれています。  
  
 または  
  
 タスクの実行時に例外がスローされました。<see cref="P:System.AggregateException.InnerExceptions" /> コレクションには、例外に関する情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <param name="cancellationToken">タスクの完了の待機中に観察するキャンセル トークン。</param>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで待機します。 タスクの完了前に、タイムアウト期間が経過するか、キャンセル トークンが取り消される場合には、待機が終了します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> の実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>現在のタスク インスタンスを次のいずれかが発生するまでに完了するまで待機する呼び出し元のスレッド同期方法を示します。  
  
-   タスクが正常に完了します。  
  
-   タスク自体が取り消された例外をスローします。 この例を処理する、<xref:System.AggregateException>例外。<xref:System.AggregateException.InnerExceptions%2A?displayProperty=fullName>プロパティには、例外または例外に関する詳細が含まれています。  
  
-   `cancellationToken`キャンセル トークンが取り消されました。 この場合への呼び出し、<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>メソッドがスローされます、<xref:System.OperationCanceledException>です。  
  
-   によって定義された間隔`millisecondsTimeout`が経過しました。 この場合、現在のスレッドが実行を再開し、メソッドを返します`false`です。  
  
> [!NOTE]
>  キャンセル、`cancellationToken`キャンセル トークンも何も起こりません実行中のタスクの場合にのみ、そのキャンセル トークンが渡されても取り消しを処理する準備ができます。 渡すの`cancellationToken`このメソッドにオブジェクトを使用すると取り消されるようにする待機に基づいていくつかの条件にします。  
  
   
  
## 例  
 次の例では、<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>タイムアウト値と、キャンセル トークンを提供するメソッドは、タスクの完了の待機を終了できます。 新しいスレッドが開始され、実行、`CancelToken`メソッドは、一時停止を呼び出して、<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=fullName>キャンセル トークンをキャンセルするメソッド。 タスクが起動し、5 秒の遅延します。<xref:System.Threading.Tasks.Task.Wait%2A>メソッドと呼ばれ、タスクの完了を待つ、簡単なタイムアウト値とキャンセル トークンの両方が指定されています。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Note that the precise output from the example depends on whether the wait was canceled because of the cancellation token or because the timeout interval elapsed.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> は取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.AggregateException">タスクが取り消されました。<see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.Threading.Tasks.TaskCanceledException" /> オブジェクトが含まれています。  
  
 または  
  
 タスクの実行時に例外がスローされました。<see cref="P:System.AggregateException.InnerExceptions" /> コレクションには、例外に関する情報が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <summary>指定したすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例では、それぞれのインデックスを渡される状態オブジェクトとしては、10 個のタスクを開始します。 インデックス付きの 2 ~ 5 個のタスクは、例外をスローします。 呼び出し、 <xref:System.Threading.Tasks.Task.WaitAll%2A> メソッドのすべての例外がラップして、 <xref:System.AggregateException> オブジェクトし、呼び出し元のスレッドに伝達します。  
  
 [!code-csharp[System.Threading.Tasks.Task\#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task\#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引数に NULL 要素が含まれています。  
  
 または  
  
 <paramref name="tasks" /> 引数が空の配列。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合、 <see cref="T:System.AggregateException" /> 例外が含まれ、 <see cref="T:System.OperationCanceledException" /> で例外の <see cref="P:System.AggregateException.InnerExceptions" /> コレクションです。  
  
 または  
  
 少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <summary>提供されたすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定したミリ秒数以内の間、待機します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> インスタンスすべての実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合は、<see cref="T:System.AggregateException" /> の <see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.OperationCanceledException" /> が格納されます  
  
 または  
  
 少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引数に NULL 要素が含まれています。  
  
 または  
  
 <paramref name="tasks" /> 引数が空の配列です。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>待機が取り消されない限り、指定したすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `cancellationToken`引数は、待機操作のキャンセルに使用します。 個別の操作のタスクのキャンセル機能とによって通知されます、[WaitAll メソッド \(Task\<xref:System.AggregateException>上に示したようにします。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> は取り消されました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合は、<see cref="T:System.AggregateException" /> の <see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.OperationCanceledException" /> が格納されます  
  
 または  
  
 少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引数に NULL 要素が含まれています。  
  
 または  
  
 <paramref name="tasks" /> 引数が空の配列です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、\-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>提供されたすべてのキャンセル可能な <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定した時間間隔の間、待機します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> インスタンスすべての実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合は、<see cref="T:System.AggregateException" /> の <see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.OperationCanceledException" /> が格納されます  
  
 または  
  
 少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す \-1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引数に NULL 要素が含まれています。  
  
 または  
  
 <paramref name="tasks" /> 引数が空の配列です。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに観察する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>指定したミリ秒数まで、または待機が取り消されるまで、提供されたすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するのを待機します。</summary>
        <returns>割り当てられた時間内に <see langword="true" /> インスタンスすべての実行が完了した場合は <see cref="T:System.Threading.Tasks.Task" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `cancellationToken`引数は、待機操作のキャンセルに使用します。 個別の操作のタスクのキャンセル機能とによって通知されます、[WaitAll メソッド \(Task\<xref:System.AggregateException>上記です。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="tasks" /> の <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが 1 つ以上破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">少なくとも 1 つ以上の <see cref="T:System.Threading.Tasks.Task" /> インスタンスが取り消されました。 タスクが取り消された場合は、<see cref="T:System.AggregateException" /> の <see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.OperationCanceledException" /> が格納されます  
  
 または  
  
 少なくとも 1 つの <see cref="T:System.Threading.Tasks.Task" /> インスタンスの実行時に、例外がスローされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引数に NULL 要素が含まれています。  
  
 または  
  
 <paramref name="tasks" /> 引数が空の配列です。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> は取り消されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <summary>指定したいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <returns>
          <paramref name="tasks" /> 配列内の完了した <see cref="T:System.Threading.Tasks.Task" /> オブジェクトのインデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 次の例では、それぞれがスリープ状態になり 50 ミリ秒の最小値または最大 1,050 \(ミリ秒\) の 5 つのタスクを起動します。<xref:System.Threading.Tasks.Task.WaitAny%2A>メソッドは、すべてのタスクを完了するを待機します。 例では、すべてのタスクの現在の状態と同様に、待機が終了したタスクのタスク ID が表示されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <summary>提供されたいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定したミリ秒数以内の間、待機します。</summary>
        <returns>
          <paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。タイムアウトが発生した場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに監視する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>待機が取り消されない限り、指定したいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <returns>
          <paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> は取り消されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、\-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>提供されたいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで、指定した時間間隔内の間、待機します。</summary>
        <returns>
          <paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。タイムアウトが発生した場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> は無限のタイムアウトを表す \-1 ミリ秒以外の負の数です。  
  
 または  
  
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">待機する <see cref="T:System.Threading.Tasks.Task" /> インスタンスの配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> \(\-1\)。</param>
        <param name="cancellationToken">タスクの完了を待機しているときに監視する <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>指定したミリ秒数まで、または待機トークンが取り消されるまで、提供されたいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するのを待機します。</summary>
        <returns>
          <paramref name="tasks" /> 配列引数内の完了したタスクのインデックス。タイムアウトが発生した場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す \-1 以外の負の数です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引数に NULL 要素が含まれています。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> は取り消されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>列挙可能なコレクション内のすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Threading.Tasks.Task.WhenAll%2A> を返すメソッド、 <xref:System.Threading.Tasks.Task> 一連のタスクの状態または一連のタスクによってスローされた例外は、関心のあるときに、オブジェクトは通常と呼ばれます。  
  
> [!NOTE]
>  呼び出し <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> メソッドが呼び出し元のスレッドをブロックしません。  
  
 返されるタスクも完了に障害が発生した状態で指定されたタスクのいずれかが完了した場合、 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=fullName> その例外が指定されたタスクのラップされていない例外のセットの集計に含まれている状態です。  
  
 指定されたタスクのいずれも障害が発生してそれらの少なくとも 1 つが取り消された場合は、返されるタスクが終了するまで、 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=fullName> 状態です。  
  
 タスクに障害が発生して、タスクが取り消された場合は、結果のタスクが終了するまで、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態です。  
  
 返されるタスクはすぐに移行する、指定された配列\/列挙可能な含まれていない場合のタスク、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態に、呼び出し元に返されます。  
  
   
  
## 例  
 次の例では、配列内の Url に ping を実行するタスクのセットを作成します。 タスクが格納されている、 `List<Task>` に渡されるコレクション、 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> メソッドです。 呼び出しの後に、 <xref:System.Threading.Tasks.Task.Wait%2A> メソッドにより、すべてのスレッドが完了した例では、検査、 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=fullName> いずれかのタスクに障害が発生しているかどうかを決定するプロパティです。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> コレクションに <see langword="null" /> タスクが含まれていました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>配列内のすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 オーバー ロード、 <xref:System.Threading.Tasks.Task.WhenAll%2A> を返すメソッド、 <xref:System.Threading.Tasks.Task> 一連のタスクの状態または一連のタスクによってスローされた例外は、関心のあるときに、オブジェクトは通常と呼ばれます。  
  
> [!NOTE]
>  呼び出し <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> メソッドが呼び出し元のスレッドをブロックしません。  
  
 返されるタスクも完了に障害が発生した状態で指定されたタスクのいずれかが完了した場合、 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=fullName> その例外が指定されたタスクのラップされていない例外のセットの集計に含まれている状態です。  
  
 指定されたタスクのいずれも障害が発生してそれらの少なくとも 1 つが取り消された場合は、返されるタスクが終了するまで、 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=fullName> 状態です。  
  
 タスクに障害が発生して、タスクが取り消された場合は、結果のタスクが終了するまで、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態です。  
  
 返されるタスクはすぐに移行する、指定された配列\/列挙可能な含まれていない場合のタスク、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態に、呼び出し元に返されます。  
  
   
  
## 例  
 次の例では、配列内の Url に ping を実行するタスクのセットを作成します。 タスクが格納されている、 `List<Task>` コレクションを配列に変換されに渡されますが、 <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> メソッドです。 呼び出しの後に、 <xref:System.Threading.Tasks.Task.Wait%2A> メソッドにより、すべてのスレッドが完了した例では、検査、 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=fullName> いずれかのタスクに障害が発生しているかどうかを決定するプロパティです。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列に <see langword="null" /> タスクが含まれていました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>列挙可能なコレクション内のすべての <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出し <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> メソッドが呼び出し元のスレッドをブロックしません。 ただし、返されたへの呼び出し <xref:System.Threading.Tasks.Task%601.Result%2A> プロパティは、呼び出し元のスレッドをブロックします。  
  
 返されるタスクも完了に障害が発生した状態で指定されたタスクのいずれかが完了した場合、 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=fullName> その例外が指定されたタスクのラップされていない例外のセットの集計に含まれている状態です。  
  
 指定されたタスクのいずれも障害が発生してそれらの少なくとも 1 つが取り消された場合は、返されるタスクが終了するまで、 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=fullName> 状態です。  
  
 タスクに障害が発生して、タスクが取り消された場合は、結果のタスクが終了するまで、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態です。<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=fullName> が指定されているすべての同じ順序で指定されたタスクの結果を含む配列に返されたタスクのプロパティが設定されます \(例: 場合は、入力配列が含まれている t1、t2、t3、出力のタスクのタスク <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=fullName> が返される、 `TResult[]` 、 `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`です。  
  
 場合、 `tasks` 引数にタスクが含まれていない、返されるタスクはすぐに移行する、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態に、呼び出し元に返されます。 返された `TResult[]` 0 要素の配列になります。  
  
   
  
## 例  
 次の例では、1 から 1,000 まで 1,000 のランダムな数字を作成し、その平均を計算する乱数ジェネレーターをインスタンス化の 10 個のタスクを作成します。<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> メソッドを使用する乱数ジェネレーターのインスタンス化を延期できるように、同一のシード値では作成されません。 呼び出し、 <xref:System.Threading.Tasks.Task.WhenAll%2A> メソッドが戻ります、 <xref:System.Int64> を平均値を格納する配列の各タスクで計算します。 これらは、全体の平均を計算に使用されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 In this case, the ten individual tasks are stored in a <xref:System.Collections.Generic.List%601> object. <xref:System.Collections.Generic.List%601> implements the <xref:System.Collections.Generic.IEnumerable%601> interface.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> コレクションに <see langword="null" /> タスクが含まれていました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>配列内のすべての <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトが完了したときに完了するタスクを作成します。</summary>
        <returns>指定されたすべてのタスクの完了を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出し <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> メソッドが呼び出し元のスレッドをブロックしません。 ただし、返されたへの呼び出し <xref:System.Threading.Tasks.Task%601.Result%2A> プロパティは、呼び出し元のスレッドをブロックします。  
  
 返されるタスクも完了に障害が発生した状態で指定されたタスクのいずれかが完了した場合、 <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=fullName> その例外が指定されたタスクのラップされていない例外のセットの集計に含まれている状態です。  
  
 指定されたタスクのいずれも障害が発生してそれらの少なくとも 1 つが取り消された場合は、返されるタスクが終了するまで、 <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=fullName> 状態です。  
  
 タスクに障害が発生して、タスクが取り消された場合は、結果のタスクが終了するまで、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態です。<xref:System.Threading.Tasks.Task%601.Result%2A> 返されたタスクが指定されているすべての同じ順序で指定されたタスクの結果を含む配列に設定されます \(例: 場合は、入力配列が含まれている t1、t2、t3、出力のタスクのタスク <xref:System.Threading.Tasks.Task%601.Result%2A> が返されます、 `TResult[]` 、 `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`です。  
  
 返されるタスクはすぐに移行する、指定された配列\/列挙可能な含まれていない場合のタスク、 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=fullName> 状態に、呼び出し元に返されます。  返された `TResult[]` 0 要素の配列になります。  
  
   
  
## 例  
 次の例では、1 から 1,000 まで 1,000 のランダムな数字を作成し、その平均を計算する乱数ジェネレーターをインスタンス化の 10 個のタスクを作成します。 この場合は、10 個の個別のタスクに含まれて、 `Task<Int64>` 配列。<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> メソッドを使用する乱数ジェネレーターのインスタンス化を延期できるように、同一のシード値では作成されません。 呼び出し、 <xref:System.Threading.Tasks.Task.WhenAll%2A> メソッドが戻ります、 <xref:System.Int64> を平均値を格納する配列の各タスクで計算します。 これらは、全体の平均を計算に使用されます。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列に <see langword="null" /> タスクが含まれていました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたすべてのタスクが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるタスクはときに完了されたすべての指定されたタスクが完了します。  返されるタスクが終了常に、`RanToCompletion`状態と共に、その結果、最初のタスクを完了に設定します。  これは、最初のタスクが完了するがで終了した場合でもは true、`Canceled`または`Faulted`状態です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" />配列が null タスクに含まれる、または空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたすべてのタスクが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるタスクを完了ときに指定されたタスクのいずれかが完了しました。  返されるタスクが常に終了するまで、 `RanToCompletion` 状態と共に、 `Result` 最初のタスクを完了に設定します。  これは、最初のタスクが完了するがで終了した場合でも当てはまります、 `Canceled` または `Faulted` 状態です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が null でした。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が null タスクに含まれる、または空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたすべてのタスクが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるタスクを完了ときに指定されたタスクのいずれかが完了しました。  そのに結果セット最初のタスクを完了すると、返されるタスクが終了 RanToCompletion 状態で常にします。 これは、最初のタスクが完了するが、キャンセルまたは Faulted 状態で終了した場合でも当てはまります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が <see langword="null" /> でした。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が null タスクに含まれる、または空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">完了したタスクの型。</typeparam>
        <param name="tasks">完了を待機するタスク。</param>
        <summary>指定されたすべてのタスクが完了してから完了するタスクを作成します。</summary>
        <returns>指定されたいずれかのタスクの完了を表すタスク。  返されるタスクの結果は完了したタスクです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 返されるタスクを完了ときに指定されたタスクのいずれかが完了しました。  そのに結果セット最初のタスクを完了すると、返されるタスクが終了 RanToCompletion 状態で常にします。 これは、最初のタスクが完了するが、キャンセルまたは Faulted 状態で終了した場合でも当てはまります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引数が null でした。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 配列が null タスクに含まれる、または空でした。</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>待機されたときに現在のコンテキストに非同期的に処理を譲る awaitable タスクを作成します。</summary>
        <returns>必要な場合は、要求時に現在のコンテキストに非同期で再度遷移するコンテキスト。 現在の <see cref="T:System.Threading.SynchronizationContext" /> が null 以外の場合は、現在のコンテキストとして扱われます。 それ以外の場合は、現在の実行タスクに関連付けられているタスク スケジューラは、現在のコンテキストとして扱われます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 使用することができます `await Task.Yield();` 強制的に、メソッドを非同期的に完了する非同期メソッドにします。 現在の同期コンテキストがある場合 \(<xref:System.Threading.SynchronizationContext> オブジェクト\)、これはそのコンテキストに戻す、メソッドの実行の残りの部分を送信します。 ただし、コンテキストが保留されているその他の作業に関連してこの作業を優先順位を設定する方法を決定します。 ほとんどの UI 環境では、UI スレッドで表示される同期コンテキストでは、入力とレンダリング作業よりも高くのコンテキストにポストされたような作業を優先は多くの場合。 このため、依存しない `await Task.Yield();` UI の応答性を維持します。  詳細については、エントリを参照してください。 [Useful Abstractions Enabled with ContinueWith](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) .NET ブログでの並列プログラミングにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したいずれかの <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> の実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Threading.Tasks.Task" /> で <see cref="T:System.Threading.Tasks.TaskScheduler" /> を同期的に実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したすべての <see cref="T:System.Threading.Tasks.Task" /> オブジェクトの実行が完了するまで待機します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたすべてのタスクが完了してから完了するタスクを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>遅延後に完了するタスクを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたすべてのタスクが完了してから完了するタスクを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Threading.Tasks.Task" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Tasks.Task" /> を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task" /> が完了したときに非同期に実行する継続タスクを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
  </Members>
</Type>