<Type Name="FileStream" FullName="System.IO.FileStream">
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>同期および非同期の読み取り操作と書き込み操作をサポートするファイル用の <see cref="T:System.IO.Stream" /> を提供します。  
  
 この型の .NET Framework ソース コードを参照するを参照してください。、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## 解説  
  
> [!NOTE]
>  この型の .NET Framework ソース コードを参照してください、 [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)します。 ソース コードをオンラインで参照、オフライン表示のリファレンスをダウンロードおよびデバッグ中にソース \(パッチや更新を含む\) をステップsee [instructions](http://referencesource.microsoft.com/).  
  
 使用して、 <xref:System.IO.FileStream> から読み取り、書き込み. を開き、ファイル システム上のファイルを閉じるし、パイプ、標準入力、および標準出力を含む他のファイルに関連するオペレーティング システム ハンドルを操作するクラス。 使用することができます、 <xref:System.IO.FileStream.Read%2A>, 、<xref:System.IO.FileStream.Write%2A>, 、<xref:System.IO.Stream.CopyTo%2A>, 、および <xref:System.IO.FileStream.Flush%2A> 同期操作を実行するメソッドまたは <xref:System.IO.FileStream.ReadAsync%2A>, 、<xref:System.IO.FileStream.WriteAsync%2A>, 、<xref:System.IO.Stream.CopyToAsync%2A>, 、および <xref:System.IO.FileStream.FlushAsync%2A> の非同期操作を実行するメソッドです。 非同期のメソッドを使用すると、メイン スレッドをブロックすることがなくリソースを消費するファイルの操作を実行できます。 このパフォーマンスに関する考慮事項は、時間のかかるストリーム操作によって UI スレッドがブロックされ、アプリが動作していないと見なされる可能性がある [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリまたは[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] アプリで特に重要です。<xref:System.IO.FileStream> 入力バッファーされ、パフォーマンス向上のための出力。  
  
> [!IMPORTANT]
>  この型は、 <xref:System.IDisposable> インターフェイスです。 型の使用が完了したらを直接または間接的にその破棄する必要があります。 型の直接 dispose を呼び出してその <xref:System.IDisposable.Dispose%2A> メソッドで、 `try`\/`catch` ブロックします。 直接ことのない破棄する場合など言語構成要素を使用して `using` \(c\#\) のまたは `Using` \(Visual Basic で\)。 詳細については、"を使用して、オブジェクトを実装して IDisposable"」セクションを参照してください、 <xref:System.IDisposable> インターフェイスに関するトピック。  
  
 <xref:System.IO.FileStream.IsAsync%2A> プロパティは、ファイル ハンドルが非同期的に開かれたかどうかを検出します。 インスタンスを作成するときに、この値を指定する、 <xref:System.IO.FileStream> を持つコンス トラクターを使用して、 `isAsync`, 、`useAsync`, 、または `options` パラメーター。 プロパティが `true`, 、ストリームがファイルの操作を非同期に実行する重複 I\/O を利用します。 ただし、 <xref:System.IO.FileStream.IsAsync%2A> プロパティがある必要ありません `true` を呼び出して、 <xref:System.IO.FileStream.ReadAsync%2A>, 、<xref:System.IO.FileStream.WriteAsync%2A>, 、または <xref:System.IO.Stream.CopyToAsync%2A> メソッドです。 ときに、 <xref:System.IO.FileStream.IsAsync%2A> プロパティは、 `false` および書き込み操作を非同期の読み込みを呼び出すと、まだ、UI スレッドはブロックされませんが、実際の I\/O 操作が同期的に実行します。  
  
 <xref:System.IO.FileStream.Seek%2A> メソッドは、ファイルへのランダム アクセスをサポートしています。<xref:System.IO.FileStream.Seek%2A> ファイル内のどの位置に移動する読み取り\/書き込み位置を使用します。 これは、バイト オフセット参照ポイント パラメーターを使用して行います。 バイト オフセットになる可能性が先頭、現在の位置または基になるファイルの最後の 3 つのメンバーで表されるシーク参照ポイントは、 <xref:System.IO.SeekOrigin> 列挙します。  
  
> [!NOTE]
>  ディスク ファイルは、常に、ランダム アクセスをサポートします。 、構築時に、 <xref:System.IO.FileStream.CanSeek%2A> にプロパティの値が設定されている `true` または `false` 基になるファイルの種類によって異なります。基になるファイルの種類の FILE\_TYPE\_DISK、winbase.h で定義されている場合、 <xref:System.IO.FileStream.CanSeek%2A> プロパティの値が `true`です。 それ以外の場合、 <xref:System.IO.FileStream.CanSeek%2A> プロパティの値が `false`です。  
  
 プロセスがロックされているファイルの一部には、またはを未解決のロックを持つファイルを閉じ、動作は未定義です。  
  
 ディレクトリ操作とその他のファイル操作の場合は、「 <xref:System.IO.File>, <xref:System.IO.Directory>, 、および <xref:System.IO.Path> クラスです。<xref:System.IO.File> クラスは、ユーティリティ クラスを作成するため、主に静的メソッドを持つ <xref:System.IO.FileStream> ファイルのパスに基づくオブジェクトです。<xref:System.IO.MemoryStream> クラスは、バイト配列からストリームを作成し、に似ていますが、 <xref:System.IO.FileStream> クラスです。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
## ストリームの位置の変更の検出  
 ときに、 <xref:System.IO.FileStream> オブジェクトでは、そのハンドルでは、排他的に保持にいない、別のスレッドがファイル ハンドルを同時にアクセスし、ファイル ハンドルに関連付けられているオペレーティング システムのファイル ポインターの位置を変更します。 この場合、キャッシュの位置で、 <xref:System.IO.FileStream> オブジェクトと、バッファーにキャッシュされたデータを侵害する可能性があります。<xref:System.IO.FileStream> オブジェクトは、オペレーティング システムのハンドルの位置で使用されるキャッシュの位置と同じであることを確認するキャッシュされたバッファーにアクセスするメソッドのチェックを定期的に実行、 <xref:System.IO.FileStream> オブジェクトです。  
  
 呼び出しでハンドルの位置での予期しない変更が検出されたかどうか、 <xref:System.IO.FileStream.Read%2A> メソッド、.NET Framework は、バッファーの内容を破棄し、ファイルからもう一度、ストリームを読み取ります。 ファイル ストリームの位置に影響を与える他のプロセスとファイルのサイズによっては、パフォーマンスに影響を与えることができます。  
  
 呼び出しでハンドルの位置での予期しない変更が検出されたかどうか、 <xref:System.IO.FileStream.Write%2A> メソッド、バッファーの内容が破棄されたと <xref:System.IO.IOException> 例外がスローされます。  
  
 A <xref:System.IO.FileStream> オブジェクトでは、そのハンドルでは、排他的に保持はないときか、 <xref:System.IO.FileStream.SafeFileHandle%2A> ハンドルを公開するプロパティにアクセスまたは <xref:System.IO.FileStream> オブジェクトが割り当てられて、 <xref:System.IO.FileStream.SafeFileHandle%2A> コンス トラクターでプロパティです。  
  
   
  
## 例  
 次の例では、一部を示しています、 <xref:System.IO.FileStream> コンス トラクターです。  
  
 [!code-cpp[fstream class\#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class\#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 次の例では、非同期的にファイルに書き込む方法を示します。 このコードを TextBlock UserInput および Button\_Click という名前の Click イベント ハンドラーにフック ボタンという名前を持つ WPF アプリで実行されます。 ファイルのパスは、コンピューター上に存在するよりも、ファイルに変更する必要があります。  
  
 [!code-csharp[Asynchronous\_File\_IO\_async\#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous\_File\_IO\_async\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り\/書き込みアクセス許可を使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.IO.Stream.Close%2A> が呼び出されると、ハンドルも閉じられ、ファイルのハンドル数は減少します。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、 `FileStream` も保持しているハンドルがデータの破損になる可能性があります。 データの安全性、呼び出す <xref:System.IO.FileStream.Flush%2A> 、ハンドルを使用して、以外のすべてのメソッドの呼び出しを回避する前に `Close` が完了したら、ハンドルを使用しています。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 `FileShare.Read` これらの既定値は、 <xref:System.IO.FileStream> なしのコンス トラクター、 `FileShare` パラメーター。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> は <see cref="T:System.IO.FileAccess" /> のフィールドではありません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定されたファイル ハンドルに対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイル ハンドルが読み取り専用アクセスに設定されているなどの場合です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り\/書き込みアクセス許可を使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.IO.Stream.Close%2A> が呼び出されると、ハンドルも閉じられ、ファイルのハンドル数は減少します。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、 `FileStream` も保持しているハンドルがデータの破損になる可能性があります。 データの安全性、呼び出す <xref:System.IO.FileStream.Flush%2A> 、ハンドルを使用して、以外のすべてのメソッドの呼び出しを回避する前に `Close` が完了したら、ハンドルを使用しています。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 `FileShare.Read` これらの既定値は、 <xref:System.IO.FileStream> なしのコンス トラクター、 `FileShare` パラメーター。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> は <see cref="T:System.IO.FileAccess" /> のフィールドではありません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定されたファイル ハンドルに対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイル ハンドルが読み取り専用アクセスに設定されているなどの場合です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパスと作成モードを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework では、パス"\\\\.\\PHYSICALDRIVE0"などのデバイス名を使用して物理ディスクへの直接アクセスをできません。  
  
 `path` パラメーターは、汎用名前付け規則 \(UNC\) 共有上のファイルを含む、ファイル名を指定できます。  
  
 コンス トラクターには、ファイルを読み取り\/書き込みアクセスが与えられ、共有読み取りアクセスを開く \(限り同じまたは別のプロセスによって書き込みが失敗するは、ファイルを開くには、要求、 `FileStream` オブジェクトが閉じられましたが、読み取り試行が成功\)。  
  
 このコンス トラクターを使用すると、読み取り専用のファイルを開くことはできません。代わりに、受け取るコンス トラクターを使用する必要があります、 `FileAccess` パラメーター値を設定して `FileAccess.Read`します。  
  
 バッファーのサイズは 4096 バイト \(4 KB\) の既定のサイズに設定されます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分を指定できます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true` すべて <xref:System.IO.FileStream> ファイルをカプセル化するオブジェクト。 場合 `path` 、シークをサポートしていないデバイスを示す、 <xref:System.IO.FileStream.CanSeek%2A> プロパティ、その結果を <xref:System.IO.FileStream> は `false`です。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
 `FileShare.Read` これらの既定値は、 <xref:System.IO.FileStream> なしのコンス トラクター、 `FileShare` パラメーター。  
  
 なしのコンス トラクター、 <xref:System.IO.FileAccess> パラメーター場合、 `mode` パラメーターに設定されて <xref:System.IO.FileMode.Append>, 、<xref:System.IO.FileAccess.Write> は既定のアクセス。 それ以外の場合、アクセスに設定されている <xref:System.IO.FileAccess.ReadWrite>します。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 次のコード例では、ファイル、バイト単位でデータを書き込むし、データが正常に書き込まれたことを確認する方法を示します。  
  
 [!code-cpp[System.IO.FileStream1\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> は空の文字列 \(""\) で、空白のみで構成されているか、正しくない文字を含んでいます。  
  
 \-または\-  
  
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> が非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> の場合などは、ファイルが見つかりません。また <paramref name="path" /> によって指定されたファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが正しくありません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定されたパスかファイル名、またはその両方がシステム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満、ファイル名は 260 文字未満にする必要があります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> に無効な値が含まれています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する <see cref="T:System.IO.FileAccess" /> 定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り\/書き込みアクセス許可、およびバッファー サイズを使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、 `FileStream` も保持しているハンドルがデータの破損になる可能性があります。 データの安全性、呼び出す <xref:System.IO.FileStream.Flush%2A> 、ハンドルを使用して、以外のすべてのメソッドの呼び出しを回避する前に `Close` が完了したら、ハンドルを使用しています。 または、読み書き可能なハンドルにこの関数を呼び出す前に `FileStream` コンス トラクターです。  
  
 `FileShare.Read` これらの既定値は、 <xref:System.IO.FileStream> なしのコンス トラクター、 `FileShare` パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> パラメーターが正しいハンドルではありません。  
  
 または  
  
 同期ハンドルである <paramref name="handle" /> パラメーターが、非同期的に使用されました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> パラメーターが負です。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの、I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定されたファイル ハンドルに対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイル ハンドルが読み取り専用アクセスに設定されているなどの場合です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <param name="ownsHandle">この <see langword="FileStream" /> インスタンスがファイル ハンドルを所有する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り\/書き込みアクセス許可と <see langword="FileStream" /> インスタンスの所有権を使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `FileStream` オブジェクトには、ファイルに指定されたアクセスが与えられます。 ハンドルの所有権があると指定します。 このプロセスへの呼び出し、ハンドルを所有しているかどうか、 <xref:System.IO.Stream.Close%2A> メソッドは、ハンドルを閉じることも、ファイルのハンドル数は減少します。`FileStream` オブジェクトには、既定のバッファー サイズは 4096 バイトが割り当てられています。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、 `FileStream` も保持しているハンドルがデータの破損になる可能性があります。 データの安全性、呼び出す <xref:System.IO.FileStream.Flush%2A> する前に、ハンドルを使用して、以外のメソッドは呼び出しません `Close` が完了したら、ハンドルを使用しています。  
  
 `FileShare.Read` これらの既定値は、 <xref:System.IO.FileStream> なしのコンス トラクター、 `FileShare` パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> は <see cref="T:System.IO.FileAccess" /> のフィールドではありません</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定されたファイル ハンドルに対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイル ハンドルが読み取り専用アクセスに設定されているなどの場合です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトがファイルにアクセスできる方法を決定する定数。 これにより、<see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> および <see cref="P:System.IO.FileStream.CanWrite" /> プロパティによって返される値も決まります。<c>path</c> がディスク ファイルを指定している場合、<see cref="P:System.IO.FileStream.CanSeek" /> は <see langword="true" /> になります。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、および読み取り\/書き込みアクセス許可を使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework では、パス"\\\\.\\PHYSICALDRIVE0"などのデバイス名を使用して物理ディスクへの直接アクセスをできません。  
  
 `path` パラメーターは、汎用名前付け規則 \(UNC\) 共有上のファイルを含む、ファイル名を指定できます。  
  
 コンス トラクターは、ファイルを読み取り\/書き込みアクセスを付与され、読み取りアクセスを共有してが開かれます \(限り同じまたは別のプロセスによって書き込みが失敗するは、ファイルを開くには、要求、 `FileStream` オブジェクトが閉じられましたが、読み取り試行が成功する\)。 バッファーのサイズは 4096 バイト \(4 KB\) の既定のサイズに設定されます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分を指定できます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true` すべて <xref:System.IO.FileStream> ファイルをカプセル化するオブジェクト。 場合 `path` 、シークをサポートしていないデバイスを示す、 <xref:System.IO.FileStream.CanSeek%2A> プロパティ、その結果を <xref:System.IO.FileStream> は `false`です。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
 `FileShare.Read` これらの既定値は、 <xref:System.IO.FileStream> なしのコンス トラクター、 `FileShare` パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> は空の文字列 \(""\) であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
 \-または\-  
  
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> は非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> の場合などは、ファイルが見つかりません。また <paramref name="path" /> によって指定されたファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが正しくありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であり、ファイルまたはディレクトリが読み取り専用アクセスに設定されているなどの場合には、要求された <paramref name="access" /> は、指定された <paramref name="path" /> のオペレーティング システムで許可されません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定されたパスかファイル名、またはその両方がシステム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満、ファイル名は 260 文字未満にする必要があります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> に無効な値が含まれています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">この <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <param name="isAsync">ハンドルが非同期的に開かれた場合 \(重複 I\/O モード用\) は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り\/書き込みアクセス許可、バッファー サイズ、および同期状態または非同期状態を使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 設定する、 `isAsync` パラメーターを `true` を非同期的にファイル ハンドルを開きます。 パラメーターの場合は `true`, 、ストリームがファイルの操作を非同期に実行する重複 I\/O を利用します。 ただし、パラメーターがある `true` を呼び出して、 <xref:System.IO.FileStream.ReadAsync%2A>, 、<xref:System.IO.FileStream.WriteAsync%2A>, 、または <xref:System.IO.Stream.CopyToAsync%2A> メソッドです。 ときに、 `isAsync` パラメーターは `false` および書き込み操作を非同期の読み込みを呼び出すと、まだ、UI スレッドはブロックされませんが、実際の I\/O 操作が同期的に実行します。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、 `FileStream` も保持しているハンドルがデータの破損になる可能性があります。 データの安全性、呼び出す <xref:System.IO.FileStream.Flush%2A> 、ハンドルを使用して、以外のすべてのメソッドの呼び出しを回避する前に `Close` が完了したら、ハンドルを使用しています。 または、読み書き可能なハンドルにこの関数を呼び出す前に `FileStream` コンス トラクターです。  
  
 `FileShare.Read` これらの既定値は、 <xref:System.IO.FileStream> なしのコンス トラクター、 `FileShare` パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> パラメーターが正しくないハンドルです。  
  
 または  
  
 同期ハンドルである <paramref name="handle" /> パラメーターが、非同期的に使用されました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> パラメーターが負です。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの、I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定されたファイル ハンドルに対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイル ハンドルが読み取り専用アクセスに設定されているなどの場合です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code. Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">この <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <param name="ownsHandle">この <see langword="FileStream" /> インスタンスがファイル ハンドルを所有する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り\/書き込みアクセス許可、<see langword="FileStream" /> インスタンスの所有権、およびバッファー サイズを使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `FileStream` オブジェクトには、ファイルに指定されたアクセスが与えられます。 ハンドルの所有権があると指定します。 この場合 `FileStream` への呼び出し、ハンドルを所有している、 <xref:System.IO.Stream.Close%2A> メソッドは、ハンドルを閉じることもできます。 具体的には、ファイルのハンドル数は減少します。`FileStream` オブジェクトが指定したバッファー サイズを指定します。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、 `FileStream` も保持しているハンドルがデータの破損になる可能性があります。 データの安全性、呼び出す <xref:System.IO.FileStream.Flush%2A> 、ハンドルを使用して、以外のすべてのメソッドの呼び出しを回避する前に `Close` が完了したら、ハンドルを使用しています。 または、読み書き可能なハンドルにこの関数を呼び出す前に `FileStream` コンス トラクターです。  
  
 `FileShare.Read` これらの既定値は、 <xref:System.IO.FileStream> なしのコンス トラクター、 `FileShare` パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> は負の値です。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの、I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定されたファイル ハンドルに対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイル ハンドルが読み取り専用アクセスに設定されているなどの場合です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトがファイルにアクセスできる方法を決定する定数。 これにより、<see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> および <see cref="P:System.IO.FileStream.CanWrite" /> プロパティによって返される値も決まります。<c>path</c> がディスク ファイルを指定している場合、<see cref="P:System.IO.FileStream.CanSeek" /> は <see langword="true" /> になります。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、読み取り\/書き込みアクセス許可、および共有アクセス許可を使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework では、パス"\\\\.\\PHYSICALDRIVE0"などのデバイス名を使用して物理ディスクへの直接アクセスをできません。  
  
 `path` パラメーターは、汎用名前付け規則 \(UNC\) 共有上のファイルを含む、ファイル名を指定できます。  
  
 コンス トラクターは、ファイルを読み取り\/書き込みアクセスを付与され、読み取りアクセスを共有してが開かれます \(限り同じまたは別のプロセスによって書き込みが失敗するは、ファイルを開くには、要求、 `FileStream` オブジェクトが閉じられましたが、読み取り試行が成功する\)。 バッファーのサイズは 4096 バイト \(4 KB\) の既定のサイズに設定されます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分を指定できます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true` すべて <xref:System.IO.FileStream> ファイルをカプセル化するオブジェクト。 場合 `path` 、シークをサポートしていないデバイスを示す、 <xref:System.IO.FileStream.CanSeek%2A> プロパティ、その結果を <xref:System.IO.FileStream> は `false`です。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 このコード例が示されている例の一部は、 <xref:System.IO.FileStream.Lock%2A> メソッドです。  
  
 [!code-cpp[System.IO.FileStream3\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> は空の文字列 \(""\) であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
 \-または\-  
  
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> は非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> の場合などは、ファイルが見つかりません。また <paramref name="path" /> によって指定されたファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I\/O エラーが発生しました。  
  
 \-または\-  
  
 システムが Windows 98 または Windows 98 Second Edition を実行中で、<paramref name="share" /> が <see langword="FileShare.Delete" /> に設定されています。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが正しくありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であり、ファイルまたはディレクトリが読み取り専用アクセスに設定されているなどの場合には、要求された <paramref name="access" /> は、指定された <paramref name="path" /> のオペレーティング システムで許可されません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定されたパスかファイル名、またはその両方がシステム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満、ファイル名は 260 文字未満にする必要があります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> に無効な値が含まれています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">この <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのファイル ハンドル。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> プロパティと <see cref="P:System.IO.FileStream.CanWrite" /> プロパティを設定する定数。</param>
        <param name="ownsHandle">この <see langword="FileStream" /> インスタンスがファイル ハンドルを所有する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <param name="isAsync">ハンドルが非同期的に開かれた場合 \(重複 I\/O モード用\) は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定した読み取り\/書き込みアクセス許可、<see langword="FileStream" /> インスタンスの所有権、バッファー サイズ、および同期状態または非同期状態を使用して、指定したファイル ハンドル用に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `FileStream` オブジェクトには、ファイルに指定されたアクセスが与えられます。 ハンドルの所有権があると指定します。 この場合 `FileStream` への呼び出し、ハンドルを所有している、 <xref:System.IO.Stream.Close%2A> メソッドは、ハンドルを閉じることもできます。 具体的には、ファイルのハンドル数は減少します。`FileStream` オブジェクトが指定したバッファー サイズを指定します。  
  
 `FileStream` ハンドルを排他的に制御を使用するいると仮定します。 読み取り、書き込み、またはシーク中に、 `FileStream` も保持しているハンドルがデータの破損になる可能性があります。 データの安全性、呼び出す <xref:System.IO.FileStream.Flush%2A> 、ハンドルを使用して、以外のすべてのメソッドの呼び出しを回避する前に `Close` が完了したら、ハンドルを使用しています。 または、読み書き可能なハンドルにこの関数を呼び出す前に `FileStream` コンス トラクターです。  
  
 `FileShare.Read` これらの既定値は、 <xref:System.IO.FileStream> なしのコンス トラクター、 `FileShare` パラメーター。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="access" /> が <see langword="FileAccess.Read" /> 未満か、<see langword="FileAccess.ReadWrite" /> より大きいか、または <paramref name="bufferSize" /> が 0 以下です。</exception>
        <exception cref="T:System.ArgumentException">ハンドルが正しくありません。</exception>
        <exception cref="T:System.IO.IOException">ディスク エラーなどの、I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定されたファイル ハンドルに対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイル ハンドルが読み取り専用アクセスに設定されているなどの場合です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for access to unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトがファイルにアクセスできる方法を決定する定数。 これにより、<see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> および <see cref="P:System.IO.FileStream.CanWrite" /> プロパティによって返される値も決まります。<c>path</c> がディスク ファイルを指定している場合、<see cref="P:System.IO.FileStream.CanSeek" /> は <see langword="true" /> になります。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、読み取り\/書き込みアクセス許可、共有アクセス許可、およびバッファー サイズを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework では、パス"\\\\.\\PHYSICALDRIVE0"などのデバイス名を使用して物理ディスクへの直接アクセスをできません。  
  
 `path` パラメーターは、汎用名前付け規則 \(UNC\) 共有上のファイルを含む、ファイル名を指定できます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分を指定できます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true` すべて <xref:System.IO.FileStream> ファイルをカプセル化するオブジェクト。 場合 `path` 、シークをサポートしていないデバイスを示す、 <xref:System.IO.FileStream.CanSeek%2A> プロパティ、その結果を <xref:System.IO.FileStream> は `false`です。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> は空の文字列 \(""\) であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
 \-または\-  
  
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> が非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> が負の値であるかゼロです。  
  
 \-または\-  
  
 <paramref name="mode" />、<paramref name="access" />、または <paramref name="share" /> に正しくない値が含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> であるときなどに、ファイルが見つかりません。<paramref name="path" /> が指定したファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I\/O エラーが発生しました。  
  
 \-または\-  
  
 システムが Windows 98 または Windows 98 Second Edition を実行中で、<paramref name="share" /> が <see langword="FileShare.Delete" /> に設定されています。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが正しくありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であり、ファイルまたはディレクトリが読み取り専用アクセスに設定されているなどの場合には、要求された <paramref name="access" /> は、指定された <paramref name="path" /> のオペレーティング システムで許可されません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定されたパスかファイル名、またはその両方がシステム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満、ファイル名は 260 文字未満でなければなりません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトがファイルにアクセスできる方法を決定する定数。 これにより、<see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> および <see cref="P:System.IO.FileStream.CanWrite" /> プロパティによって返される値も決まります。<c>path</c> がディスク ファイルを指定している場合、<see cref="P:System.IO.FileStream.CanSeek" /> は <see langword="true" /> になります。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは 4096 です。</param>
        <param name="useAsync">非同期 I\/O または同期 I\/O のどちらを使用するかを指定します。 ただし、基になるオペレーティング システムが非同期 I\/O をサポートしていないことがあります。したがって、<see langword="true" /> を指定しても、プラットフォームによってはハンドルが同期的に開かれることがあります。 非同期的に開いた場合、<see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> メソッドと <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> メソッドは、大量の読み取りまたは書き込み時にはパフォーマンスがより高くなりますが、少量の読み取りまたは書き込み時にはパフォーマンスが非常に低くなることがあります。 アプリケーションが非同期 I\/O のアドバンテージを利用するように設計されている場合は、<c>useAsync</c> パラメーターを <see langword="true" /> に設定します。 非同期 I\/O を正しく使用すると、アプリケーションが 10 倍ほど高速化することがあります。ただし、非同期 I\/O 用にアプリケーションを再設計せずに非同期 I\/O を使用すると、パフォーマンスが 10 分の 1 ほど低下することがあります。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定されたパス、作成モード、読み取り\/書き込みアクセス許可、共有アクセス許可、バッファー サイズ、および同期状態または非同期状態を使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework では、パス"\\\\.\\PHYSICALDRIVE0"などのデバイス名を使用して物理ディスクへの直接アクセスをできません。  
  
 `path` パラメーターは、汎用名前付け規則 \(UNC\) 共有上のファイルを含む、ファイル名を指定できます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分を指定できます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true` すべて <xref:System.IO.FileStream> ファイルをカプセル化するオブジェクト。 場合 `path` 、シークをサポートしていないデバイスを示す、 <xref:System.IO.FileStream.CanSeek%2A> プロパティ、その結果を <xref:System.IO.FileStream> は `false`です。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 次のコード例では、非同期的にデータをファイルに書き込むし、データが正常に書き込まれたことを確認する方法を示します。 A `State` にメイン スレッドから情報を渡すオブジェクトを作成、 `EndReadCallback` と `EndWriteCallback` メソッドです。  
  
 [!code-cpp[System.IO.FileStream2\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> は空の文字列 \(""\) であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
 \-または\-  
  
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> が非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> が負の値であるかゼロです。  
  
 \-または\-  
  
 <paramref name="mode" />、<paramref name="access" />、または <paramref name="share" /> に正しくない値が含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> であるときなどに、ファイルが見つかりません。<paramref name="path" /> が指定したファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I\/O エラーが発生しました。  
  
 \-または\-  
  
 システムが Windows 98 または Windows 98 Second Edition を実行中で、<paramref name="share" /> が <see langword="FileShare.Delete" /> に設定されています。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが正しくありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> が <see langword="Write" /> または <see langword="ReadWrite" /> であり、ファイルまたはディレクトリが読み取り専用アクセスに設定されているなどの場合には、要求された <paramref name="access" /> は、指定された <paramref name="path" /> のオペレーティング システムで許可されません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定されたパスかファイル名、またはその両方がシステム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満、ファイル名は 260 文字未満でなければなりません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="T:System.IO.File" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="access">
          <see langword="FileStream" /> オブジェクトがファイルにアクセスできる方法を決定する定数。 これにより、<see langword="FileStream" /> オブジェクトの <see cref="P:System.IO.FileStream.CanRead" /> および <see cref="P:System.IO.FileStream.CanWrite" /> プロパティによって返される値も決まります。<c>path</c> がディスク ファイルを指定している場合、<see cref="P:System.IO.FileStream.CanSeek" /> は <see langword="true" /> になります。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <param name="options">追加のファイル オプションを指定する値。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、読み取り\/書き込みアクセス許可、共有アクセス許可、同一のファイルに対して他の FileStream が保有できるアクセス、バッファー サイズ、および追加のファイル オプションを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework では、パス"\\\\.\\PHYSICALDRIVE0"などのデバイス名を使用して物理ディスクへの直接アクセスをできません。  
  
 `fileOptions` を作成するときに利用できるより高度な操作へのアクセスを提供するパラメーターが使用される、 <xref:System.IO.FileStream> オブジェクトです。  
  
 `path` パラメーターは、汎用名前付け規則 \(UNC\) 共有上のファイルを含む、ファイル名を指定できます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分を指定できます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true` すべて <xref:System.IO.FileStream> ファイルをカプセル化するオブジェクト。 場合 `path` 、シークをサポートしていないデバイスを示す、 <xref:System.IO.FileStream.CanSeek%2A> プロパティ、その結果を <xref:System.IO.FileStream> は `false`です。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 次の例がデータをファイルに書き込みを使用してデータを読み込みます、 <xref:System.IO.FileStream> オブジェクトです。  
  
 [!code-cpp[IO.FileStream.ctor1\#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1\#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> は空の文字列 \(""\) であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
 \-または\-  
  
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> が非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> が負の値であるかゼロです。  
  
 \-または\-  
  
 <paramref name="mode" />、<paramref name="access" />、または <paramref name="share" /> に正しくない値が含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> であるときなどに、ファイルが見つかりません。<paramref name="path" /> が指定したファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが正しくありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定された <paramref name="path" /> に対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイルまたはディレクトリが読み取り専用アクセスに設定されているなどの場合です。  
  
 \-または\-  
  
 <paramref name="options" /> に対して <see cref="F:System.IO.FileOptions.Encrypted" /> が指定されていますが、ファイルの暗号化は現在のプラットフォームではサポートされていません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定されたパスかファイル名、またはその両方がシステム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満、ファイル名は 260 文字未満でなければなりません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see cref="T:System.IO.FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="rights">ファイルのアクセス規則および監査規則の作成時に使用するアクセス権を決定する定数。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <param name="options">追加のファイル オプションを指定する定数。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、アクセス権、共有アクセス許可、バッファー サイズ、および追加のファイル オプションを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework では、パス"\\\\.\\PHYSICALDRIVE0"などのデバイス名を使用して物理ディスクへの直接アクセスをできません。  
  
 これを使用して <xref:System.IO.FileStream.%23ctor%2A> ファイルの作成時に、権限のアクセスを適用するコンス トラクターです。 既存のファイルに対する権限の変更やでアクセスするには、使用を検討して、 <xref:System.IO.File.GetAccessControl%2A> と <xref:System.IO.File.SetAccessControl%2A> メソッドです。  
  
 `fileOptions` を作成するときに利用できるより高度な操作へのアクセスを提供するパラメーターが使用される、 <xref:System.IO.FileStream> オブジェクトです。  
  
 `path` パラメーターは、汎用名前付け規則 \(UNC\) 共有上のファイルを含む、ファイル名を指定できます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分を指定できます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true` すべて <xref:System.IO.FileStream> ファイルをカプセル化するオブジェクト。 場合 `path` 、シークをサポートしていないデバイスを示す、 <xref:System.IO.FileStream.CanSeek%2A> プロパティ、その結果を <xref:System.IO.FileStream> は `false`です。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> は空の文字列 \(""\) であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
 \-または\-  
  
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> が非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> が負の値であるかゼロです。  
  
 \-または\-  
  
 <paramref name="mode" />、<paramref name="access" />、または <paramref name="share" /> に正しくない値が含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> であるときなどに、ファイルが見つかりません。<paramref name="path" /> が指定したファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.PlatformNotSupportedException">現在のオペレーティング システムは Windows NT 以降ではありません。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが正しくありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定された <paramref name="path" /> に対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイルまたはディレクトリが読み取り専用アクセスに設定されているなどの場合です。  
  
 \-または\-  
  
 <paramref name="options" /> に対して <see cref="F:System.IO.FileOptions.Encrypted" /> が指定されていますが、ファイルの暗号化は現在のプラットフォームではサポートされていません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定された <paramref name="path" />、ファイル名、またはその両方がシステム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満、ファイル名は 260 文字未満にする必要があります。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">現在の <see cref="T:System.IO.FileStream" /> オブジェクトによってカプセル化されるファイルの相対パスまたは絶対パス。</param>
        <param name="mode">ファイルを開く方法または作成する方法を決定する定数。</param>
        <param name="rights">ファイルのアクセス規則および監査規則の作成時に使用するアクセス権を決定する定数。</param>
        <param name="share">プロセスによるファイルの共有方法を決定する定数。</param>
        <param name="bufferSize">バッファー サイズを示す 0 より大きな正の <see cref="T:System.Int32" /> 値。 既定のバッファー サイズは、4096 です。</param>
        <param name="options">追加のファイル オプションを指定する定数。</param>
        <param name="fileSecurity">ファイルのアクセス制御と監査セキュリティを決定する定数。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを、指定したパス、作成モード、アクセス権、共有アクセス許可、バッファー サイズ、追加のファイル オプション、アクセス制御、監査セキュリティを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework では、パス"\\\\.\\PHYSICALDRIVE0"などのデバイス名を使用して物理ディスクへの直接アクセスをできません。  
  
 これを使用して <xref:System.IO.FileStream.%23ctor%2A> ファイルの作成時に、権限のアクセスを適用するコンス トラクターです。 既存のファイルに対する権限の変更やでアクセスするには、使用を検討して、 <xref:System.IO.File.GetAccessControl%2A> と <xref:System.IO.File.SetAccessControl%2A> メソッドです。  
  
 `fileOptions` を作成するときに利用できるより高度な操作へのアクセスを提供するパラメーターが使用される、 <xref:System.IO.FileStream> オブジェクトです。  
  
 `path` パラメーターは、汎用名前付け規則 \(UNC\) 共有上のファイルを含む、ファイル名を指定できます。  
  
> [!NOTE]
>  `path` ディスクに格納されているファイルにする必要はありません。ストリーム経由でアクセスをサポートするシステムの任意の部分を指定できます。 たとえば、システムによってこのクラスは、物理デバイスをアクセスできます。  
  
 <xref:System.IO.Stream.CanSeek%2A> `true` すべて <xref:System.IO.FileStream> ファイルをカプセル化するオブジェクト。 場合 `path` 、シークをサポートしていないデバイスを示す、 <xref:System.IO.FileStream.CanSeek%2A> プロパティ、その結果を <xref:System.IO.FileStream> は `false`です。 詳細については、「<xref:System.IO.Stream.CanSeek%2A>」を参照してください。  
  
> [!CAUTION]
>  特定のカルチャ設定を使用して文字のセットをコンパイルし、別のカルチャ設定で、同じ文字を取得するときに、文字は、解釈されないことしがスローされる例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 次の例がデータをファイルに書き込みを使用してデータを読み込みます、 <xref:System.IO.FileStream> オブジェクトです。  
  
 [!code-cpp[IO.FileStream.ctor2\#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2\#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> は空の文字列 \(""\) であるか、空白のみで構成されているか、または 1 つ以上の正しくない文字を含んでいます。  
  
 \-または\-  
  
 <paramref name="path" /> が NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照しています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> が非 NTFS 環境の "con:"、"com1:"、"lpt1:" などの非ファイル デバイスを参照します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> が負の値であるかゼロです。  
  
 \-または\-  
  
 <paramref name="mode" />、<paramref name="access" />、または <paramref name="share" /> に正しくない値が含まれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="mode" /> が <see langword="FileMode.Truncate" /> または <see langword="FileMode.Open" /> であるときなどに、ファイルが見つかりません。<paramref name="path" /> が指定したファイルが存在しません。 これらのモードではファイルが既に存在している必要があります。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> で指定したファイルが既に存在している場合に <see langword="FileMode.CreateNew" /> を指定しているなどの I\/O エラーが発生しました。  
  
 \-または\-  
  
 ストリームは閉じられています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">マップされていないドライブにあるなど、指定されたパスが正しくありません。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定された <paramref name="path" /> に対する要求された <paramref name="access" /> は、オペレーティング システムによって許可されません。たとえば、<paramref name="access" /> が <see langword="Write" /> か <see langword="ReadWrite" /> で、ファイルまたはディレクトリが読み取り専用アクセスに設定されているなどの場合です。  
  
 \-または\-  
  
 <paramref name="options" /> に対して <see cref="F:System.IO.FileOptions.Encrypted" /> が指定されていますが、ファイルの暗号化は現在のプラットフォームではサポートされていません。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定された <paramref name="path" />、ファイル名、またはその両方がシステム定義の最大長を超えています。 たとえば、Windows ベースのプラットフォームでは、パスは 248 文字未満、ファイル名は 260 文字未満でなければなりません。</exception>
        <exception cref="T:System.PlatformNotSupportedException">現在のオペレーティング システムは Windows NT 以降ではありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for reading, writing, and appending to files. Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">データを読み取るバッファー。</param>
        <param name="offset">読み取りの開始位置を示す <c>array</c> 内のバイト オフセット。</param>
        <param name="numBytes">読み取る最大バイト数。</param>
        <param name="userCallback">非同期の読み取り操作が完了したときに呼び出されるメソッド。</param>
        <param name="stateObject">この特定の非同期読み取り要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の読み込み動作を開始します。 \(代わりに <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> を使用してください。「解説」を参照してください。\)</summary>
        <returns>非同期の読み取りを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework 4 以前のバージョンなどのメソッドを使用する必要がある [BeginRead メソッド \(Byte\<xref:System.IO.FileStream.BeginRead%2A> と [BeginRead メソッド \(Byte\<xref:System.IO.FileStream.EndRead%2A> ファイルの非同期操作を実装します。 これらのメソッドは引き続き使用できます、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] レガシ コードをサポートするために、新しい非同期メソッドなど [BeginRead メソッド \(Byte\<xref:System.IO.FileStream.ReadAsync%2A>, 、[BeginRead メソッド \(Byte\<xref:System.IO.FileStream.WriteAsync%2A>, 、[BeginRead メソッド \(Byte\<xref:System.IO.Stream.CopyToAsync%2A>, 、および [BeginRead メソッド \(Byte\<xref:System.IO.FileStream.FlushAsync%2A>, 、ヘルプ ファイルの非同期操作をより簡単に実装します。  
  
 [BeginRead メソッド \(Byte\<xref:System.IO.FileStream.EndRead%2A> 呼び出しごとに 1 回だけ呼び出す必要が [BeginRead メソッド \(Byte\<xref:System.IO.FileStream.BeginRead%2A>です。 別の読み取りを開始する前に読み取りプロセスを終了に失敗すると、デッドロックなどの望ましくない動作がによりことができます。  
  
 [BeginRead メソッド \(Byte\<xref:System.IO.FileStream> 操作の 2 つのモードを提供します。 同期 I\/O と非同期 I\/O。 いずれを使用するときに、基になるオペレーティング システムのリソースは、これらのモードの 1 つのみでアクセスを許可する可能性があります。 既定では、 [BeginRead メソッド \(Byte\<xref:System.IO.FileStream> オペレーティング システム ハンドルを同期的に開きます。 Windows では、非同期メソッドの速度が低下します。 非同期メソッドを使用している場合に使用して、 [BeginRead メソッド \(Byte\<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> コンス トラクターです。  
  
> [!NOTE]
>  使用して、 [BeginRead メソッド \(Byte\<xref:System.IO.FileStream.CanRead%2A> プロパティを現在のインスタンスが読み取りをサポートするかどうかを判断します。 詳細については、「[BeginRead メソッド \(Byte\<xref:System.IO.Stream.CanRead%2A>」を参照してください。  
  
 例外が直ちにスローされる場合は、ストリームが閉じているか、無効な引数を渡す、 [BeginRead メソッド \(Byte\<xref:System.IO.FileStream.BeginRead%2A>です。 IO 要求中にディスク障害などの非同期の読み取り要求の中に発生するエラーは、スレッド プールのスレッドで発生しへの呼び出し時に表示される [BeginRead メソッド \(Byte\<xref:System.IO.FileStream.EndRead%2A>します。  
  
 [BeginRead メソッド \(Byte\<xref:System.IO.Stream.EndRead%2A> これを呼び出す必要があります [BeginRead メソッド \(Byte\<xref:System.IAsyncResult> 読み取られたバイト数を確認します。  
  
 複数の非同期要求は、不明な要求の完了の順序を表示します。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 このコード例が示されている例の一部は、 [BeginRead メソッド \(Byte\<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> コンス トラクターです。  
  
 [!code-cpp[System.IO.FileStream2\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">配列の長さから <paramref name="offset" /> を引いた長さが <paramref name="numBytes" /> 未満です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> または <paramref name="numBytes" /> が負の値です。</exception>
        <exception cref="T:System.IO.IOException">非同期の読み取りがファイルの終わりを超えて試行されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">現在のストリームに書き込むデータを格納しているバッファー。</param>
        <param name="offset">現在のストリームへのバイトのコピーを開始する位置を示す <c>array</c> 内のバイト オフセット。インデックス番号は 0 から始まります。</param>
        <param name="numBytes">書き込む最大バイト数。</param>
        <param name="userCallback">非同期の書き込み操作が完了したときに呼び出されるメソッド。</param>
        <param name="stateObject">この特定の非同期書き込み要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</param>
        <summary>非同期の書き込み操作を開始します。 \(代わりに <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> を使用してください。「解説」を参照してください。\)</summary>
        <returns>非同期の書き込みを参照するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 In the .NET Framework 4 and earlier versions, you have to use methods such as [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.BeginWrite%2A> and [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.EndWrite%2A> to implement asynchronous file operations. These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.ReadAsync%2A>, [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.WriteAsync%2A>, [BeginWrite メソッド \(Byte\<xref:System.IO.Stream.CopyToAsync%2A>, and [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.  
  
 [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.EndWrite%2A> must be called exactly once on every [BeginWrite メソッド \(Byte\<xref:System.IAsyncResult> from [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.BeginWrite%2A>. [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.EndWrite%2A> will block until the I\/O operation has completed.  
  
 This method overrides [BeginWrite メソッド \(Byte\<xref:System.IO.Stream.BeginWrite%2A>.  
  
 [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream> provides two different modes of operation: synchronous I\/O and asynchronous I\/O. While either can be used, the underlying operating system resources might allow access in only one of these modes. By default, [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream> opens the operating system handle synchronously. In Windows, this slows down asynchronous methods. If asynchronous methods are used, use the [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.BeginWrite%2A>. Errors that occur during an asynchronous write request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.EndWrite%2A>.  
  
 Multiple simultaneous asynchronous requests render the request completion order uncertain.  
  
 For a list of common file and directory operations, see [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc).  
  
   
  
## 例  
 This code example is part of a larger example provided for the [BeginWrite メソッド \(Byte\<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> の長さから <paramref name="offset" /> を引いた長さが <paramref name="numBytes" /> 未満です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> または <paramref name="numBytes" /> が負の値です。</exception>
        <exception cref="T:System.NotSupportedException">ストリームは書き込みをサポートしません。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームは閉じられています。</exception>
        <exception cref="T:System.IO.IOException">I\/O エラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のストリームが読み取りをサポートしているかどうかを示す値を取得します。</summary>
        <value>ストリームが読み取りをサポートしている場合は <see langword="true" />。ストリームが閉じているか、書き込み専用アクセスで開かれた場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラスの場合 <xref:System.IO.Stream> への呼び出しを読み取りをサポートしていない、 <xref:System.IO.FileStream.Read%2A>, 、<xref:System.IO.FileStream.ReadByte%2A>, 、および <xref:System.IO.FileStream.BeginRead%2A> メソッドをスローする、 <xref:System.NotSupportedException>です。  
  
 このプロパティを返しますのかどうかは、ストリームが閉じ、 `false`です。  
  
   
  
## 例  
 次の例では、使用、 `CanRead` プロパティです。 このコードの出力は「MyFile.txt 書き込みができません」 出力メッセージ「MyFile.txt でく両方の書き込みし、読み取りからです。」、変更の取得、 `FileAccess` パラメーターを `ReadWrite` で、 `FileStream` コンス トラクターです。  
  
 [!code-cpp[Classic FileStream.CanRead Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のストリームがシークをサポートしているかどうかを示す値を取得します。</summary>
        <value>ストリームがシークをサポートしている場合は <see langword="true" />。ストリームが閉じているか、<see langword="FileStream" /> がパイプまたはコンソール出力などのオペレーティング システム ハンドルから構築された場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラスの場合 <xref:System.IO.Stream> がシークをサポートしていない、するために呼び出す <xref:System.IO.FileStream.Length%2A>, 、<xref:System.IO.FileStream.SetLength%2A>, 、<xref:System.IO.FileStream.Position%2A>, 、および <xref:System.IO.FileStream.Seek%2A> スロー、 <xref:System.NotSupportedException>です。  
  
 このプロパティを返しますのかどうかは、ストリームが閉じ、 `false`です。  
  
   
  
## 例  
 次の例では、 `CanSeek` ストリームがシークをサポートしているかどうかを確認するプロパティです。  
  
 [!code-cpp[fstream canseek\#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek\#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のストリームが書き込みをサポートしているかどうかを示す値を取得します。</summary>
        <value>ストリームが書き込みをサポートしている場合は <see langword="true" />。ストリームが閉じているか、読み取り専用アクセスで開かれた場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 派生したクラスの場合 <xref:System.IO.Stream> への呼び出しの書き込みをサポートしていません <xref:System.IO.FileStream.SetLength%2A>, 、<xref:System.IO.FileStream.Write%2A>, 、<xref:System.IO.FileStream.BeginWrite%2A>, 、または <xref:System.IO.FileStream.WriteByte%2A> スロー、 <xref:System.NotSupportedException>です。  
  
 このプロパティの取得のかどうかは、ストリームが閉じ、 `false`です。  
  
   
  
## 例  
 次の例では、 `CanWrite` ストリームが書き込みをサポートするかどうかを確認するプロパティです。  
  
 [!code-cpp[fstream canwrite\#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite\#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 次に例を使用して、 `CanWrite` プロパティです。 このコードの出力は「MyFile.txt は書き込み可能な」です。 出力メッセージ「MyFile.txt でく両方の書き込みし、読み取りからです。」、変更の取得、 `FileAccess` パラメーターを `ReadWrite` で、 `FileStream` コンス トラクターです。  
  
 [!code-cpp[Classic FileStream.CanWrite Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> によって使用されているアンマネージ リソースを解放し、オプションでマネージ リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method. <xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.FileStream.Dispose%2A> method with the **parameterReference tag is not supported!!!!**  
 parameter set to **languageKeyword tag is not supported!!!!**  
. <xref:System.Object.Finalize%2A> invokes <xref:System.IO.FileStream.Dispose%2A> with **parameterReference tag is not supported!!!!**  
 set to **languageKeyword tag is not supported!!!!**  
.  
  
 When the **parameterReference tag is not supported!!!!**  
 parameter is **languageKeyword tag is not supported!!!!**  
, this method releases all resources held by any managed objects that this <xref:System.IO.FileStream> references. This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects. When overriding <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />. For more information about how to implement <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">待機する保留状態の非同期要求への参照。</param>
        <summary>保留中の非同期の読み取り操作が完了するまで待機します。 \(代わりに <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> を使用してください。「解説」を参照してください。\)</summary>
        <returns>ストリームから読み込んだバイト数 \(0 ～要求したバイト数の間の数値\)。 ストリームの末尾では 0 が返されるだけです。それ以外の場合は、少なくとも 1 バイトが読み込み可能になるまでブロックします。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 .NET Framework 4 以前のバージョンなどのメソッドを使用する必要がある <xref:System.IO.FileStream.BeginRead%2A> と <xref:System.IO.FileStream.EndRead%2A> ファイルの非同期操作を実装します。 これらのメソッドは引き続き使用できます、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] レガシ コードをサポートするために、新しい非同期メソッドなど <xref:System.IO.FileStream.ReadAsync%2A>, 、<xref:System.IO.FileStream.WriteAsync%2A>, 、<xref:System.IO.Stream.CopyToAsync%2A>, 、および <xref:System.IO.FileStream.FlushAsync%2A>, 、ヘルプ ファイルの非同期操作をより簡単に実装します。  
  
 <xref:System.IO.FileStream.EndRead%2A> 呼び出しごとに正確に呼び出す必要がある <xref:System.IO.FileStream.BeginRead%2A>です。 別の読み取りを開始する前に読み取りプロセスを終了に失敗すると、デッドロックなどの望ましくない動作がによりことができます。  
  
 このメソッドは <xref:System.IO.Stream.EndRead%2A>です。  
  
 <xref:System.IO.FileStream.EndRead%2A> 呼び出すことができるあらゆる <xref:System.IAsyncResult> から <xref:System.IO.FileStream.BeginRead%2A>します。 呼び出す <xref:System.IO.FileStream.EndRead%2A> ストリームから読み取られたバイト数がわかります。<xref:System.IO.FileStream.EndRead%2A> I\/O 操作が完了するまでブロックされます。  
  
   
  
## 例  
 このコード例が示されている例の一部は、 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> コンス トラクターです。  
  
 [!code-cpp[System.IO.FileStream2\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">この <see cref="T:System.IAsyncResult" /> オブジェクトは、このクラスで <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> を呼び出すことによって作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> が複数回呼び出されます。</exception>
        <exception cref="T:System.IO.IOException">ストリームが閉じているか、内部エラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">保留中の非同期 I\/O 要求。</param>
        <summary>非同期の書き込み操作を終了し、I\/O 操作が完了するまでブロックします。 \(代わりに <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> を使用してください。「解説」を参照してください。\)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.FileStream.BeginWrite%2A> and <xref:System.IO.FileStream.EndWrite%2A> to implement asynchronous file operations. These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.  
  
 This method overrides <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> will block until the I\/O operation has completed.  
  
   
  
## 例  
 This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">この <see cref="T:System.IAsyncResult" /> オブジェクトは、このクラスで <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> を呼び出すことによって作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> は複数回呼び出されます。</exception>
        <exception cref="T:System.IO.IOException">ストリームが閉じているか、内部エラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ガベージ コレクターが <see langword="FileStream" /> を再利用するときに、リソースの解放およびその他のクリーンアップ操作を確実に実行するようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ガベージ コレクター `Finalize` と現在のオブジェクトが完了する準備ができています。`Finalize` 閉じる、 `FileStream`です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このストリームのバッファーをクリアして、バッファー内のデータがファイルに書き込まれるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>です。  
  
 呼び出すと、 <xref:System.IO.FileStream.Flush%2A?displayProperty=fullName> メソッド、オペレーティング システムの I\/O バッファーがでもフラッシュされます。  
  
 明示的に呼び出す場合を除き、ストリームのエンコーダーはフラッシュされません <xref:System.IO.FileStream.Flush%2A> またはオブジェクトを破棄します。 設定 <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName> に `true` に、ストリーム バッファーからデータがフラッシュされますが、エンコーダーの状態はフラッシュされないことを意味します。 これにより、次の文字のブロックを正常にエンコードできるように、\(一部の文字\) の状態を保持するエンコーダーです。 このシナリオでは、UTF8、UTF7、特定の文字をエンコードするため、エンコーダーは、隣接する文字または文字列を受信した後に影響します。  
  
 読み取りまたは書き込みのいずれかのバッファーを使用できるため <xref:System.IO.FileStream.Flush> 次の 2 つの機能を実行します。  
  
-   以前、バッファーに書き込まれたデータがファイルにコピーし、エンコーダー状態を除き、バッファーをクリアします。  
  
-   場合 <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName> は `true` とデータは読み取り用のバッファーにコピーされるファイルから以前、ファイル内の現在位置がバッファー内の未読のバイト数だけデクリメントします。 バッファーがクリアされます。  
  
 使用して、 <xref:System.IO.FileStream.Flush%28System.Boolean%29> バッファリングされたすべてのデータの中間ファイル バッファーのことを確認するときにメソッドのオーバー ロードが書き込まれるディスクにします。  
  
   
  
## 例  
 このコード例が示されている例の一部は、 <xref:System.IO.FileStream.Lock%2A> メソッドです。  
  
 [!code-cpp[System.IO.FileStream3\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">I\/O エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームは閉じられています。</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">すべての中間ファイル バッファーをフラッシュする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>このストリームのバッファーをクリアして、バッファー内のデータがファイルに書き込まれるようにし、すべての中間ファイル バッファーもクリアします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 バッファリングされたすべてのデータの中間ファイル バッファーのことを確認する場合は、このオーバー ロードの記述を使用してディスクにします。  
  
 呼び出すと、 <xref:System.IO.FileStream.Flush%2A> メソッド、オペレーティング システムの I\/O バッファーがでもフラッシュされます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">キャンセル要求を監視するためのトークン。</param>
        <summary>ストリームに対応するすべてのバッファーを非同期にクリアし、バッファー内のデータを基になるデバイスに書き込み、キャンセル要求を監視します。</summary>
        <returns>非同期のフラッシュ操作を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 呼び出すと、 <xref:System.IO.FileStream.FlushAsync%2A> メソッド、オペレーティング システムの I\/O バッファーがでもフラッシュされます。  
  
 返されたタスクに含まれる完了前に、操作が取り消された場合、 <xref:System.Threading.Tasks.TaskStatus.Canceled> の値、 <xref:System.Threading.Tasks.Task.Status%2A> プロパティです。 返されたタスクに含まれる場合は、ファイルへのハンドルが破棄されると、 <xref:System.ObjectDisposedException> での例外、 <xref:System.Threading.Tasks.Task.Exception%2A> プロパティです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">ストリームは破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.IO.FileStream" /> オブジェクトが示すファイルのアクセス制御リスト \(ACL\) エントリをカプセル化する <see cref="T:System.Security.AccessControl.FileSecurity" /> オブジェクトを取得します。</summary>
        <returns>現在の <see cref="T:System.IO.FileStream" /> オブジェクトが示すファイルのアクセス制御設定をカプセル化するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 中に、 <xref:System.IO.FileStream> クラスと <xref:System.IO.FileStream.GetAccessControl%2A> 既存のファイルのアクセス制御リスト \(ACL\) エントリを取得、使用を検討することできます <xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName> メソッドでは簡単に使用します。  
  
 使用して、 <xref:System.IO.FileStream.GetAccessControl%2A> ファイルの ACL エントリを取得します。  
  
 ACL は、個人やグループがある、または権限がない、特定のファイルの特定のアクションにユーザーを示します。 詳細については、「[How to: Add or Remove an Access Control List Entry](http://msdn.microsoft.com/ja-jp/53758b39-bd9b-4640-bb04-cad5ed8d0abf)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">ファイルは閉じられます。</exception>
        <exception cref="T:System.IO.IOException">ファイルを開くときに、I\/O エラーが発生しました。</exception>
        <exception cref="T:System.SystemException">ファイルが見つかりませんでした。</exception>
        <exception cref="T:System.UnauthorizedAccessException">この操作は、現在のプラットフォームではサポートされていません。  
  
 または  
  
 呼び出し元に、必要なアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのオペレーティング システム ファイル ハンドルを取得します。</summary>
        <value>この <see langword="FileStream" /> オブジェクトによってカプセル化されるファイルのオペレーティング システム ファイル ハンドル。または <see langword="FileStream" /> が閉じられている場合は \-1。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 This property is an operating system handle for use with operating\-system\-provided system calls \(such as **languageKeyword tag is not supported!!!!**  
 on Windows\). It will not work with C library functions that expect a file descriptor, such as **languageKeyword tag is not supported!!!!**  
.  
  
 The operating system handle might have been opened synchronously or asynchronously, depending on which **languageKeyword tag is not supported!!!!**  
 constructor was called. Use the <xref:System.IO.FileStream.IsAsync%2A> property to discover whether this handle was opened asynchronously. In Win32, this means the handle was opened for overlapped IO, and it requires different parameters to **languageKeyword tag is not supported!!!!**  
 and **languageKeyword tag is not supported!!!!**  
.  
  
> [!CAUTION]
>  Data corruption might occur if a **languageKeyword tag is not supported!!!!**  
>  is created, its handle is passed, some operation moves the handle's file pointer, and then the **languageKeyword tag is not supported!!!!**  
>  is used again. Multiple threads cannot safely write to the same file simultaneously, and **languageKeyword tag is not supported!!!!**  
>  buffering code assumes that it exclusively controls the handle. **languageKeyword tag is not supported!!!!**  
>  might throw an <xref:System.IO.IOException> if **languageKeyword tag is not supported!!!!**  
>  detects that some other process has moved the file pointer. To avoid this, do not write any data into a portion of the file that **languageKeyword tag is not supported!!!!**  
>  might have buffered, and restore the file pointer to the location it had when methods were last called on **languageKeyword tag is not supported!!!!**  
> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for the ability to access unmanaged code. Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Security action: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="FileStream" /> が非同期的に開かれたか、同期的に開かれたかを示す値を取得します。</summary>
        <value>
          <see langword="FileStream" /> が非同期的に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 `IsAsync` プロパティを検出するかどうか、 `FileStream` ハンドルが開かれた非同期的に使用するようコードを有効にすると、 <xref:System.IO.FileStream.Handle%2A> プロパティ正しくします。 Win32 では、 `IsAsync` true を示し、ハンドルの重複 I\/O 用に開かれたために異なるパラメーターを必要とされている `ReadFile` と `WriteFile`です。  
  
 インスタンスを作成するときに、この値を指定する、 <xref:System.IO.FileStream> を持つコンス トラクターを使用して、 `isAsync`, 、`useAsync`, 、または `options` パラメーター。 プロパティが `true`, 、ストリームがファイルの操作を非同期に実行する重複 I\/O を利用します。 ただし、 <xref:System.IO.FileStream.IsAsync%2A> プロパティがある必要ありません `true` を呼び出して、 <xref:System.IO.FileStream.ReadAsync%2A>, 、<xref:System.IO.FileStream.WriteAsync%2A>, 、または <xref:System.IO.Stream.CopyToAsync%2A> メソッドです。 ときに、 <xref:System.IO.FileStream.IsAsync%2A> プロパティは、 `false` および書き込み操作を非同期の読み込みを呼び出すと、まだ、UI スレッドはブロックされませんが、実際の I\/O 操作が同期的に実行します。  
  
   
  
## 例  
 このコード例が示されている例の一部は、 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> コンス トラクターです。  
  
 [!code-cpp[System.IO.FileStream2\#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2\#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2\#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ストリーム長 \(バイト単位\) を取得します。</summary>
        <value>ストリーム長 \(バイト単位\) を表す long 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 次の例では、 `Length` と `Position` ファイルの終端を確認するプロパティです。  
  
 [!code-cpp[Classic FileStream.Length Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このストリームの <see cref="P:System.IO.FileStream.CanSeek" /> は <see langword="false" /> です。</exception>
        <exception cref="T:System.IO.IOException">ファイルが閉じられているなど、I\/O エラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">ロックする範囲の先頭。 このパラメーターの値は、0 \(ゼロ\) 以上にする必要があります。</param>
        <param name="length">ロックする範囲。</param>
        <summary>
          <see cref="T:System.IO.FileStream" /> に対する他のプロセスからの読み取りまたは書き込みを禁止します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ファイル ストリームの範囲をロックすると、ファイル ストリームの範囲にロックのプロセスの排他アクセスのスレッドが与えられます。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 次のコード例では、別のプロセスは、ファイルに読み取り\/書き込みアクセス権がある場合でも、ファイルの部分にアクセスできないように、ファイルの一部をロックする方法を示します。 複数のコマンド ウィンドウで、プログラムを同時に実行し、さまざまなコンソールの入力オプションを使用してを調査します。  
  
 [!code-cpp[System.IO.FileStream3\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> または <paramref name="length" /> が負の値です。</exception>
        <exception cref="T:System.ObjectDisposedException">ファイルは閉じられています。</exception>
        <exception cref="T:System.IO.IOException">別のプロセスがファイルの一部をロックしているため、プロセスはこのファイルにアクセスできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンストラクターに渡された <see langword="FileStream" /> の名前を取得します。</summary>
        <value>
          <see langword="FileStream" /> の名前を示す文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 このコード例が示されている例の一部は、 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> コンス トラクターです。  
  
 [!code-cpp[System.IO.FileStream2\#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2\#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">for access to the path. Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ストリームの現在位置を取得または設定します。</summary>
        <value>ストリームの現在位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ストリームの長さを超える位置へのシークがサポートされているとします。  ファイルの長さを超えるシーク時にファイルのサイズが大きくなります。  Microsoft Windows NT と新しいファイルの末尾に追加されたすべてのデータが 0 に設定します。  Microsoft Windows 98、または前の手順では、ファイルの末尾に追加されたすべてのデータが以前に削除したデータは 0 に設定されていません。 ストリームの位置を Windows 98 またはそれ以前のストリームの末尾の次の大きな値に設定と、発生している例外が発生する可能性があります。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 次の例では、 `Length` と `Position` ファイルの終端を確認するプロパティです。  
  
 [!code-cpp[Classic FileStream.Length Example\#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example\#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このストリームはシークをサポートしていません。</exception>
        <exception cref="T:System.IO.IOException">I\/O エラーが発生しました。  
  
 または  
  
 位置が、Windows 98 またはそれ以前のストリームの末尾を越える非常に大きな値に設定されました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">位置を負の値に設定しようとしました。</exception>
        <exception cref="T:System.IO.EndOfStreamException">サポートされていない、ストリームの末尾を越えるシークをしようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">このメソッドが戻るとき、指定したバイト配列の <c>offset</c> から \(<c>offset</c> \+ <c>count</c> \- 1<c>)</c>\) までの値が、現在のソースから読み取られたバイトに置き換えられます。</param>
        <param name="offset">読み取られるバイトが配置される <c>array</c> 内のバイト オフセット。</param>
        <param name="count">読み取る最大バイト数。</param>
        <summary>ストリームからバイトのブロックを読み取り、そのデータを特定のバッファーに書き込みます。</summary>
        <returns>バッファーに読み取られた合計バイト数。 要求しただけのバイト数を読み取れなかった場合、この値は要求したバイト数より小さくなります。ストリームの末尾に到達した場合は 0 になることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは [Read メソッド \(Byte\<xref:System.IO.Stream.Read%2A>です。  
  
 `offset` パラメーターは、オフセットのバイトの `array` \(バッファーのインデックス\) 読み取りを開始する位置を示す、 `count` パラメーターは現在のストリームから読み取るバイトの最大数を指定します。 ストリームの末尾に達した場合は、実際の数バイトを読み取り、または 0 を返されるです。 読み取り操作が成功した場合、ストリームの現在の位置は読み取ったバイト数で進められます。 例外が発生する場合は、ストリームの現在の位置は変更されません。  
  
 [Read メソッド \(Byte\<xref:System.IO.FileStream.Read%2A> メソッドは、ストリームの末尾に到達した後にだけ 0 を返します。 それ以外の場合、 [Read メソッド \(Byte\<xref:System.IO.FileStream.Read%2A> 常に返す前に、ストリームから、少なくとも 1 バイトを読み取ります。 データがないかどうかを呼び出すとストリームから [Read メソッド \(Byte\<xref:System.IO.FileStream.Read%2A>, 、少なくとも 1 バイトのデータを返すことのできるまで、メソッドはブロックされます。 実装は、ストリームの末尾に達していない場合でも、要求されたバイト数を返すことです。  
  
 使用 [Read メソッド \(Byte\<xref:System.IO.BinaryReader> プリミティブ データ型を読み取るためです。  
  
 読み取り操作を実行しているスレッドを中断しません。 アプリケーションは、正常に実行するスレッドがブロックされた後に見えますが、中断されたときは、アプリケーションのパフォーマンスと信頼性を短縮できます。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 次の例からの内容を読み取ります、 [Read メソッド \(Byte\<xref:System.IO.FileStream> 、別に書き込みます [Read メソッド \(Byte\<xref:System.IO.FileStream>します。  
  
 [!code-csharp[FSRead\#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> または <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.NotSupportedException">ストリームは読み取りをサポートしません。</exception>
        <exception cref="T:System.IO.IOException">I\/O エラーが発生しました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> と <paramref name="count" /> は、<paramref name="array" /> で使用できない範囲について説明しています。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームが閉じた後でメソッドが呼び出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">データを書き込むバッファー。</param>
        <param name="offset">ストリームからのデータの書き込み開始位置を示す <c>buffer</c> 内のバイト オフセット。</param>
        <param name="count">読み取る最大バイト数。</param>
        <param name="cancellationToken">キャンセル要求を監視するためのトークン。</param>
        <summary>現在のストリームからバイト シーケンスを非同期に読み取り、読み取ったバイト数だけストリーム内の位置を進め、キャンセル要求を監視します。</summary>
        <returns>非同期の読み取り操作を表すタスク。<paramref name="TResult" /> パラメーターの値には、バッファーに読み込まれるバイトの合計数が含まれます。 現在使用できるバイト数が要求した数より小さい場合、結果の値は要求したバイト数より小さくなることがあります。また、ストリームの末尾に到達した場合は 0 になることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [ReadAsync メソッド \(Byte\<xref:System.IO.FileStream.ReadAsync%2A> メソッドでは、メイン スレッドをブロックすることがなくリソースを消費するファイル操作を実行することができます。 このパフォーマンスに関する考慮事項は、時間のかかるストリーム操作によって UI スレッドがブロックされ、アプリが動作していないと見なされる可能性がある [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリまたは[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] アプリで特に重要です。 非同期メソッドと組み合わせてで使用される、 `async` と `await` Visual Basic および c\# のキーワードです。  
  
 使用して、 [ReadAsync メソッド \(Byte\<xref:System.IO.FileStream.CanRead%2A> プロパティを現在のインスタンスが読み取りをサポートするかどうかを判断します。  
  
 返されたタスクに含まれる完了前に、操作が取り消された場合、 [ReadAsync メソッド \(Byte\<xref:System.Threading.Tasks.TaskStatus.Canceled> の値、 [ReadAsync メソッド \(Byte\<xref:System.Threading.Tasks.Task.Status%2A> プロパティです。 返されたタスクに含まれる場合は、ファイルへのハンドルが破棄されると、 [ReadAsync メソッド \(Byte\<xref:System.ObjectDisposedException> での例外、 [ReadAsync メソッド \(Byte\<xref:System.Threading.Tasks.Task.Exception%2A> プロパティです。  
  
   
  
## 例  
 次の例では、非同期的に、ファイルを読み取る方法を示します。  
  
 [!code-csharp[Asynchronous\_File\_IO\_async\#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous\_File\_IO\_async\#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> または <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> と <paramref name="count" /> の合計が、バッファーの長さよりも大きくなっています。</exception>
        <exception cref="T:System.NotSupportedException">ストリームは読み取りをサポートしません。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームは破棄されています。</exception>
        <exception cref="T:System.InvalidOperationException">ストリームは、前の読み取り操作によって現在使用されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ファイルからバイトを読み取り、読み取り位置を 1 バイト進めます。</summary>
        <returns>
          <see cref="T:System.Int32" /> にキャストしたバイト。ストリームの末尾に達した場合は \-1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは <xref:System.IO.Stream.ReadByte%2A>です。  
  
> [!NOTE]
>  使用して、 <xref:System.IO.FileStream.CanRead%2A> プロパティを現在のインスタンスが読み取りをサポートするかどうかを判断します。 詳細については、「<xref:System.IO.Stream.CanRead%2A>」を参照してください。  
  
   
  
## 例  
 次のコード例では、ファイル、バイト単位でデータを書き込むし、データが正常に書き込まれたことを確認する方法を示します。  
  
 [!code-cpp[System.IO.FileStream1\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在のストリームは読み取りをサポートしません。</exception>
        <exception cref="T:System.ObjectDisposedException">現在のストリームが閉じられます。</exception>
        <block subset="none" type="overrides">
          <para>The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.  
  
 For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.IO.FileStream" /> オブジェクトによってカプセル化されるファイルのオペレーティング システム ファイル ハンドルを表す <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> オブジェクトを取得します。</summary>
        <value>現在の <see cref="T:System.IO.FileStream" /> オブジェクトによってカプセル化されるファイルのオペレーティング システム ファイル ハンドルを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 <xref:System.IO.FileStream.SafeFileHandle%2A> プロパティは自動的にストリームをフラッシュし、現在のストリームの位置を 0 に設定します。  これにより、移動するファイルまたは別のストリームを使用してリセットするストリームの位置、 <xref:System.IO.FileStream.SafeFileHandle%2A> このプロパティによって返されます。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">for permission to call unmanaged code.  
  
 Security action: Link Demand  
  
 Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">シークの開始位置を示す、<c>origin</c> に対する相対ポイント。</param>
        <param name="origin">
          <see cref="T:System.IO.SeekOrigin" /> 型の値を使用して、<c>offset</c> の参照ポイントとして先頭、末尾、または現在位置を指定します。</param>
        <summary>このストリームの現在位置を特定の値に設定します。</summary>
        <returns>ストリームの新しい位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは <xref:System.IO.Stream.Seek%2A?displayProperty=fullName>です。  
  
> [!NOTE]
>  使用して、 <xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName> プロパティを現在のインスタンスがシークをサポートしているかどうかを判断します。 詳細については、「<xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>」を参照してください。  
  
 ストリームの長さを超える任意の場所にシークすることができます。 ファイルの長さを超えるシーク時にファイルのサイズが大きくなります。 Windows NT およびそれ以降のバージョンでは、ファイルの末尾に追加されたデータを 0 に設定します。 Windows 98 または以前のバージョンでは、ファイルの末尾に追加されたデータが設定されていないデータを以前に削除は 0 にします。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 次の例では、ファイル、バイト単位でデータを書き込むし、データが正常に書き込まれたことを確認する方法を示します。  
  
 [!code-cpp[System.IO.FileStream1\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 次の例は、さまざまなを使用して、ファイルの先頭にファイルの末尾から逆方向でテキストを読み取ります <xref:System.IO.SeekOrigin> の値を使った、 <xref:System.IO.FileStream.Seek%2A> メソッドです。  
  
 [!code-csharp[System.IO.FileStream.Seek\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">I\/O エラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">
          <see langword="FileStream" /> がパイプやコンソール出力から構成されている場合などには、ストリームはシークをサポートしません。</exception>
        <exception cref="T:System.ArgumentException">シークがストリームの開始前に試行されています。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームが閉じた後でメソッドが呼び出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">現在のファイルに適用する ACL エントリを示すオブジェクト。</param>
        <summary>
          <see cref="T:System.Security.AccessControl.FileSecurity" /> オブジェクトが示すアクセス制御リスト \(ACL\) エントリを、現在の <see cref="T:System.IO.FileStream" /> オブジェクトが示すファイルに適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 中に、 <xref:System.IO.FileStream> クラスと <xref:System.IO.FileStream.SetAccessControl%2A> 既存のファイルで使用できる、使用を検討して、 <xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName> メソッドは簡単に使用します。  
  
 <xref:System.IO.FileStream.SetAccessControl%2A> メソッドが継承されない ACL リストを表すファイルにアクセス制御リスト \(ACL\) エントリを適用します。  
  
> [!CAUTION]
>  ACL に指定された、 `fileSecurity` パラメーターは、ファイルの既存の ACL を置き換えます。 新しいユーザーのアクセス許可を追加するには、使用、 <xref:System.IO.FileStream.GetAccessControl%2A> メソッドは、既存の ACL を取得して、変更を使用して、 <xref:System.IO.FileStream.SetAccessControl%2A> ファイルに適用します。  
  
 ACL は、個人やグループがある、または権限がない、特定のファイルの特定のアクションにユーザーを示します。 詳細については、「[How to: Add or Remove an Access Control List Entry](http://msdn.microsoft.com/ja-jp/53758b39-bd9b-4640-bb04-cad5ed8d0abf)」を参照してください。  
  
   
  
## 例  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">ファイルは閉じられます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileSecurity" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.SystemException">ファイルを検出または変更できませんでした。</exception>
        <exception cref="T:System.UnauthorizedAccessException">現在のプロセスには、ファイルを開くために必要なアクセス権がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">ストリームの新しい長さ。</param>
        <summary>ストリーム長を特定の値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは <xref:System.IO.Stream.SetLength%2A>です。  
  
 指定した値が、ストリームの現在の長さよりも小さい場合は、ストリームは切り捨てられます。 このシナリオでの現在の位置が、新しい長さより大きい場合は、現在の位置は、ストリームの最後のバイトまで移動します。 指定した値が、ストリームの現在の長さよりも大きい場合は、ストリームが展開され、現在の位置は変わりません。 ストリームが展開されている場合、古いクライアント シークレットと新しい長さのストリームの内容は未定義です。  
  
 ストリームが書き込みとシークの両方をサポートする必要があります `SetLength` 作業します。  
  
> [!NOTE]
>  使用して、 <xref:System.IO.FileStream.CanWrite%2A> プロパティを現在のインスタンスがドキュメントの作成をサポートするかどうかを確認し、 <xref:System.IO.FileStream.CanSeek%2A> シークがサポートされているかどうかを確認するにします。 追加情報については、<xref:System.IO.Stream.CanWrite%2A>、および <xref:System.IO.Stream.CanSeek%2A> を参照してください。  
  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">I\/O エラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">ストリームでは、書き込みとシークの両方は使用できません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> パラメーターを 0 未満の値に設定しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">ロックを解除する範囲の先頭。</param>
        <param name="length">ロックを解除する範囲。</param>
        <summary>他のプロセスにより以前にロックされたファイルの全部または一部へのアクセスを許可します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 一般的なファイルおよびディレクトリの操作の一覧は、次を参照してください。 [Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)します。  
  
   
  
## 例  
 次のコード例では、別のプロセスは、ファイルを読み取り\/書き込みアクセス権がある場合でも、ファイルの部分にアクセスできず、ファイルの指定した部分のロックを解除するために、ファイルの一部をロックする方法を示します。 複数のコマンド ウィンドウで、プログラムを同時に実行し、さまざまなコンソールの入力オプションを使用してを調査します。  
  
 [!code-cpp[System.IO.FileStream3\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> または <paramref name="length" /> が負の値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">ストリームに書き込むデータを格納しているバッファー。</param>
        <param name="offset">ストリームへのバイトのコピーを開始する位置を示す <c>array</c> 内のバイト オフセット。インデックス番号は 0 から始まります。</param>
        <param name="count">書き込む最大バイト数。</param>
        <summary>ファイル ストリームにバイトのブロックを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは[Write メソッド \(Byte\<xref:System.IO.Stream.Write%2A>します。  
  
 `offset`パラメーターはバイトのオフセット`array`\(バッファーのインデックス\) コピーを開始する位置を示す、`count`パラメーターは、ストリームに書き込まれるバイト数。 書き込み操作が成功した場合、ストリームの現在の位置は書き込まれたバイト数で進められます。 例外が発生する場合は、ストリームの現在の位置は変更されません。  
  
> [!NOTE]
>  使用して、[Write メソッド \(Byte\<xref:System.IO.FileStream.CanWrite%2A>プロパティを現在のインスタンスが書き込みをサポートするかどうかを判断します。 詳細については、「[Write メソッド \(Byte\<xref:System.IO.Stream.CanWrite%2A>」を参照してください。  
  
 書き込み操作を実行するスレッドを中断しません。 スレッドはブロック解除後に正常に実行するアプリケーションが表示されますが、中断、アプリケーションのパフォーマンスと信頼性に減らすことができます。  
  
 一般的なファイルとディレクトリの操作の一覧は、次を参照してください。[Common I\/O Tasks](http://msdn.microsoft.com/ja-jp/bf00c380-706a-4e38-b829-454a480629fc)です。  
  
   
  
## 例  
 このコード例に示されている例の一部である、[Write メソッド \(Byte\<xref:System.IO.FileStream.Lock%2A>メソッドです。  
  
 [!code-cpp[System.IO.FileStream3\#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3\#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> と <paramref name="count" /> は、<paramref name="array" /> で使用できない範囲を記述しています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> または <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.IO.IOException">I\/O エラーが発生しました。  
  
 または  
  
 別のスレッドが原因で、オペレーティング システムのファイル ハンドルの位置で予期しない変更が発生した可能性があります。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">現在のストリームのインスタンスでは、書き込みをサポートしません。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">データの書き込み元となるバッファー。</param>
        <param name="offset">ストリームへのバイトのコピーを開始する位置を示す <c>buffer</c> 内のバイト オフセット。インデックス番号は 0 から始まります。</param>
        <param name="count">書き込む最大バイト数。</param>
        <param name="cancellationToken">キャンセル要求を監視するためのトークン。</param>
        <summary>現在のストリームにバイト シーケンスを非同期に書き込み、書き込んだバイト数だけストリーム内の現在位置を進め、キャンセル要求を監視します。</summary>
        <returns>非同期の書き込み操作を表すタスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 [WriteAsync メソッド \(Byte\<xref:System.IO.FileStream.WriteAsync%2A> メソッドでは、メイン スレッドをブロックすることがなくリソースを消費するファイル操作を実行することができます。 このパフォーマンスに関する考慮事項は、時間のかかるストリーム操作によって UI スレッドがブロックされ、アプリが動作していないと見なされる可能性がある [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリまたは[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] アプリで特に重要です。 非同期メソッドと組み合わせてで使用される、 `async` と `await` Visual Basic および c\# のキーワードです。  
  
 使用して、 [WriteAsync メソッド \(Byte\<xref:System.IO.FileStream.CanWrite%2A> プロパティを現在のインスタンスが読み取りをサポートするかどうかを判断します。  
  
 返されたタスクに含まれる完了前に、操作が取り消された場合、 [WriteAsync メソッド \(Byte\<xref:System.Threading.Tasks.TaskStatus.Canceled> の値、 [WriteAsync メソッド \(Byte\<xref:System.Threading.Tasks.Task.Status%2A> プロパティです。 返されたタスクに含まれる場合は、ファイルへのハンドルが破棄されると、 [WriteAsync メソッド \(Byte\<xref:System.ObjectDisposedException> での例外、 [WriteAsync メソッド \(Byte\<xref:System.Threading.Tasks.Task.Exception%2A> プロパティです。  
  
   
  
## 例  
 次の例では、ファイルへ非同期的に書き込む方法を示します。  
  
 [!code-csharp[Asynchronous\_File\_IO\_async\#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous\_File\_IO\_async\#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> または <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> と <paramref name="count" /> の合計が、バッファーの長さよりも大きいです。</exception>
        <exception cref="T:System.NotSupportedException">ストリームは書き込みをサポートしません。</exception>
        <exception cref="T:System.ObjectDisposedException">ストリームは破棄されています。</exception>
        <exception cref="T:System.InvalidOperationException">ストリームは、前の書き込み操作によって現在使用されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">ストリームに書き込むバイト。</param>
        <summary>ファイル ストリームの現在位置にバイトを書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 このメソッドは <xref:System.IO.Stream.WriteByte%2A>です。  
  
 使用 `WriteByte` にバイトを書き込む、 `FileStream` 効率的にします。 ストリームが終了したか、書き込み禁止の場合は、例外がスローされます。  
  
> [!NOTE]
>  使用して、 <xref:System.IO.FileStream.CanWrite%2A> プロパティを現在のインスタンスが書き込みをサポートするかどうかを判断します。 詳細については、「<xref:System.IO.Stream.CanWrite%2A>」を参照してください。  
  
   
  
## 例  
 次のコード例では、ファイル、バイト単位でデータを書き込むし、データが正常に書き込まれたことを確認する方法を示します。  
  
 [!code-cpp[System.IO.FileStream1\#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1\#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1\#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">ストリームは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">ストリームは書き込みをサポートしません。</exception>
        <block subset="none" type="overrides">
          <para>The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.  
  
 For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このストリームのバッファーをクリアして、バッファー内のデータがファイルに書き込まれるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## 解説  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.IO.FileStream" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
  </Members>
</Type>